var store = [{
        "title": "컨테이너와 전역 속성",
        "excerpt":"📄 컨테이너 태그   콘텐츠에 아무런 영향을 주지 않고, 여러 요소를 묶어 관리하기 편하게 만드는 역할을 하는 태그입니다.   div: 블록 레벨 컨테이너      페이지 전체 면적을 차지합니다.   span: 인라인 컨테이너   지정한 부분의 면적만 차지합니다.   📄 전역 속성   전역속성(Global attributes)은 모든 HTML 태그에서 공통으로 사용할 수 있는 속성입니다.   &lt;태그명 속성명=**속성값** 속성명=**속성값**&gt;콘텐츠&lt;/태그명&gt;   대표적인 전역 속성들      id: 요소에 고유한 이름을 부여하는 식별자 역할 속성입니다. id는 태그당 하나씩만 지정합니다.   class: 요소를 그룹 별로 묶을 수 있는 식별자 역할 속성입니다. class는 다중 지정 및 중복이 가능합니다.   style: 요소에 적용할 CSS스타일을 선언하는 속성입니다.   title: 요소의 추가 정보를 제공하는 텍스트 속성입니다. 사용자에게 툴팁을 제공합니다.  ","categories": ["HTML"],
        "tags": ["HTML","컨테이너","전역속성"],
        "url": "/html/html-container/",
        "teaser": null
      },{
        "title": "HTML 문서 기본 구조",
        "excerpt":"📄 HTML이란?      HyperText: 하이퍼링크를 통해 어떤 문서에서 다른 문서로 접근할 수 있는 텍스트   MarkUp: (콘텐츠를) 표시하다   Language: 언어   즉, HTML은 웹브라우저를 통해 표시되는 웹페이지의 콘텐츠를 정의하기 위해 사용하는 언어입니다.   📄 HTML 문서 기본 구조   ▪ &lt;!DOCTYPE html&gt;   문서의 첫 부분에서 문서 유형을 지정하는 단일 태그입니다.   &lt;!DOCTYPE html&gt;   ▪ &lt;html&gt; ~ &lt;/html&gt;   문서 유형을 지정한 후 실제 문서가 시작되고 끝나는 것을 나타내는 태그입니다.   &lt;html&gt;   ... &lt;/html&gt;   ▪ &lt;head&gt; ~ &lt;/head&gt;   웹 브라우저 화면에는 보이지 않지만 웹 브라우저가 알아야 할 정보들입니다.   ▪ &lt;meta charset=\"utf-8\"&gt;   문자 인코딩 및 문서 키워드 등에 대한 요약 정보를 기입하는 단일 태그입니다.  영문과 한글을 모두 사용하기 위해 utf-8 방식을 사용하는 것이 좋습니다.    ▪ &lt;title&gt; ~ &lt;/title&gt;   문서의 제목을 나타냅니다. 콘텐츠는 브라우저 탭에 표시됩니다.       ▪ &lt;body&gt; ~ &lt;/body&gt;   실제 브라우저 화면에 표시될 내용을 입력하는 태그입니다.     들여쓰기를 깔끔하게 해서 가독성을 높이자   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그"],
        "url": "/html/html-html-docs-structure/",
        "teaser": null
      },{
        "title": "이미지 표시하기",
        "excerpt":"📄 이미지를 보여주는 img 태그   html에서는 이미지를 보여줄 때 img라는 단일 태그를 사용합니다.   &lt;img src=\"표시할 이미지 파일\" alt=\"이미지설명\" /&gt;   이때 alt는 대체 택스트 역할을 합니다.   이미지가 로딩되기 전이나 이미지 로딩에 실패한 경우   이미지 대신에 대체 텍스트가 표시됩니다.   이미지 유실 상황에 대비하거나 시각 장애인을 위한 콘텐츠에 유용합니다.(음성인식기 활용)   📄 이미지 크기 조절하기   width와 height로 크기를 지정합니다.   이때 너비와 높이는 각각 픽셀(px)단위로 적용됩니다.   &lt;img   src=\"표시할 이미지 파일\"   alt=\"이미지 설명\"   width=\"너비 값\"   height=\"높이 값\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","img"],
        "url": "/html/html-image/",
        "teaser": null
      },{
        "title": "입력 요소 만들기(input)",
        "excerpt":"📄 input 태그   입력요소는 &lt;input&gt; 태그를 이용해 만들어 줍니다.   &lt;input&gt;태그는 인라인 요소이며, 단일 태그입니다.   &lt;input&gt;태그에는 name식별자를 추가하여 각각 어떤 특징을 가지는지 설명하는 것이 좋습니다.   📄 input 태그의 type 속성   type값에 따라 입력 요소의 형태나 입력 데이터 유형 등이 달라집니다.   1. text: 텍스트 메세지를 입력합니다.   &lt;input name=\"text\" type=\"text\" maxlength=\"5\" placeholder=\"메세지입력\" /&gt;      maxlength: 텍스트 최대 크기를 지정합니다.   place holder: 텍스트 입력 전 창에 띄워지는 텍스트를 지정합니다.   2. button: 버튼이 생성됩니다.   &lt;input name=\"button\" type=\"button\" value=\"PUSH\" /&gt;   3. color: 색을 지정할 수 있는 팔레트가 띄워 집니다.   &lt;input name=\"color\" type=\"color\" /&gt;   4. rage: 숫자로 된 값을 입력 할 수 있는 바를 만들어 줍니다.   &lt;input name=\"score\" type=\"range\" max=\"100\" min=\"0\" step=\"10\" /&gt;   5. date: 날짜를 입력할 수 있는 달력이 생성됩니다.   &lt;input name=\"birthdaty\" type=\"date\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","input"],
        "url": "/html/html-input/",
        "teaser": null
      },{
        "title": "링크 만들기",
        "excerpt":"📄 링크(Link)   링크는 현재 문서에서 다른 문서로 이동할 수 있는 수단입니다.   링크는 a 태그를 사용합니다.   a 태그에 사용하는 속성      href: 링크가 참조하고자 하는 url을 입력합니다.   target: 링크 클릭 시 현재 탭에서 열지 새로운 탭에서 열지 결정합니다   &lt;a href=\"www.naver.com\" target=\"_self\"&gt; 현재 탭에서 열기(기본값) &lt;/a&gt;  &lt;a href=\"www.naver.com\" target=\"_blank\"&gt; 새로운 탭에서 열기 &lt;/a&gt;   이 외에도 href에 전화번호나 메일 주소 등을 지정 할 수 있습니다.   &lt;a href=\"tel:010-1234-5678\"&gt;   전화 걸기   &lt;!-- 데스크탑일 경우 전화기능이 없다면 사용 불가--&gt; &lt;/a&gt;  &lt;a href=\"mailto:ikosdu60@gmail.com\"&gt; 메일 쓰기 &lt;/a&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","link"],
        "url": "/html/html-link/",
        "teaser": null
      },{
        "title": "블록 레벨 요소와 인라인 요소",
        "excerpt":"📄 태그의 구분   블록 레벨 요소를 만드는 태그 vs 인라인 요소를 만드는 태그   📄 블록 레벨 요소   블록 레벨 요소는 페이지의 너비를 모두 차지하여 블록을 형성합니다.  아래와 같이 개발자도구(단축키:F12)를 사용하면  페이지의 너비를 모두 차지하고 있는 것을 확인할 수 있습니다.  블록 안에 블록을 생성하면 공간이 형성되어 층이 생깁니다.     📄 인라인 요소   인라인 요소는 콘텐츠를 표시하기 위해 필요한 공간만 차지합니다.  블록 요소 안에 인라인 요소를 넣어도 인라인 요소는 필요한 공간만 차지합니다.     ","categories": ["HTML"],
        "tags": ["HTML","블록 레벨","인라인 레벨"],
        "url": "/html/html-tag&inlinetext/",
        "teaser": null
      },{
        "title": "텍스트 태그 사용 방법과 특징",
        "excerpt":"📄 문단(paragraph)   문단 요소를 나타내는 태그로써, 가장 많이 사용되는 텍스트 태그 입니다.  문단과 문단 사이에는 공백이 있습니다.   &lt;p&gt;이것은 문단을 표시하는 태그입니다.&lt;/p&gt;   📄 제목(headline)   h 태그는 제목 요소를 나타냅니다.  숫자와 함께 사용되며, 숫자가 1일 때 가장 크고 6일 때 가장 작습니다.   &lt;h1&gt;제목을 나타내자!&lt;/h1&gt; &lt;h2&gt;제목을 나타내자!&lt;/h2&gt; &lt;h3&gt;제목을 나타내자!&lt;/h3&gt; &lt;h4&gt;제목을 나타내자!&lt;/h4&gt; &lt;h5&gt;제목을 나타내자!&lt;/h5&gt; &lt;h6&gt;제목을 나타내자!&lt;/h6&gt;   ✔ 결과   제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!   📄 수평선   hr 태그는 수평선을 표시하는 태그입니다.  주로 주제 변경 또는 내용 구분을 위해 단일 태그로 사용됩니다.   &lt;hr /&gt;   📄 줄바꿈태그와 공백문자   br태그는 줄바꿈을 담당하는 단일 태그입니다.   &lt;br /&gt;   html 문서에서 스페이스바로 공백을 두 번 이상 입력해도 표시되지 않습니다.  공백을 두 번 이상 표시할 때는 &amp;nbsp를 사용합니다.   &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","텍스트 태그"],
        "url": "/html/html-texttag/",
        "teaser": null
      },{
        "title": "CSS 함수",
        "excerpt":"📄 CSS 함수   CSS의 속성값을 지정할 때 함수의 성격을 적용할 수 있습니다.   CSS함수는 괄호 안에 인수를 전달하면, 인수에 따른 결과값을 속성에 적용하는 방식으로 동작합니다.   📄 calc()   CSS함수 중 계산을 담당하는 함수 입니다.   괄호안의 표현식을 결과값으로 적용합니다.   .message_text {   width: calc(100% - 100px); }   이렇게 message_text를 가변적인 크기로 설정이 가능합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["calc"],
        "url": "/css/css-cssfunction/",
        "teaser": null
      },{
        "title": "폼(form) 태그",
        "excerpt":"📄 폼(form) 태그   form은 입력 요소를 감싸며 입력 값을 서버 측으로 제출합니다.  입력값을 클라이언트가 서버로 전송하면 서버 측에서는 데이터를 처리한 결과를 클라이언트에게 보내줍니다.   📄 폼(form)태그의 속성      action: 입력값을 전송할 서버의 url   method: 클라이언트가 입력한 데이터를 어떤 식으로 전송할 방법(GET or POST)   &lt;form action=\"example.php\" method=:\"POST\"&gt;     &lt;input type=\"submit\" value=\"전송\"&gt; &lt;/form&gt;       GET: 서버로 요청을 보내 응답을 받아냅니다. POST: 서버에 요청을 보내어 서버에 있는 데이터를 추가/수정/삭제한 후에 응답을 받아냅니다.   ","categories": ["HTML"],
        "tags": ["HTML","form"],
        "url": "/html/html-form/",
        "teaser": null
      },{
        "title": "HTML코드 기초 문법",
        "excerpt":"📄 태그(tag)   HTML 코드에서 정보(콘텐츠)를 정의하는 형식입니다.   &lt;태그명&gt; 여기에 콘텐츠를 기입합니다.&lt;/태그명&gt; &lt;/태그명&gt; // 단일 태그 사용 형태   📄 속성   태그의 부가적인 기능을 정의합니다.   &lt;태그명 속성명=\"속성값\"&gt;내용이 들어감&lt;/태그명&gt; &lt;태그 속성명=\"속성값\"/&gt; //단일 태그 사용 형태   📄 주석   사람에게는 보이지만, 웹브라우저에게는 보이지 않는 코드입니다.   주로 메모를 남기기 위해 사용됩니다.   &lt;!--** 이 사이에 작성한 내용은 주석으로 처리된다. **--&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그","속성","주석"],
        "url": "/html/html-html-grammner/",
        "teaser": null
      },{
        "title": "목록 표시하기",
        "excerpt":"📄 ul   순서 있는 항목은 &lt;ul&gt;태그로 작성합니다.   &lt;ul&gt;   &lt;li&gt;토끼&lt;/li&gt;   &lt;li&gt;다람쥐&lt;/li&gt;   &lt;li&gt;청설모&lt;/li&gt;   &lt;li&gt;호랑이&lt;/li&gt; &lt;/ul&gt;   이와 같이 항목 하나하나는 &lt;li&gt;로 표시합니다.   ul태그로 작성하면 앞에 숫자가 붙습니다.   📄 ol   순서 없는 항목은 &lt;ol&gt;태그로 작성합니다.   &lt;ol&gt;   &lt;li&gt;HTML&lt;/li&gt;   &lt;li&gt;CSS&lt;/li&gt;   &lt;li&gt;JAVAScript&lt;/li&gt;   &lt;ol&gt;&lt;/ol&gt; &lt;/ol&gt;   &lt;ul&gt;태그와 &lt;ol&gt;태그와 &lt;li&gt;태그는 모두 블록 레벨 요소를 만드는 태그입니다.  ","categories": ["HTML"],
        "tags": ["HTML","ul","ol","li"],
        "url": "/html/html-list/",
        "teaser": null
      },{
        "title": "메타(meta) 태그",
        "excerpt":"📄 메타(meta) 태그   meta 태그는 HTML 문서의 정보를 표시하는 태그입니다.   검색엔진 최적화에 기여하며, 검색 결과에도 영향을 끼칩니다.   개발자가 페이지를 참고할 때 도움이 되기도 합니다.   📄 메타 태그의 다양한 속성들   1. charset   문자 인코딩에 대한 요약 정보를 기입하는 속성입니다.   주로 영문과 한글을 모두 사용하기 위해 utf-8방식을 사용합니다.   &lt;meta charset=\"uth-8\" /&gt;   2. http-eqiv   콘텐츠 속성의 정보/값에 대한 HTTP 헤더를 제공합니다.   &lt;!-- IE 브라우저의 최신 버전의 엔진을 사용하라는 뜻--&gt; &lt;meta http-equiv=\"x-ua-compatible\" content=\"IE-edge\" /&gt; &lt;!-- 10초마다 페이지 새로고침하라는 뜻--&gt; &lt;meta http-equiv=\"refresh\" content=\"10\" /&gt;   3.name name 속성을 이름으로, content 속성을 값으로 하여 문서 정보를 제공합니다.   &lt;!--문서 제작자--&gt; &lt;meta name=\"author\" content=\"유노코딩\" /&gt; &lt;!-- 페이지에 대한 요약--&gt; &lt;meta name=\"desciption\" content=\"페이지에 대한 짧고 명확한 요약\" /&gt; &lt;!-- 페이지의 콘텐츠와 관련된, 쉼표로 구분한 키워드 목록--&gt; &lt;meta   name=\"keywords\"   content=\"예를 들면, 강아지, 고양이, 정보, 반려동물, 등등\" /&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","메타 태그","charset","http-eqiv","name"],
        "url": "/html/html-metatag/",
        "teaser": null
      },{
        "title": "select & textarea",
        "excerpt":"📄 select   select는 다수의 옵션(선택지)를 포함할 수 있는 선택 메뉴입니다.   메뉴 안에 포함되는 옵션은 option 태그를 사용하여 표시합니다.   &lt;select&gt;     &lt;option value=\"starbucks\"&gt;스타벅스&lt;/option&gt;     &lt;optio nvalue=\"coffeebean\"&gt;커피빈&lt;/option&gt;     &lt;option value=\"ediya\"&gt;이디야&lt;/option&gt;     &lt;option value=\"pascucci\"&gt;파스쿠찌&lt;/option&gt; &lt;/select&gt;      선택지에서 커피빈을 고른다 = cafe의 입력 값은 coffebean이다    📄 textarea   textarea는 여러 줄의 일반 텍스트를 입력할 수 있는 입력 요소입니다.   &lt;textarea name=\"letter\" rows=\"10\" cols=:10\"&gt;기본적으로 쓰여 있는 텍스트&lt;/textarea&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","select","textarea"],
        "url": "/html/html-select&textarea/",
        "teaser": null
      },{
        "title": "CSS box-sizing",
        "excerpt":"📄 box-sizing 속성   box-sizing 속성은 너비와 높이가 포함할 영역을 변경함으로써 너비와 높이의 계산 방법을 결정할 수 있습니다.      content-box: 기본값. 너비와 높이가 콘텐츠 영역만을 포함합니다. padding이 추가 되어도 content크기는 보장받고 싶을 때 씁니다.   border-box: 너비와 높이가 안쪽 여백과 테두리까지 포함합니다.   div {   content-box: border-box; }      개발자도구를 통해 padding이 추가되어도 content크기는 변하지 않은 것을 확인할 수 있습니다.  ","categories": ["CSS"],
        "tags": ["content-box","border-box"],
        "url": "/css/css-boxsizing/",
        "teaser": null
      },{
        "title": "CSS 선택자",
        "excerpt":"📄 CSS 선택자   선택자는 어떤 요소에 대한 스타일을 정의할 것인지에 대한 정보입니다.   📄 선택자의 종류   1. 전체 선택자   애스터리스크(*)는 문서 내의 모든 요소를 의미합니다.   * {   color: blue; }   2. 태그 선택자(유형 선택자)   주어진 이름을 가진 요소를 선택합니다.   p {   color: blue; }   3. 클래스 선택자   주어진 class 속성값을 가진 요소를 선택합니다.   .text {   color: blue; }   4. 아이디 선택자   주어진 id 속성값을 가진 요소를 선택합니다.   #topic {   color: blue; }   5. 그룹 선택자   다양한 유형의 요소를 한꺼번에 선택하고자 할 때 사용합니다.  쉼표(,)를 이용해 선택자를 그룹화 합니다.   h1, p, div {   color: blue; }   📄 선택자의 우선순위   아이디 선택자 &gt; 클래스 선택자 &gt; 태그 선택자   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["css 선택자"],
        "url": "/css/css-cssSelector/",
        "teaser": null
      },{
        "title": "CSS기본문법",
        "excerpt":"📄 CSS란?   ▪ Cascading: 계단식  ▪ Style: 멋을 내다  ▪ Sheets: (종이)한 장    즉, 계단식으로 스타일을 정의하는 문서입니다.    css는 웹문서를 꾸며주기 위해 사용하는 언어입니다.    확장자는 *.css입니다.    css문서는 html문서와 함께 작업을 수행합니다.   &lt;link href=\"style.css\" rel=\"stylesheet\"&gt;   이와 같이 html문서에 css문서의 링크를 걸어주어 작업을 수행하게 됩니다.   📄 CSS 기본 구성   선택자 {   속성명: 속성값; }      선택자: 어떤 요소에 스타일을 적용할지에 대한 정보   {중괄호}: 선택한 요소에 적용할 스타일을 정의하는 영역   속성명: 어떤 스타일을 정의하고 싶은지에 대한 정보(색상, 크기 등)   속성값: 어떻게 정의하고 싶은지에 대한 정보   📄 주석   p {   /* 이 안에 작성하면 주석으로 처리됩니다. */ }   📄 HTML에 CSS문서를 적용하는 법      인라인 스타일: 태그에 직접 기술합니다.   스타일 태그: 스타일시트를 위한 태그를 추가하여 기술합니다   문서 간의 연결: 스타일시트 문서를 따로 작성하여 HTML 문서와 연결합니다.   &lt;link href=\"./style.css\" rel=\"stylesheet\" /&gt;      href: 연결하고자 하는 외부 소스의 url을 기술하는 속성   rel: 현재 문서(HTML)와 외부 소스의 연관 관계를 기술하는 속성    출처      유노코딩  ","categories": ["CSS"],
        "tags": ["css 구성","css 주석"],
        "url": "/css/css-cssgrammer/",
        "teaser": null
      },{
        "title": "display속성&border속성",
        "excerpt":"📄 display 속성   display 속성은 요소를 블록과 인라인 요소 중 어느 쪽으로 처리할지 정의합니다.   display 속성 값      inline: 인라인으로 처리   block: 블록 레벨로 처리   inline-block: 인라인으로 배치하되, 블록 레벨 요소의 속성을 추가할 수 있도록 처리   none: 존재는 하되, 디스플레이하지 않음   div {   display: inline; } div {   display: block; } div {   display: inline-block; } div {   display: none; }   📄 border 속성   요소가 차지하고 있는 영역에 테두리를 그릴 수 있습니다.  border 속성에는 속성값으로 테두리의 두께, 모양, 크기 등을 함께 지정할 수 있는데,  이러한 속성을 ‘단축속성’이라고 합니다.   &lt;!--두께가 2px인 직선 모양(solid)의 초록(green) 테두리를 만들어줘-- &gt; span {   border: 2px solid green; }   border 속성의 하위 속성      border-color: color 정의 방식과 동일   border-width: thin, medium, thick 등의 키워드 또는 px, em, rem 등의 단위   border-style: none, solid, dotted, dashed 등   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["display","border"],
        "url": "/css/css-display&border/",
        "teaser": null
      },{
        "title": "margin&padding 다루기",
        "excerpt":"📄 하위 속성 정의하기   div {   padding-top: 10px;   padding-right: 20px;   padding-bottom: 30px;   padding-lefr: 40px; }   위와 같이 margin에도 동일한 접미사를 붙여 개별 정의할 수 있습니다.   📄 여러 값을 한 번에 정의하기   span {   display: inline-block;   width: 100px;   height: 100px;   margin: 10px 20px 30px 40px;   &lt;!--순서: top-right-bottom-left--&gt;; }   위와 같이 padding에도 동일한 접미사를 붙여 개별 정의할 수 있습니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["margin","padding"],
        "url": "/css/css-margin&padding/",
        "teaser": null
      },{
        "title": "특성 선택자와 결합자",
        "excerpt":"📄 특성 선택자   특성 선택자(속성 선택자)는 주어진 속성의 존재 여부나 그 값에 따라 요소를 선택합니다.   [class] {   background-color: tomato; // 클래스 속성을 가진 요소에 컬러 적용. }  [class=\"item\"] {   background-color: tomato; // 클래스가 item인 요소에 컬러 적용. }  [class*=\"it\"] {   color: white; // 클래스 값에 \"it\"가 포함되는 요소에 컬러 적용. }  [class^=\"it\"] {   color: white; // 클래스 값이 \"it\"으로 시작하는 요소에 컬러 적용. }  [class$=\"it\"] {   color: white; //클래스 값이 \"it\"으로 끝나는 요소에 컬러 적용. }   📄 결합 선택자   결합 선택자(결합자)는 두 개 이상의 선택자를 결합시켜 결합된 조건을 만족하는 요소를 선택합니다.   ▪ 자손 결합자   두 개의 선택자 중 첫 번째 선택자 요소의 자손을 선택할 수 있습니다.   div p {   color: white; // div요소 안에 위치하는 모든 p 요소에 컬러 적용. }  div &gt; p {   color: white; // div 요소의 바로 아래에 위치하는 모든 p 요소에 컬러 적용. }   ▪ 형제 결합자   두 개의 선택자 중 첫 번째 선택자 요소의 형제를 선택할 수 있다.   h1 ~ p {   color: red; // h1 요소의 뒤에 오는 형제 중 모든 p 요소에 컬러 적용. }  h1 + p {   color: red; } // h1 요소의 바로 뒤에 오는 형제 p 요소에 컬러 적용.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["특성 선택자","자손 결합자","형제 결합자"],
        "url": "/css/css-Attribute_selectors/",
        "teaser": null
      },{
        "title": "fixed&sticky",
        "excerpt":"📄 position: fixed;   요소를 일반적인 문서의 흐름에서 제거하고, 지정된 위치에 고정시킵니다.   .pos {   position: fixed;   top: 50px;   left: 50px; }      위에서부터 50px 왼쪽에서부터 50px 떨어진 자리에서 움직이지 않는다.    📄 position: sticky;   요소를 일반적인 문서 흐름에 따라 배치하고, 스크롤(roll)되는 가장 가까운 상위 요소에 대해 오프셋을 적용합니다.   .pos {   position: sticky; }      스크롤 이동으로 요소가 움직여도 스티키 요소는 고정된 상태를 유지한다.    출처      유노코딩  ","categories": ["CSS"],
        "tags": ["fixed","sticky"],
        "url": "/css/css-fixed&sticky/",
        "teaser": null
      },{
        "title": "float&clear",
        "excerpt":"📄 float   float속성은 요소가 문서의 흐름에서 제외되어 자신을 포함하고 있는 컨테이너의 왼쪽이나 오른쪽에 배치되게 합니다.  문서의 흐름에선 제외되지만, 필요한 만큼의 공간은 차지합니다.   주로 레이아웃을 구성할 때 블록레벨 요소를 가로 정렬하기 위해 사용됩니다.   float의 속성값      none: 기본값   left: 왼쪽부터 가로정렬   right: 오른쪽부터 가로정렬   float: left; float: right; margin: 0 auto; /* 중앙 정렬 */   📄 clear   clear속성은 float 요소 이후에 표시되는 요소의 동작들을 조절합니다.   컨테이너 요소에 float요소를 적용하고 이후 요소에 더이상 float을 적용하고 싶지 않을 때 사용합니다.   clear의 속성값      none: 기본값   left: float이 left인 요소의 아래로 내려가겠다    right: float이 right인 요소의 아래로 내려가겠다    both: float이 left및 right인 요소의 아래로 내려가겠다    .left {   background-color: #ff8c00;   width: 150px;   height: 50px;   float: left; } .right {   background-color: #9932cc;   width: 150px;   height: 50px;   float: right; } p {   clear: both; }   출처           유노코딩            Inpa Dev - Float 속성 간단 정리      ","categories": ["CSS"],
        "tags": ["fixed","sticky"],
        "url": "/css/css-float&clear/",
        "teaser": null
      },{
        "title": "GIT에 대한 이해",
        "excerpt":"📄 GIT에 대한 이해   GIT은 VCS(VersionControlSystem)중 하나 입니다.  서버에만 히스토리 정보가 있는것이 아니라 모든 개발자들이 동일한 히스토리 정보를 가지고 있는 것을 분산형 버전관리 시스템이라고 합니다.  분산된 시스템을 이용하게 되면 서버에 문제가 생기거나 인터넷이 없어도 각각의 개발자 들이 일을 진행 할 수 있습니다.  깃에는 원격 저장소가 중앙서버 역할을 하여 사용자의 컴퓨터에 있는 로컬 저장소와 소스코드를 주고 받습니다.  따라서 다른 사용자와 협업할 때도 유용하며 코드의 변경내역을 기록하기 때문에 안전하게 소스를 작성할 수 있습니다.   📄 용어 정리      초기화: 폴더를 깃 저장소로 변경합니다. 아래와 같이 커맨드창에 입력하여 초기화 할 수도 있습니다.   git init      커밋: 변경된 코드의 이력을 기록합니다.   브랜치: 분리 격리된 코드의 이력을 기록합니다.   병합: 기존 이력과 분리된 이력을 통합합니다.   푸시: 로컬 저장소의 이력을 서버로 전송 및 공유합니다.   공부한 곳   [더 북] https://thebook.io/080212/ [강 의] 드림코딩     깃을 이해하여 보다 나은 코드 작성을 위해 차근차근 익혀 나간다.  그냥 넘겼었던 용어를 다시 보고 이해가 안되는 부분이 있으면 강의를 듣고 검색을 하며  깃의 근본을 이해해고 파악하는 중이다.   ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git-git/",
        "teaser": null
      },{
        "title": "리눅스 터미널 명령어 정리",
        "excerpt":"📄 Manual   man(manual)   매뉴얼(manual)을 뜻합니다.  나가고 싶을 때 q를 입력합니다.   clear   터미널에 있는 모든 텍스트를 깔끔하게 청소합니다.   📄 Navigating file system   pwd   현재 어떤 경로에 있는지 전체 경로를 프린트합니다.  윈도우버전 - Get-Location   ls(list)   현재 경로에 어떤 폴더와 파일들이 있는지 프린트합니다.  윈도우버전 - Dir        ls-l(list-long): 파일의 상세 속성을 확인합니다.    ls -a(list-all): 숨겨진 파일들도 모두 확인합니다.(윈도우버전 - ls -force)    open .   현재 경로를 파일 탐색기에서 엽니다.   윈도우버전 - explorer .     cd(change directory)   해당 폴더로 이동합니다.        cd..: 상위 경로로 이동합니다.    cd~ : 현재 설정된 사용자의 최상위 경로로 이동합니다.    cd - : 바로 이전 경로로 이동합니다.    find   특정한 파일이나 폴더를 찾습니다.   윈도우 버전- get-childitem       find . -type file -name “.text” : 파일 안의 모든 text파일을 찾습니다. 다양한 파일 유형으로 변경하여 활용가능합니다.  윈도우 버전 - get-childitem -File -Filter “.txt” -Recurse    find . -type directory -name “*2” : 이름이 2로 끝나는 폴더를 찾습니다.    which   실행하고자 하는 프로그램이 어디에 설치되어 있는지 경로를 확인할 때 사용합니다.  윈도우 버전 : get-command      📄 Create and manage files   touch 파일이름   파일을 생성합니다.  윈도우 버전 - new-item 파일이름     cat 파일이름   파일 안의 내용을 확인합니다.     echo “문자열” &gt; 파일   문자열을 파일에 작성합니다.       echo “문자열” » 파일 내용을 덮어 씌우지 않고 추가로 작성합니다.     mkdir   새로운 경로를 생성합니다.       mkdir -p 원하는경로/원하는경로/원하는경로 : 원하는 경로를 쭉 생성합니다.    cp 파일이름 경로/   파일을 복사합니다.     mv 파일이름 경로/   파일을 이동합니다.     rm 파일이름   파일을 삭제합니다.       rm -r 폴더이름 : 폴더 삭제     grep(Global Regular Expression Print)   특정 키워드를 검색합니다.  윈도우 버전 - select-string      grep “world” .txt    grep -n “world” *.txt : 모든 텍스트파일안의 word가 몇번째 줄에 있는지 검색합니다.    grep -nir “world” . : 현재경로를 포함한 모든 하위경로 내에서 검색합니다.     📄 Work with environment variables(환경 변수 설정하기)   export   ex. export MY_DIR=”dir1”   윈도우 버전 - $env:MU_DIR = “dir1”       cd $MY_DIR: 환경변수를 사용하고 작업 수행이 가능합니다.    unset MU_DIR: 환경변수를 제거합니다.  윈도우 버전 - $env:MY_DIR = ““     📄 vim   수정모드: i  나가기: esc + :W 수정 내용 저장 후 종료 / q: 저장하지 않고 종료     📄 새로 알게 된 용어   WSL   Windows Subsustem for Linux 윈도우 안에 리눅스시스템이 적용되어 있다.   alias   이미 정의된 데이터 오브젝트에 대해 좀더 이해하기 쉽고, 보다 의미있게 붙인 이름.   사용자가 명령어를 새로운 이름으로 정의할 수 있도록 허용한다.     학교다닐때 제일 어려워하고 싫어했던 리눅스 명령어를 제대로 파고들어봤다.  명령어 자체가 배울 땐 지루하고 따분하지만  사실 코딩을 하고 직접 경로를 다룰때는 이만큼 편한게 없는 듯 싶다.  공부를 하면 할 수록  맥북 사고 싶다ㅎㅎ  ","categories": ["Git"],
        "tags": ["리눅스"],
        "url": "/git/git-%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%84%B0%EB%AF%B8%EB%84%90-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/",
        "teaser": null
      },{
        "title": "z-index",
        "excerpt":"📄 z-index   z-index 속성은 요소의 쌓임 순서(stack order)를 정의합니다.  정수 값을 지정하여 쌓임 맥락(stacking context)에서의 레벨을 정의하는 방식으로 적용됩니다.  위치 지정 요소에 대해 적용할 수 있는 속성입니다.    .first {   z-index: 1; } .second {   z-index: 2; } .third {   z-index: 3; } .fourth {   z-index: 1; }   간단히 말해, 요소들의 z축 순서를 결정해 주는 속성입니다.      z-index은 정해진 정수 값이 있는 것이 아니라, 상대적인 수로 쌓임 맥락이 결정됩니다.   z-index의 숫자가 같을 경우에는, 나중에 쌓은 요소가 위로 오게 됩니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["z-index"],
        "url": "/css/css-z-index/",
        "teaser": null
      },{
        "title": "GIT 기본 명령어 정리",
        "excerpt":"📄 GIT 명령어 정리   ▪ git status   git status   파일 정보를 확인할 수 있습니다.   git status -s   파일 정보를 더 간단히 확인 할 수 있습니다.   ▪ git init   git init   깃을 초기화 합니다.  깃을 초기화하면 commit해서 버전을 관리하는 master branch가 생성이 됩니다.  open .git(start .git)을 입력하여 깃폴더가 생성된 것을 확인할 수 있습니다.   ▪ git rm   git rm (파일)   원격저장소와 로컬저장소의 파일을 삭제합니다.  더이상 깃 프로젝트로 활용하지 않습니다.    git rm --cached (파일)   원격저장소에 있는 파일을 삭제합니다.  로컬저장소에 있는 파일은 삭제하지 않습니다.    ▪ git add   git add (파일)   untracking 파일을 staging area에 추가합니다.  이로써 staging area에 추가된 파일은 commit할 준비가 되었습니다.    ▪ git echo   git echo (파일) &gt;&gt; .gitignore   특정 파일을 버전관리에서 제외시킵니다.    ▪ git diff   git diff   commit이나 branch 사이의 다른 점 혹은 파일이나 repository와 working directory 사이의 다른 점을 보여줍니다.  즉, 수정된 파일의 내용을 상세히 확인할 수 있습니다.    git diff --staged   staging area에 있는 파일의 수정 내용을 확인할 수 있습니다.    ▪ git commit   git commit   commit은 로컬 저장소에 코드 변경 이력을 남기기 위한 작업입니다.  staging area에 있는 파일들을 원격 저장소에 업로드할 준비를 합니다.     commit 할때 팁!      변경내용을 commit할 때는 해당내용만 변경하여 commit message에 작성한다.    commit은 너무 커도 문제가 되지만, 너무 작아도 적합하지 않다. 적당한 크기는 프로젝트를 진행하면서 감을 익힌다.   출처      드림코딩  ","categories": ["Git"],
        "tags": ["Git","status","init","rm","echo","diff"],
        "url": "/git/git-commands/",
        "teaser": null
      },{
        "title": "커밋 리셋하기(reset)",
        "excerpt":"📄 커밋 리셋하기(reset)   리셋은 특정한 커밋으로 모든 것을 초기화 시키는 명령어 입니다.   📄 작업 내용 리셋하고 working directory로 가져오기   git reset HEAD~n   이와 같은 명령어를 이용하면 HEAD부터 n번째에 있는 커밋들을 reset합니다.  작업하던 내용은 사라지지 않고 working directory로 이동합니다.   📄 작업 내용 리셋하고 staging area로 가져오기   git reset --soft HEAD~n   이와 같은 명령어를 이용하면 HEAD부터 n번째에 있는 커밋들을 reset합니다.  작업하던 내용은 사라지지 않고 staging area로 이동합니다.     아직 작업 중인 내용이 있지만 커밋을 하지 않으면 불안하고 작업단위를 구분하고자 임시 저장 내용으로 커밋하고 자 할때 유용하게 사용할 수 있는 명령어 입니다.     이렇게 사용하면 무분별한 커밋메시지가 쌓이지 않게 됩니다.   📄 작업 내용 완전히 리셋하기   git reset --hard  작업내용을 working directory, staging area로 가져오지 않고 완전히 리셋하여 파일 내용이 완전히 삭제됩니다.   포인터가 첫 번쨰 commit을 가리키는데 이 상태로 초기화 하는 것은,  마지막으로 커밋한 이후에 수정한 모든 local의 파일들을 초기화하는 것을 뜻합니다.           working directory가 비워진 것을 확인할 수 있습니다.   ","categories": ["Git"],
        "tags": ["커밋 리셋","git reset"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EB%A6%AC%EC%85%8B%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "Commit Head란?",
        "excerpt":"📄 HEAD란?   파일을 commit할 때, 현재 commit한 파일은 이전 commit한 파일을 참조합니다.   a b c d 순으로 commit한다고 가정할 때, b는 a를 가리키고 c는 b를 가리킵니다.   이런식으로 commit을 해 나가는 기본 줄기를 master branch 라고 합니다.      a &lt;- b&lt;- c&lt;- d (시각적 표현)    이 master brach에서 HEAD는 마지막으로 commit한 d파일을 가리키게 됩니다.   이때 c는 head~1이 되어 head가 있는 곳에서 첫 번째 부모임을 설명합니다.   b도 마찬가지로 head~2가 됩니다.   만약, b로 돌아가고 싶다면   git checkout b해쉬태그   를 입력하여 b로 돌아갈 수 있습니다.      git checkout master   위와 같이 입력하면 다시 원상태로 돌아옵니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["commit","Head"],
        "url": "/git/Commit-Head/",
        "teaser": null
      },{
        "title": "[flex-box] flex-direction & flex-wrap",
        "excerpt":"📄 flex-direction &amp; flex-wrap   플렉스박스는 행 또는 열을 주축으로 설정하여 웹 요소를 배치 및 정렬하는 1차원 레이아웃 방식   📄 flex-direction   플렉스 컨테이너의 주축을 결정하는 속성입니다.   flex-direction: row; /*플렉스의 진행방향이 가로축이다.*/ flex-direction: row-reverse; /*플렉스의 진행방향이 가로축 반대방향이다.*/ flex-direction: column; /*플렉스의 진행방향이 세로축이다.*/ flex-direction: column-reverse; /*플렉스의 진행방향이 세로축 반대방향이다.*/   📄 flex-wrap   플렉스 아이템들이 강제로 한줄에 배치되게 할 것인지,  또는 가능한 영역 내에서 벗어나지 않고 여러행으로 나누어 표현 할 것인지 결정하는 속성입니다.   flex-wrap: nowrap; /*기본값: 반드시 한줄로 배치된다.*/ flex-wrap: wrap; /*플렉스 컨테이너의 영역이 좁아짐에 따라 플렉스 아이템이 새로운 행으로 형성된다.*/ flex-wrap: wrap-reverse; /* 역순으로 wrap이 된다.*/   📄 flex-flow   wrap속성을 한번에 여러개 지정할 수 있는 단축 속성입니다.   flex-flow: row-reverse wrap;   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["flex-direction","flex-wrap","flex-flow"],
        "url": "/css/css-flex-direction&flex-wrap/",
        "teaser": null
      },{
        "title": "[flex-box] flex-grow & flex-shrink & flex-basis",
        "excerpt":"📄 flex-grow (기본값:0)   플렉스아이템이 기본 크기보다 더 커질 수 있는지를 결정하고,  플렉스컨테이너 내부의 할당받을 공간을 상대적으로 정의하는 속성입니다.    속성값(숫자)는 음수는 적용되지 않습니다.   li:nth-child(2) {   /*컨테이너가 커질 때, 두번째 아이템이 상대적으로 더 큰 크기를 가지게 된다.*/   flex-grow: 1; }  li:nth-child(3) {   /*flex-grow가 1인 아이템보다 더 큰 크기를 가진다.*/   flex-grow: 2; }   📄 flex-shrink (기본값:1)   플렉스 아이템이 기본 크기보다 더 작아질 수 있는지를 결정합니다.  플렉스컨테이너 내부의 할당받을 공간을 상대적으로 정의하는 속성입니다.       속성값(숫자)는 음수는 적용되지 않습니다.    li:nth-child(2) {   /*컨테이너 크기가 작아질 때, 두번째 아이템은 더 크기가 작아진다.*/   flex-shrink: 2; }  li:nth-child(3) {   /*flex-shrink가 2인 아이템보다 더 많이 줄어든다.*/   flex-shrink: 3; }     주로 반응형 웹을 만들 때 주로 사용하는 속성들입니다.  화면이 줄어들 때 어떤요소가 더 커지고 줄어들지 상대적으로 지정할 때 적절히 사용하면 유용합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["flex-grow","flex-shrink","flex-basis"],
        "url": "/css/css-flex-grow&flex-shrink/",
        "teaser": null
      },{
        "title": "[flex-box] justify-content",
        "excerpt":"📄 justify-content   플렉스아이템들이 플렉스박스 주축을 따라 배치될 때,   요소 사이의 공간을 분배하는 방식을 결정합니다.   justify-content: flex-start; /* 기본값*/ justify-content: flex-end; /*순서는 그대로 유지한채 뒤로 붙음. 리버스가 아님.*/ justify-self: center; /*가운데 정렬*/ justify-content: space-around; /*요소들이 동일한 여백을 가진다.*/ justify-content: space-between; /*양끝에 여백 없이 요소들을 동일한 간격으로 펼친다.*/ justify-content: space-evenly; /*플렉스 컨테이너가 요소 사이에 동일한 여백을 만든다.*/   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["justify-content"],
        "url": "/css/css-justify-content/",
        "teaser": null
      },{
        "title": "[flex-box] order",
        "excerpt":"📄 order   플렉스 아이템의 배치 순서를 결정합니다.  지정한 숫자(정수)에 맞춰 오름차순으로 배치합니다.  코드에 영향을 끼치는 것이 아닌, 보여지는 순서에만 영향을 줍니다.    li:nth-child(1) {   order: 5; } li:nth-child(2) {   order: -4; } li:nth-child(3) {   order: 3; } li:nth-child(4) {   order: -2; } li:nth-child(5) {   order: 1; }   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["order"],
        "url": "/css/css-order/",
        "teaser": null
      },{
        "title": "취소사항을 버전으로 남기기 (revert)",
        "excerpt":"📄 취소사항을 버전으로 남기기   reset이나 restore같은 명령어들은 history에 돌아갔다는 기록이 남지 않습니다.   이떄 기록을 남기기 위해서 revert명령어를 사용합니다.   git revert 해쉬코드 또는 HEAD~n을 사용하여 커밋을 취소하고 기록을 남깁니다.        이렇게 커밋에서 변경했던 모든 내용을 다 삭제 해주는 새로운 커밋이 생긴 것을 확인할 수 있습니다.    📄 버전을 남기지 않고 revert하기   revert에 –no-commit이라는 옵션을 남깁니다.   git revert --no-commit 해쉬코드 또는 HEAD~n   위와 같은 명령어를 이용해 커밋을 취소하면 기록이 남지 않게 됩니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["commit","revert"],
        "url": "/git/git-%EC%9E%91%EC%97%85%EC%83%81%ED%83%9C-%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "[grid] 그리드 레이아웃",
        "excerpt":"📄 그리드(grid) 레이아웃   그리드 레이아웃은 그리드 컨테이너 안의 그리드 아이템을 행과 열을 통해 정렬해 주는 2차원 레이아웃 방식을 뜻합니다.   그리드 레이아웃은 기본적으로 블록라인 컨테이너 입니다.  display: inline-grid;로 인라인 레벨 요소로 만들어 줄 수 있습니다.       그리드 컨테이너: 그리드 방식으로 레이아웃을 결정할 요소   그리드 아이템: 그리드 컨테이너 내부에서 그리드 방식으로 배치되는 요소들   📄 grid-template-columns   그리드 컨테이너의 트랙 중 열트랙에 있는 아이템들의 크기를 정해주는 속성입니다.  트랙은 그리드 컨테이너의 행 또는 열을 뜻합니다.   grid-template-columns: 100px 1fr; /*열 크기&amp;개수를 지정한다.*/      fr: 남아있는 공간에서 비율로 나눈다.    📄 grid-template-rows   그리드 컨테이너의 트랙 중 행트랙에 있는 아이템들의 크기를 정해주는 속성입니다.   grid-template-rows: 200px 1fr 1fr; /*행 크기&amp;개수를 지정한다.*/   📄 gap(grid-gap)   gap은 그리드 아이템의 간격 사이사이의 간격을 결정해주는 속성입니다.  아래와 같이 단축속성으로도 작성가능합니다.   gap: 20px 10px; /*행사이의 간격은 20px, 열사이의 간격은 10px*/   📄 트랙 관련 함수   ▪ repeat(): 반복되는 값을 자동으로 처리하는 함수  ▪ minmax(): 최솟값과 최댓값을 각각 지정할 수 있는 함수  ▪ auto-fill &amp; auto-fit: 반응형을 고려해 사용할 수 있는 키워드들(함수x)     auto-fil: 컨테이너의 여백을 남긴다.   auto-fit: 컨테이너의 여백을 채워준다.   grid-template-columns: repeat(auto-fit, minmax(100px, auto)); /*컨테이너의 여백없이 그리드 아이템의 크기의 최솟값은 100px, 최댓값은 자동으로 만든다.*/      📄 grid-column &amp; row   그리드 컨테이너의 줄번호를 이용하여 아이템을 배치하고 크기를 지정합니다.    grid-row: 1 / 2; /*1번 아이템이 행의 1~2번까지 크기를 차지한다.*/ grid-column: 1 / 3; /*1번 아이템이 열의 1~3번까지 크기를 차지한다.*/   다른 방식으로도 크기를 지정할 수 있습니다.   grid-row-start: 1; /* 행의 1번줄부터 3번줄까지 크기 차지*/ grid-row-end: 3; grid-column-start: 2; /* 열의 2번줄부터 4번줄까지 크기 차지*/ grid-column-end: 4;   📄 align &amp; justify   ▪ align-items   그리드 아이템들을 수직(열) 정렬합니다.  그리드 컨테이너에 지정합니다.   align-items: stretch; /*기본값: 열의 높이만큼 늘어난다.*/ align-items: start; /*열의 시작부분에 붙는다.*/ align-items: end; /*열의 끝에 붙는다.*/   ▪ align-self   각각의 그리드 아이템이 어떤 식으로 배치될 것인지를 스스로 결정합니다.   li:nth-child(2) {   align-self: start; } /*2번 아이템에만 start적용*/   ▪ justify-items   그리드 아이템들을 수평(행) 정렬합니다. 그리드 컨테이너에 지정합니다.    justify-items: stretch; justify-items: start; /*행너비의 시작부분에 붙는다.*/ justify-items: end; /*행너비의 끝에 붙는다.*/   ▪ justify-self   수평축(행)을 따라 각각의 그리드 아이템이 어떤 식으로 배치될 것인지를 스스로 결정합니다.    li:nth-child(3) {   justify-items: end; } /*3q번 아이템에만 end적용*/   📄 align-content &amp; justify-content   align-content와 justify-content의 속성들은 진행방향만 다른채  같은 성격을 공유합니다.   ▪ align-content   그리드 컨테이너의 열방향의 정렬방식을 지정합니다.    align-content: start; /*기본값*/ align-content: end; /*컨테이너 전체의 공간 밑에 붙는다.*/ align-content: space-around; /*각각의 아이템이 진행방향으로의 여백을 동일하게 가진다.*/ align-content: space-between; /*컨테이너의 위, 아래에 붙인 상태의 여백이 동일하다.*/ align-content: space-evenly; /*모든 여백이 똑같다.*/   ▪ justify-content   그리드 컨테이너의 행방향의 정렬방식을 지정합니다.   justify-content: center; /* 행의 가운데에 정렬한다.*/ justify-content: space-between; /*컨테이너의 왼쪽, 오른쪽에 붙인 상태의 여백이 동일하다.*/   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["grid"],
        "url": "/css/css-grid/",
        "teaser": null
      },{
        "title": "브랜치(branch)란 무엇인가",
        "excerpt":"📄 브랜치(branch)란 무엇인가   브랜치는 하나의 줄기에서 뻗어나온 과정들을 의미합니다.  즉, 저장공간 하나에서 빠져나오는 또다른 가상의 저장공간들을 생성하는 것을 뜻합니다.   📄 브랜치 과정   별도로 브랜치를 따로 작성하지 않으면 master 브랜치에서 계속 작성됩니다.  만약 새로운 기능을 만든다면, 새로운 브랜치를 만들어서 작업을 해나아가는 것이 중요합니다.  이런식으로 커밋을 하면 다수의 개발자들이 다수의 작업을 병렬적으로 처리하는 것이 가능해집니다.  이후 master 브랜치 외 featureA브랜치에서 작업이 완료가 되었다면, featureA의 커밋들을 master브랜치에 merge를 하게 되어 master브랜치에 병합합니다.  이때 featureA의 커밋들을 모두 master 브랜치로 가져오는 것 보다는, 커밋들을 합해서 새로운 하나의 커밋을 만들어 준 후에 master 브랜치로 가지고 오는 방법도 있습니다.   이후 featureA 브랜치는 삭제를 하여 깔끔하게 정리합니다.   📄 브랜치 관련 명령어   브랜치 확인하기   ▪ git branch   생성된 모든 브랜치를 확인할 수 있습니다.        ▪ git branch -all   서버를 포함한 생성된 모든 브랜치를 확인할 수 있습니다.   브랜치 생성하기   ▪ git branch (브랜치명)   브랜치를 생성합니다. 다만, 생성한 브랜치는 만들어지기만 하고 현재의 브랜치는 변하지 않습니다.      브랜치 이동하기   ▪ git switch (브랜치명)   원하는 브랜치로 이동합니다.   ▪ git switch -C new-branch1   새로운 브랜치를 생성함과 동시에 바로 이동합니다.   브랜치 삭제하기   ▪ git branch -d (브랜치명)   해당 브랜치를 삭제합니다.   ▪ git push origin --delete (브랜치명)   원격 저장소의 브랜치를 삭제합니다.   브랜치 이름 변경하기   ▪ git branch --move (브랜치명) (변경할 브랜치명)   브랜치 이름을 새롭게 변경합니다.   ▪ git push --set-upstream origin (변경할 브랜치명)      변경할 브랜치명을 원격저장소에 업데이트 합니다.    출처      드림코딩  ","categories": ["Git"],
        "tags": ["브랜치"],
        "url": "/git/git-branch/",
        "teaser": null
      },{
        "title": "log 관련 명령어",
        "excerpt":"📄 log 관련 명령어   log는 커밋한 히스토리를 볼 수 있는 명령어입니다.   git log를 통해 확인할 수 있는 것은 다음과 같습니다.      commit 아이디   작성자   commit 시간   타이틀      ▪ git log oneline      해쉬코드의 앞자리 문자열과 간단한 커밋메세지를 간단하게 확인할 수 있습니다.       ▪ git log -3      최근 히스토리 3개를 보여줍니다.     ▪ git log --author=\"sujin\"       sujin이라는 이름의 사용자가 커밋한 히스토리를 보여줍니다.    ▪ git log --before=\"2020-07-24\"       2020-07-24 이전의 커밋한 히스토리를 보여줍니다.     ▪ git log --grep=\"project\"      project가 들어간 커밋 타이틀을 보여줍니다.     ▪ git log -S \"about\"      커밋 내용에 about이 들어간 히스토리를 보여줍니다.     ▪ git log about.txt      about.txt에 해당하는 히스토리를 볼 수 있습니다.     ▪ git log -p         patch 옵션을 사용하면 수정된 파일의 내용들도 확인할 수 있습니다.     ▪ git log -p \"about.txt\"       about.txt.에 해당하는 좀 더 자세한 히스토리를 볼 수 있습니다.     ▪ git log HEAD~1       git log의 HEAD에서 이전 부모부터 히스토리를 볼 수 있습니다.     ▪ git show (해당 해쉬코드)       해당하는 커밋의 내용을 볼 수 있습니다.    ▪ git diff (해쉬코드1) (해쉬코드2)       두가지 커밋 내용을 비교하며 내용을 확인 할 수 있습니다.    참고      드림코딩  ","categories": ["Git"],
        "tags": ["log","show","diff"],
        "url": "/git/git-log-%EA%B4%80%EB%A0%A8-%EB%AA%85%EB%A0%B9%EC%96%B4/",
        "teaser": null
      },{
        "title": "머지(merge)",
        "excerpt":"📄 머지(merge)   독립된 브랜치에서 작업이 끝나면 다시 원본 브랜치에 작업한 결과를 반영하는 것을 말합니다.   📄 fast-forward merges   새로운 브랜치를 생성했을 때 merge를 할 경우,  master 브랜치가 가리키던 포인터를 새로운 브랜치로 이동시키는 것을 말합니다..  이때, 히스토리에 merge가 되었다는 사실이 남지 않고 깔끔하게 merge를 할 수 있습니다.    순서      git checkout master   master 브랜치로 이동합니다.    git merge (독립된 브랜치명)  브랜치를 병합합니다.    git branch -d (병합된 브랜치명)  더이상 필요없게 된 브랜치를 삭제합니다.   📄 fast-forward가 하기 싫을 때   히스토리를 상세히 남기는 것을 선호할 경우  git merge --no-ff feature를 사용하면 자동으로 fast-forward merges가 되는것을 방지할 수 있습니다.     📄 fast-forward가 불가능할 때   새로운 브랜치가 생성이 되고 마스터 브랜치에 새로운 커밋이 발생한 경우, fast-forward가 불가능하게 됩니다.  이렇게 되면 Three-way merge를 이용해야 합니다.  master 브랜치와 파생된 브랜치의 변동사항을 모두 합해서 merge commit을 만든 다음,   master branch에 commit을 하게 됩니다.      이렇게 merge commit된 것을 확인할 수 있습니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["merge","머지"],
        "url": "/git/git-merge/",
        "teaser": null
      },{
        "title": "cherry pick",
        "excerpt":"📄 cherry pick   작업들 중 특정 부분을 master branch로 가져오고 싶을 때 사용하는 유용한 기능입니다.   git cherry-pick 커밋해쉬코드를 입력하여 특정 커밋을 master brach로 가져옵니다.       참고      드림코딩  ","categories": ["Git"],
        "tags": ["cherry pick"],
        "url": "/git/git-cherry-pick/",
        "teaser": null
      },{
        "title": "Git Conflict 해결 방법",
        "excerpt":"📄 merge conflict   merge를 하는 과정에서 자동적으로 해결이 안되는 충돌이 발생한 상황을 말합니다.  예를 들어, 서로 다른 브랜치에서 동일한 파일을 수정했을 때 충돌이 발생할 수 있습니다.   아래와 같이 merge conflict가 발생한 것을 확인 할 수 있습니다.          Automatic merge failed: 자동 merge가 실패 됨.    git status를 입력해 확인해 보면 동시에 수정된 파일을 확인할 수 있습니다.       cat (파일명)을 입력하면 conflict가 발생한 부분을 알려주기 위해 자동으로 삽입된 문자열을 확인할 수 있습니다.       📄 merge conflict 수동적 해결방법           open 해당 파일 (윈도우: start 해당파일)명령어를 이용하여 conflict가 발생한 파일을 열어줍니다.              사용할 부분을 제외하고 삭제하거나, 모두 다 사용하고 싶다면 메세지만 삭제 한채 저장한 뒤 파일을 닫습니다.            git add를 이용해 conflict가 해결되었음을 알려줍니다.              git merge --continue를 입력해 merge를 마무리합니다.           📄 merge conflict tool을 이용한 해결방법: vscode           git config --global -e를 입력해서 vscode를 열어줍니다.            아래 코드를 입력해서 merge tool을 vscode로 다룰 수 있게 적용합니다.              conlict가 발생했을 때, git mergetool을 입력하면 vscode로 툴이 열리는 것을 확인 할 수 있습니다.       📄 merge conflict tool을 이용한 해결방법: p4merge           p4merge를 검색 후 다운받습니다.              아래 코드를 입력해서 merge tool을 p4code로 다룰 수 있게 합니다.              conlict가 발생했을 때, git mergetool을 입력하면 vscode로 툴이 열리는 것을 확인 할 수 있습니다.         참고      드림코딩  ","categories": ["Git"],
        "tags": ["git conflict","깃 충돌"],
        "url": "/git/git-conflict-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "리베이스(Rebase)",
        "excerpt":"📄 리베이스(Rebase)   리베이스는 파생된 브랜치의 기준이 되는 베이스 커밋을 변경하는 것입니다.   이런 방법으로 브랜치를 합칠 수 있습니다.   그렇다면 머지와 차이점이 뭘까요?   merge vs rebase      우선 rebase와 merge의 공통점은 브랜치를 합친다는 것입니다.   차이점은 rebase를 하는 경우는 merge보다 깨끗한 commit history를 만들 수 있다는 점입니다.   그림처럼 머지는 새로운 커밋을 생성해서 파생된 브랜치에 적용되지만,   리베이스는 베이스 커밋을 재설정 한 것이기 때문에 마치 처음부터 커밋된 것처럼 선형 브랜치 형태를 띄게 됩니다.   📄 주의할 점!   리베이스를 하는 경우 Base가 바뀐 커밋들은 복사되어 새로 만들어지는데, 이 과정에서 commit Id가 변경됩니다.   이때 다른 개발자와 함께 파생된 브랜치에서 작업을 할 경우, 리베이스를 하면 merge conflict가 발생할 수 있습니다.   그러므로 서버에 업로드된 히스토리는 절대 리베이스하면 안됩니다   📄 순서           git checkout (파생된 브랜치)를 이용해 파생된 브랜치로 이동합니다.            git rebase master를 입력해 master 브랜치의 최신버전으로 포인터를 이동시킵니다.              git merge (파생된 브랜치)를 이용하면 merge가 가능한 것을 확인할 수 있습니다.            이후 git branch -d (브랜치명)을 입력해 쓸모 없어진 브랜치를 삭제해 깔끔하게 정리해 줍니다.       📄 rebase –onto   파생된 브랜치에서 다시 파생된 브랜치의 포인터를 master 브랜치에 옮겨주는 것을 뜻합니다.  이때 rebase --onto옵션을 사용합니다.   위와 같이 포인터를 옮겨 준 후, merge를 하면 성공적으로 merge된 것을 확인할 수 있습니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["rebase"],
        "url": "/git/git-%EB%A6%AC%EB%B2%A0%EC%9D%B4%EC%8A%A4/",
        "teaser": null
      },{
        "title": "뷰포트(viewport)",
        "excerpt":"📄 뷰포트(viewport)   현재 화면에 보여지고 있는 영역을 의미합니다.   기기별로 뷰포트가 다르기때문에 보여지는 화면의 배율에 따라 화면이 다르게 보입니다.   html문서에서 이름이 뷰포트인 메타태그 설정을 확인할 수 있습니다.   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;      width=device-width : 너비를 기기의 너비 기준으로 초기화 한다. initial-scale=1.0 : 기기의 너비에 맞게 초기 scale를 지정한다.    이 메타태그 설정은 기기에 맞게 화면 배율을 조정해주기 때문에, 모바일 화면에서도 pc화면과 동일하게 콘텐츠의 크기가 유지되는 것을 확인할 수 있습니다.   📄 뷰포트 단위   뷰포트 크기를 기반으로 값을 계산하여 크기를 결정하는 가변단위들이 있습니다.   이는 반응형 웹을 만들 때 매우 유용하게 사용되는 단위들입니다.   ▪ font-size: 1vw;      화면 사이즈에서 너비의 100분의 1    화면 너비의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vh;      화면 사이즈에서 높이의 100분의 1    화면 높이의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vmin;      화면 사이즈에서 너비와 높이 중 작은것의 100분의 1 너비와 높이 중 작은 것에 백분율을 맞춘다    ▪ font-size: 1vmax;      화면 사이즈에서 너비와 높이 중 큰것의 100분의 1 너비와 높이 중 큰 것에 백분율을 맞춘다.   ","categories": ["HTML"],
        "tags": ["HTML","뷰포트"],
        "url": "/html/html-viewport/",
        "teaser": null
      },{
        "title": "미디어 쿼리(media query)",
        "excerpt":"📄 미디어 쿼리(media query)   미디어 쿼리는 미디어 타입을 인식하고, 콘텐츠를 읽어들이는 기기나 브라우저의 물리적 속성을 감지할 수 있는 기능입니다.      @media: 미디어 쿼리문 선언   screen: 가장 자주 사용되는 미디어 타입 중 하나. 화면을 뜻합니다.   /*미디어 쿼리문*/ @media screen and (min-width: 800px) {   /*800px 보다 화면이 커졌을 경우에 적용한다.*/   img {     width: 400px;     height: 400px;   } }   📄 미디어 쿼리 적용의 다른 형태   ▪ link 태그에 미디어 쿼리 추가   &lt;link rel=\"stylesheet\" href=\"style.css\" media=\"screen and (max-width: 768px)\"&gt;   ▪ @import 구문을 이용한 추가   @import url(\"style.css\") screen and (max-width: 768px);   참조      유노코딩 초보자를 위한 반응형 웹 기초 강의  ","categories": ["CSS"],
        "tags": ["미디어 쿼리"],
        "url": "/css/css-media-query/",
        "teaser": null
      },{
        "title": "git stash란?",
        "excerpt":"📄 stash란?   working directory에서 작업 도중 깃 history에 저장하지 않고도 작업 내용을 저장해 놓을 수 있는 보관소를 뜻합니다.  임시보관소로 생각하면 이해하기 편합니다.    📄 stash stack에 파일을 push하기   ▪ git stash  파일을 stash stack에 push합니다.   ▪ git stash -m \"타이틀\"  타이틀을 지정해 stash stack에 push합니다.   이렇게 파일들을 stash하게 되면 working directory와 staging area에 파일이 남지 않게 됩니다.   ▪ git stash push -m \"타이틀\" --keep-indext  만약 staging area에 있는 것을 유지하면서 stash에 저장하고 싶을 때 위와 같은 명령어를 입력하면 작업하던 내용이 유지가 됩니다.     📄 untracking 파일 stash하기   tracking되지 않은 파일은 자동으로 stash에 저장되지 않습니다.    ▪ git stash -u  위와 같은 명령어를 입력하면 모두다 stash stack에 들어가게 됩니다.     📄 stash 이력 확인하기   ▪ git stash list  위와 같은 명령어를 입력하면 stash stack을 확인할 수 있습니다.          ▪ git stash show (stash 아이디)  stash list에서 확인할 수 있는 stash아이디를 입력하면 각각 stash에서 어떤 것이 수정되었는지 확인할 수 있습니다.       만약 powershell 사용자라면, 따옴표를 추가하여 `git stash show “(stash 아이디)”으로 입력해야합니다.    ▪ git stash show (stash 아이디) -p  p라는 옵션을 이용하면 더 자세한 내용을 확인할 수 있습니다.   📄 stash 에서 다시 가져오기   ▪ git stash apply stash stack의 가장 위에 있는 부분을 working directory에 가져옵니다.  목록은 그대로 유지됩니다.   ▪ git stash apply (stash 아이디)  특정한 stash를 적용하고 싶다면 stash 아이디를 지정하여 명령어를 입력해 주면 됩니다.     ▪ git stash branch (브랜치 이름)  stash를 적용하면서 새로운 브랜치를 만들게 됩니다.   ▪ git stash pop  stash stack의 가장 위에 있는 부분을 working directory에 가져옵니다.  가지고 나온 stash는 목록에서 삭제됩니다.     📄 stash 삭제하기   ▪ git stash drop (stash 아이디)  특정 stash를 삭제합니다.     ▪ git stash clear  전체 stash를 삭제합니다.    ","categories": ["Git"],
        "tags": ["stash"],
        "url": "/git/git-stash/",
        "teaser": null
      },{
        "title": "이전 commit 수정하기",
        "excerpt":"📄 이전 commit 수정하기   최신 커밋이 아닌 이전 커밋을 수정할 때는 rebase명령어를 사용합니다.    📄 순서   1. git rebase i 해쉬코드       i는 interactive의 약자 입니다.       위와 같이 명령어를 입력하면 아래처럼 설정해둔 vscode가 열립니다.    이렇게 업데이트 될 커밋 목록을 확인할 수 있습니다.    2. 변경사항 입력   Pick은 변경없이 커밋을 그래도 사용하겠다는 뜻이므로   변경을 원하는 커밋에 PICK 대신 R(Reword)를 작성해주면 커밋메세지 입력 창이 열립니다.        이렇게 원하는 명령으로 변경합니다.    3. 변경사항 확인   히스토리를 통해 변경내역이 적용된 것을 확인할 수 있습니다.     주의할 점      수정한 커밋 뒤로 이어진 모든 커밋들도 함께 업데이트 됩니다.   참조      드림코딩 GIT마스터 과정  ","categories": ["Git"],
        "tags": ["commit","rebase"],
        "url": "/git/git-%EC%9D%B4%EC%A0%84-%EC%BB%A4%EB%B0%8B-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "git 태그(tag)",
        "excerpt":"📄 태그(tag)   태그는 특정 커밋을 북마크 해두고 싶을 때 사용하는 기능입니다.   📄 semantic versioning   숫자 세가지를 이용해서 major버전과 minor버전과 fix버전을 구분하여 나타냅니다.      major버전: 특정한 기능이 추가 되는 등 전체적인 변화가 일어났을 때 업데이트 되는 버전.   minor버전: 커다란 기능 중에서 조금의 기능이 업데이트 되거나 개선되었을 때 업데이트 되는 버전.   fix버전: 존재하는 기능 중 오류수정을 했을 때 업데이트 되는 버전.       📄 태그 확인하기   git tag (태그명)  위와 같은 명령어로 태그를 만들면 log내역을 통해서 확인 할 수 있습니다.          📄 태그 달기   git tag (태그명) (해쉬태그)  해쉬태그를 통해서 특정한 커밋에 태그를 달 수 있습니다.         📄 태그에 메세지 달기   git tag (태그명) (해쉬태그) -am (메세지)   해쉬태그를 통해 특정 커밋에 메세지를 작성 할 수 있습니다.      git show를 이용해 확인할 수 있습니다.      📄 태그 검색하기   git tag -l \"문자열\"   특정 문자열이 들어있는 모든 태그를 검색 할 수 있습니다.   📄 태그 삭제하기   git tag -d (태그명)   아래와 같이 태그를 삭제할 수 있습니다.      📄 새로운 브랜치에 태그 생성하기   git checkout -b (브랜치 이름) (태그명)   새로운 브랜치를 생성하여 태그를 만들어줍니다.      출처      드림코딩  ","categories": ["Git"],
        "tags": ["tag"],
        "url": "/git/git-%EC%B7%A8%EC%86%8C%EC%82%AC%ED%95%AD%EC%9D%84-%EB%B2%84%EC%A0%84%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "커밋 수정하기",
        "excerpt":"📄 commit 수정하기   열심히 여러가지 파일들을 커밋하다보면 커밋 메세지를 잘못 작성하는 등 커밋을 수정해야할 상황이 발생합니다.  이때 amend 명령어를 이용해 최신 커밋파일을 수정할 수 있습니다.    📄 커밋 메세지 수정하기   git commit --amend -m \"수정될 커밋 메세지\"  커밋 메세지를 수정할 경우 위와 같은 명령어를 통해 수정이 가능합니다.     📄 파일 내용 수정하기           vim 또는 직접 파일을 열어 내용을 수정합니다.              git commit amend를 이용해 커밋 파일에 수정내용을 적용합니다.         느낀점   오늘 이후로 깃을 다루는 방법이 많이 달라질 듯 하다.  commit파일 수정하는 법을 몰라서 그냥 push하고 수정파일을 다시 커밋하고 push했었는데  더 이상 번잡한 과정은 겪지 않게 되었다.   ","categories": ["Git"],
        "tags": ["amend","commit"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "가변 동영상",
        "excerpt":"📄 가변 동영상   동영상도 이미지와 마찬가지로 화면 배율에 따라 가변적으로 크기를 설정할 수 있습니다.   다만 유튜브 등 동영상 서비스에 따라 성질이 다를 수 있어 주의해야 합니다.   📄 가변 동영상 설정 1 | vedio 태그   &lt;video src=\"./my-cat.mp4\" controls&gt;&lt;/video&gt;   동영상 파일을 직접 가지고 있다면, 이렇게 body태그안에서 video태그를 설정하면 됩니다.   컨트롤 속성으로 컨트롤 패널을 추가했습니다.   style태그에서 너비를 %단위로 지정하게 되면 화면 크기에 따라 동영상 화면 크기가 변합니다.   📄 가변 동영상 설정 2 | iframe 태그   하지만 동영상 파일을 직접 가지고 있지 않다면 유튜브 등 동영상 서비스를 이용하는 방법이 있습니다.   유튜브에서 원하는 동영상을 선택후 공유 &gt; 퍼가기를 선택합니다.      유튜브는 이렇게 iframe태그를 제공합니다.   이 iframe 태그를 body태그로 가져오면 웹페이지에 동영상을 설정할 수 있습니다.   ▪ iframe 태그의 문제점   style태그에서 iframe태그의 너비를 100%로 설정해주면 생각보다 동영상 화면 크기 전환이 자연스럽지 않은 것을 확인할 수 있습니다.   제공받은 iframe태그는 동영상 서비스에서 다양한 속성을 설정하는 등 단순하지 않은게 이유가 됩니다.   이 문제는 여백을 만들어주고 그 여백에 동영상 크기를 맞춤으로써 해결할 수 있습니다.   &lt;div class=\"player\"&gt;         &lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BYMM5Dh_tSY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;      여백을 설정해줄 div를 설정해준 후 iframe태그를 넣었습니다.   &lt;style&gt;      .player{        padding-top: 56.25%;        position: relative;       }      iframe{        position: absolute;        top: 0; left: 0;        width: 100%;        height: 100%;      } &lt;/style&gt;      스타일 태그안에서 클래스 선택자를 이용해 player로 설정한 div의 padding-top크기를 동영상의 종횡비에 맞추어 %단위로 지정했습니다.   iframe은 position을 이용해 위치를 고정시키고 너비와 높이를 부모 요소인 player에 맞게 100%설정했습니다.   이렇게 iframe태그로 동영상을 가져오면 크기 전환이 더 자연스럽고 보다 나은 웹 구현이 가능하게 됩니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["가변 동영상","video","iframe"],
        "url": "/css/css-variable-video/",
        "teaser": null
      },{
        "title": "SSH로 간편하게 push하기",
        "excerpt":"📄SSH란?   Secure SHell protocol의 약자로 터미널과 서버간에 안전하게 아이디와 비밀번호를 유지해주는 방법입니다.   서버에는 public key를 생성하고 사용자의 컴퓨터에는 private key를 생성해 넣음으로써 push를 할 때 번거롭게 아이디와 비밀번호를 입력하지 않아도 됩니다.   📄 순서   1. 깃허브 페이지에서 setting &gt; SSH keys and GPS keys 로 이동     아직 등록된 SSH key가 없는 것을 확인할 수 있습니다.     2. Git Bash 열기   3. 키 생성하기   다음과 같은 명령어를 입력하면 키를 생성한다는 메세지가 출력됩니다.   $ ssh-keygen -t ed25519 -C \"your_email@example.com\"   혹시 본인의 이메일을 잊었다면 git config --list를 통해 확인 가능합니다.  키가 저장될 경로를 확인 후 비밀번호를 설정하지 않는다면, ‘ENTER’를 두번 입력합니다.        출력된 메세지를 확인해보면 public key와 private key가 어느 폴더에 저장되었는지 확인할 수 있습니다.   4. 키 설정하기   저장된 public key를 복사해서 github페이지로 돌아가 설정합니다.   이렇게 커밋을 할때마다 아이디와 비밀번호를 입력하지 않고 검증된 유저로 커밋을 할 수 있게 되었습니다.   출처      드림코딩  ","categories": ["Git"],
        "tags": ["SSH"],
        "url": "/git/git-SSH%EB%A1%9C-%EA%B0%84%ED%8E%B8%ED%95%98%EA%B2%8C-push%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "🚨 The following untracked working tree files would be overwritten by merge",
        "excerpt":"🚨 The following untracked working tree files would be overwritten by merge   git 저장소에서 파일을 당겨 오는데 오류가 발생했다.   error: The following untracked working tree files would be overwritten by merge: 오류 발생한 파일 위치 및 이름 Please move or remove them before you can merge.   깔끔하게 하고 싶어서 자꾸 이것저것 해서 그런가 overwritten 됐단다.  역시나 하라는 대로 해준다.   git clean -d -f -f   하고 다시 git pull 해주면    빠른 해결~  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git-The-following-untracked-working-tree-files/",
        "teaser": null
      },{
        "title": "🚨 Too many revisions specified",
        "excerpt":"🚨 Too many revisions specified   git 공부를 하던 도중 에러가 났다.   git stash show stash{3}   stash 변경사항을 확인하려고 명령어를 입력했는데 내 명령어를 받아주질 않는다..       너무 많은 개정이 지정되었다니..뭔말일까..   What does the error message mean, and what should I do?   구글링 gogo~   ❔ 원인   그냥 쓰던 powershell 문제 였다.   powershell은 중괄호를 좋아하지 않는다니 어쩔 수 없다.   🔨 해결   따옴표를 써서 달래주자.   git stash show \"stash{3}\"      참조      stackoverfow   느낀 점   일부러 에러가 났을 때 국내 사이트보다 해외사이트에서 해결책을 찾았다.   그러다보니 점점 해외 사이트가 눈에 익고 익숙해지는게 느껴진다.  이번 에러를 찾는 과정에선 번역기를 돌리지 않고 해결책을 찾았다.  외국이나 한국이나 웃긴점.  -&gt; 저도 이게 왜 되는지 모르겠는데 해결됐어요.  라는 글을 심심치 않게 볼 수 있다.  역시 코딩으로 하나되는 우리 지구.  ","categories": ["Git"],
        "tags": ["Git","powershell"],
        "url": "/git/git-Too-many-revisions-specified/",
        "teaser": null
      },{
        "title": "🚨 Can’t push refs to remote",
        "excerpt":"🚨 Can’t push refs to remote. Try running ‘Pull’ first to integrate your changes      파일 저장 경로가 잘못 되어 수정했더니 해결되었다. 저장 경로는 항상 주의할 것.       눌렀더니 해결. 에러 메세지를 잘 읽어보자.  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git-cant-push-refs-to-remote/",
        "teaser": null
      },{
        "title": "fetch vs pull 차이점",
        "excerpt":"📄 fetch vs pull 차이점   서버에서 commit이 발생하여 변경사항을 나의 로컬 저장소로 가져오는 상황에서 두 명령어는 차이점을 가지게 됩니다.     📄 fetch를 사용했을 경우   fetch를 사용하게 되면 나의 로컬 브랜치의 origin은 서버에서 가져온 커밋으로 위치를 바꾸지만      현재 작업중인 로컬 master 브랜치 즉, HEAD의 위치는 변하지 않습니다.     서버에 업데이트된 히스토리의 정보만 로컬로 가지고 올 때 fetch를 유용하게 사용할 수 있습니다.        git fetch origin 브랜치명  위와 같은 명령어 입력시 특정한 브랜치만 가지고 올 수 도 있습니다.     📄 pull을 사용했을 경우   pull을 사용하게 되면 origin은 물론, HEAD의 위치도 서버에서 가져온 커밋으로 위치를 변경합니다.    ","categories": ["Git"],
        "tags": ["fetch","commit","pull"],
        "url": "/git/git-fetch-vs-pull-%EC%B0%A8%EC%9D%B4%EC%A0%90/",
        "teaser": null
      },{
        "title": "서버와 로컬의 커밋이 충돌할 때",
        "excerpt":"📄 서버와 로컬의 커밋이 충돌할 때   서버와 로컬에서 동일한 파일을 수정해 커밋을 하는 경우 conflict가 발생하게 됩니다.   📄 git pull 명령어를 사용한 경우      git mergetool로 mergetool을 열어서 원하는 내용을 병합 후 저장합니다.   git add .로 모두 staging area로 이동시킵니다.   git merge --continue을 하면 로컬에서 작성한 커밋과 서버에서 작성한 커밋이 병합한 새로운 커밋을 생성하게 됩니다.   📄 git pull -rebase 명령어를 사용한 경우      git mergetool로 mergetool을 열어서 원하는 내용을 병합 후 저장합니다.   git rebase --continue로 rebase를 진행시킵니다.   기존 로컬의 커밋을 rebase했기 때문에 로컬의 커밋만 다시 새로운 커밋이 되었고 서버에서 가져온 커밋은 그대로 유지됩니다.   마지막으로 git push를 해서 로컬의 파일과 서버의 파일을 동일하게 만들어줍니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["commit","Head"],
        "url": "/git/git-%EC%84%9C%EB%B2%84%EC%99%80-%EB%A1%9C%EC%BB%AC%EC%9D%98-%EC%BB%A4%EB%B0%8B%EC%9D%B4-%EC%B6%A9%EB%8F%8C%ED%95%A0-%EB%95%8C/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "커밋 분할하기",
        "excerpt":"📄 커밋 분할하기   개발자들과 협업을 할 때는 하나의 커밋에는 하나의 내용이 있어야 합니다.   너무 많은 내용을 커밋하게 되었을 때는 커밋을 분할해야 합니다.   📄 순서   1. git rebase -i 해쉬코드 또는 HEAD~n   위와 같은 명령어를 입력하여 분할해야하는 커밋을 수정하기 위해 에디터를 띄웁니다.   에디터에서 해당 커밋의 명령어를 e(edit)로 고칩니다.   저장 후 히스토리 내역을 확인하면 HEAD가 해당 커밋으로 이동한 것을 확인할 수 있습니다.         2. git reset    명령어를 입력해 해당 커밋을 리셋시켜 파일을 working directory로 가져옵니다.       git status를 입력해 확인해 보면 rebase가 진행중이며 두개의 파일이 working directory로 온 것을 확인할 수 있습니다.   3. 각각 파일 하나씩 다시 커밋하기   파일들을 하나씩 staging area에 추가하고 다시 커밋합니다.   4. git rebase --continue   명령어를 입력해 rebase를 진행합니다.       이렇게 커밋이 분할 된 것을 확인할 수 있습니다.   참조      더 북   [강 의] 드림코딩  ","categories": ["Git"],
        "tags": ["Git","rebase","reset"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EB%B6%84%ED%95%A0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "커밋 삭제하기",
        "excerpt":"📄 commit 삭제하기   커밋 삭제 순서           히스토리 내역에 삭제하기를 원하는 커밋을 확인합니다.              git rebase -i (해쉬코드 또는 HEAD~n)  rebase 명령어를 이용해 해당 커밋까지의 내역을 수정하는 창을 띄웁니다.              삭제를 원하는 커밋에 d(drop)옵션을 입력합니다.  이렇게 되면 삭제된 파일의 다음 커밋에서 수정사항이 발생했기 때문에 conflict가 생기게 됩니다.               git status를 입력해 상태를 확인해보면, 다음과 같이 출력된 것을 확인할 수 있습니다.                 interactive rebase가 진행중인데 payment-ui.txt(삭제된 커밋 다음 커밋의 파일)이 삭제되었다.                 git add . 를 통해 삭제된 파일을 다시 추가합니다.              git rebase --continue를 통해 rebase를 계속 진행합니다.              히스토리 내역을 확인하면 해당 커밋이 삭제된 것을 확인 할 수 있습니다.      ","categories": ["Git"],
        "tags": ["Git","rebase","reset","커밋 삭제"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "커밋 전 취소하기",
        "excerpt":"📄 working directory에 있는 파일 수정 취소하기(초기화 하기)   ▪ git restore .  working directory에 있는 전체 파일을 초기화 합니다.     ▪ git restore (파일 이름)  working directory에 있는 특정 파일을 초기화 합니다.     ▪ git restore --source=(해쉬코드 또는 HEAD~n) (파일명) 파일에 대해서 특정커밋 이전 상태로 초기화 합니다.     📄 staging area에 있는 파일 수정 취소하기(초기화 하기)   ▪ git restore --staged .  staging area에 있는 전체 파일을 초기화 합니다.     ▪ git restore --staged (파일 이름)  staging area에 있는 특정 파일을 초기화 합니다.       WIP(Working In Progress): 아직 작업이 진행 중인 것을 뜻합니다.    ","categories": ["Git"],
        "tags": ["restore","commit","커밋 전 취소"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EC%A0%84-%EC%B7%A8%EC%86%8C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "커밋 합치기",
        "excerpt":"📄 커밋 합치기 순서   1. git rebase -i 해쉬코드 또는 HEAD~n   rebase해서 에디터를 열어줍니다.   2. commit을 합칠 때는 squash   커밋 명령어를 s(squash)로 바꿉니다.   다만, 병합할 커밋들 중 제일 첫번째에 있는 커밋은 바꾸지 않고 그대로 pick으로 입력합니다.   간단하게 확인   history명령어를 이용해 커밋 내역을 확인하면 병합된 커밋들을 확인할 수 있습니다.   📄 주의할 점   커밋을 병합하게 되면 병합된 커밋뿐만 아니라 이후에 커밋들도 해쉬코드가 바뀝니다.   따라서 다른 개발자들과 협업을 할 경우에는 서버에 올라간 커밋들을 수정해서는 안됩니다.   참조      더 북   [강 의] 드림코딩  ","categories": ["Git"],
        "tags": ["rebase","commit","squash"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%ED%95%A9%EC%B9%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "가변 이미지",
        "excerpt":"📄 가변 이미지   화면의 배율에 따라 크기가 달라지는 이미지 입니다.   보통 px로 고정을 시켜놓는 경우도 있지만, 그렇지 않은 경우에는 화면이 커질 수록 픽셀이 깨져보이는 현상이 발생합니다.   📄 가변 이미지 설정 1 | max-width 사용   이미지 너비를 %단위로 지정하고 max-width를 사용하면 화면이 커질수록 이미지크기가 증가하다가,  일정 크기에 도달하면 더이상 증가하지 않음으로써 이미지를 보호할 수 있습니다.    &lt;style&gt;         div{             width: 50%;/* body의 50%로 크기지정*/         }         img{              max-width: 640px; /*이미지 최대크기 지정*/         }  &lt;/style&gt;   주의할 점   width는 너비를 지정하는 속성이고, max-width는 최대 넓이 제한 길이를 지정하는 속성입니다.   혼동하지 않도록 조심해야 합니다.   📄 가변이미지 설정 2 | picture 태그 사용   주로 해상도 별로 이미지의 비율을 바꾸고 싶을때 picture태그를 사용합니다.   source태그를 통해서 이미지를 미디어 조건에 맞게 불러올 수 있습니다.    &lt;picture&gt;         &lt;source srcset=\"jake2.jpg\" media=\"(min-width: 800px)\"&gt;&lt;!--800px보다 이미지가 커지면 jake2이미지를 보여준다.--&gt;         &lt;img src=\"jake..jpg\"&gt;  &lt;/picture&gt;   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["가변 이미지","max-width","picture"],
        "url": "/css/variable-image/",
        "teaser": null
      },{
        "title": "[flex-box] align-items/self/content",
        "excerpt":"📄 align-items (Flex Item이 한줄일 때 사용)   플렉스 컨테이너의 플렉스 아이템들이 어떤 식으로 정렬될 것인지 결정합니다.    align-items: stretch; /*기본값, 아이템들이 교차축에 스트레치되어 크기가 늘어남.*/ align-items: flex-start; /*stretch가 되지 않고 교차축의 앞쪽에 배치됨*/ align-items: flex-end; /*교차축의 끝점으로부터 시작점을 향해 배치*/ align-items: center; /* 교차축의 중심부에 배치*/   📄 align-self   각각의 플렉스아이템이 교차축에서 어떤 식으로 정렬될 것인지 스스로 결정합니다.    li:nth-child(3) {   align-self: flex-start;   /*ul(컨테이너)목록 중 3번째 li(아이템)에만 flex-start적용*/ }   📄 align-content(Flex Item이 한줄이상일 때 사용)   교차축 위에서 justify-content와 동일하게 사용할 수 있는 속성입니다.      flex-wrap의 값이 wrap으로 지정되어 있을 때   아이템을 배치하기 위해 필요한 공간보다 플렉스 컨테이너가 더 클 때   align-content: space-around; /*행이 여러개가 되었을 때 요소들이 동일한 여백을 가지게 됨.*/ align-content: space-between; /*양쪽 여백이 사라진 상태에서 요소들이 동일한 여백을 가지게 됨.*/     간단히 말해, align-items는 flex-wrap이 nowrap(기본값)일때의 교차축 배치방법이고  align-content는 flex-wrap이 wrap일때의 교차축 배치방법입니다.   📄 flex-basis(기본값 : auto)   플렉스 아이템의 초기 크기를 지정합니다.  box-sizing이 따로 설정되지 않은 경우, 콘텐츠 박스의 크기를 결정합니다.    li:nth-child(2) {   /*플렉스 컨테이너가 처음 만들어졌을 때 기본 크기를 정해줌.*/   flex-basis: 100px; /*두번째 아이템 기본 크기: 100px*/   flex-shrink: 2; }   📄 flex   flex-grow, flex-shrink, flex-basis의 세 가지 속성을 한번에 정의할 수 있는 단축 속성입니다.   .item {   flex: 0 0 200px; /* 200px보다 크거나 작을 수 없음*/   flex: 0 1 200px; /*늘어나진 않지만 줄어들 수는 있음.*/ }   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["align-items","align-self","align-content"],
        "url": "/css/css-align-items/",
        "teaser": null
      },{
        "title": "CSS 텍스트 꾸미기",
        "excerpt":"📄 font-family   글꼴을 정의합니다.   여러 개의 글꼴을 연달아 작성하여 우선순위를 정할 수 있습니다.   p {   font-family: Times.monospace, serif; }   📄 font-size   글자 크기를 정의합니다.      px: 모니터 상의 화소 하나 크기에 대응하는 절대적인 크기   span {   font-size: 16px; }      rem: &lt;html&gt; 태그의 font-size에 대응하는 상대적인 크기   span {   font-size: 2rem; }      em: 부모태그(상위태그)의 font-size에 대응하는 상대적인 크기   span {   font-size: 1.5em; }   📄 text-align   정렬 방식 정의합니다.      left/right: 왼쪽 또는 오른쪽 정렬한다.   center: 가운데 정렬한다.   justify: 양끝 정렬한다.(마지막 줄 제외)   p {   text-align: right; }   📄 color   글자 색상을 정의합니다.      키워드: 미리 정의된 색상별 키워드를 정의한다.   RGB 색상 코드: # + 여섯자리 16진수 값 형태로 지정한다.   RGB 함수: Red, Green, Blue의 수준을 각각 정의해 지정한다.   span {   color: red; } span {   color: #FF000; } span {   color: rgb(100%, 0%, 0%); }   📄 line-height   글자가 위치한 높이의 크기(행간)를 의미합니다.   단위를 입력하지 않으면 브라우저가 자동으로 배율로 인식합니다.   line-height: 52px;   📄 letter-spacing   텍스트의 자간을 설정합니다.   해당 수치만큼 자간이 가까워집니다.   letter-spacing: 20px; letter-spacing: -2px;   📄 word-spacing   띄어쓰기를 기준으로한 단어의 간격을 의미합니다.   word-spacing: 20px;   📄 text-indent   텍스트의 들여쓰기를 결정합니다.   text-indent: 50px;   📄 text-transform   영문 텍스트의 대/소문자를 바꿀 수 있습니다.   text-transform: none; text-transform: capitalize; text-transform: uppercase; text-transform: lowercase;   📄 overflow   콘텐츠가 커서 요소 안에서 내용을 다 보여주기 힘들 때, 어떤 방식으로 보여줄지 결정합니다.   overflow: visible(기본값); overflow: hidden; overflow: scroll; // 무조건 스크롤 적용 overflow: auto; // 콘텐츠 밖으로 텍스트가 넘쳤을때만 스크롤 적용   📄 text-overflow   텍스트가 한줄일 때, 요소 밖으로 넘치는 text를 어떻게 표기할지 결정합니다.   선행 조건      white-space: nowrap;   overflow: hidden;   text-overflow: clip(기본값); // 공간에 맞게 텍스트가 잘림 text-overflow: ellipsis; // 잘린 텍스트를 말줄임표를 이용해 표현     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["font","text","line-height","letter","word","overflow"],
        "url": "/css/css-font/",
        "teaser": null
      },{
        "title": "상속&공용 키워드",
        "excerpt":"📄 상속(Inheritance)   상속(Inheritance)이란 하위 요소가 상위 요소의 스타일 속성값을 물려받는 것을 의미합니다.  상속 가능 여부는 속성마다 다릅니다.    상속되는 속성      color   font-family   font-size   상속되지 않는 속성      padding   margin   border   ul {   color: tamato; }   하위요소인 li 혹은 ol태그는 상위요소인 ul태그의 color에 대한 속성 값을 물려받아 color: tomato라는 값을 사용할 수 있습니다.   📄 공용 키워드   모든 CSS 속성에 사용 가능한 키워드 입니다.  ‘전역값’이라고 부르기도 합니다.      inherit: 상위 요소로부터 해당 속성의 값을 받아 사용한다.   initial: 해당 속성의 기본값을 요소에 적용한다.   unset: 상속 속성에 대해서는 inherit처럼, 상속되지 않는 속성에 대해서는 initial처럼 적용한다.  즉, 상속을 받지 않는 요소에 unset을 쓴다는 것은 initial로 쓰겠다는 말과 같다고 볼 수 있습니다.   다음은 공용키워드 inherit을 사용한 예시입니다.   &lt;section&gt;   인사말   &lt;p&gt;&lt;a href=\"#\"&gt;홍길동&lt;/a&gt;님, 안녕하세요!&lt;/p&gt; &lt;/section&gt;   a {   color: inherit; }   a태그는 브라우저의 내장 스타일이 적용되어 방문 전에는 파란색, 방문 후에는 보라색으로 표시됩니다.  이러한 내장 스타일이 마음에 들지 않는다면 color를 inherit으로 설정해주면 됩니다.   출처      유노코딩   DaleSeo - CSS의 상속  ","categories": ["CSS"],
        "tags": ["CSS 상속","inherit"],
        "url": "/css/css-inheritance/",
        "teaser": null
      },{
        "title": "의사클래스(가상클래스)",
        "excerpt":"📄 의사클래스(가상클래스)   의사클래스는 선택자에 추가하는 키워드로, 요소가 어떤 특정한 상태가 되었을 때 요소를 선택하겠다는 의미입니다.   📄 의사클래스 종류      hover: 마우스 포인터가 요소에 올라가 있다.   [type=\"button\"]:hover{ 버튼에 마우스 커서 댔을 때 배경 색깔 변경                 background-color: gray;                 }      active: 사용자가 요소를 활성화했다.(ex. 마우스 클릭)     [type=\"button\"]:active{버튼을 마우스로 클릭하면 배경 색깔 변경                 background-color: black;                 }      focus: 요소가 포커스를 받고 있다.    input:focus{ 포커스 상태일 때 색 변경             color: white;             background-color: red;             }      visited: 방문한적 있는 링크에 효과를 준다.    .link1:visited {   color: red; }      disabled: 비활성 상태의 요소이다.    &lt;input type=\"text\" placeholder=\"아무거나 쓰기\" disabled&gt;      nth-child(): 형제 사이에서의 순서에 따라 요소를 선택한다.    .box:nth-child(3) {   /*.box의 세번째 요소에 배경 색 적용*/   background-color: red; }      nth-of-type: :nth-of-type이라는 가상 클래스가 적용된 선택자에 해당 되는 요소만 카운트한다.   .container p:first-of-type {   /* container안에 있는 p 태그 중 첫번째 요소 선택*/   background: blue; }   📄 가상요소 선택자   가상 요소 선택자를 이용하면 html요소를 수정하지 않고, css만으로 가상 요소를 추가할 수 있습니다.      before   after   .box1 {   width: 200px;   height: 300px;   background-color: yellow; } .box1:after {   content: \"나는 박스2입니다.\";   display: block;   background-color: blue; }   중요하지 않은 간단한 css작업에 사용된다. content애 값을 추가해서 직접 html에 코드를 추가하지 않고 css를 다룰 수 있습니다.  콘텐츠 자체적인 내용 뿐 아니라 사용자와의 상호작용과 관련된 경우에도 스타일을 적용할 수 있어 유용합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["hover","active","before","after"],
        "url": "/css/css-pseudo-class/",
        "teaser": null
      },{
        "title": "웹폰트(Web Font)",
        "excerpt":"📄 웹폰트(Web Font)   웹 폰트란 사용자가 로컬에 폰트를 설치하지 않아도, 특정 서버에 위치한 폰트를 다운받아 웹페이지에 표시되는 폰트입니다.   📄 웹폰트 적용 방법   1. @font-face 이용      웹폰트 파일을 준비한다.   CSS 문서에서 @font-family를 이용해 폰트 파일을 불러온다.   불러온 폰트 파일을 이용해 새로운 font-family를 만든다.   만든 font-family를 사용한다.   @font-face를 사용하는 방법보다 더 간편한 방법이 있습니다.   2. import 이용      구글 폰트에 접속해서 원하는 폰트를 찾는다.   원하는 굵기의 폰트 옆에 있는 Select this style를 클릭한다.   Use on web 항목에서 import를 선택하고 해당 import 구문을 css파일 내에 입력한다.   // index.css  @import url(\"https://fonts.googleapis.com/css2?family=Nanum+Pen+Script&amp;display=swap\");  div {   font-family: \"Nanum Pen Script\", cursive; }  ","categories": ["CSS"],
        "tags": ["@font-face"],
        "url": "/css/css-web-font/",
        "teaser": null
      },{
        "title": "[애니메이션] CSS 애니메이션(animation)",
        "excerpt":"📄 animation 관련 속성    1. animation-name   : 어떤 keyframes를 요소에 적용할 것인지 지정   animation-name: moveright;    2. animation-duration   : 애니메이션을 한 번 재생하는데 걸리는 시간을 설정   animation-duration: 2s;    3. animation-direction   : 애니메이션의 재생 방향을 정의   animation-direction: normal; // 기본값(정방향) animation-direction: reverse; // 역방향 animation-direction: alternate; // 정방향으로 재생, 단 반복시 정방향/역방향을 번갈아 재생 animation-direction: alternate-reverse: 역방향으로 재생, 단 반복시 역방향/정방향을 번갈아 재생    4. animation-iteration-count   : 애니메이션 재생 횟수를 정의한다.   따로 지정하지 않으면 한번 재생되고 끝난다.   animation-iteration-count: inifinite // 무한 반복;; ; ; ; ; ; ; ; ; ; ;    5. animation-timing-function   : 애니메이션 재생 패턴을 정의한다.   animation-timing-function: ease-in-out;    6. animation-delay   : 애니메이션 시작을 얼마나 지연할 지 설정   animation-delay: 2s;    animation 단축속성 순서    animation: moveRight(name) 0.4 (duration) linear(timing-function) 1s (delay)   infinite(iteration-count) alternate(direction);     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["animation"],
        "url": "/css/css-animation/",
        "teaser": null
      },{
        "title": "CSS background",
        "excerpt":"📄 background   background는 콘텐츠의 배경을 정의합니다.   📄 background의 하위 속성   ▪ background-color   : 배경색을 정의합니다.   ▪ background-image   : 배경 이미지를 정의합니다.   background-image: url(이미지);   ▪ background-position   : 배경 이미지의 초기 위치를 정의합니다.   ▪ background-size   : 배경 이미지의 크기를 정의합니다.      cover: 이미지가 찌그러지지 않는 한도 내에서 최대로 설정합니다.   contain: 이미지가 찌그러지거나 잘리지 않는 한도 내에서 최대로 설정합니다.   ▪ background-repeat   : 배경 이미지의 반복 방법을 정의합니다.      no-repeat: 이미지를 반복하지 않습니다.(이미지가 콘텐츠보다 작을 경우 활용)   div {   background-image: url(이미지);   background-repeat: no-repeat;   background-position: center;   background-size: contain; }     background는 하위 속성을 연달아 정의할 수 있습니다.  매우 다양하여 사용자는 속성값을 정확한 값으로만 정의하면 됩니다.   background: no-repeat url(이미지);  ","categories": ["CSS"],
        "tags": ["backgroud"],
        "url": "/css/css-background/",
        "teaser": null
      },{
        "title": "CSS 상대단위",
        "excerpt":"📄 절대 길이 단위 px   px는 절대길이 단위입니다.  따라서 가변성이 없으며 반응형 웹에 적합하지 않습니다.    📄 상대 단위   상대단위는 고정되지 않고 어떤 기준에 따라 변하는 단위입니다.  반응형 웹에는 상대적으로 크기로 조정할 수 있는 상대단위를 사용합니다.    1. %   부모 요소의 해당 속성 값에 비례하여 지정한 비율의 값을 적용합니다.   2. em   스타일 지정 요소의 font-size 속성 값에 비례하여 값을 결정합니다. %는 부모 요소에 비례해서 크기르 결정하지만 em은 본인에 비례해서 크기를 결정합니다.   /* font-size : 16px 인 경우 */  1em =&gt; 16 * 1 = 16px 0.8em =&gt; 16 * 0.8 = 12.8px 3em =&gt; 16 * 3 = 48px   3. rem   최상위 html 요소의 font-size 속성 값에 비례하여 값을 결정합니다.   /* font-size : 16px 인 경우 */  1rem =&gt; 16 * 1 = 16px 0.8rem =&gt; 16 * 0.8 = 12.8px 3rem =&gt; 16 * 3 = 48px     4. vw / vh      viewport란? 화면 display상의 표시 영역            vw: viewport의 너비값에 비례            vh: viewport의 높이값에 비례       /* viewport가 1200(px)x920(px)인 경우 */  10vw =&gt; 1200x0.1 = 120px 50vh =&gt; 920x0.5 = 460px 100px =&gt; 1200x1 = 1200px   📄 상대단위의 장점      상대적인 크기의 단위를 이용하면 박스의 레이아웃 스타일을 수정할 때 유용합니다.   박스의 비율을 고려해가며 크기를 정할 수 있어서 계산이 수월합니다.   📄 주의할 점      em과 rem은 주변 상황에 따라 그 크기를 달리할 수 있는 가변성을 지니고 있지만, 브라우저나 기기 화면에 크기에 따라 크기가 달라지는 단위는 아닙니다.   em으로 margin이나 padding등 내, 외부의 여백크기를 정할 때는 부모요소로 부터 상대적인 크기를 가지는 것이 아니라, 스스로 크기를 지정하게 되므로 주의해서 사용해야 합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["%","em","rem","vw/vh"],
        "url": "/css/css-em-rem/",
        "teaser": null
      },{
        "title": "[애니메이션] @keyframes",
        "excerpt":"📄 @keyframes   : css 애니메이션의 시작, 중간, 끝 등의 중간 상태를 정의한다.   /* keyframe 작성 방법 */ @keyframes 애니메이션이름 {   from {     left: 0;   }   to {     left: 200px;   } }   %로 진행도를 표기하기도 한다.   /* keyframe 작성 방법 */ @keyframes 애니메이션이름{ \t0% { \t\tleft : 0; \t} \t50%{ \t\tleft : 200px; \t} \t100%{ \t\ttop : 200px; \t\tleft :  200px; \t} }   작성한 keyframe은 animation 속성에서 사용한다.     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["@keyframes"],
        "url": "/css/css-keyframes/",
        "teaser": null
      },{
        "title": "position(relative & absolute)",
        "excerpt":"📄 position   position은 HTML 요소가 배치되는 방식을 방법을 정의합니다.   📄 position의 속성값    1. static: 기본값   position이 기본 속성일 때는 위치 조정이 불가능한 기본 HTML 요소의 상태가 됩니다.   따라서 top, left, bottom right를 사용할 수 없습니다.   .item2 {   position: static;   top: 30px; // 의미없는 코드   left: 30px; // 의미없는 코드 }    2. relative: 기본값   : 원래 있던 자리를 기준으로 요소의 위치를 조정할 수 있습니다.   div {   width: 100px;   height: 100px;   background-color: red;    position: relative;   top: 100px;   left: 100px; // 위에서부터 100px, 왼쪽에서부터 100px이동 }      원래 위치보다 위에서부터 100px, 왼쪽에서부터 100px 떨어진다.     3. absolute   : 요소를 일반적인 문서의 흐름에서 제거하고,   대상의 부모 요소 중 relative가 적용된 요소가 있다면 해당 위치를 절대 좌표의 기준으로 정합니다.   relative가 적용된 요소가 없다면 body태그를 기준으로 절대 위치를 정합니다.   div {   width: 100px;   height: 100px;   background-color: red;    position: absolute;   top: 100px;   left: 100px; }    4. fixed   : 스크롤과 무관하게 뷰포트를 기준으로 요소의 위치를 설정합니다.   스크롤을 내려도 화면에 고정되어 위치가 변하지 않습니다.   .item2 {   position: fixed;   top: 30px;   left: 30px; }    4. sticky   : 요소의 원래 위치에 있다가 스크롤이 내려가면 지정된 좌표에 고정됩니다.   기준은 부모 요소의 좌표입니다.   스크롤이 내려가지 않았을 때는 static처럼 작동하다가, 해당요소의 위치 아래로 스크롤이 내려가면 지정한 좌표에 고정됩니다.   .item2 {   position: sticky;   top: 30px;   left: 30px; } ---  ## 출처  - [강력한 CSS](https://www.inflearn.com/course/%EA%B0%95%EB%A0%A5-css-%EC%BD%94%EB%93%9C%EC%BA%A0%ED%94%84)  ","categories": ["CSS"],
        "tags": ["position","relative","absolute"],
        "url": "/css/css-position/",
        "teaser": null
      },{
        "title": "[애니메이션] transform",
        "excerpt":"📄 transform   : 대상이 되는 요소에 이동, 회전, 확대/축소, 비틀기 등의 변형 효과를 줍니다.   📄 transform의 속성값   ▪ translate(x, y)   : 요소의 좌표를 움직인다.   transform: translate(20px, 25%);   대상 요소를 x축으로 20px만큼, y축으로 25%만큼 움직입니다.   괄호안에 값이 하나만 입력된 경우, 두 영역에 동일한 값이 입력된 것으로 간주합니다.   ▪ translateX(n) / translateY(n)    : 요소를 x축이나 y축 한방향으로 움직이고 싶을 때 사용한다.   transform: translateX(20px);   ▪ scale(x, y)    : X축으로 x만큼, Y축으로 y만큼 요소를 축소 혹은 확대합니다.   transform: translateX(0.75, 1.1);   ▪ skewX(x) / skewY(y)    : 요소를 X, Y축으로 x도 만큼 또는 y도 만큼 기울입니다.   transform: skewX(15deg);   ▪ rotate(n)    : 요소를 n만큼 회전합니다.   transform: rotate(45deg);     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["transform"],
        "url": "/css/css-transform/",
        "teaser": null
      },{
        "title": "[애니메이션] transition",
        "excerpt":"📄 transition   : CSS 속성을 이용한 변화의 전, 후 사이에 애니메이션을 추가해 움직임을 부드럽게 만들어주는 속성   📄 transition 속성   1. transition-property   : 어떠한 속성(property)에 transition을 적용할지 정합니다.   trasition-property: color, transform;   2. transition-duration   : transition에 걸리는 시간을 지정합니다.   transition-duration: 0.2s;   3. transition-timing-function   transition의 속도 패턴을 정합니다.   transition-duration: ease-in-out | linear | ease | ease-in | ease-out;   CSS-Transition timing function sample에서 각각의 속성들을 확인할 수 있습니다.   4. transition-delay   : transition 요청을 받은 후 실제로 실행되기까지 기다려야 하는 시간의 양을 지정합니다.   transition-delay: 2s;   transition의 속성을 한번에 적어줄 수도 있습니다.   transition: color 0.4s (duration) ease-in-out(timing-function) 1s (delay);   출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["transition"],
        "url": "/css/css-transition/",
        "teaser": null
      },{
        "title": "식별자(Identifier)",
        "excerpt":"📄 식별자(Identifier)   코드 내의 변수, 함수 혹은 속성을 식별하는 문자열을 식별자라고 합니다.   식별자를 통해서 이름을 지어주게 됩니다.   📄 식별자를 만들 때 규칙           식별자는 대소문자를 구분합니다.            유니코드 문자, $, 숫자를 사용할 수는 있지만, 숫자로 시작할 수는 없습니다.            예약어는 사용할 수 없고, 공백 문자도 사용할 수 없습니다.            한글도 가능은 하지만, 보통 영문을 사용합니다.       📄 주의할 점      식별자를 만들 때는 의미없는 이름보다는, 역할에 맞는 적절한 이름을 짓도록 해야합니다.   📄 식별자 가능 유무 확인하기   [식별자]https://mothereff.in/js-variables       사용가능한 식별자를 확인하는 페이지 입니다.    출처      패스트 캠퍼스 프론트엔드 올인원 패키지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","식별자"],
        "url": "/javascript/js-identifier/",
        "teaser": null
      },{
        "title": "조건문",
        "excerpt":"📄 조건문   조건문은 표현식이 참으로 평가될 때, 실행되는 블럭입니다.   if (true) {   console.log(\"항상 실행\"); // 출력됨. }  if (false) {   console.log(\"항상 실행되지 않음\"); // 출력되지 않음. }   조건이 참인 경우는 출력이 되고 거짓인 경우는 출력되지 않습니다.                  TIP       블록에 코드가 한줄이면, 중괄호는 생략 가능합니다.           if (true) console.log(\"항상 실행\");  if (false) console.log(\"항상 실행되지 않음\");   📄 표현식이 거짓으로 평가될 때   표현식이 거짓으로 평가될 때는 false만 있는 것이 아닙니다.   if (false) console.log(false); if (0) console.log(0); if (\"\") console.log(\"\"); if (null) console.log(null); if (undefined) console.log(undefined); if (NaN) console.log(NaN);   위의 경우 모두 거짓으로 평가되어 출력되지 않습니다.   📄 표현식이 참으로 평가될 때   마찬가지로 참인 경우도 여러가지 경우가 있습니다.   if (true) console.log(true); if (37) console.log(37); if (-37) console.log(-37); if (\"Mark\") console.log(\"Mark\"); if ({}) console.log({}); if ([]) console.log([]);   📄 if에 해당하지 않을 때 | else   if문으로 조건식을 작성하고 반대의 경우에는 간단하게 else로 작성할 수 있습니다.   const n = 15;  if (n % 3 === 0) {   console.log(\"n은 3의 배수 입니다.\"); } else if (n % 5 === 0) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   마찬가지로 한줄로 작성할 경우 중괄호 생략이 가능합니다.   if (n &gt; 0) console.log(\"n이 0보다 큰 경우\"); else console.log(\"n이 0보다 크지 않은 경우\");   📄 조건이 여러번 반복되는 경우   조건이 여러번 반복되는 경우에는, 조건을 변수나 상수에 넣어 작성할 수 있습니다.    const multipleOfThree = n % 3 === 0; const multipleOfFive = n % 5 === 0;  if (multipleOfThree &amp;&amp; multipleOfFive) {   console.log(\"n은 15의 배수입니다.\"); } else if (multipleOfThree) {   console.log(\"n은 3의 배수입니다.\"); } else if (multipleOfFive) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   📄 삼항 연산자를 이용한 조건부 실행   조건 ? 조건이 참이면 실행되는 표현식 : 조건이 거짓이면 실행되는 표현식   삼항 연산자를 이용한 조건부 실행은 위의 형식으로 나타납니다.   중괄호 {}를 사용할 수 없는 문법이기 때문에 하나의 표현식으로 작성합니다.   let n = 5;  const message = n % 5 === 0 ? \"5의 배수 입니다.\" : \"5의 배수가 아닙니다.\"; console.log(message);   주의할 점   삼항연산자를 남발하면 오히려 보기 헷갈릴 수 있으니 가급적 여러번 사용하는 것은 지양합니다.    📄 switch를 이용한 조건문   switch뒤 괄호 안에 있는 값이 무엇인지 중괄호 안에 있는 코드들을 비교해서 실행합니다.   복수의 if문을 switch문으로 정리할 수 있습니다.      5의 배수 일 경우 case0으로 출력하는 조건문   switch (n % 5) {   case 0: {     console.log(\"5의 배수입니다.\");     break;   }   case 1:   case 2:   case 3:   case 4:     console.log(\"5의 배수가 아닙니다.\");    default:     console.log(n); }   만약에 해당 블럭이 실행된 후 다음 블럭을 거치지 않고 switch문을 나가고 싶다면, case문 안에서 break;를 실행합니다.   break와 case 문의 순서를 잘 조정하여, 원하는 코드를 만들어 낼 수 있도록 제대로 이해해야 합니다.   출처      패스트캠퍼스 프론트엔드 강의   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","조건문"],
        "url": "/javascript/js-conditional/",
        "teaser": null
      },{
        "title": "객체(Object)",
        "excerpt":"📄 객체란 무엇인가?   객체는 이름과 값으로 구성된 프로퍼티의 정렬되지 않은 집합체입니다.   객체를 생성할 때는 함수나 클래스를 이용할 수 있습니다.   쉽게 말해 함수나 클래스를 큰 틀로 생각하고 하나하나 찍어내는 것을 각각 객체라고 생각하면 됩니다.   이 객체는 인스턴스라고 부르기도 합니다.   new라는 키워드를 통해 객체를 생성합니다.   function A() {}  const a = new A(); // new를 통해서 함수 A의 객체가 만들어져 변수 a에 할당된다. console.log(a, typeof a); console.log(A());   📄 객체에 속성(프로퍼티)추가하기   함수에서 프로퍼티를 만들어 객체에 할당할 수 있습니다.   프로퍼티를 설정하면 각각의 성질을 가지는 속성을 만들게 됩니다.   function A(name) {   this.name = name; }  const a = new A(\"Mark\"); console.log(a);   함수를 속성으로 넣기   함수를 프로퍼티로 넣는 것또한 가능합니다.   function B() {   this.hello = function () {     console.log(\"hello\");   }; }  new B().hello();      함수B의 프로퍼티 hello에 ‘hello’를 출력하는 함수를 설정함.    📄 객체 리터럴   객체 리터럴은 중괄호 안에 프로퍼티를 정의하여 객체를 생성하는 방식입니다.   프로퍼티는 쉼표(,)로 구분합니다.   const b = {   name: \"Mark\", // name이라는 프로퍼티에 'Mark'라는 값 할당 };  console.log(b, typeof b);   결과   {   name: \"Mark\"; } object;   프로퍼티에 함수도 할당할 수 있습니다.   const c = {   name: \"Mark\",   hello1() {     console.log(\"hello1\", this.name);   },   hello2: function () {     console.log(\"hello2\", this.name);   },   hello3: () =&gt; {     console.log(\"hello3\", this);   }, };  c.hello1(); c.hello2(); c.hello3();   결과   hello1 Mark hello2 Mark hello3 {}  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체"],
        "url": "/javascript/javascript-object/",
        "teaser": null
      },{
        "title": "[클래스] 상속",
        "excerpt":"📄 클래스 상속   extends라는 키워들를 통해서 자식클래스가 부모클래스를 상속받습니다.   class Parent {}  class Child extends Parent {}   오버라이딩(override)   오버라이딩은 부모클래스에서 구현한 함수나 변수를 자식클래스에서 다시 구현하는 것입니다. 즉, 자식이 만든 함수가 부모가 만든 함수를 덮어씌우는 것을 오버라이딩이라고 합니다.   class Parent {   name = \"Lee\";    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age = 37;    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }      자식 클래스에서 부모클래스의 hello 함수를 오버라이딩 함.   📄 super (새로운 속성 추가하기)   자식클래스가 부모클래스로부터 상속을 받을 때, 새로운 속성을 추가하려면 super()로 부모클래스로부터 생성자를 호출해 초기값을 세팅합니다.   super은 생성자안에서 사용합니다.    class Parent {   name;    constructor(name) {     // name값을 받는 생성자     this.name = name;   }    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age;    constructor(name, age) {     super(name); //부모클래스의 생성자를 호출해 초기값 세팅     this.age = age;   }    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }   출처      패스트클래스  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스","상속"],
        "url": "/javascript/js-class2/",
        "teaser": null
      },{
        "title": "데이터 타입(Data type)",
        "excerpt":"📄 데이터 타입(Data type)   프로그램에서 다뤄지는 모든 데이터에는 다양한 종류가 있습니다.   그 종류들을 데이터 타입이라고 부릅니다.   📄 String   String은 데이터를 문자열로 표현합니다.   데이터를 문자열로 지정하는 경우 따옴표 혹은 쌍따옴표를 이용합니다.   let text = \"hello\"; let name = \"하이요\";   📄 boolean   boolean은 데이터의 참과 거짓을 지정하는 타입입니다.   let good = true; let loading = false;   📄 null과 undefined   null과 undifined는 둘다 의미가 없음을 뜻합니다.   하지만 분명한 차이점이 존재합니다.   null은 의미가 진짜 없다는 뜻을 가지고 있고,   undefined는 의미가 아직 정해지지 않았다는 뜻입니다.   let friend = null; let criminal;   위 코드를 출력하면   friend는 null을 그대로 출력하지만,   아무것도 값이 지정되지 않은 criminal은 undefined를 출력합니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","데이터타입"],
        "url": "/javascript/javascript-datatype/",
        "teaser": null
      },{
        "title": "배열(Array)",
        "excerpt":"📄 배열(Array)   배열은 여러개의 항목이 들어있는 리스트를 뜻합니다.   배열은 대괄호([])를 사용하여 선언합니다.   대괄호 안에 들어가는 항목들은 숫자, 문자열 배열, 객체 등 이 있습니다.   const array = [1, 2, 3, 4, 5];      이름이 array인 배열을 선언함.    📄 배열에 새로운 항목 추가   배열에 새로운 항목을 추가할 때는 push라는 키워드를 사용합니다.   array.push(6);      배열에 6이라는 값을 추가함    이렇게 배열에 값을 추가하면 배열의 마지막에 추가 됩니다.    📄 배열의 크기 조회   배열의 크기를 조회 한다는 것은 배열에 몇개의 항목이 있는지 계산한다는 뜻입니다.   배열의 크기를 조회할 때는 length라는 키워드를 사용합니다.   console.log(array.length);      배열 array의 크기를 조회해서 출력한다.    출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","배열"],
        "url": "/javascript/javascript-array/",
        "teaser": null
      },{
        "title": "get & set 함수",
        "excerpt":"📄 get &amp; set 함수   클래스 내부에서 get과 set 함수를 이용해 값을 저장하고 불러올 수 있습니다.      get: 값을 조회한다.   set: 값을 저장한다.   📄 Getter함수   Getter함수는 특정 값을 실행이 아닌 조회하려고 할 때 사용됩니다.   조회하려는 값을 return키워드를 사용해 조회합니다.   const numbers = {   a: 1,   b: 2,   get sum() {     console.log(\"sum함수가 실행됩니다.\");     return this.a + this.b;   }, };      const numbers라는 객체의 a와 b를 합한 값을 조회하는 Getter함수 sum.    📄 Setter함수   Setter함수는 객체나 함수 밖에서 값을 설정하려고 할 때 사용됩니다.   그렇기 때문에 Getter함수와는 다르게 파라미터 값 설정은 필수입니다.   const dog = {   _a: 1,    set name(value) {     this._a = value;   }, };   출처      패스트캠퍼스 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","get","set"],
        "url": "/javascript/javascript-get&set/",
        "teaser": null
      },{
        "title": "함수",
        "excerpt":"📄 함수   함수는 특정코드를 하나의 명령으로 실행할 수 있게 해주는 기능입니다.   함수는 파라미터가 주어졌을 때 파라미터를 처리해서 결과를 만듭니다.   📄 선언방법   함수를 선언할 때는 functions이라는 키워드를 사용합니다.   함수의 결과 값을 나타낼 때는 return이라는 키워드를 사용합니다.   return되는 순간 함수는 종료됩니다.   functions add(a,b) { // add라는 이름의 함수에 파라미터값으로 a와 b를 받아서, a + b의 결과값을 return시키는 함수.     return a + b; }   📄 선언적 함수   선언적 함수는 함수에 이름을 붙여서 선언합니다.    function hello1() {   // 함수 선언   console.log(\"hello1\"); }  hello1(); //함수 호출   결과     📄 익명함수   함수의 이름을 만들어주지 않고 특정 변수에 함수를 할당하는 방식입니다.   const hello1 = function () {   console.log(\"hello1\"); };   결과     📄 선언적 함수와 익명함수의 차이점   선언적 함수는 호출이 먼저 나와있어도 문제없이 실행되지만,  익명함수는 호출이 먼저 나오면 에러가 발생합니다.   hello1(); // 선언적 함수는 호출이 먼저 나와있어도 문제없이 실행. hello2(); // 익명함수는 호출이 먼저나오면 문제 발생 function hello1() {   //선언적 함수   console.log(\"hello1\"); }  var hello2 = function () {   console.log(\"hello2\"); };   결과     📄 리턴   리턴은 함수를 실행하면 얻는 값입니다.   const hello3 = function (name) {   return `hello ${name}`; };   작은따옴표(‘)가 아닌 백틱(`)를 써야 합니다.   함수 안에서 함수를 만들어 리턴   리턴값으로 함수를 지정하여 리턴할 수 있습니다.    function plus(base) {   return function (num) {     return base + num;   }; }  const plus5 = plus(5); console.log(plus5(10));   📄 인자로 함수를 사용   함수를 호출하는 경우 인자로 함수를 사용할 수 있습니다.    function hello(c) {   console.log(\"hello\");   c(); }  hello(function () {   console.log(\"콜백\"); });   결과   hello; 콜백;   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","함수"],
        "url": "/javascript/js-function/",
        "teaser": null
      },{
        "title": "비구조화 할당",
        "excerpt":"📄 비구조화 할당   비구조화 할당을 다른 말로 표현하면 객체 구조 분해라고 할 수 있습니다. 말 그대로 객체의 구조를 분해해서 특정값을 추출하는 과정을 비구조화 할당이라고 합니다.   const ironMan = {   name: \"토니 스타크\",   actor: \"로버트 다우니 주니어\",   alias: \"아이언맨\", };  const { name } = ironMan; //객체 ironMan에서 name이란 값을 추출함. console.log(name);   결과   토니 스타크   중괄호({})를 사용해서 선언한 객체의 원하는 키를 뽑아냅니다.   객체뿐만아니라 배열에서도 비구조화 할당을 할수 있습니다.   const array = [1, 2];  const [one, two = 2] = array;  console.log(one); console.log(two);   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체","비구조화 할당"],
        "url": "/javascript/javascript-destructuringAssignment/",
        "teaser": null
      },{
        "title": "spread & rest",
        "excerpt":"📄 spread 연산자   spread연산자는 ES6문법에서 처음으로 등장했습니다.   spread연산자는 객체나 배열의 엘리먼트를 요소 하나하나로 펼쳐서 사용할 수 있게 합니다.   ...라는 키워드를 사용합니다.   기존 객체나 배열을 복사하고 추가적인 값을 넣어줄 때 주로 사용합니다.   const first = {   one: 1, };  const second = {   ...first, //first의 엘리먼트를 가져옴.   two: 2, };  consol.log(first); consol.log(second);   ✔ 결과   { one: 1} { one: 1, two: 2}   장점           spread연산자는 기존객체를 변경시키지 않고 복사해옵니다.            코드의 재사용성이 높아집니다.       📄 rest 연산자   rest연산자도 마찬가지로 ...키워드를 사용합니다.   차이점은 ‘나머지’라는 뜻을 가진것처럼 정해준 값 이외의 값을 복사해온다는 것입니다.   const numbers = [0, 1, 2, 3, 4, 5, 6];  const [one, ...rest] = numbers; //첫번째 값을 제외한 값을 rest로 가져온다. console.log(one); console.log(rest);   ✔ 결과   0; [(1, 2, 3, 4, 5, 6)];   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","spread","rest"],
        "url": "/javascript/javascript-spread&rest/",
        "teaser": null
      },{
        "title": "불변객체(Immutable Object )",
        "excerpt":"📄 불변 객체란?   변수에 새로운 객체를 할당하더라도, 객체의 주소가 변하지 않는 객체   불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역메모리입니다.   불변 객체는 언제 필요할까?   모든 참조형 데이터가 가변성을 띠는 것은 아닙니다.   참조형 데이터가 가변성을 가질 때는 데이터 자체가 아닌 내부 프로퍼티를 변경하는 경우입니다.   내부 프로퍼티를 변경하면 변수가 가르키고 있는 데이터의 주소가 변경되기 때문입니다.   이러한 상황에서 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 불변객체가 필요합니다.   var user = {   name: \"Jaenam\",   gender: \"male\", };  var chanegeName = function (user, newName) {   var newUser = user;   newUser.name = newName;   return newUser; };  var user2 = chanegeName(user, \"Jung\");  if (user !== user2) {   console.log(\"유저 정보가 변경되었습니다.\"); // 실행되지 않음 } console.log(user.name, user2.name); console.log(user === user2);   결과    Jung Jung true   user과 newUser이 같은 데이터 주소를 참조하게 되어 newUser의 데이터가 변경될때 마다 user의 데이터도 변경됩니다.   따라서 user를 불변 객체로 만들어 줄 필요성이 보입니다.   📄 얕은 복사와 깊은 복사   1. 얕은 복사   중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.   얕은 복사를 하면 해당 프로퍼티에 대한 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키고, 사본을 바꾸면 원본이 바뀌고 원본을 바꾸면 사본이 바뀌는 현상이 일어납니다.   var copyObject = function (target) {   var result = {};   for (var prop in target) {     result[prop] = target[prop];   }   return result; };  var user = {   name: \"Jaenam\",   urls: {     portfolio: \"http://github.com/abc\",     blog: \"http://blog.com\",     facebood: \"http://facebook.com/abc\",   }, }; var user2 = copyObject(user);  user.name = \"Jung\"; console.log(user.name === user2.name); //false  user.urls.portfolio = \"http://portfolio.com\"; console.log(user.urls.portfolio === user2.urls.portfolio); // true  user2.urls.blog = \"\"; console.log(user.urls.blog === user2.urls.blog); //true   결과    false true true   user객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것을 확인할 수 있습니다..   user.urls의 프로퍼티에 대해서도 불변 객체로 만들 필요성이 생겼습니다.   깊은 복사   깊은 복사는 얕은 복사에서 한 단계 더 복사를 하는 것입니다.   객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하고, 참조형 데이터에는 다시 그 내부의 프로퍼티를 복사합니다.   var copyObjectDeep = function (target) {   var result = {};   if (typeof target === \"object\" &amp;&amp; target !== null) {     for (var prop in target) {       result[prop] = copyObjectDeep(target[prop]);     }   } else {     result = target;   }   return result; };   target이 객체인 경우 내부 프로퍼티를 순회하여 copyObjectDeep함수를 재귀적으로 호출하고, 원본과 사본이 서로 다른 객체를 참조하게 됩니다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","불변객체"],
        "url": "/javascript/javascript-immutableObject/",
        "teaser": null
      },{
        "title": "호이스팅(hoisting)",
        "excerpt":"📄 호이스팅(hoisting)   아래에 있는 선언을 먼저 끌어올리는 것을 호이스팅이라고 합니다.   변수나 함수를 먼저 호출하고 다음에 변수나 함수를 선언하게 되면 문제없이 함수의 결과값이 출력됩니다.    hello2(); // 함수 호출  function hello2() {   //함수 선언   console.log(\"hello2\"); }   함수뿐만 아니라 var키워드를 통한 호이스팅도 가능합니다.   age = 6; age++; console.log(age);  var age;   주의할 점   var로 변수를 선언함과 동시에 값을 지정했다면, 값을 제외한 선언만 호이스팅 됩니다.   console.log(name);  name = \"Mark\";  console.log(name);  var name = \"Sujin\";   결과      이렇게 호이스팅되어 먼저 출력된 name은 값을 제외한 선언만 끌어올리기 때문에 undifined라고 출력됩니다.   함수를 선언했을 때는 함수 전체를 끌어올립니다.   function a() {   var b; // 수집 대상 1. 변수는 선언부만 끌어올립니다.   function b() {} // 수집 대상 2. 함수 선언은 전체를 끌어올립니다.    console.log(b);   b = \"bbb\";   console.log(b);   console.log(b); } a();   결과   [Function: b] bbb bbb   📄 let을 이용한 호이스팅은 불가능!   let을 이용한 호이스팅은 불가능 합니다.   let은 무조건 선언이 우선시 되어야 합니다.   console.log(name);  name = \"MARK\";  console.log(name);  let name;   결과      출처      패스트캠퍼스 프론트엔드 강의   코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","호이스팅"],
        "url": "/javascript/javascript-hoisting/",
        "teaser": null
      },{
        "title": "명시적으로 this를 바인딩 하는 방법",
        "excerpt":"📄 명시적으로 this를 바인딩 하는 방법   this는 함수를 호출할 때 결정됩니다.   하지만 this가 가리키는 대상을 명시적으로 바인딩할 수 있습니다.   📄 call 메서드   call메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.   Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])      첫 번째 인자를 this로 바인딩한다.   이후 인자들은 호출할 함수의 매개변수이다.   var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, };  obj.method(2, 3); obj.method.call({ a: 4 }, 5, 6);   call메서드의 첫번째 인자로 this가 가리키는 a값을 4로 변경합니다.   ✔ 결과   1 2 3 4 5 6   📄 apply 메서드   Function.prototype.apply(thisArg[, argsArray])      첫 번째 인자를 this로 바인딩한다.   두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다.   var func = function (a, b, c) {   console.log(this, a, b, c); }; func.apply({ x: 1 }, [4, 5, 6]);  var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, }; obj.method.apply({ a: 4 }, [5, 6]);   ✔ 결과   { x: 1 } 4 5 6 4 5 6   call/apply 메서드는 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있지만, 그럼에도 불구하고 ES5이하의 환경에서는 마땅한 대안이 없어 실무에서 광범위하게 활용됩니다.   📄 bind 메서드   Function.prototype.bind(thisArg[, arg1, arg2, ...])   bind메서드는 call과 비슷하지만,  즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 함수이다.      함수에 this를 미리 적용한다.   부분 적용 함수를 구현한다.   var func = function (a, b, c, d) {   console.log(this, a, b, c, d); }; func(1, 2, 3, 4); // Window{...} 1 2 3 4  var bindFunc1 = func.bind({ x: 1 }); bindFunc1(5, 6, 7, 8); // (1) {x: 1} 5 6 7 8  var bindFunc2 = func.bind({ x: 1 }, 4, 5); bindFunc2(6, 7); // (2) {x: 1} 4 5 6 7 bindFunc2(8, 9); // {x: 1} 4 5 8 9      this를 { x: 1}로 지정했다.    매개변수로 6, 7을 넘기면 this값이 바뀐 겂을 제외하고는 최초 func함수에 4, 5, 6, 7을 넘긴 것과 같은 동작을 한다. this의 지정과 함께 부분 적용 함수를 구현한 것이다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","this"],
        "url": "/javascript/javascript-thisbinding/",
        "teaser": null
      },{
        "title": "클로저(Closer)",
        "excerpt":"📄 클로저란   클로저란   어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상이다.   📄 클로저의 동작 원리   var outer = function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; }; var outer2 = outer(); console.log(outer2()); console.log(outer2());   ✔ 결과   2; 3;   inner함수의 실행 시점에는 outer함수가 이미 종료 되었는데 outer함수의 LexicalEnvitonment에 접근했다.   바로 가비지 컬렉터의 동작 방식 때문이다.   가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함하지 않는다.   외부함수인 outer의 실행이 종료 되더라도  내부함수인 inner함수는 언젠가 outer2를 실행함으로써 호출될 가능성이 열렸기 때문에   가비지 컬렉터의 수집대상에 포함되지 않는다.   클로저와 메모리 관리   클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수의 메모리를 소모하도록 함으로써 발생한다.   하지만 클로저의 필요성이 사라진 시점에는 더이상 메모리를 소모하지 않게 해주어야 한다.   방법은 참조 카운터를 0으로 만들어 주는 것이다.   식별자에 참조형이 아닌 기본형 데이터(보통null 또는 undefined)를 할당해주면 가비지 컬렉터가 값을 수거해 갈 것이다.   var outer = (function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; })(); console.log(outer()); console.log(outer()); outer = null; // outer 식별자의 inner 함수 참조를 끊음   (function () {   var a = 0;   var intervalId = null;   var inner = function () {     if (++a &gt;= 10) {       clearInterval(intervalId);       inner = null; // inner 식별자의 함수 참조를 끊음     }     console.log(a);   };   intervalId = setInterval(inner, 1000); })();   이렇게 식별자에 기본형 데이터 값을 대입해서 함수 참조를 끊으면 메모리를 효율적으로 관리할 수 있다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클로저"],
        "url": "/javascript/js-closer/",
        "teaser": null
      },{
        "title": "옵셔널 체이닝",
        "excerpt":"📄 옵셔널 체이닝   옵셔널 체이닝(optional chaining) ?.을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.     ?.은 ?.‘앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.   let user = null;  alert( user?.address ); // undefined alert( user?.address.street ); // undefined   user?.address로 주소를 읽으면 아래와 같이 user 객체가 존재하지 않더라도 에러가 발생하지 않습니다.   📄 주의할 점      ?.는 존재하지 않아도 되는 괜찮은 대상에만 사용해아 합니다.   ?.앞의 변수는 꼭 선언되어 있어야 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","옵셔널체이닝"],
        "url": "/javascript/js-optionalchaning/",
        "teaser": null
      },{
        "title": "원시값의 메서드",
        "excerpt":"📄 원시값이란?   원시값은 객체가 아니면서 메서드도 가지지 않는 데이터를 뜻한다.   자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다.   원시값에서도 객체에서처럼 메서드를 호출할 수 있다는 뜻이다.   📄 원시값을 객체처럼 사용하는 과정   let str = \"Hello\";  alert(str.toUpperCase()); // HELLO      문자열 str은 원시값이므로 프로퍼티 toUpperCase에 접근하는 순간 특별한 객체가 만들어진다.   메서드가 실행되고, 새로운 문자열이 반환된다.   특별한 객체는 파괴되고 원시값 str만 남는다.   📄 왜 이런 내부 프로세스가 생겨난 것일까?   자바스크립트는 다양한 고유한 프로퍼티와 메서드를 가지는 내장 객체를 제공한다.  하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다.  객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.  따라서 원시값에 메서드를 호출해 임시객체를 만들고 작업이 완료되면 임시객체를 파괴한다.   📄 주의할 점   원시값은 추가 데이터를 저장할 수 없다.   let str = \"Hello\";  str.test = 5;  alert(str.test);   엄격모드에서는 래퍼 객체를 수정하려 할 때 에러가 발생하고,  비 엄격 모드에서는 에러가 발생하진 않고 래퍼 객체에 프로퍼티 test가 추가되지만 래퍼 객체는 바로 삭제되기 때문에 마지막 줄이 실행될 땐 프로퍼티 test를 찾을 수 없다.   출처      모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","원시값"],
        "url": "/javascript/js-primitive/",
        "teaser": null
      },{
        "title": "반복문(Iteration)",
        "excerpt":"📄 반복문 for   for문은 어떤 유한한 횟수만큼 반복할 때 사용합니다.   for(초기화; 반복 조건; 반복이 된 후 실행되는 코드) {     반복이 되는 코드 블럭  }   초기화 하면서 선언된 변수를 중괄호 안 반복 블럭에서 사용할 수 있습니다.   반복문 종료하기 | break   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &gt; 2) {     break;   }   console.log(\"안녕하세요\", i); }      i가 0부터 4까지 1씩 증가하면서 출력하는데, 만약 i가 2보타 큰 경우는 반복을 종료한다.    결과     반복문 넘기기 | continue   반복되는 블럭 안에서 continue를 만나면 거기서 바로 해당 블럭은 종료됩니다.   그리고 이와 같이 다음 반복이 있으면 다음 반복으로 넘어갑니다.   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &lt; 2) {     continue;   }   console.log(\"안녕하세요\", i); }   결과    for 무한 루프   소괄호 ()안에 아무것도 적지 않고 세미콜론 ;만 작성하면 조건이 생성되지 않아 무한으로 출력합니다.   이런 경우 보통 for문 안에서 if문으로 조건을 생성하기도 합니다.   for (;;) {   console.log(\"안녕하세요\");   if (Math.random * 100 &gt; 90) {     break;   } }      랜덤숫자*100 이 90보다 크면 반복문 종료    📄 for in   for in반복문은 객체의 속성들을 반복하여 작업을 수행합니다.   객체의 key값에는 접근할 수 있지만 value에는 접근할 수 없습니다.   for(let(또는 const) in 객체이름) {}  console.log(Object.keys(객체이름)); // 객체의 키 받아오기 console.log(Object.values(객체이름)); //키의 값 받아오기 console.log(Object.entries(객체이름)); //배열 형태로 키와 값을 반환   📄 for of   ES6에 추가된 for...of반복문은 배열안의 것들을 반복할 때 사용합니다.   for of 구문을 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.   var iterable = [10, 20, 30];  for (let value of iterable) {   console.log(value); // 10, 20, 30 }   주의할 점   for..in은 배열에 사용할 순 있지만 되도록 쓰지 않는 편이 좋습니다.  for..in반복문은 모든 프로퍼티를 대상으로 순회하기 때문에 키가 숫자가 아닌 프로퍼티도 순회 대상이 되어 필요 없는 프로퍼티들이 문제를 일으킬 가능성이 생깁니다.  또한 for..in반복문은 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다.    📌 객체에는 for...in, 배열에는 for...of를 사용하자   📄 while   무한 반복 루프를 작성할 때 for문 뿐만 아니라 while문으로도 작성할 수 있습니다.   while (true) {   console.log(\"안녕하세요\");   if (Math.random() * 100 &gt; 90) {     break;   } }      Math.random() * 100이 90보다 크면 반복문 종료    do while   while문이 최초로 한번은 무조건 실행하도록 합니다.   do {   // 최초 한번은 무조건 실행   console.log(\"안녕하세요\"); } while (Math.random() * 100 &gt; 90);   출처      패스트캠퍼스   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","반복문"],
        "url": "/javascript/javascript-iteration/",
        "teaser": null
      },{
        "title": "[클래스] 클래스(Class)",
        "excerpt":"📄 클래스(Class)란   자바스크립트는 기본적으로 객체지향언어를 지원합니다.   es6문법에 class가 추가되어 좀더 강력한 객체지향언어를 지향하게 되었습니다.   Class는 객체를 생성하기 위한 템플릿이자 함수의 한 종류입니다.   클래스는 데이터와 이를 조작하는 코드를 하나로 추상화합니다.   📄 선언적 방식   class A {     constructor() {...}     method1() {...}     method2() {...} } //class A 생성  console.log(new A()); // class A의 세로운 객체를 출력   결과   A {}   클래스를 만들고 new A()를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성됩니다.  클래스 내부에서 정의한 메서드는 A.prototype에 저장됩니다.  객체의 기본 상태를 설정해주는 생성자 메서드 constructor()는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화할 수 있습니다.   주의할 점      메서드 사이에는 쉼표가 없습니다.        클래스의 선언적 방식에서 호이스팅은 일어나지 않습니다.       new키워들를 통해 호출하지 않으면 에러가 발생합니다.   클래스에 정의된 메서드는 열거할 수 없습니다. 클래스의 prototype프로퍼티에 추가된 메서드의 enumerable플래그는 false입니다.   클래스는 항상 엄격모드로 실행됩니다.(use strict)   📄 클래스 표현식   클래스의 표현식을 변수에 할당하는 방식으로 사용됩니다.   const B = class {};  console.log(new B());   결과   B {}   📄 클래스 필드로 바인딩 된 메서드   자바스크립트에서 this는 동적으로 결정됩니다.   따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출하게 되면 this는 메서드가 정의된 객체를 참조하지 않습니다.   class Button {   constructor(value) {     this.value = value;   }    click() {     cosole.log(this.value);   } }  let button = new Button(\"안녕하세요\");  setTimeout(button.click, 1000);   결과   undefined;   this의 컨텍스트를 알 수 없게 된 현상을 ‘잃어버린 this‘라고 합니다.  이러한 현상을 해결하기 위해 클래스 필드를 사용할 수 있습니다.    class Button {   constructor(value) {     this.value = value;   }    click = () =&gt; {     // 수정한 부분     alert(this.value);   }; }  let button = new Button(\"안녕하세요.\");  setTimeout(button.click, 1000);   결과   안녕하세요.   클래스 필스 click = () =&gt; {...}는 각 Button객체마다 독립적인 함수를 만들어주고 이 함수의 this를 해당 객체에 바인딩시켜줍니다.  클래스의 이러한 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야할 때 특히 유용합니다.   📄 멤버변수   멤버 변수는 메소드 밖에서 선언된 변수를 뜻합니다. 클래스의 멤버변수는 this라는 키워드를 사용하여 반드시 생성자에 만들어야 합니다.   class C {   name = \"no name\"; // 초기값 설정   age = 0;    constructor(name, age) {     // 생성자를 통해서 새로 할당.     this.name = name; // 멤버변수     this.age = age; // 멤버변수   } }  console.log(new C(\"Mark\", 37));   결과   C { name: 'Mark', age: 37 }   📄 멤버 함수   클래스에는 멤버변수 뿐만 아니라 멤버 함수도 생성할 수 있습니다.   class A {   // 방법1: 함수의 이름과 중괄호를 이용해 설정   hello1() {     console.log(\"hello1\", this);   }   // 방법2: 멤버변수 이름에 함수를 할당하는 방법   hello2 = () =&gt; {     console.log(\"hello2\", this);   }; }  new A().hello1(); new A().hello2();   결과   hello1 A { hello2: [Function: hello2] } hello2 A { hello2: [Function: hello2] }   출처           패스트캠퍼스              MDN web docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스"],
        "url": "/javascript/js-class/",
        "teaser": null
      },{
        "title": "프로토타입(prototype)",
        "excerpt":"📄 프로토타입이란?   프로토타입의 한국어 뜻은 원형입니다.   프로토타입은 말 그대로 객체의 원형이라고 할 수 있는 것입니다.   Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용합니다.           생성자 함수에 기본으로 세팅되는 프로퍼티(F.prototype)는 [[Prototype]]과 다릅니다. F.prototype은 new F()를 호출할 때 만들어지는 새로운 객체의 [[Prototype]]을 설정합니다.       F.prototype의 값은 객체나 null만 가능합니다. 다른 값은 무시됩니다.   굳이 this라는 자기참조변수를 사용하지 않고 prototype으로 변수 p에 hello라는 함수를 할당했다.   function Person(name, age) {   this.name = name;   this.age = age;   //this.hello = function() {   //    console.log('hello', this.name, this.age);   //} }  Person.prototype.hello = function () {   console.log(\"hello\", this.name, this.age); };  const p = new Person(\"Mark\", 37);  p.hello();   결과   hello Mark 37   function Person() {} //Person함수 생성  Person.prototype.hello = function () {   //Person의 프로토타입으로 hello 함수 생성   console.log(\"hello\"); };  function Korean(region) {   //Korean 함수 생성   this.region = region;   this.where = function () {     console.log(\"where\", this.region);   }; }  Korean.prototype = Person.prototype; // 프로토타입을 이용해 부모의 프로퍼티를 자식의 프로퍼티에 할당  const k = new Korean(\"Seoul\"); // 변수 k에 객체 할당  k.hello(); k.where();   결과   hello1 where Seoul   📄 프로토타입 장점   프로토타입의 장점은 함수의 재사용성을 높인다는 것입니다.   프로토 타입을 사용해서 함수 밖에서 새로운 함수나 값을 선언한다면,   새로운 함수나 값을 기존 함수에 할당할 필요없이 prototype이라는 키워드 하나로 바로 사용가능하기 때문에 코드가 훨씬 간결해집니다.   📄 프로토타입 체인   프로토타입을 이용해 서로 이어져 있는 집합을 프로토타입 체인이라고 합니다.   위의 코드에 다음과 같은 코드를 이어서 작성합니다.   console.log(k instanceof Korean); console.log(k instanceof Person); console.log(k instanceof Object);   true; true; true;      Korean이 Person을 상속하고, Person이 Object를 상속하므로 true값이 나왔다.   느낀 점   자바스크립트 공부하면서 제일 난관에 봉착했다.  뭔가 알듯 말듯 헷갈리는 개념이다.  강의를 끝나면 모던자바스크립트튜토리얼도 보고 책도 보고 할텐데 그 과정에서 익숙해지며 습득될 수 있도록 꼼꼼히 학습해야겠다.     출처           패스트캠퍼스 프론트엔드 강의              생활코딩              MDN Web Docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","프로토타입"],
        "url": "/javascript/js-prototype/",
        "teaser": null
      },{
        "title": "[클래스] 정적 메서드와 정적 프로퍼티",
        "excerpt":"📄 정적 메서드(static method)   정적 메서드는 프로토타입이 아닌 클래스 함수 자체에 설정되어 있는 메서드이다.  클래스 안에서 static이라는 키워드를 사용해서 설정한다.   class User {   static staticMethod() {...} }   정적 메서드의 this는 무엇을 가리킬까?   클래스의 메서드가 호출될 때  this의 값은 클래스 생성자 그자체가 된다.    정적 메서드는 언제 사용할까?   정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 사용한다.  데이터베이스 관련 클래스에도 사용되곤한다.    📄 정적 프로퍼티(static property)   정적 프로퍼티또한 static이라는 키워드를 사용한다.   class User {   static staticProperty = \"John\"; }   정적 프로퍼티는 언제 사용할까?   정적 프로퍼티는 데이터를 클래스 수순에 저장하고 싶을 때 사용한다.  정적 프로퍼티 역시 개별 인스턴스에 묶이지 않는다.   정적 프로퍼티와 메서드의 상속   정적 프로퍼티와 정적 메서드는 상속이 가능하다.    class Animal {} class Rabbit extends Animal {}  // 정적 메서드 consol.log(Rabbit.__proto__ === Animal); // true  // 일반 메서드 consol.log(Rabbit.prototype.__proto__ === Animal.prototype); // true   클래스 Rabbit의 프로토타입이 클래스 Animal을 가리키게 한다.  따라서 Rabbit에서 원하는 프로퍼티나 메서드를 찾지 못하면 Animal로 검색이 이어진다.   출처   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","정적메서드","정적프로퍼티"],
        "url": "/javascript/js-static-method/",
        "teaser": null
      },{
        "title": "Promise",
        "excerpt":"📄 promise   프로미스는 주로 서버에서 데이터를 받아올 때 사용합니다.   서버에 요청을 보내고 데이터를 받아올 때, 아직 데이터를 다 받아오기도 전에 데이터를 다 받아온것 처럼 화면에 데이터를 표시하고 오류가 발생합니다.   이런 문제점을 해결하는 방법이 프로미스 입니다     프로미스는 ES6부터 JavaScript의 표준 내장 객체로 추가되었습니다.   📄 promise 처리 흐름   1. 프로미스가 생성자를 통해서 생성되면 pending(대기)상태가 됩니다.   new Promise((resolve, reject) =&gt; {}); //pending   2-1. pending상태로 돌입한 후 excutor 함수 인자 중 하나인 resolve 함수를 실행하면, fulfilled(이행)상태가 됩니다.   new Promise((resolve, reject) =&gt; {   // pending상태   // ... 비동기적인 상황이 되는 처리가 벌어짐.   resolve(); // fulfilled });   2-2. excutor 함수 인자 중 하나인 reject 함수를 실행하면, rejected (거부) 상태가 됩니다.   new Promise((resolve, reject) =&gt; {   reject(); //rejected });   3-1. 프로미스 객체가 fulfilled 되는 시점에 .then 안에 설정한 callback 함수가 실행됩니다.   p.then(/*callback*/);      p라는 프로미스 객체의 callback이 실행됨.    excutor의 resolve함수를 실행할 때 인자를 넣어 실행하면, then의 callback 함수의 인자로 받을 수 있습니다.   resolve('hello'); then((message) =&gt; {...})   3-2. 마찬가지로 프로미스 객체가 rejected되는 시점에 .catch안에 설정한 callback함수가 실행됩니다.   catch(() =&gt; {     console.log('/*callback*/'); });   executor의 reject 함수를 실행할 때 인자를 넣어 실행하면, catch의 callback함수의 인자로 받을 수 있습니다.   reject('error'); catch((reason) =&gt; {...})   보통 reject 함수를 실행하며 rejected 되는 이유를 넘기는데, 표준 내장 객체인 Error의 생성자를 이용하여 Error 객체를 만들 수 있습니다.   reject(new Error('bad')); catch((error) =&gt; {...});   4. fulfilled 되거나 rejected 된 후에 최종적으로 실행할 것이 있다면, .finally()를 설정하고, 함수를 인자로 넣습니다.   finally(() =&gt; {...});   📄 callback vs promise   비동기 작업을 하는 방법은 주로 callback과 promise가 있습니다.   1. callback   보통 비동기 작업을 할 때, callback함수를 인자로 넣어 로직이 끝나면 callback함수를 호출합니다.   이런 경우 함수가 아래로 진행되지 않고, callback 함수 안으로 진행됩니다.   function c(callback) {   setTimeout(() =&gt; {     callback();   }, 1000); }  c(() =&gt; {   console.log(\"1000ms 후에 callback 함수가 실행됩니다.\"); });  c(() =&gt; {   c(() =&gt; {     c(() =&gt; {       console.log(\"3000ms 후에 callback 함수가 실행됩니다\");     });   }); }); //callback hell (콜백 지옥)   2. promise 체이닝   promise방식에서는 then 함수에서 다시 프로미스 객체를 리턴하는 방법을 통해 체이닝하면, 비동기 적업을 순차적으로 아래로 표현할 수 있습니다.   function p() {   return new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {       resolve();     }, 1000);   }); }  p()   .then(() =&gt; {     return p(); // 다시 새로운 프로미스 객체를 만들어서 리턴한다.   })   .then(() =&gt; p())   .then(p)   .then(() =&gt; {     console.log(\"4000ms 후에 fulfilled 됩니다.\");   });   📄 value가 프로미스 객체인지 알 수 없는 경우   연결된 then 메서드를 실행합니다.   value가 프로미스 객체면, resolve 된 then 메서드를 실행합니다.   value가 프로미스 객체가 아니면, value를 인자로 보내면서 then메서드를 실행합니다.   Promise.resolve(/* value */); //프로미스라는 전역객체의 resolve함수를 실행하면서 동시에 promise를 만들어낸다.  Promise.resolve(   new Promise((resolve, reject) =&gt; {     // 비동기 프로미스 객체를 생성해서 resolve의 인자인 value값으로 설정.     setTimeout(() =&gt; {       resolve();     }, 1000);   }) ).then((data) =&gt; {   console.log(     \"프로미스 객체인 경우, resolve 된 결과를 받아 then이 실행됩니다.\",     data   ); });  Promise.resolve(\"bar\").then((data) =&gt; {   console.log(\"then 메서드가 없는 경우, fulfilled됩니다.\", data); });   promise.reject를 사용하면, catch로 연결된 rejected 상태로 변경됩니다.   Promise.reject(/* */);  Promise.reject(new Error(\"reason\"))   .then((error) =&gt; {})   .catch((error) =&gt; {     console.log(error);   });   📄 promise 객체를 배열로 생성하기   promise.all   프로미스 객체를 여러개를 생성하여,   배열로 만들어 인자로 넣고 Promise.all을 실행하면,   배열의 모든 프로미스 객체들이 fulfilled 되었을 때, then의 함수가 실행됩니다.   then의 함수의 인자로 프로미스 객체들의 resolve 인자값을 배열로 돌려줍니다.   Promise.all([프로미스 객체들]);   promise.all에 전달되는 프라미스 중 하나라도 거부되면, Promise.all이 반환하는 프라미스는 에러와 함께 바로 거부됩니다.   promise.allSettled   Promise.allSettled는 모든 프라미스가 처리될 때까지 기다립니다.   반환되는 배열은 다음과 같은 요소를 갖습니다.      응답이 성공할 경우 – {status:”fulfilled”, value:result}   에러가 발생한 경우 – {status:”rejected”, reason:error}   let urls = [   \"https://api.github.com/users/iliakan\",   \"https://api.github.com/users/Violet-Bora-Lee\",   \"https://no-such-url\", ];  Promise.allSettled(urls.map((url) =&gt; fetch(url))).then((results) =&gt; {   results.forEach((result, num) =&gt; {     if (result.status == \"fulfilled\") {       alert(`${urls[num]}: ${result.value.status}`);     }     if (result.status == \"rejected\") {       alert(`${urls[num]}: ${result.reason}`);     }   }); });   결과   [   {status: 'fulfilled', value: ...응답...},   {status: 'fulfilled', value: ...응답...},   {status: 'rejected', reason: ...에러 객체...} ]   promise.race   프로미스 객체 여러개를 생성하여,   배열로 만들어 인자로 넣고 Promise.race를 실행하면,   배열의 모든 프로미스 객체들 중 가장 먼저 fulfiiled된 것으로, then의 함수가 실행됩니다.   then의 함수의 인자로 가장 먼저 fulfilled 된 프로미스 개체의 resolve 인자값을 돌려줍니다.   Promise.race([프로미스 객체들]);   출처           패스트캠퍼스 강의              캡틴판교      ","categories": ["JavaScript"],
        "tags": ["JavaScript","Promise"],
        "url": "/javascript/javascript-promise/",
        "teaser": null
      },{
        "title": "콜백(Callback)",
        "excerpt":"📄 콜백   콜백 함수는 다른 코드를 인자로 넘겨주는 함수이다.  다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한다. 자바스크립트는 호스트 환경이 제공하는 여러 함수를 사용하면 비동기 동작을 수행할 수 있다.   📄 콜백은 어떤 경우에 사용될까?   function loadScript(src) {   // &lt;script&gt; 태그를 만들고 페이지에 태그를 추가합니다.   // 태그가 페이지에 추가되면 src에 있는 스크립트를 로딩하고 실행합니다.   let script = document.createElement(\"script\");   script.src = src;   document.head.append(script); }  loadScript(\"/my/script.js\"); // script.js엔 \"function newFunction() {…}\"이 있습니다.  newFunction(); // 함수가 존재하지 않는다는 에러가 발생합니다!   new Function()에서 에러가 발생하는 이유는 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문이다.    function loadScript(src, callback) {   let script = document.createElement('script');   script.src = src;    script.onload = () =&gt; callback(script);    document.head.append(script); }  loadScript('/my/script.js', function() {   // 콜백 함수는 스크립트 로드가 끝나면 실행됩니다.   newFunction(); // 이제 함수 호출이 제대로 동작합니다.   ... });   loadScript의 두 번째 인수에 스크립트 로딩이 끝난 후 실행될 함수인 콜백 함수를 추가했다.  두 번째 인수로 전달되 함수는 원하는 동작이 완료되었을 떄 실행된다.     이것을 콜백 기반 비동기 프로그래밍이라고 부른다.  비동기적으로 수행되어야할 필요성을 가진 코드에 콜백을 기반으로 접근할 수 있다.   📄 오류 우선 콜백   콜백함수를 이용해서 에러를 핸들링할 수 있다.   function loadScript(src, callback) {   let script = document.createElement(\"script\");   script.src = src;    script.onload = () =&gt; callback(null, script);   script.onerror = () =&gt;     callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));    document.head.append(script); }  loadScript(\"/my/script.js\", function (error, script) {   if (error) {     // 에러 처리   } else {     // 스크립트 로딩이 성공적으로 끝남   } });   오류 우선 콜백의 관례      callback의 첫 번째 인수는 에러를 위해 남겨둔다. 에러가 발생하면 이 인수를 이용해 callback(err)이 호출된다.   두 번째 인수는 에러가 발생하지 않았을 때를 위해 남겨둔다. 원하는 동작이 성공한 경우엔 callback(null, result1, result2)가 호출된다.   오류 우선 콜백의 장점   오류 우선 콜백을 사용하면, 단일 콜백 함수에서 에러 케이스와 성공 케이스 모두를 처리할 수 있다.   출처      코어 자바스크립트   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","콜백"],
        "url": "/javascript/js-callback/",
        "teaser": null
      },{
        "title": "[React] 바벨 (Babel)",
        "excerpt":"📄 바벨   바벨은 최신 자바스크립트 문법을 지원하지 않는 환경에서도 최신 문법을 사용 가능하게 자바스크립트 코드를 변환해주는 컴파일러입니다.   // Babel Input: ES2015 arrow function [1, 2, 3].map((n) =&gt; n + 1);  // Babel Output: ES5 equivalent [1, 2, 3].map(function (n) {   return n + 1; });   리액트에서는 JSX 문법을 createElement함수로 호출하기 위해 바벨을 사용합니다.   📄 바벨 설치   npm install @babel/core @babel/cli @babel/preset-react      @babel/core: 바벨의 핵심 기능을 가지고 있는 패키지   @babel/cli: cli에서 사용할 바이너리가 들어있다.   @babel/preset-react: 리액트를 위한 플러그인 여러개를 모아놓은 것   npx babel --watch src --out-dir , --presets @babel/preset-react   src디렉토리의 모든 JS파일을 분석하고 변환한 내용을 적용합니다.   한번 컴파일 하고 끝나는 것이 아니라 파일이 바뀔 때마다 자동으로 컴파일을 합니다.   📄 Plugins   바벨에는 프리셋과 플러그인이 있다.      플러그인(Prugins): 코드를 변환하게 하는 작은 js프로그램   프리셋(Preset): 여러개의 플러그인을 모아놓은 것.   플러그인와 프리셋은 공식으로 정해진 것을 사용할 수도 있고 직접 자신만의 플러그인을 작성하여 변환을 코드에 적용할 수도 있다.   출처      실전 리액트 프로그래밍   BABEL 공식문서  ","categories": ["React"],
        "tags": ["바벨"],
        "url": "/react/react-babel/",
        "teaser": null
      },{
        "title": "TypeScript 기본 타입",
        "excerpt":"📄 TS 기본 타입   타입이란 자바스크립트에서 다루는 값의 형태에 대한 설명입니다.  타입스크립트에서의 가장 기본적인 타입은 자바스크립트의 7가지 기본 원시타입과 동일합니다.      null   undefined   boolean   string   number   bigint   symbol   📄 타입 애너테이션 (type annotation)   타입 애너테이션은 변수에 초깃값을 할당하지 않고도 변수의 타입을 설정할 수 있는 방법입니다.  변수에 초깃값을 할당한다면, 타입스크립트는 자동으로 타입을 추론합니다.   let user = \"sujin\";   이 코드에서 타입을 직접 알려주지 않아도 타입스크립트는 타입 시스템을 통해 user가 string타입이라는 것을 추론할 수 있습니다.  하지만, 초깃값이 없는 경우에는 타입을 추론할 수 없어 자동으로 any타입으로 간주합니다.  이렇게 초기에 타입을 유추할 수 없는 변수를 진화하는 any라고 부릅니다.   let user; // 타입: any user = \"sujin\";  user.toUpperCase(); // ok  user = 28; // 타입: number로 진화! user.toPrecision(1); // ok  user.toUpperCase(); // Error. 'toUpperCase' does not exist on type 'number'.   user의 타입이 any - string - number로 진화했습니다.  마지막으로 진화된 타입이 number이기 때문에 toUpperCase메소드를 호출하면 에러를 내뱉습니다.  이렇게 타입이 계속 변화하면 해당 변수가 어떤 타입을 가지고 있는지 확정지을 수 없고, 에러를 유발해 타입스크립트를 사용하는 이유를 손상케합니다.   타입 애너테이션은 변수의 초깃값을 할당하지 않았을 때, 타입을 확정지을 수 있게 합니다.   let user: string; user: \"sujin\";   📌 타입 애너테이션은 타입스크립트에만 존재하며 컴파일 되었을 때 자바스크립트로 복사되지 않아 자바스크립트에 아무 영향을 주지 않습니다.   📌 타입을 즉시 유추할 수 있는 변수에 타입 애너테이션을 설정하면 중복 설정입니다.   let user: string = \"sujin\";   출처           캡틴 판교-타입스크립트 입문 강의            Learning Typescript      ","categories": ["TypeScript"],
        "tags": ["type"],
        "url": "/typescript/typescript-type/",
        "teaser": null
      },{
        "title": "[React] 컴포넌트 함수의 반환값",
        "excerpt":"📄 컴포넌트 함수의 반환값   리액트의 컴포넌트는 다양한 리액트 요소를 반합니다.   export default function App() {   return \"hi\"; // 문자열을 반환했다. }   컴포넌트가 배열을 반환 할 때는 리액트 요소가 key를 가지고 있어야 합니다.   key는 랜더링을 효율적으로 하기 위해서 필요한 값입니다.   리액트가 이 값을 이용해서 가상돔에서 연산을 진행합니다.   export default function App() {   return [&lt;pkey={1}&gt;안녕&lt;/p&gt;, &lt;p key={2}&gt;하세요&lt;/p&gt;]; // }   fragment   컴포넌트는 fragment를 반환할 수 있습니다.   fragment 여러개의 요소를 반환할 때 사용합니다.   fragment는 일종의 key역할을 합니다.   export default function App() {   return (     &lt;React.Fragment&gt;       &lt;p&gt;안녕&lt;/p&gt;       &lt;p&gt;하세요&lt;/p&gt;     &lt;/React.Fragment&gt;   ); }   fragment는 불필요한 div태그를 남발하지 않게 해줍니다.   아무것도 입력하지 않고 태그의 괄호만 입력하면 fragment로 작동합니다.   fragment에서는 null또는 boolean값이 무시됩니다.   potal   컴포넌트는 potal을 반환할 수 있습니다.   potal이란 html에서 root엘리먼트가 아닌 다른 엘리먼트에 렌더링하고 싶을 때 사용합니다.   potal을 사용하기 위해서는 ReactDom에 있는 함수를 사용합니다.   두번째 매개변수는 html에 있는 요소를 지정한다.   import ReactDom from \"react-dom\";  export default function App() {   return (     &lt;&gt;       &lt;p&gt;안녕&lt;/p&gt;       &lt;Counter /&gt;       {ReactDom.createPortal(         &lt;div&gt;           &lt;p&gt;안녕하세요&lt;/p&gt;           &lt;p&gt;실전 리액트 프로그래밍 입니다.&lt;/p&gt;         &lt;/div&gt;,         document.getElementId(\"something\")       )}     &lt;/&gt;   ); }   출처      실전 리액트 프로그래밍  ","categories": ["React"],
        "tags": ["컴포넌트"],
        "url": "/react/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%95%A8%EC%88%98%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92/",
        "teaser": null
      },{
        "title": "타입 별칭",
        "excerpt":"📄 타입 별칭   : 특정 타입이나 인터페이스를 참조할 수 있는 타입 변수   타입 별칭은 재사용하는 타입에 더 쉬운 이름을 할당하는 방법입니다.  type이라는 키워들를 사용해 선언합니다.   type Person = {   name: string;   age: number; };  var seho: Person = {   name: \"sujin\",   age: 28, };   📌 타입 별칭과 인터페이스의 차이점   인터페이스는 확장이 가능하지만 타입 별칭은 확장이 불가능합니다.   계속 타입을 확장할 필요가 있는 경우에는 타입 별칭보다는 인터페이스로 선언해서 필요할 때 마다 확장하는 것이 좋습니다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["타입 별칭"],
        "url": "/typescript/typescript-type-alias/",
        "teaser": null
      },{
        "title": "유니언(Union)과 리터럴(literal)",
        "excerpt":"📄 유니언 타입 (Union Type)   : 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입   유니온 타입은 값이 정확히 어떤 타입인지 모르나 두개 이상의 타입 중 하나라는 것을 알고 있는 경우에 사용합니다.   키워드 : |   let sujin: string | number | boolean;   ▪ 타입 애너테이션으로 유니언타입을 명시적으로 표시하는 방법   변수에 초깃값이 있더라도 타입이 변경될 가능성이 있을 때, 타입 애너테이션으로 유니언타입을 표시할 수 있습니다.   let sujin: string | null = \"null\";  if (Math.random() &gt; 0.5) {   sujin = \"dreamer\"; }   초깃값으로 null을 할당했지만 타입 애너테이션으로 string타입이 올 수 있다는 것을 명시했습니다.   📄 유니온 타입 특징   1. 유니온 타입은 타입 가드가 가능하다.    타입 가드(type guard)는 타입을 좁히는 것에 사용할 수 있는 논리적 검사를 뜻합니다.  이런 타입 가드를 통해 이전에 유추된 타입보다 더 구체적인 타입을 유추하는 과정을 내로잉이라고 합니다.   ✔ 값 할당을 통한 내로잉   admiral변수는 초기에 number와 string타입으로 선언되었지만, \"Grace Hopper\"라는 값을 할당하므로써 string타입으로 타입이 구체화되었습니다.   let admiral: number | string;  admiral: \"Grace Hopper\";  admiral.toUpperCase();  admiral.toFixed(); // Error: Property 'toFixed' does not exist on type 'string'   ✔ 조건 검사를 통한 내로잉   function logMessage(value: string | number) {   if (typeof value === \"number\") {     value.toLocaleString();   }   if (typeof value === \"string\") {     value.toString();   }   throw new TypeError(\"value must be string or number\"); } logMessage(\"hello\"); logMessage(100);   2. 유니온 타입은 인터페이스 두개를 연결했을 때 공통된 속성만 제공한다.   유니온 타입은 OR연산자와 의미가 비슷합니다.  따라서 설정한 타입이 모두 공통적으로 가지고 있는 속성만 사용할 수 있습니다.   let pysicist = Math.random() &gt; 0.5 ? \"Sujin\" : 28;  pysicist.toString(); // ok  pysicist.toUpperCase(); // Error: Property 'toUpperCase' does not exist on type 'string' | 'number'   pysicist는 ‘string’ 타입과 ‘number’ 타입으로 추론됩니다.  toString메소드는 string과 number타입에 모두 사용할 수 있지만,  toUpperCase메소드는 string타입에만 사용할 수 있기 때문에 에러를 내뱉습니다.   📄 유니온 타입(Union Type)과 인터셉션(Intersection)   인터셉션은 공통된 속성만 제공하는 유니온 타입과는 달리 설정한 타입의 모든 속성을 제공합니다.   따라서 인터페이스를 모두 합친 하나의 타입이라고 정의할 수 있습니다.   실무에서는 상대적으로 유니온 타입을 더 많이 사용한다고 합니다.   function askSomeone(someone: Developer &amp; Person) {   someone.name;   someone.skill;   someone.age; }   인터셉션은 정의한 타입의 속성을 모두 넘겨야 하는 특징이 있습니다.   askSomeone({ name: \"디벨로퍼\", skill: \"웹 개발\", age: 34 });   📄 리터럴 타입 (Literal Type)   : 원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입   저는 리터럴 타입의 개념을 커스텀 타입으로 이해했습니다.  string이나 number같은 원시 타입이 아닌 사용자가 설정하고 싶은 값을 타입으로 지정할 수 있기 때문입니다.   const philosopher = \"Hypatia\";   이렇게 const로 선언한 변수에 문자열로 된 Hypatia라는 값을 할당하면 타입스크립트는 해당 값을 리터럴 타입으로 설정합니다.      여기서 const를 let으로 바꾼다면, 해당 타입의 가능한 모든 리터럴 값의 집합이 되는 원시 타입으로 설정하게 됩니다.   let philosopher = \"Hypatia\";      출처           캡틴 판교-타입스크립트 입문 강의            Learning TypeScript      ","categories": ["TypeScript"],
        "tags": ["유니언 타입","리터럴 타입","내로잉","타입 가드"],
        "url": "/typescript/typescript-union&literal/",
        "teaser": null
      },{
        "title": "Props(Properties)란?",
        "excerpt":"📄 Props 란?   Props는 컴포넌트를 사용하는 과정에서 특정 값을 전달하는 역할을 수행합니다.      Props는 외부에서 제공받은 값을 컴포넌트에 전달합니다.   상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용합니다.(단방향 데이터 흐름)   프로퍼티는 수정할 수 없습니다.   📄 왜 Props를 사용할까?   가장 큰 이유는 컴포넌트의 재사용성을 높일 수 있기 때문입니다.   상황에 따라서 데이터를 전달받아 데이터에 맞게 UI를 구현할 수 있습니다.   // App.js import React from \"react\"; import Hello from \"./Hello\"; import Wrapper from \"./Wrapper\";  function App() {   return (     &lt;Wrapper&gt;       &lt;Hello name=\"react\" color=\"red\" /&gt;       &lt;Hello color=\"pink\" /&gt;     &lt;/Wrapper&gt;   ); }  export default App;   Hello컴포넌트에서 태그의 속성값을 사용하기 위해 파라미터에 props을 입력합니다.   import React from \"react\";  function Hello(props) {   // 컴포넌트 이름은 대문자로 시작   console.log(props);   return (     &lt;div       style=     &gt;       안녕하세요 {props.name}     &lt;/div&gt;   ); }  Hello.defaultProps = {   // 특정값을 빠뜨렸을때 기본값으로 사용할 값   name: \"이름없음\", }; export default Hello; // Hello라는 컴포넌트를 내보낸다.   📄 props.children   컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 땐 props.children을 사용합니다.   import React from \"react\";  function Wrapper({ children }) {   const style = {     border: \"2px solid black\",     padding: \"16px\",   };   return &lt;div style={style}&gt;{children}&lt;/div&gt;; }  export default Wrapper;   전달된 인자들이 오브젝트로 묶어져서 LikeButton컴포넌트 안에서 this.props로 할당됩니다.      드림코딩   https://goddaehee.tistory.com/300   벨로퍼트와 함께하는 모던 리액트  ","categories": ["React"],
        "tags": ["Props","Default Props"],
        "url": "/react/react-props/",
        "teaser": null
      },{
        "title": "[React-React Hooks] useRef",
        "excerpt":"📄 useRef로 특정 DOM 선택하기   리액트로 코드를 작성하다 보면 직접 DOM요소에 접근해야하는 경우가 있습니다.   useRef를 사용하며 특정 DOM요소에 접근할 수 있습니다.   const nameInput = useRef(); // DOM 접근   변수 혹은 상수에 useRef를 호출하면 특정 객체가 생성됩니다.   &lt;input   name=\"name\"   placeholder=\"이름\"   onChange={onChange}   value={name}   ref={nameInput} // useRef /&gt;   원하는 곳에 useRef를 호출해 변수를 지정합니다.   const onReset = () =&gt; {   // 초기화 기능   setInputs({     name: \"\",     nickname: \"\",   });   nameInput.current.focus(); };   onReset함수를 호출하면 nameInput을 지정한 DOM요소에 접근하여 focus기능을 호출합니다.   📄 useRef로 컴포넌트 안의 변수 만들기   useRef는 DOM요소에 접근할 때도 사용하지만 어떤 값을 계속 기억하고 싶을 때도 사용합니다.   useRef로 만든 컴포넌트안의 변수는 변경되어도 리렌더링 되지 않습니다.   function App() {   ...    const nextId = useRef(4);    const onCreate = () =&gt; {      console.log(nextId.current); // 4     nextId.current += 1;   }    ... }   nextId의 값이 변경되어도 컴포넌트가 리렌더링되지 않는다.   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React Hooks","useRef","성능 최적화"],
        "url": "/react/react-useRef%EB%A1%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%95%88%EC%97%90-%EB%B3%80%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React] 리액트",
        "excerpt":"📄 리액트(React)   리액트는 사용자에게 보여지는 유저 인터페이스를 만들 수 있게 하는 라이브러리.입니다.   리액트는 2013년 페이스북에서 시작되어 현재 많은 웹 어플리케이션이 리액트를 사용하고 있습니다.   리액트는 컴포넌트의 집합체로서 유저 인터페이스를 보여주고 이벤트를 처리합니다.   📄 리액트 컴포넌트   import React, { Component } from 'react';  /* component */ class LikeButton extends Component {   /* state */   state = {     numnerOfLikes: 0,   };   /* render */   render() {     return &lt;button&gt;       {this.state.numberOfLikes}     &lt;/button&gt;;   } }  export defalut LikeButton;      state: 컴포넌트에 들어있는 데이터   render: 사용자에 어떻게 표시 될지 표현    리액트는 위와 같은 코드의 형식으로 돌아갑니다.   컴포넌트 안의 state가 변경이 되면 render에 적용되어 업데이트할 때 사용자에게 보여지는 내용이 바뀝니다.   만약 render함수 안에 자식요소가 들어있다면 자식요소의 render함수가 모두 업데이트 됩니다.   하지만 모든 변경 요소들이 DOM Tree에 적용되는 것은 아닙니다.   리액트의 Virtual Dom Tree는 이전 트리와 비교해 변경된 사항만 구별하여 Dom Tree에 적용시킵니다.   📄 리액트의 장점           리액트는 컴포넌트로 구성되어 있기 때문에 독립적이고 재사용성이 높다.            리액트에는 Virtual Dom Tree가 있다. 변경사항이 Virtual Dom Tree에 적용되고 이전 트리와 비교해 변경된 사항만 구별하여 Dom Tree에 적용시킨다. 모든 내용이 업데이트되지 않고 변경사항만 업데이트 되기 때문에 불필요한 동작을 줄임으로써 성능을 높일 수 있다.            위와 같은 과정은 리액트에서 직접 데이터가 변경이 될 때 마다 어플리케이션 전체를 다시 렌더링 한다. 개발자가 다른 요소를 하나하나 일일히 손댈 필요 없이 리액트 자체에서 업데이트를 해주기 때문에 효율성을 추구할 수 있다.            리액트는 기본적으로 60fps를 보장하기 때문에 성능이 보장된다.       📄 컴포넌트를 만드는 방법           클래스              컴포넌트를 상속해서 만든다.       컴포넌트가 주기적으로 업데이트 될 때 사용한다.       관련된 데이터, 함수가 묶어져 있다.       state가 들어있어 컴포넌트가 업데이트 되면 Render함수가 업데이트된다.           class LikeButton extends Component {...}                함수             업데이트가 없고 정적인 경우에 사용한다.       한가지의 기능을 수행하는 단위이며, state나 lifecycle method가 없다. 하지만 React 16.8 버전부터는 React Hook이 도입되어 state, lifecycle method를 사용할 수 있음.           function App() {   return &lt;h1&gt;Hello&lt;/h1&gt;; }   출처           드림코딩            생활코딩      ","categories": ["React"],
        "tags": ["리액트"],
        "url": "/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%9B%85(hook)/",
        "teaser": null
      },{
        "title": "[React-React Hooks] useMemo",
        "excerpt":"📄 useMemo   useMemo는 성능 최적화 단계에서 연산된 값을 재사용하기 위해 사용합니다.   import { useMemo } from \"react\";  const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);      첫 번째 인자: 콜백 함수   두 번째 인자: 의존성 배열   두 번째 인자인 배열의 요소 값이 업데이트될 때만 콜백 함수를 다시 호출합니다.   만약 빈 배열을 넘겨주면 맨 처음 컴포넌트가 마운트 되었을 때만 값을 계산하고 이후에는 memoizaton된 값을 꺼내서 사용합니다.   원하는 값이 바뀌지 않으면 리렌더링할 때 이전의 값을 재사용합니다.   📄 useMemo 사용목적      이전에 연산된 값을 재사용한다.   컴포넌트가 렌더링된 결과를 재사용한다.   📄 주의할 점   useMemo는 꼭 필요한 경우에만 사용합니다.   값을 재활용하기 위해 따로 메모리에 값을 저장해 놓기 때문입니다.   불필요한 값을 저장하면 성능이 안좋아질 수 있습니다.   출처           코딩병원            패스트캠퍼스 for velopert      ","categories": ["React"],
        "tags": ["React Hooks","useMemo","성능 최적화"],
        "url": "/react/react-useMemo/",
        "teaser": null
      },{
        "title": "[React-React Hooks] useReducer",
        "excerpt":"📄 useReducer   useReducer는 useState처럼 State를 관리하고 업데이트 할 수 있는 Hook입니다.   useReducer를 사용하면 컴포넌트 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있습니다.   📄 useReducer 구조   const [number, dispath] = useReducer(reducer, initialState, init);  function reducer(state, action) {   switch (action.type) {     case \"INCREMENT\":       return state + 1;     case \"DECREMENT\":       return state - 1;     default:       return state;   } }   action이라는 객체를 기반으로 상태를 업데이트 한다.      dispath: reducer함수를 실행시키고 action을 발생시킨다.   action: 업데이트를 위한 정보를 가지고 있다.   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React Hooks","useReducer","성능 최적화"],
        "url": "/react/react-useReducer/",
        "teaser": null
      },{
        "title": "immer 라이브러리를 통해 불변성 유지하기",
        "excerpt":"📄 immer   : 불변성을 해치는 코드를 작성해도 대신 불변성 유지를 해주는 라이브러리   immer 라이브러리를 사용하면 불변성을 유지하면서 새로운 객체를 만들 수 있습니다.   📄 React의 불변성   그렇다면 불변성은 무엇을 뜻하는 것일까요?   리액트에서 불변성은 메모리 영역에서 값을 변경할 수 없다는 뜻입니다.   자바스크립트는 원시타입과 참조타입의 값 저장방식이 다릅니다.      원시타입( Boolean, String, Number, null, undefined, Symbol)            콜스택의 value에 변수 값 저장       변수 값이 변경되면 새로운 메모리 영역을 생성해 변경된 값 저장 (불변성 유지 o)           참조 타입 (Object, Array)            콜스택의 value에 메모리 힙의 주소를 저장       변수 값이 변경되면 새로운 메모리 영역을 생성하지 않고 (콜스택 변화 x), 메모리 힙의 value값만 변경 (불변성 유지 x)       기존의 변수를 변경한 새로운 변수를 반환하는 경우(map, filter, spread operator…)에는 새로운 메모리 영역 생성 (불변성 유지 o)           리액트의 불변성을 지키면 어떤 것이 좋을까요?   리액트는 콜스택의 주소 값을 통해 상태 변화를 감지 하는 얕은 비교를 합니다.      원시타입은 불변성을 유지해 값이 변경되는 경우, 상태의 변화를 감지할 수 있습니다.   참조타입은 불변성이 유지되지 않는 경우, 리액트가 상태 변화를 감지할 수 없어 재렌더링되지 않습니다.   이렇게 보니 불변성을 유지하는 것은 꼭 필요해 보이네요.   📄 immer 사용하기           커맨드창 혹은 터미널에서 yarn add immer를 입력해 라이브러리를 설치합니다.            App.js에 import produce from 'immer'를 입력해 해당 라이브러리를 import한다.       📄 immer 구조   const 변수 = produce(바꾸고 싶은 값, draft =&gt; {   ... });      draft: 어떻게 바꿀지 알려주는 함수   📄 예시   import produce from \"immer\";  const state = {   number: 1,   donChangeMe: 2, };  const nextState = produce(state, (draft) =&gt; {   draft.number += 1; });  nextState();   불변성을 지키지 않으면서 코드를 작성(참조 타입 사용)했지만 produce함수가 불변성을 유지해주고 있습니다.   참고      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["immer","불변성"],
        "url": "/react/react-immer/",
        "teaser": null
      },{
        "title": "[React] 리액트 라우터",
        "excerpt":"📄 라우팅이란?   라우팅은 어떤 주소에 어떤 UI를 보여줄지 규칙을 정하는 작업입니다.   싱글 페이지 어플리케이션(SPA)에서 클라이언트가 라우팅을 담당합니다.   📄 SPA란?   SPA는 html을 한번만 받아와서 실행시킨 후 이후에는 필요한 데이터만 받아와서 화면에 업데이트하는 페이지입니다.   실질적으로는 하나의 페이지에서 작업하지만 사용자는 여러개의 페이지를 불러오는 것처럼 느낍니다.   ▪ SPA 단점      앱의 규모가 너무 커지면 JS파일의 크기가 너무 커질 수 있습니다.   브라우저에서 자바스크립트가 구동 되지 않으면 UI를 볼 수 없습니다. 예) 검색엔진에서 크롤링 불가능   📄 리액트에서 사용되는 라우터 라이브러리      리액트 라우터 리액트 라우터는 컴포넌트를 기반으로 라우팅합니다.   Next.js 서버사이드 렌더링을 쉽게 구현 가능합니다. 파일 경로, 이름을 기반으로 라우팅합니다.   📄 리액트 라우터   ▪ 설치 방법   npm install react-router-dom // npm  yarn add react-router-dom // yarn   ▪ BrowserRouter   &lt;BrowserRouter&gt;   basename: string   getUserConfrimation: func   forceRefresh: bool   keyLength: number   children: node      HTML5를 지원하는 브러우저의 주소를 감지합니다.   주소만 바꾸고 페이지는 다시 불러오지 않습니다.   HashRouter   &lt;HashRouter&gt;   basename: string   getUserConfirmation: func   hashType: string   children: node      #를 사용합니다.   옛날 브라우저 전용입니다.   example.com/#/path/to/route   ▪ MemoryRouter   &lt;MemoryRouter&gt;   initialEntries: array   initialIndex: number   getUserConfirmation: func   keyLength: number   children: node      브라우저의 주소와 무관합니다. 따라서 브라우저가 아닌 환경에서 쓰기 좋습니다.   임베디드 웹앱, 리액트 네이티브 등에서 사용합니다.   ▪ StaticRouter   &lt;StaticRouter&gt;   basename: string;   location: string;   location: string;   context: object   children: node      서버사이드 렌더링에서 사용하는 용도입니다.   ▪ Route   &lt;Route&gt;   Route render methods   Route props   component   render: func   ...      라우트를 정의할 때 사용하는 컴포넌트입니다.   ▪ Link   &lt;Link&gt;   to: string   to: object   replace: bool   innerRef: function   others      사용한 Router의 주소를 바꿉니다.   a 태그지만 새로고침되지 않습니다.   📄 리액트 라우터의 파라미터와 쿼리   라우너의 파라미터와 쿼리는 주소를 통해서 어떤 동적인 값을 읽어와야 할 때 사용합니다.   ▪ URL 파라미터      /profiles/velopert   정해진 특정 데이터를 조회할 때 사용합니다. ex) 아이디   ▪ Query      /filter?type=book&amp;sort_by=date   다양한 옵션을 줘서 조회할 때 사용한다. ex) 검색   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["라우터","SPA"],
        "url": "/react/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9A%B0%ED%84%B0/",
        "teaser": null
      },{
        "title": "[React] 리덕스 (Redux)",
        "excerpt":"📄 리덕스   리덕스는 컴포넌트 외부에서 상태 관리를 할 수 있는 리액트의 대표적인 전역 상태 관리 라이브러리입니다.   수많은 컴포넌트와 state가 있다면 props문법을 쓰기 어려울 때가 있습니다.   이런 경우에 redux를 사용합니다.   Redux를 설치하면 state를 보관할 수 있는 파일이 만들어집니다.   모든 컴포넌트들이 파일에서 state를 꺼내 쓸 수 있기 때문에 간편한 코드 작성이 가능합니다.   📄 리덕스의 장점   1. 상태관리가 용이하다.   상태관리가 용이하는 것은 state관리가 용이하다는 뜻입니다.   state를 수정해야 하는 상황에서 컴포넌트의 데이터를 직접 수정하는 것이 아니라 컴포넌트들이 Redux에 수정요청을 합니다.   수정요청을 받은 Redux는 state를 수정합니다.   2. 미들웨어를 활용한 다양한 기능 추가   데이터를 처리하는 중간과정에서 어떤 로직을 넣어서 필요한 기능을 추가할 수 있습니다.   미들웨어에서 로컬 스토리지에 데이터를 저장하거나 로컬 스토리지에서 데이터를 불러오는 기능을 간단하게 구현할 수 있습니다.   3. SSR시 데이터 전달이 간편하다.   리덕스의 상태값은 하나의 객체로 표현이 가능합니다.   서버는 상태값을 객체로 만들어 문자열로 변환해서 클라이언트로 전달하는데, 클라이언트는 받은 문자열을 하나의 객체로 변환해서 사용합니다.   하나의 객체로 관리가 되기 때문에 과거의 상태로 저장했다가 과거의 상태로 돌아가는 것을 간단히 구현할 수 있습니다.   4. 리액트 콘텍스트보다 효율적인 렌더링이 가능하다.   📄 리덕스를 사용할 때 규칙      하나의 애플리케이션엔 하나의 스토어가 있다. 스토어를 한개 이상 만들면 안된다.   상태는 읽기전용이다. 즉, 불변성을 지켜주어야 한다.   변화를 일으키는 함수 리듀서는 순수한 함수여야 한다. 동일한 값을 받아서 동일한 값을 반환해야 한다. ex) new Date() xxx   📄 리덕스에서 쓰는 키워드   1. action      상태에 어떤 변화가 필요할 때 action을 발생시킨다.   하나의 객체로 표현된다.   action객체는 type값을 필수로 가지고 있다.   {   type: 'TOGGLE_VALUE'   data: {     id: 0,     text: \"리덕스 배우기\"   } }   2. 액션 생성함수(Action Creator)      액션을 발생시키는 함수   파라미터를 받아와서 액션 객체를 만들어주는 함수   리덕스에서 액션 생성함수가 필수적이진 않지만 액션 객체를 더 편하게 만들 수 있다.   export function addTodo(data) {   return {     type: \"ADD_TODO\",     data   }; }  // 화살표 함수 버전  export function changeInput = text =&gt; ({   type: \"CHANGE_INPUT\",   text  });   3. 리듀서(Reducer)      변화를 일으키는 함수   state, action 이라는 파라미터를 가져온다.   리듀서에서는 불변성을 유지해야하므로 기존의 객체나 배열을 건드리지 않고 새로운 객체나 배열로 만들어야한다. ex) concat, spread…   default에서는 기존의 state를 반환하는 것이 일반적이다.   function counter(state, action) {   switch (action.type) {     case \"INCREASE\":       return state + 1;     case \"DECREASE\":       return (state = 1);     default:       return state;   } }   4. 스토어(store)      리덕스에선 하나의 애플리케이션당 하나의 스토어를 만든다.   스토어 안에는 현재 앱의 상태와 리듀서, 내장함수들이 들어있다.   4. 디스패치(dispatch)      스토어의 내장함수들 중 하나   액션을 발생시키는 것   액션을 스토어에 전달한다.   dispatch({ type: \"INCREASE\" });   5. 구독 (subscribe)      스토어의 내장함수들 중 하나   subscribe함수를 호출할 때 파라미터로 특정 함수를 넣어주면 액션이 디스패치될 때 마다 받아온 함수를 호출한다.   리듀서를 사용할 때 직접 사용하는 일은 없다.   출처           실전 리액트 프로그래밍            코딩애플      ","categories": ["React"],
        "tags": ["리덕스","상태 관리"],
        "url": "/react/react-%EB%A6%AC%EB%8D%95%EC%8A%A4/",
        "teaser": null
      },{
        "title": "JSON Server로 가짜 RestAPI 호출하기",
        "excerpt":"📄 JSON Server로 가짜 RestAPI 호출하기   프론트 작업을 할때 매번 백엔드를 개발해서 RestAPI를 호출하는 대신 JSON Server를 사용하면 손쉽게 연습용 RestAPI를 호출할 수 있는 방법이 있습니다.   📄 JSON 서버 만들기   1. data.json 폴더 만들기   폴더 안에 사용할 데이터를 작성합니다.   {   \"posts\": [     {       \"id\": 1,       \"title\": \"JSON 연습 1\",       \"body\": \"JSON 연습하기\"     },     {       \"id\": 2,       \"title\": \"JSON 연습 2\",       \"body\": \"JSON 연습하기\"     },     {       \"id\": 3,       \"title\": \"JSON 연습 3\",       \"body\": \"JSON 연습하기\"     }   ] }   2. 작성한 파일을 기반으로 서버를 연다.   $ npx json-server ./data.json --port 4000   이렇게 터미널에 입력하면 가짜 API 서버가 4000 포트로 열립니다.   3. axios를 사용하여 API 요청하기   프로젝트에 REST API Client인 axios를 설치합니다.   $ yarn add axios   만들어진 서버를 axios를 사용하여 호출해서 데이터를 받아옵니다.   // post.js import axios from \"axios\";  // 포스트 목록을 가져오는 비동기 함수 export const getPosts = async () =&gt; {   const response = await axios.get(\"http://localhost:4000/posts\");   return response.data; };   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["JSON","RestAPI"],
        "url": "/react/react-JSON-Server%EB%A1%9C-%EA%B0%80%EC%A7%9C-RestAPI-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React with TypeScript] 타입스크립트로 리액트 상태관리하기",
        "excerpt":"📄 타입스크립트로 리액트 상태관리하기   타입스크립트를 사용한 프로젝트에서 리액트 상태관리 훅을 사용하는 경우가 있습니다.   📄 1. useState 타입스크립트로 관리하기   useState에 타입스크립트를 적용한 기본 구조는 다음과 같습니다.   // useState 타입스크립트 적용 기본 구조 useState&lt;state의 type&gt;(state 초기값);  // useState 예시 (카운터 예제) const [count, setCount] = useState&lt;number&gt;(0);   이와 같이 Generics를 사용하여 상태의 타입을 설정합니다.   하지만 Generics를 사용하지 않아도 알아서 타입유추를 해주기 때문에 일일이 사용할 필요는 없습니다.   꼭 사용해야 하는 경우는 상태가 null인 경우일 때입니다.   type Information = { name: string; description: string }; const [info, setInformation] = useState&lt;Information | null&gt;(null);   ▪ useState를 적용한 코드에서 인풋상태 관리하기   타입스크립트를 적용한 코드는 각각 어떤 타입을 사용하는지 쉽게 알아낼 수 있습니다.   타입이 궁금한 값에 마우스를 갖다 대기만 하면 타입을 알려주기 때문입니다.   // src/MyForm.tsx  import React, { useState } from \"react\";  type MyFormProps = {   onSubmit: (form: { name: string; description: string }) =&gt; void; };  function MyForm({ onSubmit }: MyFormProps) {   const [form, setForm] = useState({     name: \"\",     description: \"\",   });    const { name, description } = form;    const onChange = (e: any) =&gt; {     // 타입을 모를 때는 any로 설정합니다. 하지만 any타입은 최대한 지양해야합니다.   };    const handleSubmit = (e: any) =&gt; {};    return (     &lt;form onSubmit={handleSubmit}&gt;       &lt;input name=\"name\" value={name} onChange={onChange} /&gt;       &lt;input name=\"description\" value={description} onChange={onChange} /&gt;       &lt;button type=\"submit\"&gt;등록&lt;/button&gt;     &lt;/form&gt;   ); }  export default MyForm;   위 코드의 input태그의 onChange에 마우스 커서를 올려두면 타입스크립트가 타입을 알려줍니다..      onChange의 타입은 Reaact.ChangeEventHandler&lt;HTMLInputElement&gt; 또는 undefined라고 알려주고 있습니다..   🚨 주의할 점!!   여기서 주의할 점은 저 타입을 그대로 가져다 쓰면 에러가 난다는 것입니다.      e.target에서 에러가 발생합니다.   타입 위에 Handler가 붙어 있어 에러가 발생했습니다.   Handler를 제거하고 React.ChangeEvent&lt;HTMLInputElement&gt;로 타입을 지정해 에러가 발생하지 않게 작성해야 합니다.   onChange와 마찬가지로 handleSubmit의 타입을 지정해줍니다.   import React, { useState } from \"react\";  type MyFormProps = {   onSubmit: (form: { name: string; description: string }) =&gt; void; };  function MyForm({ onSubmit }: MyFormProps) {   const [form, setForm] = useState({     name: \"\",     description: \"\",   });    const { name, description } = form;    const onChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {     const { name, value } = e.target;     setForm({       ...form,       [name]: value,     });   };    const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {     e.preventDefault();     onSubmit(form);     setForm({       name: \"\",       description: \"\",     });   };    return (     &lt;form onSubmit={handleSubmit}&gt;       &lt;input name=\"name\" value={name} onChange={onChange} /&gt;       &lt;input name=\"description\" value={description} onChange={onChange} /&gt;       &lt;button type=\"submit\"&gt;등록&lt;/button&gt;     &lt;/form&gt;   ); }  export default MyForm;   📄 2. useReducer 타입스크립트로 관리하기   useReducer를 사용하면 action을 타입으로 만들어주고 타입의 액션을 OR연산자를 사용하여 나열합니다.   type Action = { type: \"INCREASE\" } | { type: \"DECREASE\" };   액션 객체를 생성할 때 필요한 값을 타입안에 명시해주면 추후 리듀서를 사용할 때 자동완성이 되며 dispatch할때 타입명시도 해주어 코드작성에 편리합니다.   // useReducer 사용 예시  import React, { useReducer } from \"react\";  type Color = \"red\" | \"orange\" | \"yellow\";  type State = {   count: number;   text: string;   color: Color;   isGood: boolean; };  type Action =   | { type: \"SET_COUNT\"; count: number }   | { type: \"SET_TEXT\"; text: string }   | { type: \"SET_COLOR\"; color: Color }   | { type: \"TOGGLE_GOOD\" };  function reducer(state: State, action: Action): State {   switch (action.type) {     case \"SET_COUNT\":       return {         ...state,         count: action.count, // count가 자동완성되며, number 타입인걸 알 수 있습니다.       };     case \"SET_TEXT\":       return {         ...state,         text: action.text, // text가 자동완성되며, string 타입인걸 알 수 있습니다.       };     case \"SET_COLOR\":       return {         ...state,         color: action.color, // color 가 자동완성되며 color 가 Color 타입인걸 알 수 있습니다.       };     case \"TOGGLE_GOOD\":       return {         ...state,         isGood: !state.isGood,       };     default:       throw new Error(\"Unhandled action\");   } }  function ReducerSample() {   const [state, dispatch] = useReducer(reducer, {     count: 0,     text: \"hello\",     color: \"red\",     isGood: true,   });    const setCount = () =&gt; dispatch({ type: \"SET_COUNT\", count: 5 }); // count 를 넣지 않으면 에러발생   const setText = () =&gt; dispatch({ type: \"SET_TEXT\", text: \"bye\" }); // text 를 넣지 않으면 에러 발생   const setColor = () =&gt; dispatch({ type: \"SET_COLOR\", color: \"orange\" }); // orange 를 넣지 않으면 에러 발생   const toggleGood = () =&gt; dispatch({ type: \"TOGGLE_GOOD\" });    return (     &lt;div&gt;       &lt;p&gt;         &lt;code&gt;count: &lt;/code&gt; {state.count}       &lt;/p&gt;       &lt;p&gt;         &lt;code&gt;text: &lt;/code&gt; {state.text}       &lt;/p&gt;       &lt;p&gt;         &lt;code&gt;color: &lt;/code&gt; {state.color}       &lt;/p&gt;       &lt;p&gt;         &lt;code&gt;isGood: &lt;/code&gt; {state.isGood ? \"true\" : \"false\"}       &lt;/p&gt;       &lt;div&gt;         &lt;button onClick={setCount}&gt;SET_COUNT&lt;/button&gt;         &lt;button onClick={setText}&gt;SET_TEXT&lt;/button&gt;         &lt;button onClick={setColor}&gt;SET_COLOR&lt;/button&gt;         &lt;button onClick={toggleGood}&gt;TOGGLE_GOOD&lt;/button&gt;       &lt;/div&gt;     &lt;/div&gt;   ); }  export default ReducerSample;   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React","TypeScript","상태관리"],
        "url": "/react/react-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React with TypeScript] 타입스크립트를 적용한 리액트 프로젝트 생성하기",
        "excerpt":"📄 타입스크립트를 적용한 리액트 프로젝트 생성하기   리액트에 타입스크립트를 적용한 프로젝트를 생성할 때는 다음과 같은 명령어를 사용합니다.   $ npx create-react-app ts-react-tutorial --template typescript   이렇게 프로젝트를 생성하면 src폴더 안에 App.tsx파일이 생성됩니다.   컴포넌트 App의 타입이 React.FC로 지정되어 있는것을 확인할 수 있습니다.   // App.tsx  import React from \"react\"; import logo from \"./logo.svg\"; import \"./App.css\";  const App: React.FC = () =&gt; {   return (     &lt;div className=\"App\"&gt;       &lt;header className=\"App-header\"&gt;         &lt;img src={logo} className=\"App-logo\" alt=\"logo\" /&gt;         &lt;p&gt;           Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to reload.         &lt;/p&gt;         &lt;a           className=\"App-link\"           href=\"https://reactjs.org\"           target=\"_blank\"           rel=\"noopener noreferrer\"         &gt;           Learn React         &lt;/a&gt;       &lt;/header&gt;     &lt;/div&gt;   ); };  export default App;   ▪ React.FC   React.FC를 사용할 때는 props의 타입을 Generics로 넣어서 사용합니다.   // Greetings.tsx  import React from \"react\";  type GreetingsProps = {   name: string; };  const Greetings: React.FC&lt;GreetingsProps&gt; = ({ name }) =&gt; (   &lt;div&gt;Hello, {name}&lt;/div&gt; );  export default Greetings;   ✔ React.FC의 장점      props에 기본적으로 children이 들어있다.   defaultProps, propTypes, contextTypes 를 설정할 때 자동완성이 된다.   ✔ React.FC의 단점      children이 옵셔널 형태로 들어가 있어 컴포넌트의 props타입이 명백하지 않다.   // src/Greetings.tsx  import React from \"react\";  type GreetingsProps = {   name: string;   mark: string; };  const Greetings: React.FC&lt;GreetingsProps&gt; = ({ name, mark }) =&gt; (   &lt;div&gt;     Hello, {name} {mark}   &lt;/div&gt; );  Greetings.defaultProps = {   mark: \"!\", };  export default Greetings;   // src/App.tsx  import React from \"react\"; import Greetings from \"./Greetings\";  const App: React.FC = () =&gt; {   return &lt;Greetings name=\"Hello\" /&gt;; };  export default App;   mark를 defaultProps에 넣었습니다.   하지만 App에서 해당 컴포넌트를 렌더링했을때 mark의 값이 없다고 알려주며 렌더링되지 않는 현상이 발생합니다.   이때 React.FC를 생략하면 정상적으로 렌더링되기 때문에 React.FC의 사용을 권장하지 않는 것을 권장하기도 합니다.   // React.FC를 사용하지 않은 Greetings.tsx  import React from \"react\";  type GreetingsProps = {   name: string;   mark: string; };  const Greetings = ({ name, mark }: GreetingsProps) =&gt; (   &lt;div&gt;     Hello, {name} {mark}   &lt;/div&gt; );  Greetings.defaultProps = {   mark: \"!\", };  export default Greetings;   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React","TypeScript"],
        "url": "/react/react-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React with TypeScript] 타입스크립트와 Context API 활용하기",
        "excerpt":"📄 타입스크립트와 Context API 활용하기   Context API를 사용할 때 state를 위한 Context와 dispatch를 위한 Context를 따로 만들어 줍니다.   이때 dispatch를 위한 타입을 설정하면 dispatch에서 리액트를 불러올 수 있습니다.   액션들의 타입을 dispatch의 Generics로 설정했습니다.   // 예시 type SampleDispatch = Dispatch&lt;Action&gt;;   // src/SampleContext.tsx  import React, { useReducer, useContext, createContext, Dispatch } from \"react\";  // 필요한 타입들을 미리 선언  type Color = \"red\" | \"orange\" | \"yellow\";  // 상태를 위한 타입 type State = {   count: number;   text: string;   color: Color;   isGood: boolean; };  // 모든 액션들을 위한 타입 type Action =   | { type: \"SET_COUNT\"; count: number }   | { type: \"SET_TEXT\"; text: string }   | { type: \"SET_COLOR\"; color: Color }   | { type: \"TOGGLE_GOOD\" };  // 디스패치를 위한 타입 (Dispatch 를 리액트에서 불러올 수 있음), 액션들의 타입을 Dispatch 의 Generics로 설정 type SampleDispatch = Dispatch&lt;Action&gt;;  // Context 만들기 const SampleStateContext = createContext&lt;State | null&gt;(null); const SampleDispatchContext = createContext&lt;SampleDispatch | null&gt;(null);  // 리듀서 function reducer(state: State, action: Action): State {   switch (action.type) {     case \"SET_COUNT\":       return {         ...state,         count: action.count, // count가 자동완성되며, number 타입인걸 알 수 있습니다.       };     case \"SET_TEXT\":       return {         ...state,         text: action.text, // text가 자동완성되며, string 타입인걸 알 수 있습니다.       };     case \"SET_COLOR\":       return {         ...state,         color: action.color, // color 가 자동완성되며 color 가 Color 타입인걸 알 수 있습니다.       };     case \"TOGGLE_GOOD\":       return {         ...state,         isGood: !state.isGood,       };     default:       throw new Error(\"Unhandled action\");   } }  // SampleProvider 에서 useReduer를 사용하고 // SampleStateContext.Provider 와 SampleDispatchContext.Provider 로 children 을 감싸서 반환합니다. export function SampleProvider({ children }: { children: React.ReactNode }) {   const [state, dispatch] = useReducer(reducer, {     count: 0,     text: \"hello\",     color: \"red\",     isGood: true,   });    return (     &lt;SampleStateContext.Provider value={state}&gt;       &lt;SampleDispatchContext.Provider value={dispatch}&gt;         {children}       &lt;/SampleDispatchContext.Provider&gt;     &lt;/SampleStateContext.Provider&gt;   ); }  // state 와 dispatch 를 쉽게 사용하기 위한 커스텀 Hooks export function useSampleState() {   const state = useContext(SampleStateContext);   if (!state) throw new Error(\"Cannot find SampleProvider\"); // 유효하지 않을땐 에러를 발생   return state; }  export function useSampleDispatch() {   const dispatch = useContext(SampleDispatchContext);   if (!dispatch) throw new Error(\"Cannot find SampleProvider\"); // 유효하지 않을땐 에러를 발생   return dispatch; }   null체킹을 해주는 커스텀 훅을 만드는 것은 큰 의미가 있습니다.   null체킹을 하지 않으면 useSampleState의 결과값의 타입은 State | null이 됩니다.   하지만 커스텀 훅을 통해 null체킹을 해준다면 유효한 코드의 타입을 보장할 수 있습니다.   Context API에 타입스크립트를 적용하면 Context 안에 들어있는 상태를 조회할 때, 새로운 액션을 디스패치해야 할 때 자동완성이되어 개발 생산성을 높여줄 수 있습니다.   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React","TypeScript","Context API","null checking"],
        "url": "/react/react-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-Context-API-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "🚨 Component cannot be used as a JSX component. Its return type is not a valid JSX element",
        "excerpt":"🚨 에러 발생   프로젝트 진행 중 Layout 컴포넌트에서 에러가 발생했다.      ❔ 에러 원인   해당 컴포넌트를 함수형으로 작성했는데 return 문이 없었다.   🔨 에러 해결   // Page.tsx ... export default function Page({ children }: Props) {   return &lt;Container&gt;{children}&lt;/Container&gt; } ...   출처      stack overflow  ","categories": ["JavaScript"],
        "tags": ["에러"],
        "url": "/javascript/typescript-Component-canot-be-used/",
        "teaser": null
      },{
        "title": "🚨 Type '{...}' has no properties in common with type 'IntrinsicAttributes'",
        "excerpt":"🚨 에러 발생   프로젝트 과정 중 _app.tsx파일에서 에러가 발생했다.   Type '{...}' has no properties in common with type 'IntrinsicAttributes'      ❔ 에러 원인   해당 컴포넌트의 props인 children이 존재하지 않는다는 뜻이다.   🔨 에러 해결   props를 설정해서 타입을 지정해주자.   import React from \"react\";  interface Props {   children?: React.ReactNode;   [k: string]: any; }  export default function Layout({ children, ...props }: Props) {   return &lt;div&gt;Layout&lt;/div&gt;; }   Props를 interface로 설정해서 타입을 지정하고 컴포넌트에 설정해 주었다.  ","categories": ["TypeScript"],
        "tags": ["에러","props"],
        "url": "/typescript/typescript-Type-has-no-properties/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "🚨 refers to a value, but is being used as a type here.",
        "excerpt":"🚨 문제 발생   타입 스크립트로 React-Router-Dom에서 제공하는 Navigate 컴포넌트를 사용하려고 하는데 에러가 발생했다.   'Navigate' refers to a value, but is being used as a type here.      ❔문제 원인   타입스크립트 파일 확장자를 ts로 한 상태에서 컴포넌트를 사용해서 발생한 문제였다.   🔨 문제 해결    :thumbsup:   참고      StackOverFlow  ","categories": ["TypeScript"],
        "tags": ["에러","Navigate"],
        "url": "/typescript/typescript-refers-to-a-value.-but-is-being-used-as-a-type-here/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "[React] 컨텍스트 API (Context API)",
        "excerpt":"📄 컨텍스트 API   컨텍스트 API는 자신은 사용하지 않으면서 밑으로 내려줘야하는 코드가 있을 때 혹은 다른 멀리 있는 컴포넌트에 있는 값을 바로 사용할 경우 사용합니다.   컨텍스트를 사용하면 props로 일일이 데이터를 전달해주지 않아도 해당 데이터를 가지고 있는 상위 컴포넌트가 하위 컴포넌트에게 전달해 줄 수 있습니다.   컨텍스트를 사용하기 위해서 createContext함수를 호출하면 객체가 반환된다.   // 컨텍스트 함수 호출 const UserContext = createContext(\"unknown\");  // 컨텍스트 함수 사용 const ContextExample = useContext(UserContext);   createContext를 호출할 때 초기값을 설정하는데 컴포넌트가 값을 검색할때 해당 값이 없으면 초기값이 사용된다.   📄 주의할 점   context는 꼭 필요할 때만 사용한다.      Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있다.   Prop drilling을 피하기 위한 목적이라면 Component Composition (컴포넌트 합성)을 먼저 고려하자.   📄 예제   import React, { createContext, useContext, useState } from \"react\";  const MyContext = createContext(\"defalutValue\");  function Child() {   const text = useContext(MyContext);   return &lt;div&gt;안녕하세요? {text} &lt;/div&gt;; }  function Parent() {   // 중간 컴포넌트인 Parent에 아무런 props도 전달되지 않았다.   return &lt;Child /&gt;; }  function GrandParent() {   return &lt;Parent /&gt;; }  function ContextSample() {   const [value, setValue] = useState(true);   return (     &lt;MyContext.Provider value={value ? \"Good\" : \"Bad\"}&gt;       &lt;GrandParent /&gt;       &lt;button onClick={() =&gt; setValue(!value)}&gt;CLICK ME&lt;/button&gt;     &lt;/MyContext.Provider&gt;   ); }  export default ContextSample;      MyContext에 createContext로 기본값이 defalutValue인 컨텍스트를 생성했다.   Child 컴포넌트의 text에 MyContext를 적용했다.   메인 컴포넌트인 ContextSample에서 text를 가져다 쓸 GrandParent컴포넌트를 MyContext태그로 감싸 사용한다.   기본값을 바꾸고 싶다면 Provider 컴포넌트를 사용해 value의 값을 설정한다.   객체 안에는 Provider 컴포넌트가 들어있습니다.   Provider에서 value에 값을 넣어주면 Context가 적용된 값이 바뀝니다.   Provider컴포넌트의 값이 변경되면 하위의 컴포넌트는 다시 랜더링 됩니다.   중간에 있는 컴포넌트가 렌더링 되지 않아도 해당 컴포넌트는 리렌더링됩니다.   출처           패스트캠퍼스 for velopert            별코딩-useContext + Context AP      ","categories": ["React"],
        "tags": ["컨텍스트"],
        "url": "/react/react-%EB%B0%B0%EC%97%B4-%EB%A0%8C%EB%8D%94%EB%A7%81/",
        "teaser": null
      },{
        "title": "🚨 setStateAction 타입에러",
        "excerpt":"🚨 에러 발생   todolist를 만드는데 궁금한 점이 생겼다.   const [createInput, setCreateInput] = useState(\"\");  const onChangeCreateInput = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {   const value = e.target;   setCreateInput(value);   // Error: Argument of type 'EventTarget &amp; HTMLInputElement' is not assignable to parameter of type 'SetStateAction&lt;string&gt;'.ts(2345) };   value의 중괄호의 의미가 궁금해졌다.   중괄호를 사용하여 객체로 선언했을때는 에러가 안나는데 중괄호를 없애니까 에러가 발생했다.   해결을 위해 okky에 질문해보았다.   ❔ 에러 원인   EventTarget &amp; HTMLInputElement 타입의 전달 인자(호출할 때)는 SetStateAction의 타입의 파라미터(정의할 때)에 할당할 수 없다.   즉, 이벤트 객체인 e의 타입과 setCreateInput의 파라미터의 타입이 다르다는 것이다.   에러가 발생한 부분의 코드에서   e.target의 타입을 받은 value의 타입은 EventTarget &amp; HTMLInputElement인데,   사용하는 상태 변경 함수 setCreateInput의 타입이 SetStateAction&lt;string&gt; 즉, string이기 때문에 타입에러가 발생한 것이다.   🔨 에러 해결   const{ value } = e.target은 const value = e.target.value와 같은 의미이다.   타입을 맞춰 쓰기 위해서는 객체 구조 분해 할당 문법을 사용하여 이벤트 객체 안의 값을 꺼내서 써야 한다.   출처   OKKY  ","categories": ["TypeScript"],
        "tags": ["에러","setStateAction"],
        "url": "/typescript/typescript-setStateAction-%ED%83%80%EC%9E%85%EC%97%90%EB%9F%AC/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "[React] 리액트 상태관리",
        "excerpt":"📄 리액트 상태관리   🎲 Key Point | 상태를 관리한다 = 데이터를 관리하고 저장한다.   상태(state)란, 웹 애플리케이션을 렌더링 하는데 있어 영향을 미칠 수 있는 값입니다.   상태 즉, State 관리는 지역상태와 전역상태가 있습니다.   props를 통해서 데이터를 전달하면 지역상태, 다른 저장소에서 데이터를 불러오면 전역 상태입니다.   보통 전역 상태로 핸들링하는게 항상 좋을 것이라 생각하지만 그렇지만은 않습니다.      기본적인 경우에는 지역 상태로 데이터를 관리   지역상태로 관리시 다수의 컴포넌트 간에 상태 의존성이 높아진다면 전역 상태로 데이터 관리   전역 상태 관리 시 서버에서 가져오는 데이터(db)와, 단순하게 UI 상태를 나타내는 데이터는 분리   서버 데이터 캐싱 시 전역 상태로 다루는 것은 추천하지 않음. 서버 상태를 관리 할때는 SWR이나 Reat-Query와 같은 서버 전용 라이브러리 사용 권장   📄 리액트의 다양한 상태관리 방법   1. Redux   Redux의 가장 큰 특징은 다음과 같습니다.      데이터의 흐름이 단방향이다. (Flux 패턴)   모든 상태를 store에 저장한다.   redux는 하나의 store를 가지고 있어 하나의 객체 트리를 가지고 있기 때문에 확장할 때 용이하다는 큰 장점을 가지고 있습니다.   또한 데이터 흐름이 단방향으로 일어나기 때문에 결과를 예측하기 쉽습니다.   다만 store는 외부요소기 때문에 리액트 내부에서 접근할 수 없어서 비동기 처리를 위해 react-saga같은 별도의 라이브러리를 추가해서 사용해야 합니다.   reducer은 순수함수이기 때문에 상태를 변경하는 것이 아니라 새로운 상태를 반환합니다.   2. MobX      store가 여러개다.   store의 데이터를 action발행 없이 업데이트 할 수 있다.   mobx는 redux와 달리 store가 여러개지만 상태 변경할 경우, 다수의 store가 영향을 받을 수 있습니다.   또한 action 없이 데이터를 발행할 수 있지만 테스트나 유지보수 측면에서 문제를 일으킬 가능성이 있어 큰 규모의 프로젝트를 다루기에는 부적합니다.   3. Context API   context API는 리액트에 내장되어 있습니다.      주로 정적인 데이터를 관리할 때 사용한다.   Provider로 감싸진 부분의 업데이트가 되지 않은 state에도 리렌더링이 발생한다.   4. Recoil      Recoil은 Atom과 Selector로 이루어져 있다.   Atom을 구독하고 있으면 해당 컴포넌트만 선택적으로 리렌더링된다.   Selector은 비동기 처리와 데이터 캐싱 기능을 담당한다. Recoil은 비교적 최근에 나온 라이브러리라 아직 버전이 낮아 안정성측면이 좋지 않다는 단점이 있다.  ","categories": ["React"],
        "tags": ["상태 관리"],
        "url": "/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[TodoList-Project] useQuery 적용하고 페이지 업데이트 멈추는 현상",
        "excerpt":"🚨 에러 발생 1   리액트 쿼리를 작성했던 투두리스트에 적용했다.   // todolist12.tsx  const { data: getTodo } = useQuery&lt;TodoItemType[]&gt;('getTodo', getTodoList)  ...   &lt;TodoList todos={getTodo} onToggleDone={onToggleDone} onClickDelete={onClickDelete} /&gt;   완료 버튼을 누르거나 삭제 버튼을 누르면 변경 데이터가 바로 브라우저에 보이지 않고 새로고침을 해야 반영이 되었다.   ❔ 에러 원인 1   react-query의 캐싱 기능 버튼을 눌러도 리렌더링을 하였을때 변경사항이 반영되지 않은 것이다.   🔨 에러 해결 1   react-query의 refetch 옵션을 사용하였다.   refetch는 말 그대로 다시 데이터를 fetch하는 것이다.    const { data: getTodo, refetch } = useQuery&lt;TodoItemType[]&gt;('getTodo', getTodoList)   ...   const onToggleDone = async (id: number, done: boolean) =&gt; {     await todoStore.toggleDone(id, done)     refetch()   }    const onClickDelete = (id: number) =&gt; {     todoStore.deleteTodo(id)     refetch()   }   액션을 보내는 함수 가장 뒷 부분에 refetch()를 작성하면 변경 사항이 화면에 보여진다.   하지만 곧바로 다른 이슈가 발생했다.     🚨 에러 발생 2   완료버튼이나 삭제버튼을 연달아 누르면 작동하는 순서가 밀리거나 너무 느리게 반영이 되었다.   ❔ 에러 원인 2   todoStore.toggleDone -&gt; refetch로 작동하면 비동기로 진행되기 때문에 순서가 보장되지 않는다. 완료 버튼을 눌렀을때 순서대로 작동되지 않고 refetch되고 나서 toggleDone이 되어 순서가 얽혀버린것이다.   🔨 에러 해결 3   const onSubmitCreate = async (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {   e.preventDefault();   await todoStore.createTodo(createInput);   setIsOpenCreate(false);   setCreateInput(\"\");   refetch(); };  const onToggleDone = async (id: number, done: boolean) =&gt; {   await todoStore.toggleDone(id, done);   refetch(); };  const onClickDelete = async (id: number) =&gt; {   await todoStore.deleteTodo(id);   refetch(); };   방법은 await를 걸어서 순서를 보장해주는 것이었다.   async 함수로 만들어 await를 걸어주니 문제없이 작동했다.  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","react-query","useQuery","에러"],
        "url": "/todolist-project/todolist-useQuery%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0/",
        "teaser": null
      },{
        "title": "[React] 리액트 쿼리 (React Query)",
        "excerpt":"📄 React Query   리액트 쿼리는 Server State를 관리하는 라이브러리입니다.   리액트 쿼리를 사용하면 React 프로젝트에서 Server 와 Client 사이 비동기 로직들을 손쉽게 다룰 수 있습니다.   📄 React Query 의 주요 특징      Client에서 제어하거나 소유하지 않은 원격의 공간에서 관리되고 유지됨   Fetching 이나 Updating에 비동기 API가 필요함   다른 사람들과 공유되는 것으로 사용자가 모르는 사이에 변경될 수 있다.   신경 쓰지 않는다면 잠재적으로 “ out of date”가 될 가능성을 지님   서버 상태는 서버에서 관리되는 데이터들을 뜻합니다.  서버와 DB에서 관리되는 데이터를 다른 사용자가 변경했을 때, 클라이언트가 fetching을 하지 않으면 화면에 변경사항이 업데이트 되지 않습니다. 리액트 쿼리를 사용하면 데이터가 변결될 때마다 fetching하지 않아도 변경사항을 화면에 업데이트할 수 있습니다.     📄 useMutation   useMutation은 데이터 생성, 업데이트, 삭제를 할 때 사용합니다.   import { useMutation } from \"react-query\";  const { data, isLoading, mutate, mutateAsync } = useMutation(   mutationFn,   options );  mutate(variabels, {   onError,   onSettled,   onSuccess, });   // Todo 등록하기 const addTodo = useMutation(postTodoList); // Todo 완료 적용하기 const doneTodo = useMutation(async () =&gt; patchTodoList); // Todo 삭제하기 const deleteTodo = useMutation(async () =&gt; deleteTodoList);   ▪ useMutation의 Options   ✔ mutationFn: (variables: TVariables) =&gt; Promise&lt;TData&gt;      비동기 작업을 수행하고 프로미스를 반환하는 함수.   api 요청하는 함수를 작성하면 된다.   variables는 mutate가 전달하는 객체   ✔ onMutate: (variables: TVaribles) =&gt; Promise&lt;TContext | void&gt; | TContext | void      onMutate는 mutation 함수가 실행되기 전에 실행된다.   mutation 함수가 받을 동일한 변수가 전달된다.   mutation의 성공을 바라며 미리 UI부터 변화시켜주는 optimistic update 기능을 사용할 때 유용하다.   ✔ onSuccess: (data: TData, variables: TVariables, context?: TContext) =&gt; Promise&lt;unknown&gt; | void      onSuccess는 mutation이 성공하고 결과를 전달할 때 실행된다.   ✔ onError: (err: TError, variables: TVariables, context?: TContext) =&gt; Promise&lt;unknown&gt; | void      onError는 mutation이 error를 만났을 때 실행된다.   ✔ onSettled: (data: TData, error: TError, variables: TVariables, context?: TContext) =&gt; Promise&lt;unknown&gt; | void      onSettled는 mutation이 성공해서 성공한 데이터 또는 error가 전달될 때 실행된다.   ▪ useMutation의 Returns   ✔ mutate: (variables: TVariables, { onSuccess, onSettled, onError}) =&gt; void      mutate를 호출해서 mutation을 실행시킬 수 있다.   variables는 mutationsFn에 전달하는 객체이다.   onSuccess, onSuccess, onSettled, onError는 useMutation option과 같다.   useMutation(addTodo, {   onSuccess: (data, variables, context) =&gt; {     // I will fire first   },   onError: (error, variables, context) =&gt; {     // I will fire first   },   onSettled: (data, error, variables, context) =&gt; {     // I will fire first   }, });  mutate(todo, {   onSuccess: (data, variables, context) =&gt; {     // I will fire second!   },   onError: (error, variables, context) =&gt; {     // I will fire second!   },   onSettled: (data, error, variables, context) =&gt; {     // I will fire second!   }, });   ✔ mutateAsync: (variables: TVaribles, { onSuccess, onSettled, onError}) =&gt; Promise&lt;TData&gt;      mutate와 같으나 promise를 반환한다.   // 예시 const onSubmitCreate = async (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {   e.preventDefault;   // 호출 순서를 보장하기 위해 mutateAsync를 사용해 Promise를 반환하게 하였다.   await addTodo.mutateAsync({ text: createInput });   refetch();   setIsOpenCreate(false);   setCreateInput(\"\"); };   출처      hyolog 리액트쿼리-useMutation  ","categories": ["React"],
        "tags": ["React Query"],
        "url": "/react/react-React-Query/",
        "teaser": null
      },{
        "title": "[React] Redux toolkit",
        "excerpt":"📄 Redux toolkit   리액트 환경에는 수많은 상태관리 방법이 있습니다.   리액트에 이미 내장되어 있는 Context API가 있으며, 이외에도 다양한 상태 관리 라이브러리들이 존재합니다.   그럼에도 불구하고 리덕스가 많은 개발자들에게 사용되고 있는 이유는 무엇일까요.   📄 Context API vs Redux   사실 Context API와 Redux는 비교대상이 아닙니다.   Context는 수단일 뿐, 상태관리 자체는 useState와 useReducer가 담당합니다.   Context API와 Redux의 가장 큰 차이점은 성능 최적화에서 보여집니다.   Context API는 성능 최적화가 이루어지지 않아 특정값을 의존하는 경우, 해당하는 특정값이 아닌 다른 값이 변경될 때도 컴포넌트가 리렌더링이 됩니다.   반면 Redux는 의존하지 않는 값이 바뀌게되면 그 값에 영향을 받지 않고 리렌더링이 발생하지 않습니다.   따라서 Context API를 사용할 경우에는 컴포넌트의 분리가 중요합니다.   📄 Redux tookit 시작하기   ▪ Installation   ▪ CRA를 사용하는 경우   # Redux + Plain JS template npx create-react-app my-app --template redux  # Redux + TypeScript template npx create-react-app my-app --template redux-typescript   ▪ 존재하는 앱에 추가하는 경우   # NPM npm install @reduxjs/toolkit # Yarn yarn add @reduxjs/toolkit   📄 Redux toolkit에 존재하는 API   ▪ configureStore()      createStores는 간단한 configuration 옵션들과 기본값을 제공한다.   자동으로 사용자의 slice reducers를 합쳐서 사용하는 middleware가 무엇이든 추가한다.   ▪ createReducer()      상태가 바뀌기 전에 사용자가 룩업 테이블을 제공하게 한다.            lookup table? 주어진 연산에 대해 미리 계산된 결과들의 집합(배열)            자동으로 immer라이브러리를 사용해서 간단한 immutable 업데이트를 작성하게 한다.   ▪ createAction()      주어진 액션 타입에 대해 string타입으로 액션함수를 발생시킨다.   이 함수는 toString()이 내장되어 있어, 상수 타입을 대신해서 쓰인다.   ▪ createSlice()      reducer 함수들, slice 이름, 초기 state 값을 허용하여 자동으로 slice reducer를 생성한다.   ▪ createAsyncThunk      string 타입의 액션과 프로미스를 반환하는 함수를 받아들인다.   자동으로 slice reducer를 생성한다.   ▪ createEntitiyAdapter      일련의 재사용 가능한 리듀서와 스토어 안에 데이터를 관리하기 위한 selectors를 생성한다.   📄 RTK Query   RTK Query는 @reduxjs/toolkit 패키지에 추가되어 있는 부가적인 옵션입니다.   API 인터페이스를 정의하기 위해 데이터를 fetching하고 caching하는 간단하지만 강력한 툴셋을 제공합니다.   📄 RTK Query에 포함된 API들   ▪ createApi()      RTK Query의 핵심적인 기능   데이터를 fetching하고 변환하는 방법을 포함해서 엔드포인트를 정의하고 엔드포인트로부터 데이터를 검색하는 방법을 허용한다.            endpoint? 컴퓨터 네트워크에 연결하고 컴퓨터 네트워크와정보를 교환하는 물리적 디바이스            ▪ fetchBaseQuery()      요청을 단순화하는 것을 목표로 하는 fetch를 감싼다. = 데이터 fetching을 단순화하기 위해 사용된다.   Redux toolkit 공홈은 createApi에서 baseQuery를 사용하는 것을 추천한다.   ▪ ApiProvider      아직 Redux Store가 없는 경우 사용할 수 있다.   ▪ setupListeners()      refetOnMount와 refetchOnReconnect를 위해 사용되는 유틸리티   📄 타입스크립트와 RDK 시작하기   ▪ Redux Toolkit 초기 설정   💾 app/store.ts   import { configureStore, ThunkAction, Action } from \"@reduxjs/toolkit\"; import counterReducer from \"../features/counter/counterSlice\";  export const store = configureStore({   reducer: {     counter: counterReducer,   }, });  export type AppDispatch = typeof store.dispatch; // 타입 에러를 막기 위해 스토어 설정 파일에서 직접 내보내고다른 파일로 직접가져오는 것이 안전하다. export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppThunk&lt;ReturnType = void&gt; = ThunkAction&lt;   ReturnType,   RootState,   unknown,   Action&lt;string&gt; &gt;;   💾 app/hooks.ts   사용하는 훅들의 타입을 지정해야 합니다. RootState와 AppDispatch의 타입은 각각 컴포넌트에서 import해서 사용하는 것이 가능하지만,   useDispatch와 useSelector는 타입이 지정된 훅으로 사용하는 것이 더 좋습니다.      useSelector의 경우, 매번 (state: RootState)의 타입을 지정해줄 필요가 없습니다.   useDispatch의 경우, 기본 Dispatch는 thunk를 알지못해서 thunk middleware 타입이 포함된 스토어에서 커스터마이징된 AppDispatch 타입을 사용해야합니다. useDispatch를 추가하면 필요할때 AppDispatch를 가져올 수 있습니다.   이 훅들은 타입이 아니라 변수이기 때문에 store 파일이 아니라 hooks파일에 지정해야한다. 이렇게 hooks파일에 지정해서 필요할때 마다 component파일에서 import해올 수 있다.   import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\"; import type { RootState, AppDispatch } from \"./store\";  // Use throughout your app instead of plain `useDispatch` and `useSelector` export const useAppDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;(); export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;   📄 Application 사용   ▪ Slice State와 Action Types   각각 slice 파일은 초기 state value에 대한 타입을 지정해서 createSlice가 각각 리듀서의 state에 대한 타입을 추론할 수 있습니다.   initial state type을 미리 지정하고 initial state 객체를 생성합니다.   // slice state 타입 정의 export interface CounterState {   value: number;   status: \"idle\" | \"loading\" | \"failed\"; }  // initial state 객체 생성 const initialState: CounterState = {   value: 0,   status: \"idle\", };   ▪ createSlice로 slice 생성   createSlice는 name, initialState, reducers가 있습니다.      name: action앞에 붙어 다른 slice의 action들과 중복을 피한다.   initialState: 미리 생성한 initialState가 들어있다.   reducer: reducer는 action 역할을 하고 state의 변화를 담당한다. immer.js를 내장하고 있어 state값을 자동으로 return한다.   const counterSlice = createSlice({   name: \"counter\",   initialState,   reducers: {     increment: (state) =&gt; {       state.value += 1;     },     decrement: (state) =&gt; {       state.value -= 1;     },     incrementByValue: (state, action: PayloadAction&lt;number&gt;) =&gt; {       state.value += action.payload;     },   }, });   ▪ export   slice 내의 actions과 reducer를 export합니다.   // export actions export const { increment, decrement, incrementByValue } = counterSlice.actions; // export default slice.reducer export default counterSlice.reducer;   ▪ Store 생성   store에는 state와 dispatch할 함수들이 들어있습니다.   타입스크립트를 사용하고 있다면 각각 state와 dispatch의 타입을 지정해 주어야 한다.      store 생성 명령어: configureStore   import { configureStore } from \"@reduxjs/toolkit\"; import CounterReducer from \"../features/counter/counter\";  export const store = configureStore({   reducer: {     counter: CounterReducer,   }, });  // store와 dispatch의 타입 export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppDispatch = typeof store.dispatch;   ▪ Provider 생성   Provider은 store와 app을 연결해서 컴포넌트들이 store에 있는 state나 dispatch를 사용할 수 있게 합니다. 가장 상위 컴포넌트에 store를 연결하면 하위 컴포넌트에서도 store를 사용할 수 있습니다.   // index.tsx import { Provider } from \"react-redux\"; import { store } from \"./app/store\";  ReactDOM.render(   &lt;React.StrictMode&gt;     &lt;Provider store={store}&gt;       &lt;App /&gt;     &lt;/Provider&gt;   &lt;/React.StrictMode&gt;,   document.getElementById(\"root\") );   ▪ 컴포넌트 안에서 사용하기   import React, { useState } from \"react\"; import { useAppDispatch, useAppSelector } from \"../../app/hooks\";  import { increment, decrement, incrementByValue } from \"./counter\";  function CounterView() {   // 설정한 hook들을 적용   const count = useAppSelector((state) =&gt; state.counter.value);   const dispatch = useAppDispatch();   // useState로 num값 관리   const [num, setNum] = useState&lt;number&gt;(0);   const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {     setNum(parseInt(e.currentTarget.value));   };    return (     &lt;&gt;       &lt;div         style=       &gt;         // 버튼이 눌리면 import해온 함수들이 dispatch된다.         &lt;button onClick={() =&gt; dispatch(decrement())}&gt;-1&lt;/button&gt;         &lt;h1 style=&gt;{count}&lt;/h1&gt;         &lt;button onClick={() =&gt; dispatch(increment())}&gt;+1&lt;/button&gt;       &lt;/div&gt;        &lt;div&gt;         &lt;input type=\"number\" onChange={handleChange} /&gt;         &lt;button onClick={() =&gt; dispatch(incrementByValue(num))}&gt;+{num}&lt;/button&gt;       &lt;/div&gt;     &lt;/&gt;   ); } export default CounterView;   참고      Redux tookit 공식 페이지   doobaloper.log-Redux-Toolkit이란?  ","categories": ["React"],
        "tags": ["Redux toolkit","상태 관리"],
        "url": "/react/react-redux-toolkit/",
        "teaser": null
      },{
        "title": "JS 문자열을 HTML 개체로 변환",
        "excerpt":"📄 JS 문자열을 HTML 개체로 변환   자바스크립트에서 작성한 문자열을 innerHTML 속성을 이용해 HTML로 변환시켜 주는 방법입니다.   const stringToHTML = function (str) {   const dom = document.createElement(\"div\");   dom.innerHTML = str;   return dom; }; console.log(stringToHTML(`&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;p&gt;How are you today?&lt;/p&gt;`));   결과   &lt;div&gt;   &lt;h1&gt;Hello world&lt;/h1&gt;   &lt;p&gt;How are you today?&lt;/p&gt; &lt;/div&gt;      domcument에 div 엘리먼트를 추가한다.   새로 생성된 div 인스턴스는 dom과 연결된다.   dom의 경우 innerHTML 속성을 설정해서 HTML 개체로 변환한다.   return은 strinToHTML 함수에 대한 dom 인스턴스가 된다.   출처      DelftStack-JavaScript에서 문자열을 HTML로 변환  ","categories": ["JavaScript"],
        "tags": ["JavaScript","문자열","HTML"],
        "url": "/javascript/javascript-stringtohtaml/",
        "teaser": null
      },{
        "title": "배열 내장 함수",
        "excerpt":"📄 배열 내장함수   자바스크립트 배열에는 자체적으로 내장되어 있는 함수들이 있습니다.   이 함수들을 잘 활용한다면 코드가 더욱 간결해지고 가독성이 높아질 수 있습니다.   📄 forEach   forEach함수는 기존의 for문을 대체할 수 있습니다.   const array = [a, b, c, d];  superheroes.forEach((item) =&gt; {   console.log(item); });   forEach의 파라미터로 각 원소에 대하여 처리하고 싶은 코드를 함수로 넣어줍니다.   이렇게 주어진 함수를 배열 요소 각각에 대해 실행합니다.   📄 map   map은 배열 안의 각 원소를 변환할 때 사용하며,   결과 값이 담긴 새로운 배열을 생성합니다.     map 함수의 파라미터로는 변화를 주는 함수를 전달해줍니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((n) =&gt; n * n);   map을 사용하면서 index값을 얻고 싶다면 함수의 두번째 파라미터를 이용하면 됩니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((currentElement, index) =&gt; {   console.log(\"The current iteration is: \" + index); // 배열의 인덱스 값   console.log(\"The current element is: \" + currElement); // 배열의 현재 값 });   📄 IndexOf   IndexOf는 배열에서 원하는 항목이 몇번째 원소인지 찾아주는 함수입니다.   const superheroes = [\"아이언맨\", \"캡틴 아메리카\", \"토르\", \"닥터 스트레인지\"];  const index = superheroes.indexOf(\"토르\");   함수의 파라미터로 원하는 값을 넣어주면 몇번째 함수인지 반환합니다.   📄 findIndex &amp; find   만약 찾고자 하는 배열안의 값이 숫자나 문자열이라면 indexOf를 사용하지만   배열안의 값이 객체이거나 배열인 경우에는 사용할 수 없습니다.   그럴경우 사용하는 함수가 findIndex와 find입니다.   findIndex함수를 사용하고자 하면 함수에 검사하고자 하는 조건을 반환하는 함수를 넣습니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   }, ];  const index = todos.findIndex((todo) =&gt; todo.id === 3);      배열 todos에서 id가 3인 값의 index를 반환한다.    결과   `2`;   만약 Index아닌 객체나 배열의 값 전체를 반환하고자 하면 find함수를 사용합니다.   const index2 = todos.find((todo) =&gt; todo.id === 3);   결과   { id: 3, text: '객체와 배열 배우기', done: true }   📄 filter   filter함수는 특정조건을 만족하는 원소를 찾아서 그 원소들을 새로운 배열로 만듭니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   },   {     id: 4,     text: \"배열 내장함수 배우기\",     done: false,   }, ];  const tasksNotDone = todos.filter((todo) =&gt; todo.done === false); console.log(tasksNotDone);   결과   [{ id: 4, text: \"배열 내장함수 배우기\", done: false }];   📄 splice &amp; slice   splice함수 사용법   const spliced = 배열.splice(index number, n);      index number인 원소부터 n개를 지우겠다.    slice함수 사용법   slice메소드는 배열에서 특정 범위를 잘라내 새로운 배열로 반환합니다.   const sliced = 배열.slice(start, end);  let nums = [0, 1, 2, 3, 4, 5, 6, 7]; nums.slice(2, 4);  // nums = [2, 3]   slice 메소드의 두번째 인자는 새로운 배열의 범위에 포함되지 않습니다.   공통점   두 함수 모두 배열을 잘라낼 때 사용합니다.   차이점   splice로 배열을 잘라내면 기존배열이 그대로 잘리지만, slice로 배열을 잘라내면 기존배열이 유지됩니다.   📄 shift &amp; unshift      shift: 배열의 첫번째 원소를 추출합니다.   unshift: 배열의 맨 앞에 원소를 추가합니다.   const value = numbers.shift(); // value라는 값에 배열 numbers의 첫번째 원소 할당. numbers.unshift(5); // 배열 numbers의 마지막 자리에 원소 5 추가.   📄 push &amp; pop      push: 배열의 마지막 원소를 추가합니다.   pop: 배열의 마지막 자리에 있는 원소를 추출합니다.   numbers.push(50); // numbers라는 배열에 값 50 추가 const value = numbers.pop(); // value에 numbers의 마지막 원소 할당   📄 reduce   reduce함수는 배열의 각 요소에 대해 주어진 리듀서 함수를 실행합니다.   배열안의 각 요소를 순회하며 callback함수의 실행 값을 누적하여 하나의 결과값을 반환합니다.   arr.reduce(callback, initialValue);   callback함수는 4개의 파라미터 값을 받습니다.      누산기 (acc): 콜백의 반환값을 누적합니다.   현재 값(cur): 처리할 현재 요소   현재 인덱스(idx): 처리할 현재 요소의 인덱스   원본 배열(src): reduce()를 호출한 배열   const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((acc, cur, idx) =&gt; {   return (acc += cur); }, 0); // 0은 초기값 console.log(result); // 15   출처           패스트캠퍼스 프론트엔드 강의            MDN      ","categories": ["JavaScript"],
        "tags": ["JavaScript","forEach","map","IndexOf","findIndex","filter","splice","slice","shift","push","pop","reduce"],
        "url": "/javascript/javascript-arrayfunction/",
        "teaser": null
      },{
        "title": "Fetch",
        "excerpt":"📄 Fetch   : 원격 API를 호출할 수 있는 자바스크립트 내장 함수   📄 Fetch 사용법   Fetch함수는 두가지의 인자를 받습니다.      URL   옵션객체   인자를 받아 Promise객체를 반환합니다.   반환된 객체는 API호출이 성공했을 때 응답(response) 객체를 resolve하고 실패했을 때는 예외(error)객체를 reject합니다.   fetch(url, options)   .then((response) =&gt; response.json())   .catch((error) =&gt; console.log(\"error:\", error));      Response: HTTP 응답 전체를 나타내는 객체. JSON 본문 콘텐츠를 추출하기 위해서는 json()메서드를 호출해야 합니다.   📄 GET 호출: 데이터 불러오기   fetch함수의 기본적인 동작은 GET입니다.   fetch(\"https://jsonplaceholder.typicode.com/posts/1\").then((response) =&gt;   console.log(response) );   ✔ 결과   Response {status: 200, ok: true, redirected: false, type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts/1\", …}   응답(response) 객체는 json메서드를 제공합니다.   json()을 호출하면 응답 객체로부터 JSON 포멧의 응답을 자바스크립트 객체로 변환해서 얻을 수 있습니다.   // json()을 활용하여 응답객체를 자바스크립트 객체로 변환 fetch(\"https://jsonplaceholder.typicode.com/posts/1\")   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   {   \"userId\": 1,   \"id\": 1,   \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",   \"body\": \"quia et suscipit↵suscipit recusandae consequuntur …strum rerum est autem sunt rem eveniet architecto\" }   📄 POST 호출: 데이터 생성하기   POST는 원격 API에서 관리하고 있는 데이터를 생성할 때 사용합니다.      method 옵션을 POST로 지정한다.   headers옵션을 통해 JSON포멧을 사용한다고 알려준다.   요청 전문을 JSON 포멧으로 직렬화하여 body옵션에 설정해준다.   fetch(\"https://jsonplaceholder.typicode.com/posts\", {   method: \"POST\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), }).then((response) =&gt; console.log(response));   ✔ 결과: 응답코드가 201 Created   Response {type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts\", redirected: false, status: 201, ok: true, …}  // json메서드로 응답객체를 호출했을 때(response.json()) {title: \"Test\", body: \"I am testing!\", userId: 1, id: 101}   📄 PUT, DELETE: 데이터 수정, 삭제하기   PUT과 DELETE는 데이터를 수정하거나 데이터를 삭제할 때 사용됩니다.   // PUT fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"PUT\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과     {title: \"Test\", body: \"I am testing!\", userId: 1, id: 1}   DELETE는 보낼 데이터가 없어 header와 body옵션이 필요하지 않습니다.   // DELETE fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"DELETE\", })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   { }   📄 fetch 함수 커스텀화 하기   async function post(host, path, body, headers = {}) {   const url = `https://${host}/${path}`;   const options = {     method: \"POST\",     headers: {       \"Content-Type\": \"application/json\",       ...headers,     },     body: JSON.stringify(body),   };   const res = await fetch(url, options);   const data = await res.json();   if (res.ok) {     return data;   } else {     throw Error(data);   } }  post(\"jsonplaceholder.typicode.com\", \"posts\", {   title: \"Test\",   body: \"I am testing!\",   userId: 1, })   .then((data) =&gt; console.log(data))   .catch((error) =&gt; console.log(error));   출처      MDN-Fetch 사용하기   DaleSeo-fetch()함수로 원격 API호출하기  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Fetch"],
        "url": "/javascript/javascript-fetch/",
        "teaser": null
      },{
        "title": "getElementById 와 querySelector 비교",
        "excerpt":"📄 getElementById 와 querySelector 비교   getElementById와 querySelector의 공통점은 엘리먼트를 검색해서 반환한다는 것입니다.   하지만 둘의 사용법은 다르며 사용하는 상황에서 차이점을 드러냅니다.   📄 getElementById와 querySelector의 차이점   getElementById      id를 통해 엘리먼트를 반환한다.   만약 document에 해당 id가 없다면 null을 반환한다.   querySelector      selector의 구체적인 그룹과 일치하는 document의 첫번째 엘리먼트를 반환한다.   일치하는 요소가 없다면 null을 반환한다.   ✔ 예시   &lt;form id=\"userForm\"&gt;   &lt;input id=\"username\" type=\"text\" value=\"Guilherme\"&gt; &lt;/form&gt;   getElementById로 username을 가져올 때:   var username = document.getElementById(\"username\");   querySelector로 username을 가져올 때:   var username = document.querySelector(\"#userForm #username\");   =&gt; 결과는 같지만 querySelector로 가져올 때 더 구체적이고 한정적이다.   📄 querySelectorAll vs selectElementByClassName   하나가 아니라 여러개의 요소를 하나의 이름으로 한번에 얻고 싶을 때 사용하는 방법이다.   ✔ 예시   &lt;form id=\"productForm\"&gt;   &lt;input id=\"productOne\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productTwo\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productThree\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt; &lt;/form&gt;   getElementByClassName으로 가져올 때: HTMLCollection에 리턴   var products = document.getElementByClassName(\"product\");   querySelectorAll로 가져올 때: NodeList에 리턴   var products = document.querySelectorAll(\"#productForm .product\");   둘다 인덱스를 제공해 인덱스 번호로 접근이 가능하지만, HTMLCollection항목은 name과 id속성으로도 접근할 수 있다.     엘리먼트에 접근할 때 방법이 두가지가 있어 어떤 상황에 어느 것을 사용하는지 궁금해서 정리를 시작했다.   구체적으로 엘리먼트를 선택하고 싶다면 querySelector를,   좀더 빠른 성능으로 접근하고 싶다면 getElementById를 사용하는 것이 좋다.   출처   *guinatal.github - qeurySelector vs getElementById  ","categories": ["JavaScript"],
        "tags": ["JavaScript","getElementById","querySelector"],
        "url": "/javascript/javascript-getElementById&querySelector/",
        "teaser": null
      },{
        "title": "JSON (JavaScript Object Notation)",
        "excerpt":"📄 JSON (JavaScript Object Notation)   : 데이터를 쉽게 교환하고 저장하기 위한 텍스트기반의 데이터 교환 표준   텍스트 기반이다 ❔   어떤 프로그래밍 언어에서도 JSON 데이터를 읽고 사용할 수 있다 ❕   즉, 데이터를 교환할때 어떤 프로그래밍언어도 쓸 수 있는 방법이다.   📄 JSON과 XML   XML(EXtensible Markup Language)은 문자기반의 마크업 언어로 데이터를 보여주는 것이 아닌 저장하고 전달하는 것 만을 목적으로 만들어졌다.   공통점      둘다 데이터를 저장하고 전달하기 위해 만들어졌다.   사람도 읽을 수 있다.   계층적인 데이터구조를 가진다.   다양한 프로그래밍 언어에 의해 파싱될 수 있다.   XMLHttpRequest 객체를 이용하여 서버로부터 데이터를 전송받을 수 있다.   차이점      JSON은 종료 태그를 사용하지 않는다.   JSON의 구문이 XML의 구문보다 짧다.   JSON 데이터가 XML 데이터보다 더 빨리 읽고 쓸 수 있다.   XML은 배열을 사용할 수 없지만, JSON은 배열을 사용할 수 있다.   XML은 XML 파서로 파싱되고, JSON은 자바스크립트 표준함수인 eval()함수로 파싱된다.   // XML 예제 &lt;dog&gt;     &lt;name&gt;식빵&lt;/name&gt;     &lt;family&gt;웰시코기&lt;family&gt;     &lt;age&gt;1&lt;/age&gt;     &lt;weight&gt;2.14&lt;/weight&gt; &lt;/dog&gt;  // JSON 예제 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }   JSON은 XML보다 더 빠른 처리속도를 가지고 있지만 전송받은 데이터의 무결성을 직접 인증해야하는 특징을 가지고 있다.   📄 JSON 문법   JSON은 객체 표기법 중 리터럴(literal)과 프로퍼티(property)를 표현하는 방법을 쓴다.      리터럴: 변수가 아닌 해석되는 값 자체 ex) 12(숫자 리터럴), “JSON”(문자열 리터럴), true(불리언 리터럴)   객체: 이름(name)과 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합   // 네쌍의 프로퍼티로 구성된 객체 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }      JSON에서 주석을 사용하는것은 권장하지 않는다.   undefined 와 null   JSON에서는 undefined타입을 제공하지 않는다. 자바스크립트와 다르게 JSON에서 null은 값을 가지고 있지 않다는 의미를 가지는 하나의 데이터값을 가지고 있기 때문에 유의해서 사용해야 한다.   📄 자바스크립트와 JSON   자바스크립트에서 JSON을 사용하기 위해 3가지의 메소드를 제공한다.      JSON.stringify(): 인수로 전달받은 자바스크립트 객체를 문자열로 변환   JSON.parse(text): 인수로 받은 문자열을 자바스크립트 객체로 변환   toJSON: 자바스크립트의 Date 객체의 데이터를 JSON 형식의 문자열로 변환. Date.prototype 객체에서만 사용할 수 있다.   // toJSON 예제 var date = new Date(); // 자바스크립트 Date 객체  var str = date.toJSON(); // Date 객체를 JSON 형식의 문자열로 변환함.  document.getElementById(\"json\").innerHTML = date + \"&lt;br&gt;\";  document.getElementById(\"json\").innerHTML += str;   출처      TCP SCHOOL.com-JSON  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Json"],
        "url": "/javascript/javascript-json/",
        "teaser": null
      },{
        "title": "디바운싱(Debouncing)",
        "excerpt":"📄 디바운싱(debouncing)      이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술   연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것   디바운싱 기술는 검색 기능을 구현하는 경우에 가장 많이 사용됩니다.   이런 경우에는   j ja jav java   처럼 키워드 하나하나 인식해서 키워드 하나에 매번 이벤트가 발생하게 됩니다.   이렇게 처리해야하는 일이 여러번의 요청이 있을때 최종(혹은 처음) 요청의 처리결과만 내놓게 하는게 디바운싱입니다.   var timer; document.querySelector(\"#input\").addEventListener(\"input\", function (e) {   if (timer) {     clearTimeout(timer);   }   timer = setTimeout(function () {     console.log(\"여기에 ajax 요청\", e.target.value);   }, 200); });      타자를 칠 때(input 이벤트 발생)마다 타이머를 설정한다.   200ms동안 입력이 없으면 입력이 끝난 것으로 한다. (시간 자유 설정 가능)   200ms 이전에 타자 입력이 발생하면 이전 타이머는 취소하고 새로운 타이머를 다시 설정한다.   출처      제로초-쓰로틀링과 디바운싱  ","categories": ["JavaScript"],
        "tags": ["JavaScript","디바운싱"],
        "url": "/javascript/javascript-debouncing/",
        "teaser": null
      },{
        "title": "배열 중복 요소 없애기 (Set)",
        "excerpt":"📄 Set   배열을 다룰때 Set함수를 사용하면 중복된 요소를 없애고 값을 한번만 보여줍니다.   Set은 객체로 다루어지지만 배열의 타입이 Object이기 때문에 사용할 수 있습니다.   📄 Set 사용하기   var mySet = new Set();   mySet은 중복된 요소가 있으면 하나만 남기고 사라집니다.   mySet.add(1); // Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add(\"some text\"); // Set { 1, 5, 'some text' }   5를 두번 추가했지만 한개만 남습니다.   this.setHistoryData = (histData) =&gt; {   const avoidDulpli = [...new Set([histData, ...this.state.historyList])];   if (avoidDulpli.length &gt; 5) {     avoidDulpli.pop();   }   this.setState({     ...this.state,     historyList: avoidDulpli,   }); };   구현하던 프로젝트에서 검색기록을 내는 코드입니다.   검색한 데이터(histData)를 받아서 새로운 배열 avoidDulpli를 만들고,   new Set을 이용해 중복된 값은 제거되는 새로운 배열을 만들어 받아온 데이터(histData)가 앞에 추가됩니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Set"],
        "url": "/javascript/javasrcipt-arraySet/",
        "teaser": null
      },{
        "title": "이미지 랜덤 배치",
        "excerpt":"📄 이미지 랜덤 배치하기   목표: Vanila JavaScript로 새로고침 될 때마다 이미지가 특정 범위에 랜덤으로 배치된다.   원하는 범위의 위치를 받아와서 이미지의 left와 right 값을 지정해주자!    📄 1. 원하는 feild의 위치를 파악한다.   const fieldRect = field.getBoundingClientRect(); function initGame() {   console.log(fieldRect); }   getBoundingClientRect를 이용해 출력하면 지정한 요소의 위치를 콘솔창에서 확인할 수 있다.   📄 2. feild에 추가하기 전에 이미지를 생성하는 함수를 만들어준다.   // 랜덤으로 숫자를 생성하는 함수 function randomNumber(min, max) {   return Math.random() * (max - min) + min; }  // 아이템을 생성하는 함수 function addItem(className, count, imgPath) {   const x1 = 0;   const y1 = 0;   // 이미지가 feild에서 벗어나는 것을 막기 위해 최댓값을 조정한다.   const x2 = fieldRect.width - CARROT_SIZE;   const y2 = fieldRect.height - CARROT_SIZE;    for (let i = 0; i &lt; count; i++) {     const item = document.createElement(\"img\"); // 이미지 추가!     item.setAttribute(\"class\", className); // 이미지에 클래스 속성추가!     item.setAttribute(\"src\", imgPath); // 이미지 경로 추가!     item.style.position = \"absolute\"; // feild에 상대적으로 오프셋 적용     const x = randomNumber(x1, x2); // 최솟값 x1와 최댓값 x2 사이에서 랜덤으로 숫자를 받아 상수 x에 할당!     const y = randomNumber(y1, y2); // 최솟값 y1와 최댓값 y2 사이에서 랜덤으로 숫자를 받아 상수 y에 할당!     item.style.left = `${x}px`; // 추가한 이미지의 left값에 x값 할당!     item.style.top = `${y}px`; // 추가한 이미지의 top에 y값 할당!     field.appendChild(item); // field에 해당 이미지를 추가   } }   📄 3. addItem함수에 값을 지정한다.   function initGame() {   addItem(\"carrot\", 5, \"carrot.png\"); // 당근 이미지 5개!   addItem(\"bug\", 5, \"bug.png\"); // 벌레 이미지 5개! }   결과      새로고침할 때 마다 당근 5개와 벌레 5개가 배치된다.   느낀점   강의 전혀 안보고 하려고 했는데 실패했다~   이미지를 랜덤으로 배치하는 함수가 따로 있는 줄 알았다.  모든게 함수나 API로 있진 않나보다.  구글링할때 많은 사람들이 제이쿼리를 쓰는 것을 보았다.  생각보다 바닐라로 구현하는 내용은 보지 못했다.  코드를 혼자서 완성시키는 것은 지금 당장 해내지 못할지라도 강의에서 보여주는 코드를 완벽하게 이해하고 넘어가서 다음에 사용하는 경우가 생긴다면 그때는 꼭 적용시켜서 스스로 해낼 것이다.    출처      드림코딩  ","categories": ["JavaScript"],
        "tags": ["JavaScript"],
        "url": "/javascript/js-image-random/",
        "teaser": null
      },{
        "title": "async 함수로 데이터 fetch하기",
        "excerpt":"📄 async 함수로 데이터 fetch하기   서버로부터 데이터를 fetch해오는 방법은 여러가지가 있다. 보통 promise를 사용하거나 async await문을 사용한다.   📄 Promise를 통한 비동기 코딩의 문제점   1. 디버깅   function fetchAuthorName(postId) {   return fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)     .then((response) =&gt; response.json())     .then((post) =&gt; post.userId)     .then((userId) =&gt; {       return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)         .then((response) =&gt; response.json())         .then((user) =&gt; user1.name); // 의도한 Error     }); }  fetchAuthorName(1).then((name) =&gt; console.log(\"name:\", name));   ✔ 결과   ReferenceError: user1 is not defined     at fetch.then.then.then.then.then (&lt;anonymous&gt;:7:29)   동일한 이름의 메소드인 여러개의 then()중에서 정확히 어디서 에러가 발생했는지 에러 메세지만 보고는 알 수 없다.   2. 예외처리   Promise를 사용하면 try/catch대신 catch()메서드만 사용하여 예외처리를 해야한다. 비동기, 동기 코드가 섞인 경우에는 예외 처리를 하는 과정이 복잡해질 수 있다.   3. 들여쓰기   실제 프로젝트에서 비동기 처리 코드는 길고 복잡하기 마련인데, 무한 then() 메서드에 빠지게 되면 코드의 가독성이 매우 떨어진다.   📄 aync/await를 통해 데이터 fetch해오기   async/await를 사용하면 Promise가 가진 문제점들을 해결해 줄 수 있다.   Promise 사용했을 때:   fetch(`https://api.idiots.band/api/search?keyword=${e.target.value}`)   .then((x) =&gt; x.json())   .then((data) =&gt; {     console.log(JSON.stringify(data, null, 2));   });   async-await 사용했을 때:   onSearchBand: async (inputValue) =&gt; {   const postResponse = await fetch(     `https://api.idiots.band/api/search?keyword=${inputValue}`   );   const post = await postResponse.json();   this.setState(post); };      fetch함수를 사용하는 함수를 aysnc 함수로 만들어준다.   fetch함수에 await를 걸어준다.   await로 가져온 데이터는 .json()을 호출해서 한번 더 await를 걸어준다.   예외처리 하기 주의사항   export const getSearchData = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const postResponse = await fetch(url);   if (postResponse.ok) {     const data = await postResponse.json();     return data;   } else {     throw new Error(data);   } };   이 코드는 에러는 나지 않지만 성능이 떨어진다.      async 함수는 모두 Promise를 리턴한다.   reponse.ok인 경우도 Promise가 리턴된다.   하지만 throw new Error(data)를 선언한다면 async 함수는 Promise&lt;Response&gt; | Promise&lt;void&gt;로 타입이 잡히게 된다.   따라서 reponse.ok를 선언했다면 예외처리를 할 경우도 Promise를 반환하게 하는 것이 바람직하다.   // 바람직한 코드  export const getSearchBand = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const response = await fetch(url);   if (response.ok) {     return response.json();   }   return Promise.reject(new Error(\"API 요청에 실패 했습니다.\")); };   출처      DaleSeo - 비동기 처리 3부 async/await  ","categories": ["JavaScript"],
        "tags": ["JavaScript","async"],
        "url": "/javascript/javascript-datafetchByAsync/",
        "teaser": null
      },{
        "title": "🚨 Type 'KeyboardEvent' is not generic.",
        "excerpt":"🚨 에러 발생   KeyboardEvent를 쓰려고 했는데 에러가 발생했다.   const onPressEnter = useCallback(   async (e: KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {     // Error. Type 'KeyboardEvent' is not generic.ts     if (e.key === \"Enter\" &amp;&amp; !isUserValidation) {       await onClickSignIn();     }   },   [isUserValidation] );   앞에 React.를 붙이면 해결 됐지만, 다른 이벤트를 쓸 때는 평소처럼 그냥 쓰여서 궁금해서 찾아봤다.   ❔ 에러 원인   사용하고 있던 이벤트가 React가 아닌 DOM에서 가져와서 생긴 에러였다. 코드의 import을 봤더니 KeyboardEvent만 빠져있었다.   import { ChangeEvent, useMemo, useState } from \"react\";   🔨 에러 해결   KeyboardEvent를 React에서 impot해올 수 있도록 변경해주었다.   import { ChangeEvent, KeyboardEvent, useMemo, useState } from \"react\";   참고      stack overflow-Why is the MouseEvent in the checkbox event handler not generic?  ","categories": ["TypeScript"],
        "tags": ["에러","React","TypeScript"],
        "url": "/typescript/typescript-Type-'KeyboardEvent'-is-not-generic.ts/",
        "teaser": null
      },{
        "title": "변수(variable)와 상수(constant)",
        "excerpt":"📄 선언이란?   특정 이름에 특정 값을 담는 것을 선언이라고 합니다.   선언을 하는 방식에는 두가지가 있습니다.   하나는 변수이고 다른 하나는 상수입니다.   📄 변수   변수에는 고정된 값이 아닌 바뀔 수 있는 값을 담습니다.   let이라는 키워드를 사용하여 변수를 선언합니다.   let value = 1;      value라는 변수를 선언하고, 1이라는 값을 담았다.    📄 상수   상수는 변수와 다르게 고정된 값을 가집니다.   상수를 선언할 때는 const라는 키워드를 사용합니다.   const a = 1; a = 2;   상수는 고정된 값을 담기 때문에 위와 같은 코드에는 오류가 발생합니다.   한번 선언되어 1이라는 값을 가지고 있는 상수 a에 다른 값을 다시 넣었기 때문입니다.    주의할 점   상수 객체는 수정될 수 있습니다.   const user = {   name: \"John\", };  user.name = \"Pete\";  console.log(user.name);      ```js Pete; ```  `const`는 `user`의 값을 고정하지만, 그 내용은 고정하지 않습니다.  `const`는 `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생합니다.  ## 📄 왜 변수와 상수를 사용할까?  복잡한 식을 컴퓨터가 매번 읽어낸다면 프로그래밍의 효율성이 떨어집니다.  변수와 상수에 값을 담아두면 컴퓨터가 매번 똑같은 일을 반복하지 않고 코드도 간결해집니다.  ```js const sum = 5 + 10;  if (sum % 3 === 0) {   console.log(\"야호\"); } ```  이렇게 값을 변수나 상수에 지정하면 컴퓨터가 5 + 10을 매번 계산하지 않고 코드를 실행할 수 있습니다.  ## 📄 변수 명명 규칙  - 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다. - 첫 글자는 숫자가 될 수 없습니다. - 대·소문자는 구별됩니다. `a`와 `A`는 다릅니다. - 비 라틴계 언어도 변수명에 사용할 수 있지만 권장하지 않습니다. - 예약어는 사용하지 않습니다. - 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하는 카멜표기법이 흔히 사용됩니다. - `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용합니다. - 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 a, b, c와 같은 짧은 이름은 피해야 합니다. - 최대한 서술적이고 간결하게 명명해 주세요. data와 value는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합니다. - 자신만의 규칙이나 소속된 팀의 규칙을 따릅니다. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 currentVisitor나 newManInTown이 아닌 currentUser나 newUser라는 이름으로 지어야 합니다. - 변수명은 클래스명과 관련지으면 좋습니다.  ## 출처  - 패스트캠퍼스 프론트엔드 강의  * [모던 자바스크립트 튜토리얼](https://ko.javascript.info/object)  ","categories": ["JavaScript"],
        "tags": ["JavaScript","변수","상수"],
        "url": "/javascript/javascript-variableConstant/",
        "teaser": null
      },{
        "title": "github-actions-tutorial",
        "excerpt":"📄 CI/CD   : 어플리케이션 개발 단계부터 배포때까지 모든 단계를 자동화하는 과정   🎲 Point (큰 틀로 먼저 생각하기)      CI - 새로운 변경 사항 머지, 빌드, 테스트 자동화        CD - 배포 자동화 (with AWS S3)       github actions: 자동화를 가능하게 해주는 하나의 가상 컴퓨터   ▪ CI (Continuos Integration) - 지속적인 통합   : 새로운 코드의 변경 사항이 빌드 및 테스트 되어 공유 레포지토리에 지속적으로(=자동적으로)통합되는 것           코드 변경사항을 주기적으로 빈번하게 머지해야 한다. = 작은 단위로 나누어 머지를 진행한다.            CI를 위해 작성된 스크립트를 통해 테스트의 과정이 자동으로 진행된다.       ▪ CD (Continuous Delivery(or Deployment)) - 지속적인 제공(or 배포)         Continuous Delivery는 개발환경 배포까지 자동화,   Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미   CD는 개발자의 변경 사항이 레포지토리를 넘어, 고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미합니다.   CI/CD를 위해 플랫폼을 사용하는데 설치형과 클라우드형이 있다.   대표적인 설치형 플랫폼은 Jenkins, 클라우드형 CI/CD 플랫폼은 Github Actions가 있다.      클라우드 서비스? 타사 제공업체가 호스팅하여 인터넷을 통해 사용자에게 제공하는 인프라, 플랫폼 또는 소프트웨어    ▪ 왜 CI/CD를 구축할까? (CI/CD의 장점)      개발 생산성을 향상 시켜준다.   문제점을 빠르게 발견할 수 있다.        발견된 버그를 빠르게 수정 또한 가능하다.       코드의 퀄리티 향상 &gt; 코드의 유닛 테스트가 가능하기 때문     📄 What is Github Actions !   : Github에서 제공하는 클라우드형 CI/CD 툴   🎲 Point (사용 이유를 명확히 이해하기)      CI/CD 자동화 파이프라인을 구축하기 위해서 사용한다.   자동화를 위해 github 에서 제공하는 하나의 가상 컴퓨터   ▪ 장점      툴(ex. Jekins)을 따로 설치하지 않고 Repository에서 관리   쉬운 설정   ▪ 알아야 할 개념 5가지      name: CI/CD  on:   push: // push event     branches:       - main    pull_request: // pr event     branches:       - main   workflow_dispatch: // github actions 페이지에서 workflow를 실행할 수 있는 기능을 추가하는 이벤트  jobs:   helloWorld:     runs-on: ubuntu-latest // runner     steps:       - run: echo HelloWorld       - uses: actions/checkout@master           Workflows              특정한 이벤트가 발생했을 때 어떤 일을 수행하는 지 알려주는 자동화된 프로세스       여러 Job으로 구성                Events              github에서 발생할 수 있는 이벤트(main 브랜치로 머지, 커밋을 푸쉬)                Jobs                       하나의 Runner에서 실행될 여러 step 모음, workflow의 job들은 동시에 실행(병렬로 실행), step은 순차적으로 실행               여러 step으로 구성되어 있음.       다른 Job에 의존할 수 있고, 독립적 또는 병렬적으로 실행 가능.                Actions              github workflow 라이브러리       남들이 만들어둔 일련의 step들을 가져다 씀.       use 키워드를 사용  marketplace에 설정된 actions가 많음. 가져다쓰면 된다.  직접 코드 수정시에도 확인가능                Runners              내가 직접 Job을 실행시킬 필요 없이 Job을 실행시키는 VM 머신(가상 컴퓨터)                workflow dispatch        📄 GitHub Actions으로 CI 파이프라인 구축하기   CRA에는 별도의 test 기능이 있기 때문에 jest와 같은 테스트 라이브러리를 설치할 필요가 없다.      App.js   import \"./App.css\";  function App() {   return &lt;h1&gt;Hello, World&lt;/h1&gt;; }  export default App;      App.test.js (테스트코드 예시)   import { render, screen } from \"@testing-library/react\"; import App from \"./App\";  test(\"renders learn react link\", () =&gt; {   render(&lt;App /&gt;); // App.js가 렌더링 되는지 확인    // h1 태그를 가지고 있는지 테스트   const heading = screen.getByRole(\"heading\");   expect(heading).toBeInTheDocument();    // App.js가 Hello, Deploy라는 글자를 가지고 있는지 테스트   expect(heading.textContent).toBe(\"Hello, Deploy\"); });      CICD.yml 프로젝트 경로에 .github\\workflows라는 폴더를 만들어 yml파일을 생성한다.   name: CI/CD  on:   push:     branches:       - main    pull_request:     branches:       - main   workflow_dispatch:  jobs:   helloWorld:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@master       - run: npm ci // clean install의 약자, npm package를 설치한다.       - run: npm run test       - run: echo SUCCESS   ✔ 잘못된 코드로 테스트 자동화 확인해보기   Hello deploy를 Hello World으로 바꾸어 테스트.   import \"./App.css\";  function App() {   return &lt;h1&gt;Hello, World&lt;/h1&gt;; }  export default App;      어느 부분에서 test를 통과하지 못했는지 확인할 수 있다.   ▪ 정상 코드로 테스트 자동화 실행하기      모든 step이 작동한 것을 확인할 수 있다.   ▪ PR할 때 제대로 test 되는지 확인해보기      코드를 작성할 브랜치(break-tests)생성        push후 pr 생성        바로 test결과를 알 수 있다. Detail을 클릭하면 action으로 넘어가 해당 work flow에서 어디가 잘못되었는지 확인 할 수 있다.        PR목록에서도 확인 가능하다.        테스트시 문제가 없으면 초록 뱃지가 뜨는 것을 확인 할 수 있다.       📌 참고. github 페이지에서 workflow 생성하기       CI/CD를 적용할 프로젝트의 action 탭에서 node.js 템플릿을 선택한다.    기본적인 템플릿에서 각자 상황에 맞게 수정한다.    📄 github actions를 사용해 CD 파이프라인 만들기 (with AWS S3)      AWS: 아마존에서 만든 클라우드 서비스   AWS S3: AWS에서 제공하는 인터넷 스토리지 서비스 like vercel   1. AWS에서 회원가입 후 버킷(= 저장소) 만들기      AWS 리전: 어디에 있는 컴퓨터를 빌려 쓰는가?   객체 소유권 - ACL 비활성화 (권장)     :star: 중요. 퍼블릭 엑세스 차단 해제 &gt; 우리가 만드는 웹에 모두가 접근하게 하기 위해서   주의(빨간 세모)박스에는 체크.   버킷 버전 관리 - 비활성화 체크   기본 암호화 - 비활성화 체크   버킷 만들기      2. 프로젝트 build 실행하고 버킷에 파일 업로드하기      프로젝트 build 폴더에 있는 파일을 업로드 합니다.         속성탭에서 정적 웹 사이트 호스팅을 활성화 합니다.            정적 웹 페이지: Client Side Rendering방식으로 진행되는 웹 페이지 (이미 저장된 html 문서를 클라이언트에게 전송)       동적 웹 페이지: Server Side Rendering방식으로 진행되는 웹 페이지 (사용자의 요청 정보를 처리한 후에 제작된 HTML문서를 클라이언트에게 전송)       따라서 AWS S3 기능으로는 Next.js로 만든 웹 페이지를 호스팅할 수 없음. AWS EC2라는 기능이 있다고 함.                인덱스 문서 - 특정한 웹사이트로 버킷에 접속하면 처음으로 보여줄 기본 페이지        호스팅을 활성화 하면 주소를 받습니다.       하지만 처음엔 403 Forbidden 에러가 발생합니다.       왜? 니가 누군지 아는데 닌 권한이 없다. 버킷안에 있는 객체에 접근할 권한이 없다.       차단 풀었는데 왜? 아까는 차단을 거는 것을 해제한것.       차단은 풀렸지만 권한은 따로 부여해주어야 한다.       권한을 부여하자       3. 웹페이지에 접근 권한을 부여한다.   권한 탭에 들어가서 버킷 정책으로 이동한다.      버킷 정책에서 엑세스 권한 설정이 가능하다. Json 파일로 제작   {   \"Version\": \"2012-10-17\", // 정책을 설정하는 aws문법의 마지막 업데이트   \"Statement\": [     {       \"Sid\": \"PublicReadGetObject\", // 사이드 아님. S아이디임. 고유한 ID.       \"Effect\": \"Allow\", // 권한을 허용할지 말아야할지       \"Principal\": \"*\", // 누구한테 권한을 허용할 것인지       \"Action\": \"s3:GetObject\", // 어떤 행동을 허락할 것인지       \"Resource\": \"arn:aws:s3:::&lt;bucket-name&gt;/*\" // 여러가지 버킷 또는 파일 중 권한을 허용할 리소스     }   ] }      버킷 정책에서 권한을 모두에게 허용하면, 403 forbidden error가 사라지고 잘 작동하는 것을 확인할 수 있습니다.   여기까지 aws에 파일을 올려서 한 수동적인 배포!   4. 터미널에서 AWS S3에 배포하고 github actions로 자동화하기!   자동화하기 위해 터미널에서 aws를 다룰 수 있도록 aws CLI를 설치한다. AWS 공식 DOC에서 AWS CLI를 설치한다. 설치 방법: Windows(OS) PC에 AWS CLI 설치하기      AWS CLI란? AWS Command Line Interface, 터미널에서 AWS 실행을 가능하게 해주는 오픈 소스 도구       유저탭을 클릭해 보안자격증명 페이지로 들어가 엑세스키 만들기 버튼을 클릭한다.    엑세스키 만들기 버튼을 눌러 단계를 진행하면 만들어진 엑세스키를 보여준다.      엑세스 키 = 사용자의 아이디   비밀 엑세스 키 = 사용자의 비밀번호 :star: 중요! 비밀 엑세스 키는 처음 만든 상황 이후에는 보이지 않으니 따로 저장해 두어야 한다.      터미널에서 aws configure --profile &lt;프로필 이름&gt;을 입력해 프로젝트 배포에 사용될 프로필을 설정한다.      Default region name: ap-northeast-2 // 서울      aws configure list-profiles명령어를 통해 생성된 프로필을 확인할 수 있다.         aws s3 sync build/ s3://&lt;aws 페이지에서 생성한 버킷 이름&gt; --delete --profile &lt;사용할 프로필 이름&gt;   aws 페이지에서 작성한 버킷의 객체를 모두 지우고 현재 루트에 있는 build파일을 모두 업로드 한다.      aws 페이지에서도 파일들이 업로드 된것을 확인할 수 있다. 프로젝트의 내용이 변경된 경우, build하고 다시 버킷에 파일을 업로드하면 변경된 내용을 확인할 수 있다.   5. 본격적으로 CD 파이프라인 구축하기   name: CI/CD  on:   push:     branches:       - main   workflow_dispatch:  jobs:   CICD:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@main       - run: npm ci       - run: npm run test       - run: echo SUCCESS       - run: npm run build       - name: deploy to s3          uses: jakejarvis/s3-sync-action@master // 이부분을 main으로 바꾸면 error발생          with:             args: --delete // 버킷에 있는 모든 객체 삭제          env: // 환경변수 세팅             AWS_S3_BUCKET: $             AWS_ACCESS_KEY_ID: $             AWS_SECRET_ACCESS_KEY: $             AWS_REGION: 'ap-northeast-2'             SOURCE_DIR: 'build'   엑세스 키 비밀번호를 숨기기 위해 깃헙에서 자체적으로 제공해주는 기능을 사용한다.    Settings&gt; secrets/Actions &gt; New repository secret 중요. 수정은 가능하지만 원래 저장했던 내용은 볼 수 없다.    환경변수는 생성했던 버킷 이름, ID, 비밀번호를 설정하면 된다.   main 브랜치에 push를 날리면    actions탭에서 CD가 성공적으로 구축된 것을 확인할 수 있다.   📄 팀원들과 토론할 점           develope 브랜치에 push &amp; pr할때 CI 작동            CD는 어느 이벤트에 작동하도록 설정해야 하는지?       출처           원티드 프리온보딩 프론트엔드 인턴십 강의            드림코딩 - CI/CD 5분 개념 정리       드림코딩 - 제발 깃허브 액션 모르는 개발자 없게 해주세요 :star: 정리 Good!        Github Actions 공식문서       CI/CD란 무엇인가   어쩐지 오늘은 - Github Action 사용법 정리 :star: 정리 Good!   DaleSeo - Jest로 기본적인 테스트 작성하기        Windows(OS) PC에 AWS CLI 설치하기       GitHub Docs - Understanding GitHub Actions  ","categories": ["Git"],
        "tags": ["github actions","CI","CD","스터디"],
        "url": "/git/git-github-actions-tutorial/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "동적 임포트(Dynamic import)",
        "excerpt":"📄 동적 임포트(Dynamic import)   보통 코드의 최상단에서 import문을 사용해 클래스나 함수를 가져오는 것을 정적 import라고 합니다.   정적으로 모듈을 import한다면      import문에 동적 매개 변수를 사용할 수 없습니다. = 원시 문자열만 가능하기 때문에 함수 호출 결과값을 경로로 사용할 수 없습니다.   런타임이나 조건부로 모듈을 불러올 수 없습니다. = if문, 코드 블록에서 사용할 수 없습니다.   📄 동적으로 모듈 import 하는 방법   동적으로 모듈을 import한다면      프로미스 객체를 반환합니다. 프로미스 객체의 반환값은 불러온 모듈입니다.   코드의 위치에 관계없이 사용이 가능하기 때문에, 모듈들을 사용자가 필요로 할 때 불러올 수 있습니다.   import()를 호출하는 순간부터 로딩이 되기 때문에 성능을 향상시킬 수 있습니다.   import(\"./sum\").then((sum) =&gt; {   console.log(sum(1 + 2)); });  ","categories": ["JavaScript"],
        "tags": ["JavaScript","동적 임포트","import"],
        "url": "/javascript/javascript-dynamic-import/",
        "teaser": null
      },{
        "title": "[React] 리액트에서 컴포넌트 동적으로 불러오기 with React.lazy",
        "excerpt":"📄 React.lazy   React.lazy는 React에서 동적으로 컴포넌트 파일을 불러올 때 사용합니다.   규모가 큰 프로젝트의 경우 한 페이지에 수많은 컴포넌트를 import합니다.   정적으로 컴포넌트를 import한다면 첫 페이지를 로드하는 즉시 대규모 단일 Javascript번들이 사용자에게 전송됩니다.   따라서 동적으로 import하여 필요할때만 컴포넌트를 로드하는 작업을 할 수 있습니다.   📄 사용법   ▪ React.lazy()   const Home = lazy(() =&gt; import(\"./routes/Home\")); const About = lazy(() =&gt; import(\"./routes/About\"));      불러오는 파일은 React 컴포넌트를 포함해야 합니다.   default export를 가진 컴포넌트여야 합니다.   ▪ Suspense   const App = () =&gt; (   &lt;Router&gt;     &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;       &lt;Routes&gt;         &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;         &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;       &lt;/Routes&gt;     &lt;/Suspense&gt;   &lt;/Router&gt; );      fallback: 컴포넌트가 로드될 때까지 기다리는 동안 보여줄 React 엘리먼트입니다.   하나의 Suspense 컴포넌트가 여러개의 lazy컴포넌트를 감쌀 수 있습니다.      이를 시작하기 좋은 장소는 라우트입니다. 웹 페이지를 불러오는 시간은 페이지 전환에 어느 정도 발생하며 대부분 페이지를 한번에 렌더링하기 때문에 사용자가 페이지를 렌더링하는 동안 다른 요소와 상호작용하지 않습니다.    출처      리액트 공식문서 - 코드 분할  ","categories": ["React"],
        "tags": ["React.lazy"],
        "url": "/react/react-React.lazy/",
        "teaser": null
      },{
        "title": "[TodoList-Project] 클래스로 작성하는 로그인/회원가입 axios통신",
        "excerpt":"📑 axios통신 로직을 클래스로 작성한 이유   꽤 여러번 투두리스트를 만들어봤지지만 axios 통신 로직은 항상 함수로만 작성했다. 원티드에서 강의를 듣고 클래스에 대해 고민하게 되었다. 클래스는 객체 형태로 state를 저장할 수 있기 때문에 state를 가진 모듈이라면 클래스로 작성하는 것이 좋다고 한다. 로그인/회원가입을 구현하는 로직은 url과 token을 가지고 있기 때문에 클래스로 작성을 하기로 결정했다. 이번에 본격적으로 구글링을 하는 연습을 하기 위해서 영어로 된 문서도 적극적으로 참고했다.   📑 httpClient.ts | axios Client를 담당   import axios, { AxiosInstance, AxiosRequestConfig } from \"axios\"; import { getLocalStorageToken } from \"../store/localStorage\";  declare module \"axios\" {   type AxiosRequest&lt;T = unknown&gt; = Promise&lt;T&gt;; } // 0  abstract class HttpClient {   // 1   protected readonly instance: AxiosInstance;    public constructor(baseURL: string) {     // 2     this.instance = axios.create({       baseURL: BASE_URL,     });      this._initializeRequestInterceptor(); // 3   }    private _initializeRequestInterceptor = () =&gt; {     // 4     this.instance.interceptors.request.use(this._handleRequest);   };    private _handleRequest = (config: InternalAxiosRequestConfig) =&gt; {     const accessToken = getLocalStorageToken();     if (accessToken &amp;&amp; config.headers) {       config.headers.Authorization = `Bearer ${accessToken}`;     }     return config;   }; }  export default HttpClient;           타입스크립트를 사용하고 있기 때문에 AxiosRequest가 무슨일을 하는지 알려줘야 한다. 이렇게 하면 response를 순수 data로 사용할때 타입스크립트가 에러를 내지 않는다고 한다.            우선, HttpClient라는 추상 클래스를 만들어 instance를 생성할 수 없게 만들어주었다. instance를 생성할 클래스는 기능별로 따로 만들었기 때문이다.            axios-instance를 생성하는 constructor이다. constructor로부터 base URL을 얻을 수 있다. axios.create는 protected 멤버로 설정된 instance에 저장되어 외부 클래스에서 사용할 수 없게 했다. 하지만 상속받은 클래스에서는 접근할 수 있다.            데이터를 요청하기 전 토큰이 있는지 확인해야 하기 때문에 axios의 interceptor메소드를 활용할 것이다. _는 private 메소드라고 암시하는 뜻이다.            interceptor메소드는 _handleRequest라는 콜백함수를 가진다. axios 요청시 로컬스토리지에 있는 값을 꺼내서 헤더에 Authorization 키를 설정할 수 있다.         📑 authAPI.ts | 로그인/회원가입 axios 통신을 담당   import { AxiosResponse } from \"axios\"; import { SIGNIN_URL, SIGNUP_URL } from \"../../constants/constants\"; import HttpClient from \"../httpClient\"; import { UserParam } from \"../../types/auth/UserInterface\";  class AuthAPI extends HttpClient {   public constructor() {     super();      this._initializeResponseInterceptor();   }    private _initializeResponseInterceptor = () =&gt; {     this.instance.interceptors.response.use(       this._handleResponse,       this._handleError     );   };    private _handleResponse = (response: AxiosResponse) =&gt; {     const responseCode = response.status;      switch (responseCode) {       case 200:         alert(\"로그인되었습니다.\");         break;       case 201:         alert(\"회원가입에 성공했습니다. 로그인해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }     return response;   };    protected _handleError = (error: AxiosError) =&gt; {     const { response: errorResponse } = error;     const errorCode = errorResponse.status;      switch (errorCode) {       case 400:         alert(\"동일한 이메일이 이미 존재합니다.\");         break;       case 401:         alert(\"아이디와 비밀번호를 확인해주세요.\");         break;       case 404:         alert(\"해당 사용자가 존재하지 않습니다. 회원가입을 진행해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }   };    public SignIn = (data: UserParam) =&gt; this.instance.post(SIGNIN_URL, data);    public SignUp = (data: UserParam) =&gt; this.instance.post(SIGNUP_URL, data); }  const authApi = new AuthAPI(); export { authApi };     참고      Enhance Your HTTP  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","axios","클래스"],
        "url": "/todolist-project/projects-todolist-axios/",
        "teaser": null
      },{
        "title": "[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기",
        "excerpt":"📄 리덕스 툴킷을 사용하지 않은 이유   리덕스를 인강을 통해서 배웠지만 처음엔 이해가 잘 안갔다. 리듀서, 액션 등등 새로운 키워드가 많았고 컨셉도 어려웠다. 배우고 꾸준히 사용해보지 않아서 고이 묻어둔 상태였는데 원티드에서 리덕스를 다루게 되어 다시 꺼내 보았다. 그렇게 리덕스를 사용해서 만든 과제물에 대해 팀원분에게 피드백을 듣게 되었고 리덕스의 컨셉을 이해하지 않았다는 것을 알게 되었다.   기존의 나는 api를 호출할 때 store에서 따로 상태관련 로직을 작성하지 않았다. 예를 들어 Post요청을 한다고 가정했을 때, 데이터를 Put요청을 통해 수정하고 바로 다시 Get요청으로 데이터를 불러와 변경된 데이터를 화면에 렌더링해서 보여줬다. 이 과정에서는 api호출이 총 두번 발생한다.   하지만 store에서 상태 관리 로직을 작성한다면 따로 Get요청을 하지 않아도 클라이언트단에서 변경된 데이터를 바로 렌더링 할 수 있었다. 같은 과정이지만 api요청이 한번으로 줄어들게 되는 것이었다. 단점으로는 코드가 무거워진다는 부분이 있지만 api호출이 줄어드는 만큼 확실히 사용자 입장에선 더 빠르게 느껴질 것 같다.   📄 기존의 리덕스 사용 방식   const commentSlice = createSlice({   name: \"comment\",   initialState: initialState,   reducers: {},   extraReducers: (builder) =&gt; {     builder.addCase(getComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(createComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(editComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(deleteComment.fulfilled, (state, action) =&gt; action.payload);   }, });  export default commentSlice;   redux-toolkit에서 제공하는 createAsyncThunk를 이용해 비동기 로직을 처리하고 댓글의 상태를 관리하는 리듀서를 작성했다. 상태 관련 로직이 전혀 없기 때문에 리듀서가 깔끔하고 각 액션이 어떤 일을 수행하는지 알 수 없다.   📄 개선된 리덕스 사용 방식   const todoReducer = (   state: TodoParam[] = initialState,   action: TodoActionType ) =&gt; {   switch (action.type) {     case GET_TODOS:       return action.payload;     case CREATE_TODO:       return [...state, action.payload];     case DELETE_TODO:       return state.filter((todo) =&gt; todo.id !== action.payload);     case UPDATE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload.id           ? { ...todo, todo: action.payload.todo, isCompleted: false }           : todo       );     case DONE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload           ? { ...todo, isCompleted: !todo.isCompleted }           : todo       );     default:       return state;   } };   리덕스를 제대로 다시 공부하기 위해 툴킷을 사용하지 않고 구현해보았다. 한번 Get요청을 통해 받아온 데이터를 관리하는 리듀서를 만들었다. 상태가 변경될때마다 새로고침을 하는게 아니라면 다시 Get요청을 하지 않아도 되니 api요청이 훨씬 줄어들었다.   지금은 규모가 작은 프로젝트지만 큰 프로젝트의 경우라면 관련 로직이 꽤 길어질 것 같은데 그때도 이렇게 관리를 하는게 맞는지 궁금해졌다. 이 부분은 좀더 찾아봐야 알 것 같다.  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","Redux"],
        "url": "/todolist-project/projects-todoList-redux/",
        "teaser": null
      },{
        "title": "[React] 라우터를 이용한 접근 제한 처리",
        "excerpt":"📄 라우터를 이용한 접근 제한 처리   라우터를 사용해 단순하게 경로를 설정해주는 것이 아닌 토큰이나 쿠키의 여부에 따라 접근 제한처리를 하는 것도 가능합니다.   💾 [publicRoute.js]   const PublicRoute = ({ children }) =&gt; {   const isLogined = getLocalStorageToken();   return isLogined ? &lt;Navigate to=\"/todo\" /&gt; : children; };      PublicRoute는 로그인 여부와 상관없이 모든 사용자에게 제공된다.   토큰이 있을 경우 /todo경로로 리다이렉트한다.   💾 [privateRoute.js]   const PrivateRoute = ({ children }) =&gt; {   const isLogined = getLocalStorageToken();   return isLogined ? children : &lt;Navigate to=\"/\" /&gt;; };      PrivateRoute는 로그인한 사용자에게만 제공된다.   토큰이 없을 경우 /경로로 리다이렉트 한다.   💾 [Route.js]   function Router() {   return (     &lt;Routes&gt;       &lt;Route         path=\"/\"         element={           &lt;PublicRoute&gt;             &lt;Home /&gt;           &lt;/PublicRoute&gt;         }       /&gt;       &lt;Route         path=\"/todo\"         element={           &lt;PrivateRoute&gt;             &lt;Todos /&gt;           &lt;/PrivateRoute&gt;         }       /&gt;     &lt;/Routes&gt;   ); }      Route를 설정할 때 해당 컴포넌트를 PrivateRoute 또는 PublicRoute로 감싸서 사용한다.  ","categories": ["React"],
        "tags": ["React Hooks","라우터","publicRoute","privateRoute"],
        "url": "/react/react-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C-%EC%B2%98%EB%A6%AC/",
        "teaser": null
      },{
        "title": "Nodejs, npm, yarn",
        "excerpt":"📄 Node.js란?      Nodejs는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript의 런타임 입니다. (by Node 공식 페이지)       런타임이란? 특정 언어로 만든 프로그램을 실행할 수 있는 환경    Nodejs는 자바스크립트를 브라우저 내에서 말고도 다른환경에서 자바스크립트를 실행할 수 있게 합니다.   Node.js 의 유래   크롬같은 브라우저에는 html을 동적으로 움직일 수 있게하는 자바스크립트 해석 엔진이 있습니다.   크롬은 V8, 모질라는 SpiderMonkey를 사용합니다.   브라우저 중 크롬이 인기가 있는 이유중 하나는 빠른 속도입니다.   자바스크립트를 해석하는 속도가 빠르기 때문에 사용자가 브라우저를 이용할 때 속도가 빠르다고 느끼게 됩니다.   크롬은 사용하던 해석 엔진인 V8을 Node.js라는 이름으로 따로 출시합니다.   📄 npm(Node Packaged Manager)   npm은 Node.js의 패키지 관리자입니다.   npm은 Node.js로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램입니다.   npm을 사용하여 패키지를 설치하면 package.json에서 설치한 패키지가 자동으로 정리됩니다.   📄 yarn   yarn 또한 npm과 같이 javascript 패키지 매니저입니다.   yarn을 사용하면 npm 보다 더 나은 환경에서 자바스크립트를 실행할 수 있어 사용량이 높습니다.   yarn을 사용하는 이유   1. 속도   우선 npm보다 빠릅니다. 다운받은 패키지를 캐시에 저장하여 중복된 데이터는 다운로드하지 않고 캐시에 저장된 파일을 활용하기 때문입니다.   npm은 패키지를 설치할때 순차적으로 설치하는 반면, yarn은 병렬로 처리해 속도면에서 우수합니다.   2. 안정성과 보안   npm은 의존 관계를 가지는 다른 패키지들이 포함되지만 yarn은 package.json에 있는 파일만 설치한다고 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Nodejs","npm","yarn"],
        "url": "/javascript/javascript-jsruntime/",
        "teaser": null
      },{
        "title": "짝수와 홀수",
        "excerpt":"문제 📖   정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요.      num은 int 범위의 정수입니다.   0은 짝수입니다.   function solution(num) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(num) {   const answer = num % 2 === 0 ? \"Even\" : \"Odd\";   return answer; }  solution(4);   num을 2로 나누어 나머지값에 대한 유무를 삼항연산자로 표현하고, 상수 answer에 값을 할당에 결과값을 return시켰다.   Best Practice 👍   function evenOrOdd(num) {   return num % 2 ? \"Odd\" : \"Even\"; }   숫자 0은 false, 이외의 값은 true라는 점을 활용하니 코드가 더욱 간결해졌다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","짝수와홀수"],
        "url": "/programmers-lv1/evenandodd/",
        "teaser": null
      },{
        "title": "최댓값과 최솟값",
        "excerpt":"문제 📖   문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.   예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다.      s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.   function solution(s) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(s) {   const stringToArray = s.split(\" \");   const stringToNumber = stringToArray.map((element) =&gt; parseInt(element));   const maxValue = Math.max(...stringToNumber);   const minValue = Math.min(...stringToNumber);   const answer = `${minValue} ${maxValue}`;   return answer; }   먼저 split 배열 내장 함수를 통해 공백을 기준으로 문자열을 구분했다.   이후 최댓값과 최솟값을 구하기 위해 구분된 배열의 문자들을 숫자로 바꾸어 주고,   spread연산자로 배열을 분해해서 최댓값과 최솟값을 구했다.   문자열을 반환해야 한다고해서 백틱으로 maxValue minValue을 감싸 return시켰다.   Best Practice 👍   # 1   function solution(s) {   const arr = s.split(\" \");    return Math.min(...arr) + \" \" + Math.max(...arr); }   우선, 내가 작성한 코드보다 훨씬 간결한 것을 확인했다.   내가 몰랐던 점은 다음과 같다.      Math가 문자열도 취급한다는 것   굳이 따로 변수나 상수에 값을 할당하는 것보다 바로 return을 시키는게 더 나을 때도 있다는 것   # 2   function solution(s) {   let min = Math.min.apply(null, s.split(\" \").map(Number));   let max = Math.max.apply(null, s.split(\" \").map(Number));   var answer = min + \" \" + max;   return answer; }   이 코드가 인상적이었던 점은 map함수를 사용하는 방식 때문이었다.   내 풀이를 보면 map을 사용할때 각각 요소에 parseInt를 적용해서 숫자로 변환하는 방식이었는데, 그냥 Number라고 적기만 해도 식이 진행된다는 것을 알게 되었다.  ","categories": ["programmers-lv2"],
        "tags": ["프로그래머스","최댓값과 최솟값"],
        "url": "/programmers-lv2/programmers-maxandmin/",
        "teaser": null
      },{
        "title": "평균 구하기",
        "excerpt":"문제 📖   정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.      arr은 길이 1 이상, 100 이하인 배열입니다.   arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(arr) {   const answer = arr.reduce((a, c) =&gt; a + c) / arr.length;   return answer; }   배열 내장 함수인 reduce함수를 사용했다.   for문을 사용하는 것보다 훨씬 간결한 코드가 나왔다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","평균구하기","해시"],
        "url": "/programmers-lv1/programmers-arr/",
        "teaser": null
      },{
        "title": "폰켓몬",
        "excerpt":"문제 📖   당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.   홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.      첫 번째(3번), 두 번째(1번) 폰켓몬을 선택   첫 번째(3번), 세 번째(2번) 폰켓몬을 선택   첫 번째(3번), 네 번째(3번) 폰켓몬을 선택   두 번째(1번), 세 번째(2번) 폰켓몬을 선택   두 번째(1번), 네 번째(3번) 폰켓몬을 선택   세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.   당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.   나의 풀이 🙋‍♀️   function solution(nums) {   const totalNumber = Math.ceil(nums.length / 2);   const set = new Set(nums);   const newNums = [...set];    const answer =     Math.ceil(newNums.length) &gt; totalNumber       ? totalNumber       : Math.ceil(newNums.length);    return answer; }   우선 주어진 배열의 길이를 totalNumber에 저장해 answer에 최댓값으로 생각했다.   이후 set함수를 사용해서 배열의 중복요소를 제거했다.   최종 정답은 중복요소를 제거한 배열의 길이가 최댓값보다 크면 최댓값인 totalNumber, 작으면 중복요소를 제거한 배열의 길이로 설정했다.   Best Practice 👍   function solution(nums) {   const max = nums.length / 2;   const arr = [...new Set(nums)];    return arr.length &gt; max ? max : arr.length; }   다른 사람의 풀이를 보니 내가 너무 성급하게 정답을 제출했다는 것을 알았다.   내 풀이에서는 newNums.length에 쓸데없이 올림처리를 한 것을 지우지도 않았고, set함수를 사용할때 굳이 상수를 두번이나 선언한게 보인다.   답이 나와도 다시한번 보고 정리하는 습관을 가져야겠다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","폰켓몬","해시"],
        "url": "/programmers-lv1/programmers-phonecatmon/",
        "teaser": null
      },{
        "title": "약수의 합",
        "excerpt":"문제 📖   정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.      n은 0 이상 3000이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(n) {   let sum = n;   for (let i = 1; i &lt;= Math.floor(n / 2); i++) {     if (n % i === 0) sum += i;   }   return sum; }   간단하게 for문을 사용했다.   어차피 주어진 수 n의 절반까지만 정답의 유효 범위이기 때문에 반복 횟수를 조금이라도 줄이려고 신경썼다.   반복문을 통해 주어진 수 n을 정수로 나눈 값이 0일 경우, 총합 sum에 더해준다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","약수의 합"],
        "url": "/programmers-lv1/sumofdivisor/",
        "teaser": null
      },{
        "title": "2016년",
        "excerpt":"문제 📖   2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT   입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.      2016년은 윤년입니다.   2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   나의 풀이 🙋‍♀️   function solution(a, b) {   const dayOfTheWeek = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];   const daysOfMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   let sum = 0;    if (a === 1) {     sum = b;   } else {     for (let i = 0; i &lt;= a - 2; i++) {       // 1       sum += daysOfMonth[i];       if (i == a - 2) {         sum += b; //2       }     }   }    const index = sum - Math.floor(sum / 7) * 7; // 3    return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1]; }   내가 생각한 풀이의 순서는 다음과 같다.      주어진 월(a)전의 총 날짜를 더한 값을 구한다.. = sum   sum에 b를 더해 필요한 날짜를 모두 더한 값을 구한다.   sum에 7의 배수를 뺐을 때 나올 수 있는 한자리 수를 구해 dayOfTheWeek의 인덱스로 활용한다.   trouble shooting 1 💥   처음 코드   for (let i = 0; i &lt;= a - 2; i++) {   sum += daysOfMonth[i];   if (i == a - 2) {     sum += b;   } }   수정한 코드   if (a === 1) {   sum = b; } else {   for (let i = 0; i &lt;= a - 2; i++) {     sum += daysOfMonth[i];     if (i == a - 2) {       sum += b; //2     }   } }   이 부분은 왜 통과하지 못했는지 머리를 굴리다 1월인 경우, 2월인 경우 값을 대입해서 생각해보니 문제점을 찾을 수 있었다.   만약 1월이라면 a는 1이되는데 for문의 조건에 처음부터 충족되지 못해서 sum에 값이 들어가지 않았던 것이다.   if문으로 조건을 달아주긴 했지만 조건문속 반복문속 조건문.. 정말 맘에 들지 않는다..   trouble shooting 2 💥   처음 코드   return dayOfTheWeek[index - 1];   수정한 코드   return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1];   계산대로 하면 모든 케이스가 통과해야하는데 13개의 케이스 중 2개가 통과하지 못하고 계속 실패로 걸렸다.   테스트 케이스에 날짜를 하나 하나 추가해서 결과를 확인하던 중 이유를 알 수 있었다.   index가 0이 될 수도 있었던것이었다.   예를 들어 5월 5일인 경우, index가 126 - (18*7) = 0이 되는데 나는 결과값을 dayOfTheWeek[index-1]로만 리턴해서 결과가 undefined가 나왔던 것이다.   return할 때 삼항연산자를 이용해 index가 0이 될 경우의 케이스도 처리해주었다.   Best Practice #1 👍   function getDayName(a, b) {   var tempDate = new Date(2016, a - 1, b);    return tempDate.toString().slice(0, 3).toUpperCase(); }  //아래 코드는 테스트를 위한 코드입니다. console.log(getDayName(5, 24));   Date가 있는 걸 알긴 했지만 그러면 너무 단순해질것같아서 사용하지 않았다.   그래도 메소드를 사용한걸 보니 훨씬 보기 편하다.   Best Practice #2 👍   function solution(a, b) {   const monthDay = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   const weekDay = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\"];    let days = b;   for (let i = 0; i &lt; a - 1; i++) days += monthDay[i];    return weekDay[days % 7]; }   코드가 흘러가는 구성이 내가 작성한 코드와 크게 다르지 않다.   하지만 간결함과 가독성이 크게 다르다.   for문의 조건식에서 &lt;=을 &lt;로 고쳤을뿐인데 if문이 하나 줄었다.   굳이 sum이라는 변수를 새로 만들지 않고 b에 값을 더해주었다.   굳이… Math.floor()를 사용하지 않고도 그냥 %연산자로 나머지값 계산해서 index로 처리해주었다…   만약 다른 사람이 푼 답에 Best Practice가 있다면 배열 내장 함수를 사용했을 것이라고 생각했는데 아니었다.   물론 배열 내장 함수를 사용할 수도 있지만 이 코드가 가독성도 좋고 제일 좋아보였다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","2016년"],
        "url": "/programmers-lv1/2016/",
        "teaser": null
      },{
        "title": "투명도 설정하기",
        "excerpt":"📄 opacity 속성   div {   background-color: rgb(255, 255, 255);   opacity: 0.5; }           opacity로 0~1의 값을 설정한다.            0에 가까울수록 투명하다.       📄 rgba 속성   div {   background-color: rgb(255, 255, 255, 0.5); }   차이점   opacity는 해당 요소를 포함한 하위 요소까지 적용되고,  raga는 해당 요소에만 적용됩니다.  ","categories": ["CSS"],
        "tags": ["opacity","rgba"],
        "url": "/css/css-opacity/",
        "teaser": null
      },{
        "title": "🚨 Cannot find module",
        "excerpt":"🚨 Cannot find module   자바스크립트 강의를 들으며 실습 도중 파일이 실행이 안됐다.      경로 설정 문제 인줄 알았는데 파일 설정을 잘못했다.   🔨 해결           확장자 명이 js로 되어 있는지 확인하고 고친다.            끝^^       느낀점   항상 오류가 발생하면 사실 대부분 이런 사소한 문제들인것 같다.   모든 과정을 꼼꼼히 살피자.   참고      [stackoverflow]https://stackoverflow.com/questions/9023672/how-do-i-resolve-cannot-find-module-error-using-node-js  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/cannot-find-module/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 🚨 Could not find a declaration file of module",
        "excerpt":"🚨 에러 발생   모코숲 프로젝트 진행 중 react-persist를 설치해서 사용하려고 하는데 에러가 발생했습니다.      하라는대로 npm i --save-dev @types/redux-persist를 입력해도 계속 동일한 현상이 발생합니다.   🔨 에러 해결   react-app-env.d.ts파일에 다음과 같이 추가해주었습니다.   /// &lt;reference types=\"redux-persist\" /&gt;   평소에 크게 신경 쓰지 않았던 파일이기에 여기서 에러가 해결될 줄 몰랐다.   📌 react-app-env.d.ts 란?   d.ts 는 전역에서 사용할 타입 유형을 선언만 할 수 있는 파일입니다.   이 파일은 컴파일 이후 자바스크립트 코드로는 생성되지 않습니다.   CRA로 프로젝트 생성시 자동으로 react-app-env.d.ts파일이 생성됩니다.   /// &lt;reference types=\"react-scripts\" /&gt;   여기서 트리플 슬래시(///)로 작성된 내용은 컴파일러 지시어로 사용됩니다.   node_modules의 react-script라는 dependency를 불러와서 사용한다는 뜻입니다.   이런 지시어는 패키지에 대한 종속성을 선언하는데 사용됩니다.   참조   stack overflow - How to add redux-persist to typescript project?  ","categories": ["coding-swamp"],
        "tags": ["모코늪","redux-persist","react-app-env.d.ts"],
        "url": "/coding-swamp/coding-swamp-Could-not-find-a-declaration-file.md/",
        "teaser": null
      },{
        "title": "🚨 Assignment to constant variable.",
        "excerpt":"🚨 Assignment to constant variable.   자바스크립트 퀴즈를 푸는데 코드에 빨간 표시도 안났는데 에러가 떴다.   직역하면 상수값을 변수에 할당했다는 뜻이다.   function countBiggerThanTen(numbers) {   let sum = 0;   numbers.forEach((number) =&gt; {     if (number &gt; 10) {       sum += 1; // TypeError: Assignment to constant variable.     }   });   console.log(sum); }   원인   이미 선언한 const 변수에 새로운 값을 할당했을 때 발생한다.   위 코드에서 계속 값이 바뀌는 sum을 상수로 선언했다.   해결   값을 재할당에서 사용할 수 있는 let으로 바꾸어 주었더니 정상적으로 동작했다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/javascript-assignment-to-constant-variable/",
        "teaser": null
      },{
        "title": "🚨 Cannot use import statement outside a module",
        "excerpt":"🐞 에러 발생   공연 검색기 프로젝트 중 에러가 발생했다.    ❔ 원인   해당 스크립트를 모듈로 인식하지 못해 import문을 쓸 수 없다는 뜻이다.   직접 스크립트의 타입을 지정해주어야 한다.   ❕ 해결   [index.html]   &lt;script src=\"main.js\" type=\"module\"&gt;&lt;/script&gt;   이렇게 해당 스크립트 태그에서 타입을 모듈로 지정해주면 에러가 해결된다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","import"],
        "url": "/javascript/javascript-cannot-use-import-statement-outside-a-module/",
        "teaser": null
      },{
        "title": "이벤트 버블링 (Event Bubbling), 이벤트 캡쳐 (Event Capture), 이벤트 위임 (Event Delegation)",
        "excerpt":"📄 이벤트 버블링 (Event Bubbling)   이벤트 버블링은 특정 요소에서 이벤트가 발생했을 때, 해당 이벤트가 더 상위 요소로 전달되는 과정입니다.   브라우저는 특정 요소에서 이벤트가 발생했을 때 그 이벤트를 최상위에 있는 요소까지 전파합니다.   이러한 과정을 이벤트 버블링이라고 합니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   three; two; one;   📄 이벤트 캡처 (Event Capture)   이벤트 캡처는 이벤트 버블링과 반대로 진행되는 이벤트 전달 과정입니다.   이벤트 캡처는 이벤트 버블링과 반대로 상위요소에서 하위요소로 이벤트 전달 과정이 진행됩니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   one; two; three;   addEventListener의 세번째 파라미터로 capture: true를 설정해주면 이벤트 캡처가 진행되어 가장 상위 요소에 적용된 이벤트가 먼저 발생합니다.   📄 이벤트 진행을 막고싶을 때는 어떻게 할까?   이벤트 버블링이나 이벤트 캡처를 구현할때 적용한 모든 요소에 이벤트를 실행하지 않고 중간에 멈추기 위한 속성이 있습니다. event.stopPropagation()을 사용하면 이벤트의 진행과정을 중단시킬 수 있습니다.   // 이벤트 버블링 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // three }  // 이벤트 캡쳐 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // one }   📄 이벤트 위임 (Event Delegation)   이벤트 위임은 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식입니다.   &lt;h1&gt;오늘의 할 일&lt;/h1&gt; &lt;ul class=\"itemList\"&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item1\" /&gt;     &lt;label for=\"item1\"&gt;이벤트 버블링 학습&lt;/label&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item2\" /&gt;     &lt;label for=\"item2\"&gt;이벤트 캡쳐 학습&lt;/label&gt;   &lt;/li&gt; &lt;/ul&gt;   // 새 리스트 아이템을 추가하는 코드 var itemList = document.querySelector(\".itemList\");  var li = document.createElement(\"li\"); var input = document.createElement(\"input\"); var label = document.createElement(\"label\"); var labelText = document.createTextNode(\"이벤트 위임 학습\");  input.setAttribute(\"type\", \"checkbox\"); input.setAttribute(\"id\", \"item3\"); label.setAttribute(\"for\", \"item3\"); label.appendChild(labelText); li.appendChild(input); li.appendChild(label); itemList.appendChild(li);  var itemList = document.querySelector(\".itemList\"); itemList.addEventListener(\"click\", function (event) {   alert(\"clicked\"); });   아이템이 새로 추가될 때마다 이벤트를 새로 추가하지 않고 상위 요소인 .itemList에 이벤트를 달아줌으로써 하위요소에도 이벤트가 등록되었습니다.   출처      캡틴 판교-이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","이벤트 버블링","이벤트 캡처","이벤트 위임"],
        "url": "/javascript/javascript-eventBubbling/",
        "teaser": null
      },{
        "title": "[React] 새로 고침해도 state 유지하기 with Redux-Persist",
        "excerpt":"📄 Redux-Persist      Redux-Persist는 state를 Local Storage 혹은 Session Storage에 저장해 새로고침을 해도 state를 유지시키는 redux 라이브러리입니다.   모코숲 프로젝트를 진행하는 중 새로고침하면 리덕스 store에 저장되어 있던 데이터들이 reset되어 동일한 데이터를 매 페이지에서 요청해야 했습니다.   페이지가 처음 로딩될 때 api를 매번 요청할 수는 있지만, 더 효율적인 방법이 있을까 고민하던 중 Redux-Persist라는 라이브러리를 알게 되었습니다.   📄 사용방법   1. 설치 (yarn + typescript 환경)   yarn add redux-persist @types/redux-persist   2. Storage 종류에 따라 `import`      Local Storage를 사용할 경우   import storage from 'redux-persist/lib/storage      Session Storage를 사용할 경우   import sessionStorage from 'redux-persist/lib/storage   이 과정에서 발생한 에러로 redux-persist를 몇번이나 재설치했습니다.   🔗 TIL-Could not find a declaration file of module   에러는 TIL폴더에 정리해 두었습니다.   3. config 작성 후, rootReducer를 감싼다.   // store/index.ts  const persistConfig = {   // config 작성   key: \"root\",   storage,   whiteList: [\"studyItem\", \"member\", \"studyList\"], // 적용할 리듀서를 whiteList에 포함시킨다. };  const rootReducer = combineReducers({   userForm: userFormSlice,   signInForm: signInFormSlice,   member: memberSlice,   editMode: editModeSlice,   userMenu: userMenuSlice,   studyForm: studyFormSlice,   studyList: studyListSlice,   studyItem: studyItemSlice, });  const persistedReducer = persistReducer(persistConfig, rootReducer);  const store = configureStore({   reducer: persistedReducer,   middleware: (getDefaultMiddleware) =&gt;     getDefaultMiddleware({ serializableCheck: false }).concat(logger), });  export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppDispatch = typeof store.dispatch; export default store; export const persistor = persistStore(store); // 작성된 persistor은 index.tsx에서 사용된다.   4. index.tsx파일에 적용시키기   // index.tsx  const root = ReactDOM.createRoot(   document.getElementById(\"root\") as HTMLElement ); root.render(   &lt;Provider store={store}&gt;     &lt;PersistGate loading={null} persistor={persistor}&gt;       &lt;ThemeProvider theme={theme}&gt;         &lt;GlobalStyle /&gt;         &lt;Page&gt;           &lt;App /&gt;         &lt;/Page&gt;       &lt;/ThemeProvider&gt;     &lt;/PersistGate&gt;   &lt;/Provider&gt; );   5. 결과   이렇게 모든 과정을 거치면    localStorage에 persist:root라는 이름의 키로 값이 저장된 것을 확인할 수 있습니다.      logger에도 반영되어 console창에서도 확인할 수 있습니다.   REHYDRATE과정에서 storage에 저장된 값을 가져와 state로 설정합니다.   📄 storage에 있는 데이터 삭제하기   브라우저를 완전히 떠났을 때 데이터가 남아있으면 안되므로 로그아웃시 locas Storage에 저장된 state들을 삭제해 주었습니다.   const onClickLogout = async () =&gt; {   await persistor.purge();   navigator(\"/signin\");   removeToken(); };   참조      GROWNFRESH-Redux-Persist  ","categories": ["React"],
        "tags": ["Redux-Persist"],
        "url": "/react/react-Redux-Persist/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.   GitHub TIL레포에 공부내용을 기록해왔는데 이 블로그로 모든 내용을 옮겨야 한다.   내용이 꽤 많지만 전체적으로 한번씩 읽으면서 복습한다고 생각하고 여유롭게 이사해야겠다.   TIL 레포에서 GitHub 블로그로 이사하는 이유   우선, github 레포에서 보는 md파일은 가독성이 좋지 않다. 글씨의 크기나 간격이 편하게 읽기 좋은 정도는 아니다. 가장 큰 이유는 내가 지속적으로 관리하는 페이지를 가지고 싶었다. 이 블로그에 공부기록도 하지만 이외에 다양한 주제를 가지고 나를 표현하는 웹 사이트로 성장시킬 예정이다.  ","categories": ["일상"],
        "tags": ["Blog"],
        "url": "/%EC%9D%BC%EC%83%81/first-post/",
        "teaser": null
      },{
        "title": "완주하지 못한 선수",
        "excerpt":"문제 📖   수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.   마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.      마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.   completion의 길이는 participant의 길이보다 1 작습니다.   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.   참가자 중에는 동명이인이 있을 수 있습니다.   나의 풀이 #1 🙋‍♀️   function solution(participant, completion) {   const setParticipant = new Set(participant); // 1   if (setParticipant.size &lt; participant.length) {     // 2     const notCompletion = participant.filter((item) =&gt; {       if (setParticipant.has(item)) {         setParticipant.delete(item);       } else {         return item;       }     });     return notCompletion[0];   }   const answer = participant.filter((person) =&gt; !completion.includes(person)); // 3   return answer[0]; }      Set객체를 사용해서 participant 중복요소를 제거한다.   중복요소를 제거한 participant 객체(setParticipant)의 크기가 participant보다 작다면, 동명이인이 있다는 뜻이므로 filter함수를 사용해 완주하지 못한 선수의 이름을 구한다.   동명이인이 없는 경우 바로 완주하지 못한 선수의 이름을 구한다.   이 코드를 제출하며 정확성 체크는 통과하지만 효율성 체크는 통과하지 못한다.   효율성까지 테스트하는 문제는 처음이라 시간이 좀 걸려서 코드를 고쳤다.   나의 풀이 #2 🙋‍♀️   function solution(participant, completion) {   const sortedParticipant = participant.sort(); // 1   const sortedCompletion = completion.sort();    for (let i = 0; i &lt; sortedParticipant.length; i++) {     // 2     if (sortedParticipant[i] !== sortedCompletion[i]) {       // 3       return sortedParticipant[i];       break;     }   } }      참가자 배열과 완주자 배열의 문자열을 abc차순으로 정리한다.   for문을 사용해서 참가자 수만큼 반복문을 실행한다.   순차가 정리된 배열끼리 이름을 비교하게 되고, 이름이 같지 않으면 해당 이름을 정답으로 제출한다.   효율성 체크는 수행 시간과 메모리를 기준으로 평가된다.   코드의 시간복잡도와 저장된 메모리를 고려해야 통과할 수 있다.   반복문을 사용하는 경우에는 원하는 값이 도출되었을 때, 바로 반복문을 종료시킬 수 있어야 효율성이 증가한다.   그런면에서 배열에 for...in을 사용하는 것은 좋지 않다.   for...in은 모든 값을 조회해 효율성을 떨어뜨리기 때문이다.   Best Practice 👍   function solution(participant, completion) {   const map = new Map(); // 1    for (let i = 0; i &lt; participant.length; i++) {     let a = participant[i],       b = completion[i];      map.set(a, (map.get(a) || 0) + 1); // 2     map.set(b, (map.get(b) || 0) - 1); // 3   } // 4    for (let [k, v] of map) {     // 5     if (v &gt; 0) return k;   }    return \"nothing\"; }   해시의 컨셉을 정확히 접목시킨 풀이이다.   해시의 개념은 알고 있었지만 프로그래머스에서 이렇게 접목시킬 생각은 못했다.      우선 Map객체를 생성한다.   참가자 수만큼 반복문을 돌려 map에 키는 참가자 이름으로, 값은 기존에 1을 더해준다.   map에 완주자 이름의 키에 해당되는 값을 -1만큼 빼준다.   처음 for문을 나온 map의 키는 참가자이름이고 값은 0 또는 1이 된다.   완주하지 못한 참가자는 1의 값을 가지고 있으므로 해당 key의 값을 답으로 제출한다.   동명이인이 있을 경우에는 해당 이름의 값에 두번 1이 더해지고 한번 1이 빼지므로 마찬가지로 1이 된다.   풀이를 정리하자면 다음과 같게 된다.      sort로 풀면 O(NlogN)의 시간이 걸리지만 해시로 풀면 O(N)의 시간 복잡도를 가진다.   다음 해시 문제를 풀때는 꼭 Map을 사용해서 답을 낼 것이다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","완주하지 못한 선수","해시"],
        "url": "/programmers-lv1/programmers-notcolpletedplayer/",
        "teaser": null
      },{
        "title": "[자료구조] 해시(Hash) by JS",
        "excerpt":"📄 해시(Hash)      해시는 (Key, Value)로 데이터를 저장하는 자료구조입니다.   주어진 데이터를 해시함수에 적용하면 데이터를 기반으로 key를 만들어 해시 테이블에 저장합니다.   해시 함수는 똑같은 데이터들을 똑같이분류하는 기능을 담당합니다.   📄 장점   인덱스를 통한 검색이 이루어져 속도가 빠르다는 장점을 가지고 있습니다.   검색이 상수시간에 이루어지므로 O(1)의 시간복잡도를 가집니다.   📄 자바스크립트로 해시 함수 구현하기   function hashStringToInt(s, tableSize) {   let hash = 17;    for (let i = 0; i &lt; s.length; i++) {     // 인덱스의 크기가 커질 경우를 대비해 tableSize로 나눈 값을 쓴다.     hash = (13 * hash * s.charCodeAt(i)) % tableSize;   }   return hash; }  class HashTable {   table = new Array(100); // 크기가 100인 Hash Table    setItem = (key, value) =&gt; {     const index = hashStringToInt(key, this.table.length);     this.table[index] = value;   };    getItem = (key) =&gt; {     const index = hashStringToInt(key, this.table.length);     return this.table[index];   }; }   📄 해시 충돌   해시 충돌은 같은 인덱스에 데이터들이 들어오는 현상입니다.   ▪ 대처 방법   ✔ Separate Caining   해당 인덱스의 value에 배열이나 연결리스트를 사용해 값을 중첩으로 저장하는 방법입니다.   setItem = (key, value) =&gt; {   const idx = hashStringToInt(key, this.table.length);   if (this.table[idx]) {     this.table[idx].push([key, value]);   } else {     this.table[idx] = [[key, value]];   } };  getItem = (key) =&gt; {   const idx = hashStringToInt(key, this.table.length);   if (!this.table[idx]) return null;    // O(n)   return this.table[idx].find((el) =&gt; el[0] === key)[1]; };   ✔ Linear Probing   선형 탐색 데이터는 다음 버켓(인덱스)자리에 밀어넣는 방법입니다.   이 방법을 사용하면 최대 테이블 길이만큼만 저장할 수 있다는 단점이 있습니다.   ✔ Resizing   테이블의 크기를 늘린 후 전체 데이터를 재정렬한다.   테이블의 길이가 데이터의 크기에 따라 늘어난다는 특징을 가지고 있습니다.   function hashStringToInt(s, tableSize) {   let hash = 17;    for (let i = 0; i &lt; s.length; i++) {     hash = (13 * hash * s.charCodeAt(i)) % tableSize;   }   return hash; }  class HashTable {   table = new Array(3);   numItems = 0;    // resizing   resize = () =&gt; {     const newTable = new Array(this.table.length * 2);      // 새로 만들어진 해시테이블의 모든 요소 재정렬     this.table.forEach((item) =&gt; {       if (item) {         item.forEach(([key, value]) =&gt; {           const idx = hashStringToInt(key, newTable.length);           if (newTable[idx]) {             newTable[idx].push([key, value]);           } else {             newTable[idx] = [[key, value]];           }         });       }     });     this.table = newTable;   };    setItem = (key, value) =&gt; {     this.numItems++;      const loadFactor = this.numItems / this.table.length;     if (loadFactor &gt;= 0.8) {       // 해시 테이블이 80%이상 차있으면 재정렬한다.       this.resize();     }      const idx = hashStringToInt(key, this.table.length);     if (this.table[idx]) {       this.table[idx].push([key, value]);     } else {       this.table[idx] = [[key, value]];     }   }; }   참고           업비트 투자자보호센터            노마드 코더 - 개발자라면 꼭 알아야할 Hash table의 모든 것!      ","categories": ["structure"],
        "tags": ["자료구조","해시"],
        "url": "/structure/structure-hash/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 사용자 폼 관련 Slice 리팩토링 (state 객체로 관리하기)",
        "excerpt":"❔ 리팩토링 이유   좋은 코드는 코드만 보고 어떤 일을 하는지 알 수 있는 코드라고 배웠다.   하지만 나의 코드는 코드만 보고 무슨일을 하는 지 알 수 없었다.   기존의 MemberForm 데이터 구조   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   value: [     { key: \"imageFile\", value: null, isValidate: true },     { key: \"username\", value: \"\", isValidate: false, emailAuth: false },     { key: \"email\", value: \"\", isValidate: false },     { key: \"password\", value: \"\", isValidate: false },   ], };   데이터 구조가 이렇게 되어있으면 값에 접근할 때 값의 이름이 아니라 index로 접근해야 했다.   처음 프로젝트를 시작할때 File 타입에 null이 할당되지 않아 객체 안에 굳이 key라는 이름의 key를 생성했다.   imageFile: File: null; // error   아마 내가 ‘imageFile’의 타입을 오로지 File로만 했던 모양인데 시간이 지나고 보니 코드가 굉장히 가독성이 없다는 것이 보였다.   💾 Components/SignUpForm   const result: UserParam = {   imageFile: userData[0].value,   username: userData[1].value!,   email: userData[2].value!,   password: userData[3].value!, };   userData에 index로 접근하기 때문에 해당 변수가 어떤 값을 가지고 있는지 알 수 없다.   이를 고치기 위해선 memberForm의 state 구조를 변경해야 했다.   ❕ 리팩토링 결과   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   memberForm: {     imageFile: null,     username: \"\",     email: \"\",     password: \"\",   } as Omit&lt;MemberFormParam, \"profileUrl\" &amp; \"imageUrl\"&gt;,   emailAuth: false,   isEditMode: false, };   💾 Components/SignUpForm   const result: UserParam = {   imageFile: memberForm.imageFile,   username: memberForm.username,   email: memberForm.email,   password: memberForm.password, };   값에 이름으로 접근하니 어떤 데이터가 할당되는지 알 수 있게 되었다.   💬 나의 생각   분명 코드를 작성할 때는 최선인 것 같았는데 지나고 보니 아닌 경우가 꽤 많다.   완성된 프로젝트라 하더라도 다시 보고 리팩토링을 계속 해주는 것이 좋겠다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","redux-toolkit","데이터구조"],
        "url": "/coding-swamp/projects-coding-swamp/",
        "teaser": null
      },{
        "title": "논리 연산자를 이용한 조건문",
        "excerpt":"📄 논리 연산자를 이용한 조건문   조건문은 계산식뿐만 아니라 논리연산자를 이용해 완성할 수 있습니다.   📄 표현식 &amp;&amp; 표현식   &amp;&amp;는 and연산자로 불리며 조건 중 하나라도 거짓일 경우 거짓이 됩니다.   if (true &amp;&amp; true) {   console.log(\"두개 모두 참이면 참\"); }  if (true &amp;&amp; false) {   console.log(\"한개만 참이면 거짓\"); }  if (false &amp;&amp; false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 표현식 || 표현식   ||는 &amp;&amp;OR연산자**로 둘중 하나만 참이면 참이 됩니다.   if (true || true) {   console.log(\"두개 모두 참이면 참\"); }  if (true || false) {   console.log(\"한개만 참이면 참\"); }  if (false || false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 !표현식   !는 NOT연산자로 반대의 결과값을 출력합니다.   if (!true) {   console.log(\"참이면 거짓\"); // 거짓이므로 출력되지 않음. }  if (!false) {   console.log(\"거짓이면 참\"); }   결과      📄 논리연산자를 이용한 조건부 실행   표현식은 앞을 먼저 평가하고 뒤를 평가합니다.   앞 표현식을 평가를 해서 참 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤의 표현식이 실행됩니다.   n % 5;  // 앞이 참이기 때문에 뒤가 실행이 되지 않음. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");  n = 6;  // 앞이 거짓이기 때문에 뒤가 실행됨. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");   결과    📄 논리연산자 우선순위   논리연산자에는 우선순위가 있습니다.   NOT(!) &gt; AND(&amp;&amp;) &gt; OR(||) 순으로 NOT연산자가 제일 먼저 실행됩니다.   const value = !((true &amp;&amp; false) || (true &amp;&amp; false) || !false);   세가지 논리연산자가 동시에 쓰였지만,   우선순위가 적용되어 value는 false라는 값을 가지게 됩니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","논리연산자"],
        "url": "/javascript/javascript-logical-operator/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] useState 비동기 에러 처리하기",
        "excerpt":"🐞 문제발생   사용자의 프로필을 수정하는 과정에서 useState를 사용해 form을 변경하는데, state가 업데이트 되지 않았다.   ▪ 문제 코드    ... const initialEditForm = {   profileUrl: '',   imageFile: null,   username: '',   imageUrl: '', }  const [memberForm, setMemberForm] = useState(initialEditForm)  ...  const onChangeProfileImg = useCallback(     async (e: ChangeEvent&lt;HTMLElement&gt;) =&gt; {       const ImageFiles = (e.target as HTMLInputElement).files       if (ImageFiles &amp;&amp; ImageFiles[0]) {         const url = URL.createObjectURL(ImageFiles[0])         setMemberForm({ ...memberForm, imageFile: ImageFiles[0] }) // 문제부분         setMemberForm({ ...memberForm, imageUrl: url })       }     },     [imgInputRef],   )    이 부분을 해결하려고 imageFile만 담는 state를 생성했을 때는 값이 바뀌는 것을 확인했는데, 도대체 왜 처음 작성했던 코드에서는 state가 변경되지 않는지 너무 궁금해서 꽤 오래 코드를 수정하고 손봤다.   그래도 해결이 안되서 오키에 질문글을 작성하고 이유를 알 수 있었다.   🔨 문제해결   문제는 useState의 비동기 처리 방식이었다.   useState가 비동기로 동작한다는 것을 어렴풋이 알고있었지만 어떻게 처리가 진행되는지 몰라서 문제가 어디서 발생했는지 정확히 모르고 애먼 코드들만 뜯어보고 답답해했다.  왜 imageUrl은 변경이 적용되고 첫번째 setState를 호출해서 적용한 imageFile은 변경이 안될까?   💡 useState는 비동기적으로 처리가 진행되기 때문에 useState를 두번 호출할 때, 마지막 호출시 처음 state의 변경분은 반영되지 않기 때문이다!   리액트는 성능을 최적화하기 위해 setState가 연속 호출되면 배치처리를 통해 한번에 렌더링한다고 한다.      배치(batch)란? 리액트가 여러개의 state 업데이트를 하나의 리렌더링으로 묶는 것    따라서, 위 코드에서 문제가 발생한 이유는 기존 memberForm에 imageFile이 더해진 상태로 변경된 것이 state에 적용되기 전에 다시 memberForm을 재사용하기 때문에 imageFile에 관한 변경사항이 적용되지 않고 imageUrl이 더해진 값으로 state가 적용되기 때문이었던 것이다.   ▪ 변경된 코드   setMemberForm({ ...memberForm, imageFile: ..., imageUrl: url })   setState를 한번만 호출해서 비동기 상황을 발생시키지 않게 고쳤고, 문제는 해결되었다.  비동기에 관한 삽질은 api통신을 할 때만 생길줄 알았던 내 안일한 생각이 가장 큰 문제였다.  안다고 다 아는게 아니라는 것을 다시 한번 뇌에 새기게 되었다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","useState","비동기"],
        "url": "/coding-swamp/projects-codingswamp-useState-asynchronous/",
        "teaser": null
      },{
        "title": "tsconfig.json 파일 살펴보기",
        "excerpt":"📄 tsconfig.json 파일이란?  tsconfig.json 파일은 타입스크립트 프로젝트에서 타입스크립트에 관한 환경설정을 할 수 있는 타입스크립트 컴파일러 설정파일입니다.   📄 tsconfig.json 파일에서 사용하는 옵션   tsconfig.json 파일에는 다양한 옵션이 있지만, 자주 사용되는 옵션을 정리했습니다.   {   \"compilerOptions\": {     \"module\" :\"CommonJS\",     \"target\": \"es5\",       \"esModuleInterop\": true,                                 \"moduleResolution\": \"node\",                               \"outDir\": \"dist\",     \"baseUrl\": \".\",     \"sourceMap\": true,     \"downlevelIteration\": true,     \"noImplicitAny\": false,     \"paths\": {\"*\": [\"node_modules/*\"]}                                  },   \"include\": [\"src/**/*\"] }       include: 타입스크립트 컴파일러 대상이 되는 경로   ▪ module 키     컴파일된 ES5 자바스크립트 코드는 웹브라우저와 노드제이에스에서 양쪽에서 동작해야 한다.   하지만, 웹브라우저와 노드제이에스는 동작방식이 다르다. (웹 브라우저: amd, 노드제이에스: commonjs )   따라서, module키로 동작 대상 플랫폼이 무엇인지 구분해주는 역할을 한다.   ▪ moduleResolution 키     moduule이 어떤 값을 가지느냐에 따라 다르게 설정된다.   commonjs는 node로 설정하고, amd는 classic으로 설정한다.   ▪ target 키     트랜스파일할 대상 자바스크립트의 버전을 설정한다.   보통 es5를 설정한다.   ▪ baseUrl &amp; OutDir 키     트랜스파일된 자바스크립트 파일을 저장하는 경로   OutDir은 baseUrl 설정값을 기준으로 하위 디렉토리를 뜻한다.   ▪ paths 키     소스 파일의 import 문에서 from 부분을 해석할 때 찾아야 하는 디렉토리를 설정한다.   node-module을 포함한 이유는 찾아야하는 소스가 외부 패키지일 경우를 위해 설정한 것이다.   ▪ esModuleInterop 키     웹 브라우저에서 동작한다는 가정으로 만들어진 오픈소스 자바스크립트 라이브러리가 CommonJS방식으로 동작하는 타입스크립트 코드에서 실행될 수 있도록 설정   ▪ sourceMap 키     소스맵 파일 생성 유무를 설정한다.   소스맵 파일에는 변환된 자바스크립트 코드가 타입스크립트 코드의 어느 부분에 해당하는지 보여준다.   ▪ downlevelIteration 키     타입스크립트의 생성기(generator) 구문이 정상적으로 동작하도록 설정   ▪ nolmplicitAny 키     지정하지 않은 타입을 암시적으로 any로 설정하게 한다.   false로 설정하면 타입을 지정하지 않았을 때, 에러메세지가 표시되지 않고 넘어간다.   참고      Do It 타입스크립트 프로그래밍 (책)  ","categories": ["TypeScript"],
        "tags": ["tsconfig"],
        "url": "/typescript/typescript-tsconfig/",
        "teaser": null
      },{
        "title": "[Leaning Typescript 🦜] system of a clown",
        "excerpt":"🤡 system of a clown      🎈 Help me, please!  I planned an elaborate clown-themed surprise party for my best friend. The whole event was planned using a few files of TypeScript code I’d written.  My friend somehow caught wind of the party and enlisted the clowns’ help to vandalize the program. Not only did the clowns remove or make incorrect my TypeScript type annotations, they introduced subtle bugs by subtly changing some of the values.  Could you please add correct type annotations in my files and fix any bugs detected by TypeScript? You’re my surprise clown celebration’s last hope! 🤡    🎈 도와주라주!  내 베프를 위해 삐에로 컨셉의 깜짝 파티를 준비했어. 모든 이벤트가 내가 쓴 몇개의 타입스크립트 파일로 준비되어 있지.  근데 내 친구가 어떻게든 정보를 들어가지고 프로그램을 파괴하기 위해 삐에로들한테 도움을 요청한거야! 삐에로들은 내 타입스크립트 애너테이션을 지우고 망가뜨리는것 뿐만 아니라, 일부 값들을 교묘하게 바꿔버리며 버그마저 도입해버렸어.  내 파일에 올바른 애너테이션을 추가하고 버그를 잡아줄 수 있어? 너는 내 깜짝 삐에로 파티의 마지막 희망이야! 🤡      타입 애너테이션 (type annotation)? 타입에 주석을 다는 것으로 변수나 함수의 타입을 설정하는 것.  ex) let name: string = ‘sujin’    🎈 Step 1: Clowning Around      The first area of code I’ll need you to fix is the activity assignment engine. It repeatedly creates groups of size 5-10 guests. Each group is directed to go to an activity, which can hold up to a certain number of them at a time.   It looks like the clowns didn’t change too much on this one. They mostly just removed a few type annotations and changed one value.   Could you please add back missing type annotations to avoid evolving or implicit anys, and fix the wrong value?    ▪ 요약: 액티비티 할당 엔진에서 타입 애너테이션을 추가하고 오류난 부분을 고쳐라!   📃 문제 코드   let remainingGuests = 20; while (true) {   // Each group of guests will be size 5-10   const guestsToAssign = Math.floor(Math.random() * 5) + 5;   let activity; // Those were some nice type annotations you had here!   let capacity; // It'd be a shame if we ... *erased* them! 😈   let requiresSupplies;   switch (Math.floor(Math.random() * 5)) {     case 0:       activity = \"balloon animals\";       capacity = 5;       requiresSupplies = true;       break;     case 1:       activity = \"face painting\";       capacity = \"1\";       requiresSupplies = true;       break;     case 2:       activity = \"juggling\";       capacity = 3;       requiresSupplies = true;       break;     default:       activity = \"dancing\";       capacity = 10;       break;   }   console.log(`${guestsToAssign} of us will enjoy ${activity}.`);   for (let i = 0; i &lt; guestsToAssign; i += capacity) {     console.log(`\\t${capacity} will enter the ${activity} activity.`);   }   remainingGuests -= guestsToAssign;   if (remainingGuests &lt; 0) {     break;   }   console.log(`We have ${remainingGuests} remaining guests to entertain.\\n`); } console.log(\"\\nAll done!\"); export {};   문제로 나온 이 코드를 tsc명령어를 이용해 컴파일하면 다음과 같은 오류가 발생합니다.      산술 연산자에 string값이 할당되고 있는 상황입니다.   📃 풀이 과정   오류가 난 부분을 보니, 산술 연산자에 string값이 할당되어 컴파일과정에서 막혀버렸습니다.   해당 변수 capacity를 찾습니다.   switch문안에서 문자열로 되어 있는 capacity를 찾아 숫자로 고칩니다.    case 1:       activity = \"face painting\";       // capacity = \"1\";       capacity = 1; // 수정       requiresSupplies = true;       break;   요구사항대로 변수가 선언된 부분에서 타입 애너테이션도 추가합니다.   let activity; // Those were some nice type annotations you had here! let capacity; // It'd be a shame if we ... *erased* them! 😈 let requiresSupplies;   ✔ 수정된 전체 코드   let remainingGuests = 20;  while (true) {   // Each group of guests will be size 5-10   const guestsToAssign = Math.floor(Math.random() * 5) + 5;   let activity: string; // Those were some nice type annotations you had here!   let capacity: number; // It'd be a shame if we ... *erased* them! 😈   let requiresSupplies: boolean;    switch (Math.floor(Math.random() * 5)) {     case 0:       activity = \"balloon animals\";       capacity = 5;       requiresSupplies = true;       break;     case 1:       activity = \"face painting\";       capacity = 1;       requiresSupplies = true;       break;     case 2:       activity = \"juggling\";       capacity = 3;       requiresSupplies = true;       break;     default:       activity = \"dancing\";       capacity = 10;       break;   }    console.log(`${guestsToAssign} of us will enjoy ${activity}.`);    for (let i = 0; i &lt; guestsToAssign; i += capacity) {     console.log(`\\t${capacity} will enter the ${activity} activity.`);   }    remainingGuests -= guestsToAssign;   if (remainingGuests &lt; 0) {     break;   }    console.log(`We have ${remainingGuests} remaining guests to entertain.\\n`); }  console.log(\"\\nAll done!\");  export {};   🎈 Step 2: Clown Availability      The second and -thank heavens- final area of code I’ll need you to fix is my clown assignment planner. I use this to print which clowns will be partying with which guests.   Oh, and they introduced several unsettling clown puns in comments.  It’s because of those puns that I can’t fix the code myself.  The clowns again changed a few things around, but nothing more than an incorrect type annotation or different value for a variable.  «««&lt; HEAD Could you please fix up the file to have no TypeScript complaints? x ======= Could you please fix up the file to have no TypeScript complaints?    ▪ 요약: 고마운데 일하나 더 해라! 광대 배정 플래너에서 오류를 수정해라!   📄 문제 코드   // Note: I'm planning on inviting 20 guests in total. // Some clowns can only handle a certain number of guests. let guestCount: boolean = 20; let clownsCount = \"zilch!\";  let krustyAvailability = true; let ronaldAvailability = true; let pennywiseAvailability = true;  let matchingsDescription: any = \"\"; let lastClown;  do {   clownsCount += 1;    // Krusty says: I had a one-man show on Broadway...   // That's who showed up, one man!   if (krustyAvailability) {     guestCount -= 10;     krustyAvailability = false;     matchingsDescription += \"Krusty will handle the first ten guests.\\n\";     lastClown = \"Krusty\";     continue;   }    // Ronald says: McDonald's donated a large set of computers to a school...   // They were all Big Macs!   if (ronaldAvailability) {     guestCount -= 5;     ronaldAvailability = false;     matchingsDescription += \"Ronald will handle the next five guests.\\n\";     lastClown = \"Ronald\";     continue;   }    // Pennywise asks: what's a sewer's favorite data type?   // Pennywise answers: Floats!   if (pennywiseAvailability) {     pennywiseAvailability = false;     matchingsDescription += \"Pennywise w̺̞̠i̢͇͙l͇̞l͇͍̘ c͓͕̝o̡̠̞n̼̝s̡̞͎u͉̝͔m͚̪̞e̢͚̝ y̴̡̡͕͌̿́ó̸̢͇͚̾̕u̸̡̡͎͒͛r̸͕͓͖̈́͆͒ s̵̺̘̪͒͆̓o̵̡͚̟̽͆̚u̵̠͖̓͐͝l̸͓̘͇̐̓̚s̸̺͎̽̈́͆.\";     lastClown = \"Pennywise\";     continue;   }    throw new Error(`Oh no! We're out of clowns!`); } while (guestCount &gt; 0);  if (clownsCount &gt; 2) {   console.log(\"We've got a lot of clowns coming!\"); }  if (matchingsDescription.length()) {   console.log(`There will be ${clownsCount} clowns!\\n`);   clownsole.log(matchingsDescription);   console.log(`The last clown is: ${lastClown.toUpperCase()}!`); } else {   console.log(\"Nobody gets a clown. Terrible party. Goodbye.\"); }  export {};   1번 문제보다 많은 오류가 발생했습니다.      📄 풀이과정   ▪ Type 'number' is not assignable to type 'boolean'.   guestCount의 타입이 number인데 boolean으로 타입 애너테이션 설정이 잘못되어 있습니다.   // 문제 코드 let guestCount: boolean = 20;  // 수정된 코드 let guestCount: number = 20;    ▪  Operator '&gt;' cannot be applied types 'string' and 'number'.   clownCount에 산술연산자를 사용하고 있는데 선언부에 보면 문자열을 할당하고 있습니다.   zilch가 무슨 뜻인지 찾아보니 아무것도 없음이라는 뜻이라 값을 할당하지 않았습니다.   let으로 선언되었기 때문에 가능합니다.   // 문제 코드 let clownsCount = \"zilch!\"; ... if (clownsCount &gt; 2) { \tconsole.log(\"We've got a lot of clowns coming!\"); }  // 수정된 코드 let clownCount;      새로운 에러를 만들며 해결되지 않았습니다.   값이 할당되기 전에 산술연산자를 적용할 수 없기 때문입니다.   초기값으로 0을 할당해주었지만, 뭔가 답이 아닐것만 같은 느낌이 드네요.   // 수정된 코드 let clownCount: number = 0;   ▪ Cannot find name 'clownsole'. Did  you mean 'console'?   clownsole은 처음 들어봅니다. 문제가 저를 바보로 아나봅니다. 재밌네요.   // 문제 코드 clownsole.log(matchingsDescription);  // 수정된 코드 let clownCount: number = 0; console.log(matchingsDescription);   끝!   Found 0 errors. Watching for file changes.   📄 고쳐야 할 점   let guestCount = 20; let clownsCount = 0;   솔루션 코드를 보니 타입 애너테이션이 빠져있습니다.   책을 읽을 때 값을 할당할 경우 자동으로 타입추론이 되기 때문에 타입 애너테이션을 설정하면 중복으로 타입설정과정이 진행되는 것과 마찬가지라 불필요한 과정이라고 한 기억이 납니다.   ✔ 값을 할당해 타입추론이 될 경우에는, 타입 애너테이션을 생략하자   그래도 0을 할당하는게 맞았네요 🎉     문제 출처      learning typescript  ","categories": ["TypeScript"],
        "tags": ["learning typescript","러닝 타입스크립트","type system","clowning around"],
        "url": "/typescript/typescript-learning-typescript-clowning-around/",
        "teaser": "/assets%5Cimage%5Clearning-typescript.PNG"
      },{
        "title": "🍸 칵테일 러브 좀비",
        "excerpt":"   ▪ 제목: 칵테일, 러브, 좀비  ▪ 작가: 조예은  ▪ 출판사: 안전가옥  ▪ 독서 기간: ? ~ 2023/03/16  ▪ 읽은 방식: 전자책     칵테일, 러브, 좀비는 4개의 단편소설로 구성된 한국 미스터리소설이다. 반전과 미스테리를 좋아하는 독자라면 필수로 읽어야 하는 작품집이라 생각한다. 그만큼 유명하기도 하다.   수록된 작품 중 가장 인상깊었던 작품을 고르자면 습지와 오버랩 나이프, 나이프라 할 수 있겠는데 이유는 서로 다르다.   습지는 귀신이 나오지만 무섭지 않다. 오히려 긴장감 넘치는 책 분위기 속에서 살짝 긴장을 풀고 차분하게 읽을 수 있는 분위기를 풍기는 내용이다. 미스테리 스릴러 소설이라고 무조건 빠른 호흡과 높은 텐션이 필수일 필요가 없다는 점을 새로이 알게 해준 작품이다.   이에 반해 오버랩 나이프, 나이프는 읽는 내내 책 종이가 넘어가는게 아까울 정도로 빠져들었다. 이때 혼자 카페에 앉아 책을 읽었는데 반전을 맞이할 때마다 표정관리하느라 꽤나 힘들었다. 조예은 작가님의 작품은 스토리가 흔하지 않고 결말이 뻔하지 않다. 작품의 제목조차 처음에는 어떤 뜻인지 알 수 없다. 오버랩 나이프, 나이프. 어떤 내용이 전개될지 도통 알기 힘들다. 작품을 다 읽고 다시 제목을 보았을 때 제목에서 다 알려주고 있다는걸 깨닫고는 무언가 당해버린 기분이 든다. 미루고 미뤘던 젤리장수 대학살도 조만간 읽어야 겠다.  ","categories": ["books"],
        "tags": ["칵테일 러브 좀비","조예은","안전가옥","추리/미스테리"],
        "url": "/books/books-cocktail-love-jombie/",
        "teaser": "/assets%5Cimage%5CPenguin.jpg"
      },{
        "title": "[Leaning Typescript 🦜] Primitive Cooking",
        "excerpt":"🥗 Primitive Cooking      Those pesky Java programmers are at it again!  I wrote a few functions for a friend to help arrange meals when I have guests over. The friend worked with their enterprise application development team to “improve” the code. Next thing I know, they’ve replaced all my TypeScript-y literal and union types with plain old primitive types.  Those Java fans are perfectly good developers -and lovely people- but we don’t see eye-to-eye on type systems. Now TypeScript is reporting type errors on my code. Could you please correct the type annotations in my files – and maybe a couple bugs the improved types helped TypeScript find?    성가신 자바 프로그래머들이 또 시작이야!  나는 친구를 위해 손님들이 왔을 때 식사 준비를 도와줄 수 있도록 몇개의 기능을 작성했어. 친구는 코드를 ✌향상시키기 위해✌ 기업 애플리케이션 개발팀과 일해. 다음으로 내가 아는건, 그 사람들이 내 타입스크립트 코드의 리터럴과 유니언 타입을 오래된 순수 원시 타입으로 바꿨다는 거야.(읽기만 해도 열받음)  이 자바 팬들은 완전 좋은 개발자들이야(게다가 사랑스러움). 하지만 우린(자바와 자바스크립트) 타입 시스템이 일치하지 않잖아. 지금 타입스크립트가 내 코드에서 타입 에러들을 보고하고 있거든. 내 파일들에서 타입 애너테이션들을 올바르게 고쳐줄래?   🍽 Step 1: Ingredients      The first area of code I’ll need you to fix is my ingredients planner. I use this to print what kind of salad greens and dressings to use for meals.  Again, the runtime code is working fine. It’s just the type annotations you’ll need to correct.    ▪ 요약: 샐러드 야채와 드레싱 재료 플래너의 타입 애너테이션을 고쳐라!   📄 문제 코드   // Please correct any type annotation problems here! ✨ let arugula: number; let dressing: string; let lettuce: number; let mealDate: string;  arugula = 2; dressing = \"honey dijon\"; lettuce = undefined; mealDate = new Date(\"September 13, 2021\");  console.log(`We're starting on ${mealDate} with a dressing of ${dressing}.`);  if (arugula) {   console.log(`There are ${arugula} arugula serving(s) for this first meal.`); }  if (lettuce) {   console.log(`There are ${lettuce} lettuce serving(s) for this first meal.`); }  arugula = undefined; dressing = \"balsamic vinaigrette\"; lettuce = 1; mealDate = new Date(\"March 13, 2022\");  console.log(`Next up, a ${mealDate} meal with a dressing of ${dressing}.`);  if (arugula) {   console.log(`This time, there are ${arugula} arugula serving(s).`); }  if (lettuce) {   console.log(`This time, there are ${lettuce} lettuce serving(s).`); }  export {};   코드를 컴파일 하면 다음과 같은 에러가 발생합니다.      📄 풀이 과정   에러 메시지를 보고 변수 선언부에서 유니언 타입으로 타입을 확장해주었습니다.   let arugula: number | undefined; let dressing: string; let lettuce: number | undefined; let mealDate: string | Date;   정답 코드를 보니 고쳐야할 점이 있습니다.   let mealDate: Date;   변수 mealDate는 하나의 타입만 사용합니다.  따라서 유니언 타입을 통해 타입을 확장하는게 아니라, 타입 애너테이션에서 타입을 수정해주면 되는 것이었습니다.  낚였습니다.   🍽 Step 2: Recipes      Those salad ingredients are looking delectable, thank you! Next up is my list of favorite recipes.  It looks like these seem to pass the TypeScript compiler fine as-is. However, there’s a catch: I want to make sure future recipes keep to the same difficulty and group types. Could you please use unions of literal types for them? Both should only have three possible values.  This time, the runtime code is mostly working fine. Except I think I made a typo in one of the group values? You’ll need to fix that. Otherwise it’s just the type annotations you’ll need to correct.    ▪ 요약: 샐러드는 이제 되었으니, 미래의 요리법(?)이 동일한 난이도와 그룹 타입을 갖도록 리터럴 유니언 타입을 사용해라!      작성되는 유니언 타입은 세개의 타입으로 구성됩니다.   📄 문제 코드   이번 문제는 문제 코드를 컴파일해도 에러가 발생하지 않습니다.   목적은 에러 해결이 아닌, 유니언 타입을 사용한 코드 리팩토링입니다.   // Please clarify any overly wide (permissive) type annotations here! ✨ let difficulty: number; let group: string; let title: string;  // Start with something quick and painless to prepare... difficulty = 1; group = \"appetizer\"; title = \"Raspberry Vinaigrette Salad\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  // Next up, a nice hearty dish to center the meal... difficulty = 2; group = \"entree\"; title = \"Cauliflower Steaks\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  // Make a real impact with fancy delectable desserts... difficulty = 3; group = \"dessert\"; title = \"Coconut Chocolate Ganache\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  // Send everyone off with a nice closer. difficulty = 1; group = \"desert\"; title = \"Biscuits and Coffee\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  export {};   📄 풀이 과정   정해진 값을 사용하는 변수는 difficulty와 group으로 보입니다.   이 변수들이 사용하는 값을 리터럴 타입으로 사용해서 유니언 타입으로 타입을 구체화 시켜보겠습니다.   let difficulty: 1 | 2 | 3; let group: \"appetizer\" | \"entree\" | \"dessert\"; let title: string;   유니언 타입을 작성하다보니 문제 제공자의 오타가 보입니다.   설마 레시피에 ‘desert(사막)`를 뜻하는 단어를 사용하진 않을 것 같은데요.   정답 코드에는 dessert로 올바르게 작성되어 있습니다.   너무 사소한 실수라 해당 레포에 pr를 날려볼까 고민하다 어떤 사람은 a하나로도 pr를 작성하길래 pr를 작성해보기로 결심했습니다.   아니면 조슈아 골든버그씨가 말해주겠죠.   🖇 인생 처음 오픈소스 PR   🍽 Step3: Seating      You’re doing wonderfully, my friend. I can’t wait to invite you to my next fancy dinner party.  Speaking of which, I need to properly type the program to randomize invitations and seat assignments. My friends can be kind of childish -they’re babies, really- and are very picky about seating.  I also very much like what you did with the string literal union types in the last step. Could you please avoid using the string type altogether in this one? Just use literal types.  Oh, and I think there’s a typo in one of the names here too.    ▪ 요약: 저번 step에서 네가 만든 string 리터럴 유니언 타입 맘에 들었어. 이번엔 string타입을 사용하지말고 리터럴 타입만 사용해서 타입을 완성시켜봐라!   📄 문제 코드   // Please fill in any missing type annotations here... const headOfTable = \"Me!\"; let adjacentLeft; let adjacentRight; let furtherLeft; let furtherRight;  // I always invite Susie and Tommy! ♥ if (Math.random() &gt; 0.5) {   adjacentLeft = \"Susie\";   adjacentRight = \"Tommy\"; } else {   adjacentLeft = \"Tommy\";   adjacentRight = \"Susie\"; }  // I invite Angelica about half of the time. We're not as close as Susie and Tommy. It's a long story. // I try to fill `furtherLeft` first... if (Math.random() &gt; 0.5) {   furtherLeft = \"Angelica\"; }  // Same with Chuckie. I like them, but do I *really* like hanging out with them? Only sometimes. // ...then after that `furtherRight` if (Math.random() &gt; 0.5) {   if (furtherLeft) {     furtherRight = \"Chuckie\";   } else {     furtherLeft = \"Chuckie\";   } }  // If I invited Angelica but not Chuckie, I'll invite Kimi. They get along well with Angelica but not Chuckie. if (furtherLeft === \"Angelica\" &amp;&amp; furtherRight !== \"Chuckie\") {   furtherRight = \"Kimi\"; }  // If I invited Chuckie but not Angelica, I'll invite Timmy. They get along well with Chuckie but not Angelica. if (furtherLeft === \"Chuckie\") {   furtherRight = \"Timmy\"; }  console.log(`At the head of the table is... ${headOfTable}`);  console.log(`Adjacent to the left is: ${adjacentLeft}`); console.log(`Adjacent to the right is: ${adjacentRight}`);  console.log(`Further down on the left is: ${adjacentLeft ?? \"nobody\"}`); console.log(`Further down on the right is: ${adjacentRight ?? \"nobody\"}`);  export {};   📄 풀이 과정   변수 선언부를 보니 초깃값이 설정되어 있지 않아, 타입이 any로 추론되고 있습니다.   변수 선언부에서 리터럴 타입으로 각각 타입을 설정합니다.   let adjacentLeft: \"Susie\" | \"Tommy\"; let adjacentRight: \"Susie\" | \"Tommy\"; let furtherLeft: \"Angelica\" | \"Chuckie\"; let furtherRight: \"Kimi\" | \"Timmy\" | \"Chuckie\";      값이 할당되기 전에 사용되어 에러를 발생시킵니다.   값이 할당되지 않은 변수를 위해 undefined 타입을 명시적으로 추가해주었습니다.   let furtherLeft: \"Angelica\" | \"Chuckie\" | undefined; let furtherRight: \"Kimi\" | \"Timmy\" | \"Chuckie\" | undefined;   문제 출처      learning typescript  ","categories": ["TypeScript"],
        "tags": ["learning typescript","러닝 타입스크립트","Primitive Cooking","유니언 타입","리터럴 타입"],
        "url": "/typescript/typescript-learning-typescript-primitive-cooking/",
        "teaser": "/assets%5Cimage%5Clearning-typescript.PNG"
      },{
        "title": "같은 숫자는 싫어",
        "excerpt":"문제 📄   배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,      arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.   arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.   배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.   나의 풀이 #1 🙋‍♀️   function solution(arr) {   return arr.filter((value, index) =&gt; value !== arr[index + 1]); }   프로그래머스 문제를 풀어보기 시작하고 처음으로 정답다운 풀이가 나온 느낌입니다.   filter함수를 사용해서 배열을 순환하며 해당 값과 바로 오른쪽의 값을 비교하며 같지 않은 값만 모아놓은 배열을 새로 생성했습니다.   마지막 값은 undefined와 비교하기 때문에 새로운 배열에 무조건 들어가게 됩니다.   나의 풀이 #2 🙋‍♀️   문제를 보고 바로 filter함수를 사용하면 되겠다 싶었는데 문제 옆에 스택/큐라고 쓰여 있어 스택 큐를 떠올리며 다시 풀어봤습니다.   function solution(arr) {   let answer = []; // 1   for (let i = 0; i &lt; arr.length; i++) {     arr[i] === arr[i + 1] ? \"\" : answer.push(arr[i]); // 2   }   return answer; }      정답에 해당하는 값만 담을 새로운 배열 answer을 생성합니다.   반복문을 돌려 해당 값과 오른쪽의 값을 비교하여 값이 다른 경우에만 새로운 배열(answer)에 담아 반환해줍니다.   Best Practice 👍   function solution(arr) {   var answer = [arr[0]];    for (let i = 1; i &lt; arr.length; i++) {     if (answer[answer.length - 1] !== arr[i]) {       answer.push(arr[i]);     }   }    return answer; }   다른 분의 풀이를 보니 비교한 값이 다른 경우만 생각해도 된다는 것을 알았습니다.   굳이 제 풀이처럼 삼항연산자를 쓰지 않아도 되는 것이었습니다.   왠지 삼항연산자에 집착이 생겨버려 자꾸 쓰게 되네요.   불필요한 습관을 버려야겠습니다.   문제 출처  ","categories": ["programmers-lv1"],
        "tags": ["filter","스택","큐"],
        "url": "/programmers-lv1/programmers-I-don't-want-the-same-number/",
        "teaser": null
      },{
        "title": "가운데 글자 가져오기",
        "excerpt":"문제 📖   단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.      s는 길이가 1 이상, 100이하인 스트링입니다.   🙋‍♀️ 나의 풀이   function solution(s) {   const stringToArray = [...s]; // 1   const target = s.length / 2; // 2    if (s.length % 2 === 0) {     // 3     return stringToArray[target - 1] + stringToArray[target];   }    return stringToArray[Math.floor(target)]; // 4 }      문자열을 배열(stringToArray)로 바꾼다.   배열의 크기를 2로 나눈 수(target)를 구한다.   stringToArray가 짝수면 target과 직전의 값을 인덱스로 하는 값을 함께 반환한다.   아니면 target을 반내림해서 하나의 값만 반환한다.   이번 문제는 간단해서 1분도 안되어 풀었지만, 오히려 이런 문제에서 고수는 드러나기 마련입니다.   그리고 당연하게도 저는 아직 초보자임이 들통나버립니다.   🔨 Best Practice   function solution(s) {   return s.substr(Math.ceil(s.length / 2) - 1, s.length % 2 === 0 ? 2 : 1); }   왜 삼항연산자를 사용할 생각을 못했을까요.   새로운 subString()이라는 자바스크립트 문법을 하나 알아갑니다.   📌 substr이라는 자바스크립트 문법이 인상적이어서 가져왔는데 댓글을 보니 미래에 삭제되니 subString()으로 대체해서 사용하라고 알려주네요.   🔖 subString()   subString()은 문자열을 인덱스를 기준으로 자를 수 있는 메소드 입니다.   str.substring(시작 인덱스, 마지막 인덱스(옵션));   시작 인덱스는 해당 인덱스를 포함하지만, 마지막 인덱스를 해당 인덱스까지 포함하지 않고 직전까지 잘라내기 때문에 헷갈리지 말아야 합니다.   const str = \"Mozilla\";  console.log(str.substring(1, 3)); console.log(str.substring(3, 1)); // Expected output: \"oz\"  console.log(str.substring(2)); // Expected output: \"zilla\"  console.log(str.substring(2, 2)); // Expected output: \"\"   만약, 마지막 인덱스보다 시작 인덱스가 크다면 알아서 순서를 바꿔서 메소드가 동작합니다.   시작 인덱스와 마지막 인덱스가 같다면 빈 문자열을 반환합니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["filter","스택","큐"],
        "url": "/programmers-lv1/programmers-Import-Intermediate-Characters/",
        "teaser": null
      },{
        "title": "JadenCase 문자열 만들기",
        "excerpt":"📄 문제   JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고) 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.      s는 길이 1 이상 200 이하인 문자열입니다.   s는 알파벳과 숫자, 공백문자(“ “)로 이루어져 있습니다.            숫자는 단어의 첫 문자로만 나옵니다.       숫자로만 이루어진 단어는 없습니다.       공백문자가 연속해서 나올 수 있습니다.           🙋‍♀️ 나의 풀이   function solution(s) {   const arr = s.toLowerCase().split(\" \");    const answer = arr.map((value) =&gt;     value ? value[0].toUpperCase() + value.substring(1) : \"\"   );    return answer.join(\" \"); }   이 문제에는 함정이 있습니다.   공백문자가 연속해서 나올 수 있습니다.   문제를 제대로 읽지 않으면 무엇 때문에 통과할 수 없는지 알 수 없습니다.   제 경험담입니다 :)   제가 푼 순서는 다음과 같습니다.      주어진 문자열을 모두 소문자로 바꾸고 공백을 기준으로 배열(arr)을 생성한다.   생성된 배열을 순환해 첫 글자를 대문자로 바꿔줍니다.   첫 글자가 대문자로 바뀐 문자열들이 담긴 배열을 다시 문자열로 바꿔 반환합니다.   2번 과정에서 공백문자가 연속으로 나올 가능성도 생각해야 합니다.   빈 문자열에 인덱스로 접근할 경우 undefined를 반환하기 때문에 toUpperCase에서 런타임 오류를 발생시킵니다.   문자열을 배열로 바꾼 arr의 요소가 공백문자일 경우 바로 넘어가도록 삼항연산자를 사용했습니다.   🔨 Best Practice   function solution(s) {   return s     .split(\" \")     .map((v) =&gt; v.charAt(0).toUpperCase() + v.substring(1).toLowerCase())     .join(\" \"); }   공백 문자를 해결하는 방법에 charAt이 있었습니다.   charAt은 해당 인덱스에 위치한 문자열을 반환합니다.   따라서 빈 문자열에 charAt으로 접근할 경우 똑같이 빈 문자열을 반환하기 때문에 문제가 일어나지 않는 것입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["프로그래머스","JadenCase 문자열 만들기"],
        "url": "/programmers-lv2/programmers-jadencase/",
        "teaser": null
      },{
        "title": "👩‍💻 개발자의 글쓰기",
        "excerpt":"    ▪ 제목: 개발자의 글쓰기  ▪ 작가: 김철수  ▪ 출판사: 위키북스  ▪ 독서 기간: 2023/03/29 ~ ing  ▪ 읽은 방식: 종이책     원래 독서기록을 쓸 때는 자유형식으로 쓰지만, 이 책은 글 쓰는 스킬을 정리해두면 두고두고 볼 것 같아 정리합니다. 전체 내용을 정리한 것이 아니라 글 작성자에게 필요한 개념을 주로 정리했습니다.   📄 1장 개발자가 알아야 할 글쓰기 기본   문장을 구조화 하는 법   핵심을 말하고 부가 설명을 해라.   나는 김수진이다. 글쓰기를 좋아하는 웹 개발자 취준생이다.   서술식, 개조식, 도식의 차이      서술식            ~다.       소설, 신문, 개발 가이드문서           개조식            명사형 종결어미       릴리스 문서나 장애 보고서       글머리 기호를 활용           도식            중복이나 누락이 많은 경우       각 항목이나 사항의 관계를 명확히 규정하고 싶은 경우           변수나 함수 영어 단어 선택 팁      create: 정해진 틀이 없을 때 틀을 만들기 위해 사용        resister: 정해진 틀에 값을 넣을 때 사용.       change: 단순히 내용을 바꾸는 경우에 사용   modify: 잘못된 것을 바로잡을 때 사용   revise: 기존에 없던 새로운 정보나 아이디어를 덧붙일 때 사용   📄 2장 개발 시간을 줄여주는 이름 짓기와 주석 쓰기   책 읽는 중… 📖  ","categories": ["books"],
        "tags": ["개발자의 글쓰기","IT서적","김철수","위키북스"],
        "url": "/books/books-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "Sass (Syntactically Awesome StyleSheets)",
        "excerpt":"Sass의 수요가 높아지고, 많이들 사용하는 추세라 배워보고 싶었는데 생각보다 공부하고 프로젝트에 적용시키기가 어려웠습니다.   프로젝트를 진행하는 경우에 Sass를 사용해 보고 싶었지만, 빌드된 CSS파일 관리를 어떻게 해야할지 몰라 결국 익숙한 styled-components로 사용하기도 했습니다.   예전에 웹 공부를 시작할때 기초 강의로 도움을 받았던 유노코딩님의 Sass 강의가 열려 재밌게 공부하고 정리한 내용입니다.   📄 Sass란 무엇인가?   Sass는 css를 효율적으로 작성하기 위한 CSS 전처리기 언어입니다.  전처리기는 ‘전에 처리한다’라고 이해하면 쉽습니다.  css가 되기 전에 Sass구문으로 작성해 처리하기 때문입니다.  css는 코드가 커질수록 유지보수가 복잡해집니다.  Sass는 이를 보완하기 위해 등장하였으며, 코드를 수정하거나 재사용하기에도 굉장히 편리합니다.   정리하자면 CSS를 읽기도 좋고 쓰기에도 좋게 사용하기 위해 만들어진 CSS 전처리기 언어입니다.   ▪ Sass 동작 방식   Sass의 동작 방식은 다음과 같습니다.      Sass 구문에 맞게 코드를 작성한다.   Sass 전처리기에 의해 CSS 코드로 변환(컴파일)된다.   변환을 마치고, CSS 파일이 생성된다.(빌드)   ▪ SCSS 이란?   SCSS는 Sass의 하위 개념입니다.  Sass 구문과 동일한 기능을 제공하는데 사용하기 좋아 SCSS구문의 수요가 더 높은 편입니다.   👾 scss로 작성한 코드   $font-stack: Helvetica, sans-serif; $primary-color: #333;  body {   font: 100% $font-stack;   color: $primary-color; }   👾 sass로 작성한 코드   $font-stack: Helvetica, sans-serif; $primary-color: #333;  body   font: 100% $font-stack;   color: $primary-color;    Sass로 작성하나 SCSS로 작성하나 결과는 같지만 SCSS구문이 더 가독성있고 친숙한 느낌을 줍니다.   // 결과  body {   font: 100% $font-stack;   color: $primary-color; }   📄 Sass 준비하기   ▪ Live Sass Compiler 설치하기   scss 코드의 변경 사항을 자동으로 감지해 저장할 때마다 새롭게 빌드를 진행하게 해주는 vscode extension입니다.      SCSS파일을 생성 후 vscode 하단에 있는 Live Sass Compiler 버튼을 클릭하면 실행됩니다.      ▪ 명령행 인터페이스 사용하기   명령행은 명령 프롬프트나 터미널을 뜻합니다.  명령행에서 명령어를 입력해 Sass 컴파일을 진행할 수 있습니다.  node.js가 설치되어 있어야 합니다..    ✔ Sass 명령행 인터페이스 설치하기   npm install -g sass  // 설치 확인하기 sass --version       ✔ Sass파일을 css파일로 컴파일하기   아래와 같이 컴파일을 진행하면 style폴더에 main.css 파일이 생성되어 컴파일됩니다.   sass style/main.scss:style/main.css // style/main.scss를 style/main.css로 컴파일한다.  // live Sass Compiler처럼 자동으로 변경사항 감지하는 옵션 추가 sass --watch  style/main.scss:style/main.css   css에서 기존 중괄호와 들여쓰기가 포함된 css스타일을 extend 스타일이라고 부릅니다.  extend 스타일은 가독성엔 좋지만 직접 css를 다루지 않는 경우엔 가독성이 필요가 없으니 파일이 큰 경우 용량에 부담이 됩니다.  compressed옵션은 그러한 단점을 보완해 코드를 공백없이 압축해 줍니다.   sass --style compressed style/main.scss:style/main.css       ✔ extend 스타일   h1 {   color: black;   background-color: yellow; }   ✔ compressed 스타일   h1 {color: #fff;background-color: #ff0;}   📄 주석과 중첩(nestring)   ▪ 주석   주석 1: 여러 줄 짜리 주석   /* 여러 줄 짜리 주석*/   주석 2: 한 줄 짜리 주석   // 한 줄 짜리 주석   Scss에서 주석을 사용하는 방법은 두가지 입니다.  한 줄 짜리 주석은 컴파일된 css파일에 반영되지 않지만, 기존 css 주석은 최종 css 파일에도 반영된다는 차이점을 가지고 있습니다.   ▪ 중첩 규칙 (nesting)   css를 작성하는 경우 선택자를 서로 다른 선언문에서 반복해야 하는 경우가 있습니다.  Sass에서는 선택자를 반복하지 않고 중첩해 사용할 수 있습니다.   div {   width: 100px;   height: 100px;    p {     color: red;      span {       color: blue;     }   } }   컴파일 후 결과 파일에는 선택자가 따로 생성되어 반영된다.   div {   width: 100px;   height: 100px; } div p {   color: red; } div p span {   color: blue; }     ✔ 단축 속성 중첩   Sass의 단축 속성 중첩은 ‘네입스페이스 속성 중첩’이라고도 부릅니다.   아래 코드는 font의 속성들을 중첩으로 정의한 예시입니다.   p {   font: {     family: sans-serif;     size: 1rem;     style: normal;     weight: 900;   } }     ✔ 상위 선택자 참조 (&amp;)   기호 &amp;사용하면 중첩된 선언문안에서 상위 선택자를 참조할 수 있습니다.  의사클래스를 선택하고자 할 때 유용합니다.   .first-btn {   &amp;:hover {     background: {       color: red;     }   } }   📄 변수   Sass에서는 $를 사용해 변수를 만들어 데이터를 저장하고 사용할 수 있습니다.  생성된 변수는 최종 CSS파일에서 표시되지 않습니다.   $main-color: orange; $font-color: white;  button {   &amp;:nth-child(1) {     color: $font-color;     background-color: $main-color;     width: 100px;   }   &amp;:nth-child(2) {     color: $font-color;     background-color: $main-color;     width: 200px;   }   &amp;:nth-child(3) {     color: $font-color;     background-color: $main-color;     width: 300px;   } }   ▪ SCSS 변수 사용 규칙      개수 제한은 없지만, 가독성을 해치니 남용하지 않는다.   변수명에는 영문자, 숫자, -, _를 사용하며 가능한 직관적인 이름을 사용한다.   📄 믹스인 (mixin)   믹스인은 사이트 전체에서 재사용할 스타일 그룹을 정의하기 위해 사용하는 문법입니다.   ▪ 믹스인 정의하기   믹스인을 정의할 때 인자를 함께 정의하면, 믹스인 호출 시에 상황에 따라 값을 다르게 주어 사용할 수 있습니다.  인자를 정의할 때 기본값은 옵션으로 설정합니다.  정의된 믹스인은 최종 CSS파일에 포함되지 않습니다.   @mixin box-style($bg-color: yellow, $font-color: green) {   width: 100px;   height: 100px;   display: flex;   justify-content: center;   align-items: center;   background-color: $bg-color;   color: $font-color; }   ▪ 믹스인 사용하기   정의된 믹스인을 사용하고자 할땐 @include지시어를 사용합니다.   .one {   @include box-style(); }  .two {   @include box-style(purple, yellow); }   📄 @content   @content는 믹스인의 인자로 단순한 변수가 아닌 스타일 블록 전체를 넘길 때 사용하는 문법입니다.  인자와 스타일 블록을 모두 전달받는 형태의 믹스인을 정의할 수도 있습니다.   @mixin btn-style($hv-color) {   @content;   width: 100px;   height: 25px;    &amp;:hover {     background-color: $hv-color;   } }  .one {   @include btn-style(orange) {     color: white;     background-color: tomato;   } }  .two {   @include btn-style(green) {     color: red;     background-color: teal;   } }   📄 여러개의 .scss파일을 하나의 .css파일로 관리하기   여러개의 .scss파일이 우후죽순 생겨날 때 이를 관리하는 방법이 있습니다.  모든 scss파일을 하나의 css파일로 보내버리는 것이 아니라,   하나의 main.scss파일에서 각 기능을 담당하는 scss파일을 @import해서 사용하는 방법입니다.   이때 주의해야할 점은 mains.scss파일이 아닌 scss파일의 이름은 언더바로 시작해야 컴파일 대상에서 제외된다는 사실입니다.&lt;/br&gt; @import지시자를 사용할 때는 언더바를 제거하고 사용합니다.   //main.scss  @import \"variables.scss\"; @import \"mixins.scss\";  div {   @include box($main-color); }   이렇게 CSS파일을 하나로 만들게 된다면      HTML과 CSS 문서 간 연결 횟수가 줄어 웹사이트 성능 개선에 도움이 되고   scss파일을 기능별로 분리할 수 있어 보기도 좋고 재사용하기도 좋습니다.   📄 스타일 중복을 피하는 방법 @extend   @extend지시자는 기존의 스타일을 확장해서 다른 클래스에서 쓰고 싶을 때 사용합니다.   .message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   @extend .message;   background: #f05; }   mixin과 비슷하지만, 저는 mixin은 규격을 설정하는 것이고 extend는 확장을 위해 사용하는 것이라고 이해했습니다.   실제로 컴파일된 결과도 mixin과 다릅니다.   .message, .bad-message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   background: #f05; }   @exclue를 사용해 컴파일된 결과를 보면 속성들을 사용하고 있는 클래스 네임이 쉼표와 함께 열거되고 있는 것을 확인할 수 있습니다.   유령 클래스(공식 명칭은 아닙니다.)를 사용해 컴파일 되었을 때 기존 클래스는 노출되지 않으면서 재사용한 클래스만 보여주는 방법도 있습니다.  유령 클래스는 %기호를 사용합니다.   %message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   @extend %message;   background: #f05; }   컴파일 된 결과를 확인하면 유령클래스의 이름은 노출되지 않고 있는 것을 확인할 수 있습니다.   .bad-message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   background: #f05; }   📄 조건문을 사용해 코드의 흐름 제어하기   Sass에서는 @if 지시자를 이용해 조건을 설정할 수 있습니다.&lt;/br&gt; 아래 예시는 mixin안에 조건문을 설정한 경우입니다.&lt;/br&gt; @else 지시자를 사용하면 @if문이 불만족할 경우의 속성을 설정할 수 있습니다.   @mixin select-color($color) {   @if $color == blue {     color: blue;   } @else {     color: tomato;   } }  h1 {   @include select-color((red)); }   Sass에서 조건문은 웹사이트를 개발하는 단계보다는 라이브러리를 만드는 경우에 더 자주 사용된다고 합니다.   📄 미디어 쿼리   미디어 쿼리는 반응형 웹을 만들 때 사용되는 필수 문법입니다.  Sass에서 미디어 쿼리를 사용할 때 문자열을 변수로 사용하는 경우가 있는데 이때 문자열 삽입용 기호인 #{}를 사용해야 합니다.   $width-small: \"all and (min-width: 300px)\"; $width-medium: \"all and (min-width: 600px)\"; $width-large: \"all and (min-width: 900px)\";  div {   width: 100px;   height: 100px;    @media #{$width-small} {     background-color: cadetblue;   }    @media #{$width-medium} {     background-color: orange;   }    @media #{$width-large} {     background-color: purple;   } }     출처           유노코딩            실습을 진행한 깃허브 레파지토리      ","categories": ["CSS"],
        "tags": ["Sass"],
        "url": "/css/css-Sass/",
        "teaser": null
      },{
        "title": "[Lv 2] 올바른 괄호",
        "excerpt":"📄 문제   괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어   ”()()” 또는 “(())()” 는 올바른 괄호입니다. “)()(“ 또는 “(()(“ 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.      문자열 s의 길이 : 100,000 이하의 자연수   문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   let sum = 0;   for (let i = 0; i &lt; s.length; i++) {     // 1     if (s[i] === \"(\") sum += 1; // 2     if (s[i] === \")\") sum -= 1; // 3      if (sum &lt; 0) return false; // 4   }   return sum === 0; // 5 }   제가 생각한 풀이는 이렇습니다.      주어진 문자열을 순환한다.   ( 은 +1을 sum에 누적한다.   (은 -1을 sum에 누적한다.   누적된 값이 음수인 경우는 올바르지 않은 괄호이므로 false를 반환한다.   최종 누적된 sum이 0인지 진위값을 반환한다.   이 문제를 처음 보고 어떻게 접근할지 감이 잘 안와서 시간이 약간 걸렸습니다.   자료구조 공부가 부족한 탓일까요.   꾸준히 문제를 풀어야 하는 필요를 다시 한번 생각하게 됩니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["올바른 괄호","스택/큐"],
        "url": "/programmers-lv2/programmer-%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8/",
        "teaser": null
      },{
        "title": "x만큼 간격이 있는 n개의 숫자",
        "excerpt":"📄 문제   함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.      x는 -10000000 이상, 10000000 이하인 정수입니다.   n은 1000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(x, n) {   let answer = []; // 1    for (let i = 1; i &lt; n + 1; i++) {     answer.push(x * i); // 2   }   return answer; }      정답으로 반환할 배열 answer을 생성합니다.   for문을 돌려 배열 내장함수인 push를 이용해 배열에 x만큼 더해준 값을 삽입합니다.   👍 Best Practice   function solution(x, n) {   return Array(n)     .fill(x)     .map((v, i) =&gt; (i + 1) * v); }   아예 미리 x로 채워진 배열을 생성후 map을 이용해 값을 변경해준 답안입니다.   한줄로 훨씬 깔끔하지만 성능은 for문으로 하는게 더 좋다고 합니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["x만큼 간격이 있는 n개의 숫자"],
        "url": "/programmers-lv1/programmers-x%EB%A7%8C%ED%81%BC-%EA%B0%84%EA%B2%A9%EC%9D%B4-%EC%9E%88%EB%8A%94-n%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Lv 1] 문자열 내 p와 y의 개수",
        "excerpt":"📄 문제   대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.   예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다.      문자열 s의 길이 : 50 이하의 자연수   문자열 s는 알파벳으로만 이루어져 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   return (     s.toLowerCase().split(\"p\").length - 1 ===     s.toLowerCase().split(\"y\").length - 1   ); }   문자열을 소문자로 바꾸고 p와 y를 기준으로 잘라 크기를 구한 후 1를 빼주면 각 문자가 몇개 들어있는지 알 수 있습니다.   pPoooyY의 경우 toLowerCase()를 통해 소문자로 바꾸면 ppoooyy가 됩니다.   이후 p를 기준을 문자열을 split()메소드를 이용해 잘라내면 [\"\", \"\", \"oooyy\"]가 됩니다.   이 배열의 크기는 3인데 여기서 1을 빼면 p의 개수를 알 수 있습니다.   👍 Best Practice   function numPY(s) {   return s.match(/p/gi).length == s.match(/y/gi).length; }   이 답안은 match()라는 메소드를 이용했네요.   이번에 처음으로 알아갑니다.   📌 match()는 특정 문자열를 추출하여 배열로 반환해주는 메소드입니다.   그런데 이 코드는 문제가 있습니다.   p와 y가 없을 때 match()가 null을 반환해서 length함수를 쓸 수 없기 때문에 다음과 같은 컴파일 에러가 납니다.    Cannot read properties of null (reading 'length')   이 부분을 해결해보기 위해 옵셔널 체이닝을 걸어주겠습니다.   function numPY(s) {   return s.match(/p/gi)?.length == s.match(/y/gi)?.length; }   이렇게 되면 undefined === undefined가 되어 true를 반환해 에러없이 통과할 수 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["문자열 내 p와 y의 개수","match"],
        "url": "/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-p%EC%99%80-y%EC%9D%98-%EA%B0%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "[Lv 2] 최솟값 만들기",
        "excerpt":"📄 문제   길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)   예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면      A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)   A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)   A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)   즉, 이 경우가 최소가 되므로 29를 return 합니다.   배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.      배열 A, B의 크기 : 1,000 이하의 자연수   배열 A, B의 원소의 크기 : 1,000 이하의 자연수   🙋‍♀️ 나의 풀이   function solution(A, B) {   const newA = A.sort((a, b) =&gt; a - b);   const newB = B.sort((a, b) =&gt; b - a);   let answer = 0;   for (let i = 0; i &lt; A.length; i++) {     answer += newA[i] * newB[i];   }   return answer; }   이번 문제를 통해 숫자를 오름차순, 내림차순 하는 법을 공부했습니다.   곱셈한 값의 누적결과가 최솟값이 되려면 가장 작은 수 x 가장 큰 수가 되어야 하기 때문입니다.   따라서 A는 오름차순으로 B는 내림차순으로 정렬해 인덱스가 일치하는 값끼리 곱셈해주었습니다.   👍 Best Practice   function solution(A, B) {   A.sort((a, b) =&gt; a - b);   B.sort((a, b) =&gt; b - a);   return A.reduce((total, val, idx) =&gt; total + val * B[idx], 0); }   reduce메소드를 사용한 풀이입니다.   reduce메소드를 배열 하나에만 적용할 수 있다는 생각에 시도하지 않았는데 이렇게도 접근이 가능하네요 👍   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["최솟값 만들기","reduce"],
        "url": "/programmers-lv2/programmers-%EC%B5%9C%EC%86%9F%EA%B0%92-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 1] 나머지가 1이 되는 수 찾기",
        "excerpt":"📄 문제   자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.      3 ≤ n ≤ 1,000,000   🙋‍♀️ 나의 풀이   function solution(n) {   for (let i = 0; i &lt; n; i++) {     if (n % i === 1) return i;   } }   for문으로 반복문을 돌려 나머지가 1이 되면 바로 값을 반환했습니다.   👍 Best Practice   function solution(n, x = 1) {   while (x++) {     if (n % x === 1) {       return x;     }   } }   증감연산자를 for문뿐만 아니라 while문에서 사용해 반복문을 돌릴 수 있다는 걸 배워갑니다.   문제 출처      프로그래머스 - 나머지가 1이 되는 수 찾기  ","categories": ["programmers-lv1"],
        "tags": ["나머지가 1이 되는 수 찾기"],
        "url": "/programmers-lv1/programmers-%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%80-1%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 2] 이진 변환 반복하기",
        "excerpt":"📄 문제   0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.   x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 “c를 2진법으로 표현한 문자열”로 바꿉니다. 예를 들어, x = “0111010”이라면, x에 이진 변환을 가하면 x = “0111010” -&gt; “1111” -&gt; “100” 이 됩니다.   0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 “1”이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.      s의 길이는 1 이상 150,000 이하입니다.   s에는 ‘1’이 최소 하나 이상 포함되어 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   let binaryTransforms = s;   let NumberOfZero = 0;   for (let i = 0; i &lt; s.length; i++) {     // NumberOfZero += binaryTransforms.match(/0/gi)?.length; 🚨 Error!     NumberOfZero += binaryTransforms.split(\"0\").length;     binaryTransforms = binaryTransforms?.match(/1/gi).length.toString(2);      if (binaryTransforms === \"1\") return [i + 1, NumberOfZero];   } }   저번에 공부한 match()라는 메소드를 야무지게 써먹어 보았습니다.   그런데 문자열에서 0만 뽑아오는 binaryTransform이 0이 없을 때 null을 뱉어 NumberOfZero이 Nan이라는 결과를 뱉습니다.   이를 해결하기 위해 split()메소드를 사용해 무조건 값이 나오게 만들어 length 속성을 사용할 수 있도록 작성했습니다.   👍 Best Practice   function solution(s) {   var answer = [0, 0];   while (s.length &gt; 1) {     answer[0]++;     answer[1] += (s.match(/0/g) || []).length;     s = s.replace(/0/g, \"\").length.toString(2);   }   return answer; }   제가 많은 것들을 놓치고 있었네요.      명확한 조건이 있음에도 의미 없이 for문을 사용   OR 연산자를 사용해 조건을 걸어 length 사용 가능   답을 무조건 변수에 넣는다고 좋은 것이 아님   저는 다른것보다 답을 배열에 넣어놓은 부분이 마음에 들었습니다.   반환되는 값이 어떤 역할을 하는지 명확히 하려고 변수에 담았는데 오히려 여기서 보여주는 답안이 answer이 하는 역할을 더 잘 보여주는 것 같습니다.   또하나 인상적인 점은 string 메소드인 replace()를 사용했다는 것입니다.   📌 String.prototype.replace(): 문자열을 치환할 수 있다. str.replace(해당 문자열 || 정규식, 치환할 문자열 || 함수)    이녀석도 기억해서 다음 문제에 사용하게 된다면 야무지게 써먹어보겠습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["이진수","replace"],
        "url": "/programmers-lv2/programmers-%EC%9D%B4%EC%A7%84-%EB%B3%80%ED%99%98-%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 2] 숫자의 표현",
        "excerpt":"📄 문제   Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.      1 + 2 + 3 + 4 + 5 = 15   4 + 5 + 6 = 15   7 + 8 = 15   15 = 15   자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.      n은 10,000 이하의 자연수 입니다.   🙋‍♀️ 나의 풀이 1   function solution(n) {   let answer = 1;   let acc = 0;   for (let i = 1; i &lt;= n / 2; i++) {     for (let j = i; j &lt;= n; j++) {       acc += j;       if (acc &gt; n) break;       if (acc == n) {         answer++;         acc = 0;         break;       }     }     acc = 0;   }   return answer; }   처음에 for문을 돌려 연속된 수의 합을 구했는데 정확성 테스트는 통과했지만 효율성 테스트에서 모두 막혔습니다.   어떻게든 넘어가려고 if문에 i 조건까지 수정했는데 통과할 수 없어 풀이 과정 자체에 대해 다시 생각했습니다.   🙋‍♀️ 나의 풀이 2   function solution(n) {   let answer = 0;   for (let i = 1; i &lt;= n; i++) {     if (n % i === 0 &amp;&amp; i % 2 === 1) answer++;   }   return answer; }   연속된 수의 합을 구하는 방법을 찾던 중 다음과 같은 방법을 찾았습니다.      자연수의 소수 중 홀수의 개수는 연속된 자연수의 합이 나올 수 있는 개수와 같다.    예를 들어,   15의 약수는 [1, 3, 5, 15]입니다.      1의 경우, 연속하는 1개의 자연수로 표현 가능 =&gt; 15   3의 경우, 연속하는 3개의 자연수로 표현 가능 =&gt; 3+4+5   5의 경우, 연속하는 5개의 자연수로 표현 가능 =&gt; 1+2+3+4+5   15의 경우, 모든 홀수는 n과 n+1로 표현가능 =&gt; 7+8   이 풀이에서는 공식을 사용했기 때문에 for문이 한번만 돌아가 효율성 테스트를 모두 통과할 수 있었습니다.   다른 문제보다 수학적 지식이 요구되었던 문제였던것 같은데 정답률(73%)이 높네요.   원래 수학은 졸업하면 까먹는건데…  ","categories": ["programmers-lv2"],
        "tags": ["숫자의 표현"],
        "url": "/programmers-lv2/programmers-%EC%88%AB%EC%9E%90%EC%9D%98-%ED%91%9C%ED%98%84/",
        "teaser": null
      },{
        "title": "[Lv 1] 정수 제곱근 판별",
        "excerpt":"📄 문제   임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.      n은 1이상, 50000000000000 이하인 양의 정수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   const sqrt = Math.sqrt(n); // 1   return Number.isInteger(sqrt) ? (sqrt + 1) * (sqrt + 1) : -1; // 2 }   제곱근을 반환해주는 메소드 Math.sqrt()를 이용해 문제를 풀었습니다.   for문이나 while문을 사용하면 너무 많은 경우의 수가 생겨 효율성이 좋지 않을 거라고 생각했기 때문입니다.      주어진 숫자 n의 제곱근(sqrt)을 구한다.   sqrt가 정수라면 1을 더한 제곱을 반환, 아니면 -1을 반환한다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["정수 제곱근 판별","sqrt","Number.isInteger","pow"],
        "url": "/programmers-lv2/programmers-%EC%A0%95%EC%88%98-%EC%A0%9C%EA%B3%B1%EA%B7%BC-%ED%8C%90%EB%B3%84/",
        "teaser": null
      },{
        "title": "[Leaning Typescript 🦜] various-lawyerings",
        "excerpt":"👩‍🎓 Various Lawyerings      Hello, fellow lawyer. I’m glad you’ve chosen to join me in preparing to engage in legal battle. As you can see, I require your assistance in developing TypeScript projects to manage my files for this most important case.    안녕, 동료 변호사야.  이번 법정 사건을 나와 함께 준비하기로 했다니 정말 기쁘다.  보다시피, 아주 중요한 케이스를 위한 파일을 관리하는 지금 개발중인 타입스크립트 프로젝트를 너가 도와줬음 좋겠다잉.      타입 인터페이스말고, 타입 객체를 사용하세요.   🎓 Step 1: Aviary Classification      As a world-renowned expert in bird law, it is my duty to properly educate the court on the characteristics of various birds and related bird information. I cannot uphold my critical task if my bird files are not in proper order.  I require you to write an object type describing a Bird type for my array of birds. Please be as specific as possible for types when possible. Any property other than name whose values are strings should be a union of unions of string literals.    ▪ 요약: 새 정보가 들어있는 객체 타입을 가능한 구체적으로 만들어줘. name말고도 값이 string인 프로퍼티는 string 리터럴 유니언 타입이 되어야해   📄 문제 코드   birds배열의 속성들이 객체로 이루어져 있습니다. 이 객체들의 타입을 지정해주어야 합니다.   // Write your Bird type here! ✨ export const birds = [   {     dangerous: true,     diet: \"omnivore\",     name: \"White-Throated Magpie-Jay\",     noisy: true,   },   {     diet: \"omnivore\",     intelligent: true,     name: \"Eurasian Magpie\",   },   {     diet: \"carnivore\",     name: \"Yellow-Billed Blue Magpie\",     noisy: true,   },   {     intelligent: true,     diet: \"omnivore\",     name: \"American Crow\",   }, ];   📄 풀이과정   공통된 속성들을 빼주고 서로 다른 경우의 속성들을 유니언 타입으로 생성해 교차 타입으로 묶어주었습니다.   error는 없어졌지만 이게 요구사항대로 한게 맞는지 모르겠습니다.   type Bird = { name: string; diet: string } &amp; (   | { dangerous: boolean; noisy: boolean }   | { diet: string }   | { noisy: boolean }   | { intelligent: boolean } );   ✔ 정답   export type Bird = {   dangerous?: boolean,   diet: \"carnivore\" | \"omnivore\",   intelligent?: boolean,   name: string,   noisy?: boolean, };   역시 틀렸습니다. 교차 타입말고 선택적 속성을 사용하니 훨씬 가독성있네요.   교차 타입을 알기 전에는 이렇게 코드를 작성했었는데 교차 타입을 공부하니 애먼곳에 얶매여 생각했습니다.   역시 코드는 사람이 눈으로 읽기 좋게 짜야합니다.   🎓 Step 2: Case Management      Very good, very good. My birds are classified correctly. I thank you.  Next, I have the opposite type of task for you to tackle. I have created a Case type for you and have a cases array. But, the elements in cases vary in format and do not always match up with the Case type. Please correct cases – without changing the Case type.    ▪ 요약: 아주 맘에 드는구만. 이번엔 반대로 내주지. 타입 Case를 바꾸지 말고 배열 cases를 바꿔서 문제를 해결해 봐라!   📄 문제 코드   이번에는 타입을 수정하지 않고 주어진 배열 데이터인 cases를 고쳐야 합니다.   export type Case = {   court: \"state\" | \"federal\";   decided: Date;   defendant: string;   id: string | string[];   plaintiff: string;   title: string; };  export const cases: Case[] = [   {     court: \"federal\",     decided: new Date(\"February 18, 1986\"),     defendant: [\"Glynn Batson\", \"and\", \"Southplains Land Corporation\"],     id: 841710,     plaintiff: \"United States of America\",     title: \"United States v. Batson\",   },   {     court: \"state\",     decided: \"April 17, 1992\",     defendant: \"Bradford Marine, Inc\",     id: [\"90-6372-CIV\", \"90-6599-CIV\"],     plaintiff: \"Lyn C. Noble\",     title: \"Noble v. Bradford Marine, Inc\",   },   {     amusing: true,     court: \"NY state\",     defendant: \"PepsiCo, Inc.\",     decided: {       on: new Date(\"August 5, 1999\"),     },     ids: [\"96-cv-5320\", \"96-cv-9069\"],     plaintiff: \"John Leonard\",     title: \"Leonard v. Pepsico, Inc.\",   }, ];   📄 해결 과정   주어진 타입 Case에 맞게 배열 cases를 바꾸어 주었습니다.   Case에 없는 속성은 아예 삭제했습니다.   export type Case = {   court: \"state\" | \"federal\";   decided: Date;   defendant: string;   id: string | string[];   plaintiff: string;   title: string; };  export const cases: Case[] = [   {     court: \"federal\",     decided: new Date(\"February 18, 1986\"),     defendant: \"Glynn Batson and Southplains Land Corporation\",     id: \"841710\",     plaintiff: \"United States of America\",     title: \"United States v. Batson\",   },   {     court: \"state\",     decided: new Date(\"1992-04-17\"),     defendant: \"Bradford Marine, Inc\",     id: [\"90-6372-CIV\", \"90-6599-CIV\"],     plaintiff: \"Lyn C. Noble\",     title: \"Noble v. Bradford Marine, Inc\",   },   {     court: \"state\",     defendant: \"PepsiCo, Inc.\",     decided: new Date(\"August 5, 1999\"),     id: [\"96-cv-5320\", \"96-cv-9069\"],     plaintiff: \"John Leonard\",     title: \"Leonard v. Pepsico, Inc.\",   }, ];   정답 코드와 일치합니다 :)   📄 Step 3: Making Arguments      Well done, dear chap! Well done indeed. I have but one more file for you. It contains the many motions I have seen in cases involving my clients. I must admit, I’d grown quite weary while jotting down those motions. It is missing TypeScript types, and many elements in the motions array have typos in their data. The tricky thing is, there are a few different types of motions that can be filed. There should be some kind of discriminating indicator property on the types to distinguish between:       Status: allowed, denied, and pending. Within those types:            Allowed: it may also indicate how many hours it spent in deliberation       Denied: it may also indicate how many hours it spent in deliberation, and whether it annoyed the justice       Pending: it may also indicate how many hours it’s estimated to spent in deliberation           Step: post-trial and pre-trial. Within those types:            Pre-trial: I only noted dismissals, suppressions, and venue changes       Post-trial: I only noted acquittals, corrections, and new trials           ▪ 아주 잘했군, 녀석. 나 정말 피곤하다… 내 클라이언트 사건들에서 사라진 타입을 찾고 오타 좀 고쳐주라.. 여기 구별하기 위한 프로퍼티들이 있어.(망해버린 번역입니다.)   📄 문제 코드   배열 motions 요소를 이루는 객체의 타입을 지정해주어야 하네요.   // Write your types here! ✨  export const motions: Motion[] = [   {     annoyedJustice: true,     classification: \"acquittal\",     deliberationHours: 1,     from: \"defendant\",     reason: \"The heretofore document had dried ink on it.\",     status: \"denied\",     step: \"post-trial\",   },   {     annoyedJustice: true,     classification: \"correction\",     deliberationHours: 2.5,     from: \"plaintiff\",     reason: \"The tenant has ninety days to vacate.\",     status: \"denied\",     step: \"post-trial\",   },   {     classification: \"suppress\",     deliberationHours: 4,     from: \"plaintiff\",     reason: \"Frank was never allowed in the house.\",     status: \"allowed\",     step: \"pre-trial\",   },   {     classification: \"new trial\",     estimatedDeliberationHours: 3,     from: \"defendant\",     reason: \"The duel's been accepted. There's no backing out. That's the law.\",     status: \"pending\",     step: \"post-trial\",   },   {     annoyedJustice: false,     classification: \"dismiss\",     deliberationHours: 0.5,     from: \"plaintiff\",     reason:       \"It seems like you have a tenuous grasp on the English language in general.\",     status: \"denied\",     step: \"pre-trial\",   },   {     annoyedJustice: true,     classification: \"correction\",     deliberationHours: 1.5,     from: \"defendant\",     reason: \"Fillibuster?\",     status: \"denied\",     step: \"post-trial\",   },   {     annoyedJustice: true,     classification: \"venue\",     deliberationHours: 0.25,     from: \"defendant\",     reason: \"A time was never specified for the duel.\",     status: \"denied\",     step: \"pre-trial\",   },   {     annoyedJustice: true,     classification: \"correction\",     deliberationHours: 5,     from: \"plaintiff\",     reason: \"He's making a few good points!\",     status: \"denied\",     step: \"post-trial\",   }, ];   📄 풀이 과정   이번 문제는 제 영어 실력에 한계가 느껴졌습니다.   주어진 지문을 보고 문제가 잘 이해가 가지 않았습니다.   처음으로 못풀었던 문제입니다..   우선 객체의 공통된 속성들을 가지고 베이스 타입을 만들어줍니다.   export type MotionBase = {   from: \"defendant\" | \"plaintiff\";   reason: string; };   이후, 지문에서 주어진 요구사항에 맞게 두가지 타입을 분류합니다.   export type PreTrialMotion = MotionBase &amp; {   classification: \"dismiss\" | \"suppress\" | \"venue\";   step: \"pre-trial\"; };  export type PostTrialMotion = MotionBase &amp; {   classification: \"acquittal\" | \"correction\" | \"new trial\";   step: \"post-trial\"; };   이렇게 재판 유형에 따른 타입 TrialMotion을 유니언 타입으로 만들어주었습니다.   export type TrialMotion = PostTrialMotion | PreTrialMotion;   이제 각 상태에 맞게 타입을 분류하고 유니언 타입으로 합쳐 최종 타입을 생성합니다.   export type AllowedMotion = TrialMotion &amp; {   deliberationHours: number;   status: \"allowed\"; };  export type DeniedMotion = TrialMotion &amp; {   annoyedJustice: boolean;   deliberationHours: number;   status: \"denied\"; };  export type PendingMotion = TrialMotion &amp; {   estimatedDeliberationHours: number;   status: \"pending\"; };  export type Motion = AllowedMotion | DeniedMotion | PendingMotion;   영어 공부를 좀 더 해야겠네요.   정답 코드를 보기 전까진 어떻게 해야할지 사실 감이 잘 잡히지 않았습니다.   역시 영어는 꼭 공부해야겠습니다.   문제 출처      learning typescript  ","categories": ["TypeScript"],
        "tags": ["learning typescript","러닝 타입스크립트","타입 객체","various-lawyerings"],
        "url": "/typescript/typescript-learning-typescript-various-lawyerings/",
        "teaser": "/assets%5Cimage%5Clearning-typescript.PNG"
      },{
        "title": "객체 타입",
        "excerpt":"📄 객체 타입   객체 타입이란 타입스크립트에서 {속성명: 타입 명}형식으로 이루어진 타입입니다.   type Poet = {   // 별칭 객체 타입   born: number;   name: string; };  let poetLater: Poet;  poetLater = {   born: 1935,   name: \"Mary Oliver\", };  poetLater = \"Sappho\"; // Error: Type 'string' is not assignable to type '{born: numner; name: string;}   📄 구조적 타이핑   구조적 타이핑은 실제 구조와 정의에 의해 결정되는 타입 시스템입니다.   런타임에 타입을 결정하는 자바스크립트의 덕 타이핑과 달리, 타입스크립트는 구조적으로 타입화합니다.      덕 타이핑이란? 동적 타이핑의 한 종류로 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것    ▪ 초과 속성 검사   초과 속성 검사는 객체 타입 속성을 검사하는 과정입니다.   초과 속성 검사에는 중요한 조건이 있습니다.   “객체 리터럴을 변수에 집적 할당하는 경우에만”초과 속성 검사가 진행된다는 것입니다.   다음과 같은 예시에서는 객체 리터럴 Poet을 변수 extraPerson에 직접 할당했기 때문에 초과 속성 검사가 진행되어 타입 에러를 뱉습니다.   type Person = {   name: string,   age: number, };  // ok. Person필드와 일치 const Sujin: Person = {   name: \"sujin\",   age: 28, };  const extraPerson: Person = {   name: \"sujin\",   age: 28,   nickName: \"masuri\", // Error! };   이번에는 중간에 변수를 거쳐서 객체리터럴를 대입해보겠습니다.   const exisitingObject = {   name: \"sujin\",   age: 28,   nickName: \"masuri\", };  const extraPerson: Person = existingObject; // ok   객체를 다른 변수에 할당했더니, 변수 existingObject는 초과 속성 검사를 받지 않았기 때문에 에러가 발생하지 않습니다.   ▪ 선택적 속성   선택적 속성은 에너테이션(:)앞에 ?를 추가해서 선택적으로 속성을 허용할 때 사용합니다.   타입을 undefined로 선언한경우, 그 값이 undefined일지라도 반드시 그 값이 존재해야합니다.   반면, 선택적으로 선언된 속성은 존재하지 않아도 됩니다.   type Writer = {   author: string | undefined;   editor?: string; };  const hasRequired: Writer = {   author: undefined; }  const missingRequired: Writer = {}; // Error: Property 'author' is missing in type '{}' but required in type 'Writers'.   📄 교차 타입   교차 타입은 합집합의 개념으로 이해할 수 있습니다.   유니언 타입이 이거 또는 저거의 개념으로 주어진 타입 중 하나의 타입만 선택하게 되는 반면에,   교차 타입은 서로 다른 타입이 하나의 타입으로 만들어져 여러 타입을 동시에 나타낼 수 있습니다.   교차 타입은 유니언 타입과 결합하여 사용할 수 있습니다.   type ShortPoem = {   author: string; } &amp; ({ kigo: string; type: \"haiku\" } | { meter: number; type: \"villanelle\" });  // type: // {author: string;  kigo: string; type: \"haiku\"} // 또는 // {author: string; meter: number; type: \"villanelle\" }   ▪ never   원시타입에 교차타입을 적용하는 것은 무의미한 일입니다.   원시타입에 교차타입을 적용하면 never라는 타입이 되는데, 이는 비어있는 타입을 뜻합니다.   let notNumber: number &amp; string = 0; // Error: Type 'number'is not assignable to type 'never'   참고      learning TypeScript   InPa-Dev - 타입스크립트 잉여 속성 검사 원리 이해하기  ","categories": ["TypeScript"],
        "tags": ["객체 타입","구조적 타이핑","선택적 속성","교차타입","never"],
        "url": "/typescript/typescript-%EA%B0%9D%EC%B2%B4-%ED%83%80%EC%9E%85/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 🚨 react-scripts: not found",
        "excerpt":"🚨 문제 발생   모코늪 프로젝트에서 github actions를 통해 프로젝트를 배포하는데 npm run build명령어가 되질 않습니다.      프로젝트에서 npm을 업데이트하고 설치해도 같은 문제가 발생해서 아예 package.lock파일과 node_modules폴더를 삭제하고 다시 npm을 설치해주었습니다.   실패했습니다.   🔨 문제 해결   구글링하면 왜 자꾸 사람들이 node_modules를 지워라, 다시 npm install을 해라 하는지 알았습니다.   그런 케이스들은 로컬 환경에서 일어났던 에러였으니 당연히 다시 npm을 설치해 초기화 시켜주면 해결이 되었던 것입니다.   저는 로컬 환경에서는 빌드가 되었지만 github actions에서 되지 않았던 것이었는데 말이죠.   저의 CICD.yml파일입니다.   jobs:   CICD:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@main       # - run: npm ci 이 부분을 실수로 삭제 해놓고 헤매고 있던 것이었습니다.       - run: npm run build       - name: deploy to s3         uses: jakejarvis/s3-sync-action@master         with:           args: --delete         env:           AWS_S3_BUCKET: $           AWS_ACCESS_KEY_ID: $           AWS_SECRET_ACCESS_KEY: $           AWS_REGION: \"ap-northeast-2\"           SOURCE_DIR: \"build\"   📌 npm ci 란?   npm ci는 package-lock.json에 있는 패키지 정보를 이용해 정확한 버전의 패키지들을 설치해서 node_modules에 적재합니다.   npm run build을 실행할 수 있는 파일은 node_modules에 있는데 node_modules를 설치하지 않았으니 에러가 발생할 수 밖에요.     그런데 사실 에러가 완전히 끝나지 않았습니다.      @toast ui 라이브러리가 현재 사용중인 react 18버전과 맞지 않습니다.   산넘어 산입니다.   이거 리액트 버전을 낮추는거 밖에 답이 안보이네요.   참고      https://github.com/facebook/create-react-app/discussions/10220  ","categories": ["coding-swamp"],
        "tags": ["모코늪","리액트","github actions","에러","npm ci"],
        "url": "/coding-swamp/coding-swamp-scripts-not-found/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 🚨 Could not resolve dependency + package maneger Error",
        "excerpt":"🚨 문제 발생   리액트 프로젝트를 github actions를 통해 배포하는데 문제가 발생했습니다.   리액트 버전이 현재 18.2.0인데 @toast-ui라이브러리와 맞지 않습니다.      아무래도 리액트를 17로 버전을 낮춰야겠습니다.   🔨 해결 과정   다음 명령어를 통해 리액트를 17.0.2버전으로 다운그레이드 합니다.   당연히 react-dom도 함께 다운그레이드 합니다.   npm install react@^17.0.2 react-dom@17.0.2    👍   이제 로컬에서 잘 돌아가는지 테스트해보겠습니다.   버전이 바뀌니 뭔가 문제가 발생하네요.   내 이럴 줄 알았습니다.   ▪ Can’t resolve ‘react-dom/client’      💾 [index.ts]   버전이 바뀌어 사용방법도 다릅니다.   아래 코드처럼 수정해줍니다.   // import ReactDOM from \"react-dom/client\"; import ReactDOM from \"react-dom\";   ▪ Property ‘createRoot’ does not exist on type   바뀐 버전은 렌더 방식도 다릅니다.   마찬가지로 index.ts파일에서 진행됩니다.   리액트 17버전은 ReactDOM이 직접 render하는 구조입니다.   // const root = ReactDOM.createRoot( //   document.getElementById(\"root\") as HTMLElement // );  // root.render( //   &lt;Provider store={store}&gt; //     &lt;PersistGate loading={null} persistor={persistor}&gt; //       &lt;ThemeProvider theme={theme}&gt; //         &lt;GlobalStyle /&gt; //         &lt;Page&gt; //           &lt;App /&gt; //         &lt;/Page&gt; //       &lt;/ThemeProvider&gt; //     &lt;/PersistGate&gt; //   &lt;/Provider&gt;, // );  ReactDOM.render(   &lt;Provider store={store}&gt;     &lt;PersistGate loading={null} persistor={persistor}&gt;       &lt;ThemeProvider theme={theme}&gt;         &lt;GlobalStyle /&gt;         &lt;Page&gt;           &lt;App /&gt;         &lt;/Page&gt;       &lt;/ThemeProvider&gt;     &lt;/PersistGate&gt;   &lt;/Provider&gt;,   document.getElementById(\"root\") );   이제 문제 없이 프로젝트가 잘 돌아갑니다.   과연 npm ci명령도 잘 통과할까요..   🚨 문제 발생 #2      이번엔 testing library가 문제네요.   현재 설치되어 있는 testing-library 버전 @13.4.0은 react 버전 @18.0.0이랑 맞는답니다.   라이브러리끼리 서로 합의 봐주면 안되는 것이었을까요.   찾아보니 react-testing-libray 12버전은 react 18버전 아래로는 다 지원이 가능하다고 합니다.   🔨 문제 해결   react-testing-library를 12.1.5버전으로 다운그레이드 하겠습니다.   npm install @testing-library/react@^12.1.5   🚨 문제 발생 #3   npm ci명령에서 다시 문제가 발생했습니다.      package-lock.json파일을 삭제 후 다시 npm install해도 안되네요.   npm install로 npm을 설치해서 package-lock.json파일도 생성되었는데 왜 안될까요.   🔨 문제 해결   그것은 바로 제가 yarn.lock파일을 가지고 있었기 때문입니다.   프로젝트를 계속 yarn으로 진행했는데 이게 문제가 될 줄 몰랐습니다.   CI를 진행하는데 필요한 정보가 package-lock.json이 아니라 yarn.lock에 있었나 봅니다.   그렇다면 이제부턴 정말 yarn뿐입니다.   npm을 쓰든 yarn을 쓰든 하나의 매니저와 갑시다…   npm은 보내주고 yarn을 사용해 CI를 진행하겠습니다.   yarn으로 ci를 실행시키는 커맨드는 다음과 같습니다.   yarn install --immutable --immutable-cache --check-cache   [💾 CICD.yml]   문제된 부분을 수정합니다.   jobs:   CICD:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@main       - run: yarn install --immutable --immutable-cache --check-cache // 🎉       - run: yarn build // 🎉       - name: deploy to s3         uses: jakejarvis/s3-sync-action@master         with:           args: --delete         env:           AWS_S3_BUCKET: $           AWS_ACCESS_KEY_ID: $           AWS_SECRET_ACCESS_KEY: $           AWS_REGION: \"ap-northeast-2\"           SOURCE_DIR: \"build\"      드디어…CICD 파이프라인이 완성되었습니다. 🎉     🥶 오늘의 회고   공부를 하면 할수록 꼼수를 부리면 나중에 탈이 나고, 귀찮아서 넘기면 눈덩이처럼 커져 돌아오는것을 알았습니다.  그냥 애초에 눈에 보일 때 해결해야 뒤탈이 없습니다.  사실 toast-ui에 뭔가 버전이 안맞는 다는 걸 알았는데 개발환경에선 문제가 없길래 넘겼거든요.  인터스텔라가 흥행한 이유는 과거를 후회하는 인간이 많기 때문일까요.  이상 독학러의 주저리였습니다.     참고           what-are-the-corresponding-testing-library-react-versions-for-react-16-8-6            npm-ci-can-only-install-packages-with-an-existing-package-lock-json-or-npm-shrin      ","categories": ["coding-swamp"],
        "tags": ["모코늪","리액트 버전","toast-ui","다운 그레이드","testing-library","에러","npm"],
        "url": "/coding-swamp/coding-swamp-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%B2%84%EC%A0%84-%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[Lv 1] 자연수 뒤집어 배열로 만들기 by JS",
        "excerpt":"📄 문제   자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.      n은 10,000,000,000이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   const numToArr = [...String(n)].reverse(); // 1   let answer = [];   for (let i = 0; i &lt; numToArr.length; i++) {     answer.push(Number(numToArr[i])); // 2   }   return answer; }      주어진 숫자를 문자열로 바꿔 하나하나 배열의 요소로 만들어준 후 순서를 바꾼다.   answer에 numToArr의 요소를 숫자로 바꿔 삽입해준다.   뭔가 한줄짜리 코드로 바꿀 수 있을 것 같은데 깔끔하게 답이 나오지 않아 이렇게 제출했습니다.   👍 Best Practice 1   function solution(n) {   return (n + \"\")     .split(\"\")     .reverse()     .map((n) =&gt; parseInt(n)); }   역시 한줄짜리 답안이 있네요.   아직 배열 내장 메소드를 쓰는 것이 그렇게 익숙하지 않은듯 합니다.   그런데 왜 숫자 뒤에 공백을 붙이고 split(““)을 하면 문자열로 하나하나 쪼개질까요.   열심히 이리저리 콘솔을 찍어본 결과 숫자 뒤에 공백(““)을 붙이면 문자열이 되기 때문이었습니다.   제가 했던 [...String(n)]과 같은 과정이네요.   👍 Best Practice 2   function solution(n) {   var arr = [];    do {     arr.push(n % 10); // 1     n = Math.floor(n / 10); // 2   } while (n &gt; 0); // 3    return arr; }      주어진 자연수를 10으로 나누어 소수점 한자리를 나오게해 그 값을 arr에 넣어준다.   뒤에 소수점을 하나 떨궈내고 자릿수를 하나 줄인다.   n이 0이 될때까지 반복한다.   세상은 이런 분들이 바꿔가는걸까요.   저는 어떻게든 배열 메소드를 쓰려고 했는데 이런 멋진 방법이 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["reverse","split","스택/큐"],
        "url": "/programmers-lv1/programmers-%EC%9E%90%EC%97%B0%EC%88%98-%EB%92%A4%EC%A7%91%EC%96%B4-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "타입스크립트에서 함수 다루기",
        "excerpt":"타입스크립트에서 함수를 사용할때 변수를 사용할때와 마찬가지로 타입을 지정해주어야 합니다.   함수에서는 크게 매개변수와 반환값에 타입을 지정합니다.   📄 함수 매개변수   함수의 매개변수에 타입을 지정하면 그 매개변수는 필수 매개변수가 됩니다.   그렇다면 반대로 선택적 매개변수는 어떻게 지정할까요?   타입 애너테이션(:)앞에 ?를 붙여주면 됩니다.   function announceSong(song: string, singer?: string) {   console.log(`Song: ${song}`); }   announceSong함수의 매개변수인 singer은 선택적 매개변수가 되었습니다.   singer의 구체적인 타입은 string | undefined입니다.   이렇게 생성된 선택적 매개변수는 호출될때 생략해도 에러가 발생하지 않습니다.   ▪ 나머지 매개변수   나머지 매개변수는 매개변수의 개수를 특정할 수 없을 때 사용합니다.   스프레드 연산자(...)를 사용해 배열로 나타납니다.   function singAllTheSongs(singer: string, ...song: string[]) {   for (const song of songs) {     console.log(`${song}, by ${singer}`);   } }  singAllTheSongs(\"Day6\"); // ok singAllTheSongs(\"Day6\", \"예뻤어\", \"한 페이지가 될 수 있게\", \"때려쳐\"); // ok   📄 반환 타입   타입스크립트는 함수의 반환 타입도 유추할 수 있습니다.   따라서 타입스크립트가 명확하게 타입을 유추할 수 있는 상황이라면, 타입을 명시적으로 지정하는 것은 중복된 타입 지정이므로 지양하는 것이 좋습니다.   function(): 반환 타입 {   ... }  const name = (): 반환 타입 =&gt; {   ... }   📄 함수 타입   함수 타입은 함수를 매개변수에 값으로 넘겨줘야 하는 상황에 지정해야 합니다.   마찬가지로 타입이 맞지 않으면 에러가 발생합니다.   functions runOnSongs(getSonAt: (index: number) =&gt; string){   console.log(getSongAt('hello')); // Error. }   📄 그 외 반환 타입   ▪ void   반환 타입이 void인 경우는 다음과 같습니다.      return문이 없는 함수인 경우   값을 반환하지 않는 return문인 경우   반환 타입이 void인 경우 undefined와 잘 구분해야 합니다.   반환 타입이 void인 경우는 반환 타입이 무시된다는 것을 의미하고 undefined는 반환되는 리터럴값이기 때문입니다.   function returnVoid(){   return; }  let lazyValue: string | undefined;  lazyValue = returnVoid()\\ // Error: Type 'void' is not assignable to type 'string | undefined'   ▪ never   never 반환 타입은 의도적으로 오류를 발생시킵니다.   따라서 에러를 제어하는 경우에 사용합니다.   function fail(message: string): never {   throw new Error(`Invariant failure: ${message}`); }  function workWithUnasafeParam(param: unknown) {   if (typeof param !== \"string\") {     fail(`param should be a string, not ${typeof param}`);   }    param.toUpperCase(); }   참고      learning typescript  ","categories": ["TypeScript"],
        "tags": ["함수"],
        "url": "/typescript/typescript-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98-%EB%8B%A4%EB%A3%A8%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "[Lv 2] 다음 큰 숫자",
        "excerpt":"📄 문제   자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.      조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.   조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.   조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.   자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.      n은 1,000,000 이하의 자연수 입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   let answer = n;   const numberOfOne = n.toString(2).split(1).length - 1;    while (answer++) {     if (answer.toString(2).split(1).length - 1 == numberOfOne) return answer;   } }   저는 주어진 숫자에서 1을 더해가며 이진수로 변환 후 1의 개수를 split()메소드로 계산해 조건을 걸었습니다.   항상 익숙한 for문만 쓰다가 처음으로 while문을 써보았습니다.   👍 Best Practice   function solution(n, a = n + 1) {   return n.toString(2).match(/1/g).length == a.toString(2).match(/1/g).length     ? a     : solution(n, a + 1); }   주어진 문제 함수가 재귀함수가 되었네요.   조건이 맞을 때까지 계속 자기 자신을 호출하는 형태입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["이진수","알고리즘"],
        "url": "/programmers-lv2/programmers-%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Lv 1] 정수 내림차순으로 배치하기 by JS",
        "excerpt":"📄 문제   함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.      n은 1이상 8000000000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   return Number([...String(n)].sort((a, b) =&gt; b - a).join(\"\")); }   저는 주어진 숫자를 문자열 배열로 만들어 내림차순 한 뒤, 다시 문자열로 바꾸고 숫자로 반환했습니다.   배열 요소를 다 합해 문자열로 바꾸는 방법이 생각이 안나서 조금 헤맸습니다.   📌 배열 요소를 이어서 문자열로 바꾸는 방법: arr.join(\"\")  문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["내림차순","배열","문자열"],
        "url": "/programmers-lv1/programmers-%EC%A0%95%EC%88%98-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 2] 피보나치 수",
        "excerpt":"📄 문제   피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.   예를들어      F(2) = F(0) + F(1) = 0 + 1 = 1   F(3) = F(1) + F(2) = 1 + 1 = 2   F(4) = F(2) + F(3) = 1 + 2 = 3   F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다.   2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.      n은 2 이상 100,000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   아마 지금까지 풀었던 프로그래머스 문제 중 가장 오래걸렸던 문제였던 것 같습니다.   재귀로 접근하려고 했다가 실패하고 스택 개념을 적용했습니다.   function solution(n) {     let arr = [0, 1]     for(let i = 2; i &lt;= n; i++){         arr.push(arr[i-2] + arr[i-1])     }     return arr[n]%1234567 }   값이 하나씩 늘어갈 때마다 배열에 값을 넣어줬습니다.   하지만 모든 테스트 코드를 통과하지 못했습니다.   자바스크립트의 number의 범위는 2^53 -1이 최대이기 때문에 이 이상의 값이 나오면 에러가 발생하기 때문이었습니다.   여기서 시간이 오래걸려 주어진 힌트를 보고 문제를 다시 풀었습니다.   function solution(n) {     let arr = [0, 1]     for(let i = 2; i &lt;= n; i++){         arr.push((arr[i-2] + arr[i-1])%1234567)     }     return arr[n] }  매 연산에 %1234567을 해주어 너무 큰 값이 발생하지 않게 하는 것이었습니다.   이는 자바스크립트의 특징으로 파이썬의 경우에는 해당되지 않는다고 합니다.   ","categories": ["programmers-lv2"],
        "tags": ["피보나치 수","알고리즘","스택"],
        "url": "/programmers-lv2/programmers-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98/",
        "teaser": null
      },{
        "title": "[알고리즘] 시간 복잡도와  빅오(Big O) 계산법",
        "excerpt":"📄 시간 복잡도   프로그래머스 문제를 푸는데 이제 점점 성능을 고려해야할 필요성이 생겼습니다.  효율성 테스트를 넘어가야 하기 때문이죠. 🥶  똑같은 답일지라도 빨리 답이 나오는 코드가 더 좋은 성능을 가진 코드인데 이를 구별할 수 있게 하는 것이 시간 복잡도입니다.   시간 복잡도는   입력 값에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마나 걸리는 지 알려주는 지표입니다.   이 시간 복잡도를 나타내주는 방법 중 하나가 빅오(Big O) 표기법입니다.   📄 빅오(Big O) 표기법의 종류      ▪ O(1) | Constant Complexity   O(1)는 입력값에 상관없이 정해진 스텝의 계산을 실행합니다.   콘솔을 한번만 찍는 함수는 아무리 큰 입력값이 오더라도 계산에 영향을 끼치지 않습니다.   const constantComplexity = (arr) =&gt; {   console.log(\"hello\"); };  constantComplexity([1, 2, 3, 4, 5]);      스택의 push, pop   ▪ O(n) | linear complexity   O(n)는 입력값이 증가함에 따라 시간이 같은 비율로 증가합니다.   const linearComplexity = (n) =&gt; {   for(let i = 0; i &lt; n; i++&gt;){     ...   } }      for 문   ▪ O(n²) | Quadratic Complexity   O(n)는 입력값이 증가함에 따라 시간이 n²으로 증가합니다.   const quadraticComplexity = () =&gt; {   for (let i = 0; i &lt; n; i++) {     for (let j =0; j &lt; n; j++) {       ...   } }      이중 for문   삽입정렬(insertion sort)   선택정렬(selection sort)   거품정렬(bubble sort)   ▪ O(log N) | Logarithmic Complexity   O(n)는 입력값에 따라 처리 시간이 증가합니다.   O(n)은 입력 값이 1이 될 때까지 절반으로 나누는 작업을 반복합니다.  따라서 입력값에 따라 처리 시간이 증가하지만, 비례해서 증가하는 것이 아니므로 O(1)다음으로 빠른 계산법입니다.      이진 트리 탐색   퀵 정렬(quick sort)   병합정렬(merge sort)   힙 정렬(heap Sort)   출처      노마드 코더 - 개발자라면 이제는 알아야하는 Big O 설명해드림. 10분컷.   shitai.koto - [Algorithm] 시간 복잡도(Time complexity) 학습  ","categories": ["Algorithm"],
        "tags": ["시간 복잡도","빅오 계산법"],
        "url": "/algorithm/algorithm-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/",
        "teaser": null
      },{
        "title": "Math 메소드 정리",
        "excerpt":"📄 Math.abs(number)   ▪ 용도: 인수의 절댓값을 반환한다.   Math.abs(-1); // 1 Math.abs(\"\"); // 0 Math.abs([]); // 0 Math.abs(null); // 0 Math.abs(undefined); // NaN   📄 Math.round(number)   ▪ 용도: 소수점 이하를 반올림한 정수를 반환한다.   Math.round(1.2); // 1 Math.round(-1.6); // -2 Math.round(); // NaN   📄 Math.ceil(number)   ▪ 용도: 소수점 이하를 올림한 정수를 반환한다.   Math.ceil(1.4); // 2 Math.ceil(1); // 1 Math.ceil(); // NaN   📄 Math.floor(number)   ▪ 용도: 소수점 이하를 내림한 정수를 반환한다.   Math.floor(1.4); // 1 Math.floor(-1.8); // -2 Math.floor(); // NaN   📄 Math.sqrt(number)   ▪ 용도: 인수의 제곱근을 반환한다.   Math.sqrt(9); // 3 Math.sqrt(-9); // NaN Math.sqrt(); // NaN   📄 Math.random()   ▪ 용도: 0에서 1미만의 랜덤 숫자를 반환한다.   Math.random(); // 0.xxxxxxxx   📄 Math.pow(number, number)   ▪ 용도: 첫번째 인수를 밑, 두번째 인수를 지수로한 거듭제곱근을 반환한다.   Math.pow(2, 8); // 256  // ES7 거듭 제곱 연산자 2 ** 8; // 256   📄 Math.max(numbers)   ▪ 용도: 인수 중 최댓값을 반환한다.   Math.max(1, 2, 3); // 3   📄 Math.min(numbers)   ▪ 용도: 인수 중 최솟값을 반환한다.   Math.min(1, 2, 3); // 1  ","categories": ["JavaScript"],
        "tags": ["Math"],
        "url": "/javascript/javascript-Math-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 기능 개발 by JS",
        "excerpt":"📄 문제   프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.   또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.   먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.      작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.   작업 진도는 100 미만의 자연수입니다.   작업 속도는 100 이하의 자연수입니다.   배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.   🙋‍♀️ 나의 풀이   function solution(progresses, speeds) {   let answer = [];   let hundreds = 0;   while (progresses.length !== 0) {     // 1     for (let i = 0; i &lt; progresses.length; i++) {       progresses[i] += speeds[i];     } // 2     if (progresses[0] &gt;= 100) {       while (progresses[0] &gt;= 100) {         progresses.shift();         speeds.shift();         hundreds++;       } // 3       answer.push(hundreds); // 4       hundreds = 0;     }   }   return answer; }      시간 복잡도: O(n^2)      progresses의 길이가 0이 될 때까지 반복문을 실행합니다.   progresses에 인덱스를 맞춰 speeds를 더해줍니다.   만약 progresses의 첫번째 인덱스의 값이 100보다 큰 경우 shift메소드를 사용해 각 각 배열들의 첫번째 원소를 추출하고, 추출된 횟수를 나타내는 변수 hundreds에 1을 더합니다.   progresses의 첫번째 인덱스가 100보다 크지 않아 반복문을 나오면, 작업이 완료된 기능의 개수인 hundreds를 answer에 추가합니다.   문제를 풀 때 중첩 반복문이 나오면 답은 나와도 성능상 좋지 않게 느껴져 아쉽습니다.    👍 Best Practice   function solution(progresses, speeds) {   let answer = [0];   let days = progresses.map((progress, index) =&gt;     Math.ceil((100 - progress) / speeds[index])   );   let maxDay = days[0];    for (let i = 0, j = 0; i &lt; days.length; i++) {     if (days[i] &lt;= maxDay) {       answer[j] += 1;     } else {       maxDay = days[i];       answer[++j] = 1;     }   }    return answer; }   각 기능들이 배포에 걸리는 시간을 배열로 만들어(days) 조건에 따라 maxDay를 바꿔가며 days를 순환합니다.   아예 접근방식이 달라버리네요. 이럴수가 있다니..  속도나 성능을 떠나서 풀이 방식이 신기합니다.  처음에 눈으로 보고 이해가 안가서 종이에 하나하나 조건을 줘가면서 이해했습니다. 세상엔 똑똑한 사람이 많네요.  ","categories": ["programmers-lv2"],
        "tags": ["스택/큐","while"],
        "url": "/programmers-lv2/programmers-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C/",
        "teaser": null
      },{
        "title": "[알고리즘] 정렬 (sorting)",
        "excerpt":"📄 정렬 알고리즘   정렬 알고리즘은 물건을 정리하는 것 처럼 데이터를 정해진 순서대로 나열하는 알고리즘입니다.   정렬 알고리즘에는 대표적으로 버블 정렬, 선택 정렬, 삽입 정렬이 있습니다.   📄 버블 정렬 (Bubble Sort)   버블 정렬은 매 사이클마다 모든 배열 요소를 비교합니다.      0번째 원소와 1번째 원소를 비교 &amp; swap   1번째 원소와 2번째 원소를 비교 &amp; swap   n-1번째 원소와 n번째 원소를 비교 &amp; swap   버블 정렬은 중첩 반복이 발생하므로 O(N^2)의 시간복잡도를 가집니다.   function bubble(input) {   const len = input.length;   let tmp = null;   for (let i = 0; i &lt; len; i++) {     for (let j = 0; j &lt; len - i - 1; j++) {       if (input[j] &gt; input[j + 1]) {         // swap         tmp = input[j];         input[j] = input[j + 1];         input[j + 1] = tmp;         tmp = null;       }     }   } }   이때 최악의 경우 모든 요소를 swap해야 하기 때문에 직관적이지만 비효율적인 방식이라 자주 사용되진 않습니다.   📄 선택 정렬 (Selection Sort)   선택 정렬은 원소를 넣을 위치(인덱스)를 미리 정해놓고, 데이터셋을 순회하여 해당 원소를 찾습니다.   쉽게 얘기하자면, 오름차순으로 정리할 때 가장 작은 수를 찾아 맨 앞과 교환한다는 뜻입니다.      주어진 데이터셋에서 최소값을 찾는다.   해당 값을 맨 앞의 요소와 swap한다.   두번째 요소부터 위 과정을 반복한다.   function selectionSort (array){   for (let i = 0; i &lt; array.length; i++){     let minIndex = i;     for (let j = i + 1; j++){       if (array[minIndex] &gt; array[j]){         minIndex = j; // 1       }     }     if (minIndex !== i){ // 2       let swamp = array[minIndex];       array[minIndex] = array[i];       array[i] = swamp;     }   }   return array }   선택 정렬은 정렬이 되어 있는 경우, 되어 있지 않은 경우 모든 O(N^2)의 시간 복잡도를 가집니다.   📄 삽입 정렬   삽입 정렬은 한 사이클동안 모든 요소를 순환하지 않습니다.   사이클마다 해당 요소를 왼쪽에 있는 값들과 비교하고 알맞은 자리에 해당 요소를 삽입합니다.      두번째 요소를 왼쪽 요소와 비교하고 데이터셋을 정렬한다.   세번째 요소를 첫번째 요소와 두번째 요소와 비교하고 데이터셋을 정렬한다.   배열의 크기만큼 위 과정을 반복한다.   function insertionSort(array) {   for (let i = 1; i &lt; array.length; i++) {     let cur = array[i];     let left = i - 1;      while (left &gt;= 0 &amp;&amp; array[left] &gt; cur) {       array[left + 1] = array[left];       left--;     }     array[left + 1] = cur;   }   return array; }   삽입 정렬의 경우 정렬이 모두 되어 있는 최선의 경우에는 O(N)의 시간복잡도를 가지고,  정렬이 되어 있지 않은 최악의 경우에는 O(N^2)의 시간 복잡도를 가집니다.   참고      노마드 코더 - 어? 재밌네? 정렬 알고리즘, 한방에 이해하기!   Code Playground  ","categories": ["Algorithm"],
        "tags": ["버블 정렬","선택 정렬","삽입 정렬"],
        "url": "/algorithm/algorithm-%EC%A0%95%EB%A0%AC/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] k번째수",
        "excerpt":"📄 문제   배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.   예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면   array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.      array의 길이는 1 이상 100 이하입니다.   array의 각 원소는 1 이상 100 이하입니다.   commands의 길이는 1 이상 50 이하입니다.   commands의 각 원소는 길이가 3입니다.   🙋‍♀️ 나의 풀이 #1   function solution(array, commands) {   let answer = [];   for (let i = 0; i &lt; commands.length; i++) {     answer.push(       array.slice(commands[i][0] - 1, commands[i][1]).sort((a, b) =&gt; a - b)[         commands[i][2] - 1       ]     );   }   return answer; }      주어진 배열 array를 요구사항대로 자르고 sort() 메소드로 정렬했습니다.   그래도 정렬 알고리즘을 배웠으니 한번 메소드를 사용하지 않고 풀어보겠습니다.   🙋‍♀️ 나의 풀이 #2   삽입 정렬을 사용한 풀이입니다.   function solution(array, commands) {   let answer = [];   for (let i = 0; i &lt; commands.length; i++) {     const slicedArray = array.slice(commands[i][0] - 1, commands[i][1]);     // 삽입 정렬 시작     for (let j = 1; j &lt; slicedArray.length; j++) {       let cur = slicedArray[j];       let left = j - 1;        while (left &gt;= 0 &amp;&amp; slicedArray[left] &gt; cur) {         slicedArray[left + 1] = slicedArray[left];         left--;       }       slicedArray[left + 1] = cur;     }     answer.push(slicedArray[commands[i][2] - 1]);   }   return answer; }      속도면에서는 크게 다른 점이 없습니다.   👍 Best Practice   function solution(array, commands) {   return commands.map((command) =&gt; {     const [sPosition, ePosition, position] = command;     const newArray = array       .filter(         (value, fIndex) =&gt; fIndex &gt;= sPosition - 1 &amp;&amp; fIndex &lt;= ePosition - 1       )       .sort((a, b) =&gt; a - b);      return newArray[position - 1];   }); }   주어진 조건 commands를 구조 분해 할당을 사용해 가독성을 높인 풀이입니다.   slice 메소드가 아니라 filter 메소드를 사용해 배열을 자를 수도 있다는걸 하나 알아갑니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["정렬","k번째 수"],
        "url": "/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 하샤드 수",
        "excerpt":"📄 문제   양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.      x는 1 이상, 10000 이하인 정수입니다.   🙋‍♀️ 나의 풀이   function solution(x) {   let sum = [...x.toString()].reduce((acc, cur) =&gt; {     return (acc += Number(cur));   }, 0);   return x % sum === 0; }      주어진 숫자(x)를 문자열로 변환 후, 각 자릿값을 배열의 요소로 만든다.   배열의 요소를 reduce메소드를 사용해 더한 누적값을 변수 sum에 할당한다.   요구사항대로 주어진 숫자를 누적값으로 나누었을 때 0이 되는지에 대한 boolean값을 반환한다.   처음으로 프로그래머스에서 reduce함수를 사용했습니다.   점점 응용하는 메소드가 생길수록 뿌듯합니다.   👍 Best Practice   function Harshad(n) {   return !(n % (n + \"\").split(\"\").reduce((a, b) =&gt; +b + +a)); }   반환값을 true/false가 아닌 0과 1을 통해 표현할 수도 있다는 것을 적용한 식입니다. 👍   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["하샤드 수","reduce"],
        "url": "/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 가장 큰 수",
        "excerpt":"📄 문제   0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.   예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.   0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.      numbers의 길이는 1 이상 100,000 이하입니다.   numbers의 원소는 0 이상 1,000 이하입니다.   정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.   🙋‍♀️ 나의 풀이   function solution(numbers) {   let answer = numbers     .map((value) =&gt; value + \"\")     .sort((a, b) =&gt; b + a - (a + b))     .join(\"\");    return answer[0] === \"0\" ? \"0\" : answer; }      주어진 배열 numbers를 순회해 sort()메소드를 적용한다.’   인접한 두 수를 순서를 바꿔 비교하고 내림차순한다.   완성된 배열을 join(““)으로 문자열로 바꾼다.   만약 [0, 0, 0]인경우 답이 “000”이 되므로 삼항연산자를 이용해 첫번째 자릿수가 0인경우 0을 바로 반환한다.  ","categories": ["programmers-lv2"],
        "tags": ["가장 큰 수","정렬","sort"],
        "url": "/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 두 정수 사이의 합",
        "excerpt":"📄 문제   두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요. 예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.      a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.   a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.   a와 b의 대소관계는 정해져있지 않습니다.   🙋‍♀️ 나의 풀이   function solution(a, b) {   let [newA, newB] = [a, b].sort((a, b) =&gt; a - b); // 1   let sum = 0;   for (let i = newA; i &lt;= newB; i++) {     // 2     sum += i;   }   return sum; }      주어진 정수를 배열에 담아 정렬후 구조분해 할당을 사용해 새로운 값을 만들었다.   반복문으로 newA부터 newB까지의 합을 구해 답을 반환한다.   👍 Best Practice   function adder(a, b, s = 0) {   for (var i = Math.min(a, b); i &lt;= Math.max(a, b); i++) s += i;   return s; }   Math 메소드를 적절히 활용한 풀이입니다. 👍  ","categories": ["programmers-lv1"],
        "tags": ["sort"],
        "url": "/programmers-lv1/programmers-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4-%ED%95%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 콜라츠 추측",
        "excerpt":"📄 문제 출처   1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.   예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.      입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.   🙋‍♀️ 나의 풀이   function solution(num) {   let answer = 0;   while (num &gt; 1) {     num = num % 2 === 0 ? num / 2 : num * 3 + 1;     answer++;     if (answer === 500) return -1;   }   return answer; }   재귀함수를 사용해 볼까 하다가 성능상 반복문이 더 좋을 것 같아 while문에 조건을 걸어 num가 1이 될때 까지 반복했습니다.   👍 Best Practice   function collatz(num, count = 0) {   return num == 1     ? count &gt;= 500       ? -1       : count     : collatz(num % 2 == 0 ? num / 2 : num * 3 + 1, ++count); }   그래도 재귀함수를 사용한 풀이는 멋있네요.   삼항 연산자를 중첩으로 사용할 수 있다는 것도 처음 알아갑니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["콜라츠 추측"],
        "url": "/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/",
        "teaser": null
      }]
