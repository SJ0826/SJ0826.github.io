var store = [{
        "title": "컨테이너와 전역 속성",
        "excerpt":"📄 컨테이너 태그   콘텐츠에 아무런 영향을 주지 않고, 여러 요소를 묶어 관리하기 편하게 만드는 역할을 하는 태그입니다.   div: 블록 레벨 컨테이너      페이지 전체 면적을 차지합니다.   span: 인라인 컨테이너   지정한 부분의 면적만 차지합니다.   📄 전역 속성   전역속성(Global attributes)은 모든 HTML 태그에서 공통으로 사용할 수 있는 속성입니다.   &lt;태그명 속성명=**속성값** 속성명=**속성값**&gt;콘텐츠&lt;/태그명&gt;   대표적인 전역 속성들      id: 요소에 고유한 이름을 부여하는 식별자 역할 속성입니다. id는 태그당 하나씩만 지정합니다.   class: 요소를 그룹 별로 묶을 수 있는 식별자 역할 속성입니다. class는 다중 지정 및 중복이 가능합니다.   style: 요소에 적용할 CSS스타일을 선언하는 속성입니다.   title: 요소의 추가 정보를 제공하는 텍스트 속성입니다. 사용자에게 툴팁을 제공합니다.  ","categories": ["HTML"],
        "tags": ["HTML","컨테이너","전역속성"],
        "url": "/html/html-container/",
        "teaser": null
      },{
        "title": "HTML 문서 기본 구조",
        "excerpt":"📄 HTML이란?      HyperText: 하이퍼링크를 통해 어떤 문서에서 다른 문서로 접근할 수 있는 텍스트   MarkUp: (콘텐츠를) 표시하다   Language: 언어   즉, HTML은 웹브라우저를 통해 표시되는 웹페이지의 콘텐츠를 정의하기 위해 사용하는 언어입니다.   📄 HTML 문서 기본 구조   ▪ &lt;!DOCTYPE html&gt;   문서의 첫 부분에서 문서 유형을 지정하는 단일 태그입니다.   &lt;!DOCTYPE html&gt;   ▪ &lt;html&gt; ~ &lt;/html&gt;   문서 유형을 지정한 후 실제 문서가 시작되고 끝나는 것을 나타내는 태그입니다.   &lt;html&gt;   ... &lt;/html&gt;   ▪ &lt;head&gt; ~ &lt;/head&gt;   웹 브라우저 화면에는 보이지 않지만 웹 브라우저가 알아야 할 정보들입니다.   ▪ &lt;meta charset=\"utf-8\"&gt;   문자 인코딩 및 문서 키워드 등에 대한 요약 정보를 기입하는 단일 태그입니다.  영문과 한글을 모두 사용하기 위해 utf-8 방식을 사용하는 것이 좋습니다.    ▪ &lt;title&gt; ~ &lt;/title&gt;   문서의 제목을 나타냅니다. 콘텐츠는 브라우저 탭에 표시됩니다.       ▪ &lt;body&gt; ~ &lt;/body&gt;   실제 브라우저 화면에 표시될 내용을 입력하는 태그입니다.     들여쓰기를 깔끔하게 해서 가독성을 높이자   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그"],
        "url": "/html/html-html-docs-structure/",
        "teaser": null
      },{
        "title": "이미지 표시하기",
        "excerpt":"📄 이미지를 보여주는 img 태그   html에서는 이미지를 보여줄 때 img라는 단일 태그를 사용합니다.   &lt;img src=\"표시할 이미지 파일\" alt=\"이미지설명\" /&gt;   이때 alt는 대체 택스트 역할을 합니다.   이미지가 로딩되기 전이나 이미지 로딩에 실패한 경우   이미지 대신에 대체 텍스트가 표시됩니다.   이미지 유실 상황에 대비하거나 시각 장애인을 위한 콘텐츠에 유용합니다.(음성인식기 활용)   📄 이미지 크기 조절하기   width와 height로 크기를 지정합니다.   이때 너비와 높이는 각각 픽셀(px)단위로 적용됩니다.   &lt;img   src=\"표시할 이미지 파일\"   alt=\"이미지 설명\"   width=\"너비 값\"   height=\"높이 값\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","img"],
        "url": "/html/html-image/",
        "teaser": null
      },{
        "title": "입력 요소 만들기(input)",
        "excerpt":"📄 input 태그   입력요소는 &lt;input&gt; 태그를 이용해 만들어 줍니다.   &lt;input&gt;태그는 인라인 요소이며, 단일 태그입니다.   &lt;input&gt;태그에는 name식별자를 추가하여 각각 어떤 특징을 가지는지 설명하는 것이 좋습니다.   📄 input 태그의 type 속성   type값에 따라 입력 요소의 형태나 입력 데이터 유형 등이 달라집니다.   1. text: 텍스트 메세지를 입력합니다.   &lt;input name=\"text\" type=\"text\" maxlength=\"5\" placeholder=\"메세지입력\" /&gt;      maxlength: 텍스트 최대 크기를 지정합니다.   place holder: 텍스트 입력 전 창에 띄워지는 텍스트를 지정합니다.   2. button: 버튼이 생성됩니다.   &lt;input name=\"button\" type=\"button\" value=\"PUSH\" /&gt;   3. color: 색을 지정할 수 있는 팔레트가 띄워 집니다.   &lt;input name=\"color\" type=\"color\" /&gt;   4. rage: 숫자로 된 값을 입력 할 수 있는 바를 만들어 줍니다.   &lt;input name=\"score\" type=\"range\" max=\"100\" min=\"0\" step=\"10\" /&gt;   5. date: 날짜를 입력할 수 있는 달력이 생성됩니다.   &lt;input name=\"birthdaty\" type=\"date\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","input"],
        "url": "/html/html-input/",
        "teaser": null
      },{
        "title": "링크 만들기",
        "excerpt":"📄 링크(Link)   링크는 현재 문서에서 다른 문서로 이동할 수 있는 수단입니다.   링크는 a 태그를 사용합니다.   a 태그에 사용하는 속성      href: 링크가 참조하고자 하는 url을 입력합니다.   target: 링크 클릭 시 현재 탭에서 열지 새로운 탭에서 열지 결정합니다   &lt;a href=\"www.naver.com\" target=\"_self\"&gt; 현재 탭에서 열기(기본값) &lt;/a&gt;  &lt;a href=\"www.naver.com\" target=\"_blank\"&gt; 새로운 탭에서 열기 &lt;/a&gt;   이 외에도 href에 전화번호나 메일 주소 등을 지정 할 수 있습니다.   &lt;a href=\"tel:010-1234-5678\"&gt;   전화 걸기   &lt;!-- 데스크탑일 경우 전화기능이 없다면 사용 불가--&gt; &lt;/a&gt;  &lt;a href=\"mailto:ikosdu60@gmail.com\"&gt; 메일 쓰기 &lt;/a&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","link"],
        "url": "/html/html-link/",
        "teaser": null
      },{
        "title": "블록 레벨 요소와 인라인 요소",
        "excerpt":"📄 태그의 구분   블록 레벨 요소를 만드는 태그 vs 인라인 요소를 만드는 태그   📄 블록 레벨 요소   블록 레벨 요소는 페이지의 너비를 모두 차지하여 블록을 형성합니다.  아래와 같이 개발자도구(단축키:F12)를 사용하면  페이지의 너비를 모두 차지하고 있는 것을 확인할 수 있습니다.  블록 안에 블록을 생성하면 공간이 형성되어 층이 생깁니다.     📄 인라인 요소   인라인 요소는 콘텐츠를 표시하기 위해 필요한 공간만 차지합니다.  블록 요소 안에 인라인 요소를 넣어도 인라인 요소는 필요한 공간만 차지합니다.     ","categories": ["HTML"],
        "tags": ["HTML","블록 레벨","인라인 레벨"],
        "url": "/html/html-tag&inlinetext/",
        "teaser": null
      },{
        "title": "텍스트 태그 사용 방법과 특징",
        "excerpt":"📄 문단(paragraph)   문단 요소를 나타내는 태그로써, 가장 많이 사용되는 텍스트 태그 입니다.  문단과 문단 사이에는 공백이 있습니다.   &lt;p&gt;이것은 문단을 표시하는 태그입니다.&lt;/p&gt;   📄 제목(headline)   h 태그는 제목 요소를 나타냅니다.  숫자와 함께 사용되며, 숫자가 1일 때 가장 크고 6일 때 가장 작습니다.   &lt;h1&gt;제목을 나타내자!&lt;/h1&gt; &lt;h2&gt;제목을 나타내자!&lt;/h2&gt; &lt;h3&gt;제목을 나타내자!&lt;/h3&gt; &lt;h4&gt;제목을 나타내자!&lt;/h4&gt; &lt;h5&gt;제목을 나타내자!&lt;/h5&gt; &lt;h6&gt;제목을 나타내자!&lt;/h6&gt;   ✔ 결과   제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!   📄 수평선   hr 태그는 수평선을 표시하는 태그입니다.  주로 주제 변경 또는 내용 구분을 위해 단일 태그로 사용됩니다.   &lt;hr /&gt;   📄 줄바꿈태그와 공백문자   br태그는 줄바꿈을 담당하는 단일 태그입니다.   &lt;br /&gt;   html 문서에서 스페이스바로 공백을 두 번 이상 입력해도 표시되지 않습니다.  공백을 두 번 이상 표시할 때는 &amp;nbsp를 사용합니다.   &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","텍스트 태그"],
        "url": "/html/html-texttag/",
        "teaser": null
      },{
        "title": "CSS 함수",
        "excerpt":"📄 CSS 함수   CSS의 속성값을 지정할 때 함수의 성격을 적용할 수 있습니다.   CSS함수는 괄호 안에 인수를 전달하면, 인수에 따른 결과값을 속성에 적용하는 방식으로 동작합니다.   📄 calc()   CSS함수 중 계산을 담당하는 함수 입니다.   괄호안의 표현식을 결과값으로 적용합니다.   .message_text {   width: calc(100% - 100px); }   이렇게 message_text를 가변적인 크기로 설정이 가능합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["calc"],
        "url": "/css/css-cssfunction/",
        "teaser": null
      },{
        "title": "폼(form) 태그",
        "excerpt":"📄 폼(form) 태그   form은 입력 요소를 감싸며 입력 값을 서버 측으로 제출합니다.  입력값을 클라이언트가 서버로 전송하면 서버 측에서는 데이터를 처리한 결과를 클라이언트에게 보내줍니다.   📄 폼(form)태그의 속성      action: 입력값을 전송할 서버의 url   method: 클라이언트가 입력한 데이터를 어떤 식으로 전송할 방법(GET or POST)   &lt;form action=\"example.php\" method=:\"POST\"&gt;     &lt;input type=\"submit\" value=\"전송\"&gt; &lt;/form&gt;       GET: 서버로 요청을 보내 응답을 받아냅니다. POST: 서버에 요청을 보내어 서버에 있는 데이터를 추가/수정/삭제한 후에 응답을 받아냅니다.   ","categories": ["HTML"],
        "tags": ["HTML","form"],
        "url": "/html/html-form/",
        "teaser": null
      },{
        "title": "HTML코드 기초 문법",
        "excerpt":"📄 태그(tag)   HTML 코드에서 정보(콘텐츠)를 정의하는 형식입니다.   &lt;태그명&gt; 여기에 콘텐츠를 기입합니다.&lt;/태그명&gt; &lt;/태그명&gt; // 단일 태그 사용 형태   📄 속성   태그의 부가적인 기능을 정의합니다.   &lt;태그명 속성명=\"속성값\"&gt;내용이 들어감&lt;/태그명&gt; &lt;태그 속성명=\"속성값\"/&gt; //단일 태그 사용 형태   📄 주석   사람에게는 보이지만, 웹브라우저에게는 보이지 않는 코드입니다.   주로 메모를 남기기 위해 사용됩니다.   &lt;!--** 이 사이에 작성한 내용은 주석으로 처리된다. **--&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그","속성","주석"],
        "url": "/html/html-html-grammner/",
        "teaser": null
      },{
        "title": "목록 표시하기",
        "excerpt":"📄 ul   순서 있는 항목은 &lt;ul&gt;태그로 작성합니다.   &lt;ul&gt;   &lt;li&gt;토끼&lt;/li&gt;   &lt;li&gt;다람쥐&lt;/li&gt;   &lt;li&gt;청설모&lt;/li&gt;   &lt;li&gt;호랑이&lt;/li&gt; &lt;/ul&gt;   이와 같이 항목 하나하나는 &lt;li&gt;로 표시합니다.   ul태그로 작성하면 앞에 숫자가 붙습니다.   📄 ol   순서 없는 항목은 &lt;ol&gt;태그로 작성합니다.   &lt;ol&gt;   &lt;li&gt;HTML&lt;/li&gt;   &lt;li&gt;CSS&lt;/li&gt;   &lt;li&gt;JAVAScript&lt;/li&gt;   &lt;ol&gt;&lt;/ol&gt; &lt;/ol&gt;   &lt;ul&gt;태그와 &lt;ol&gt;태그와 &lt;li&gt;태그는 모두 블록 레벨 요소를 만드는 태그입니다.  ","categories": ["HTML"],
        "tags": ["HTML","ul","ol","li"],
        "url": "/html/html-list/",
        "teaser": null
      },{
        "title": "메타(meta) 태그",
        "excerpt":"📄 메타(meta) 태그   meta 태그는 HTML 문서의 정보를 표시하는 태그입니다.   검색엔진 최적화에 기여하며, 검색 결과에도 영향을 끼칩니다.   개발자가 페이지를 참고할 때 도움이 되기도 합니다.   📄 메타 태그의 다양한 속성들   1. charset   문자 인코딩에 대한 요약 정보를 기입하는 속성입니다.   주로 영문과 한글을 모두 사용하기 위해 utf-8방식을 사용합니다.   &lt;meta charset=\"uth-8\" /&gt;   2. http-eqiv   콘텐츠 속성의 정보/값에 대한 HTTP 헤더를 제공합니다.   &lt;!-- IE 브라우저의 최신 버전의 엔진을 사용하라는 뜻--&gt; &lt;meta http-equiv=\"x-ua-compatible\" content=\"IE-edge\" /&gt; &lt;!-- 10초마다 페이지 새로고침하라는 뜻--&gt; &lt;meta http-equiv=\"refresh\" content=\"10\" /&gt;   3.name name 속성을 이름으로, content 속성을 값으로 하여 문서 정보를 제공합니다.   &lt;!--문서 제작자--&gt; &lt;meta name=\"author\" content=\"유노코딩\" /&gt; &lt;!-- 페이지에 대한 요약--&gt; &lt;meta name=\"desciption\" content=\"페이지에 대한 짧고 명확한 요약\" /&gt; &lt;!-- 페이지의 콘텐츠와 관련된, 쉼표로 구분한 키워드 목록--&gt; &lt;meta   name=\"keywords\"   content=\"예를 들면, 강아지, 고양이, 정보, 반려동물, 등등\" /&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","메타 태그","charset","http-eqiv","name"],
        "url": "/html/html-metatag/",
        "teaser": null
      },{
        "title": "select & textarea",
        "excerpt":"📄 select   select는 다수의 옵션(선택지)를 포함할 수 있는 선택 메뉴입니다.   메뉴 안에 포함되는 옵션은 option 태그를 사용하여 표시합니다.   &lt;select&gt;     &lt;option value=\"starbucks\"&gt;스타벅스&lt;/option&gt;     &lt;optio nvalue=\"coffeebean\"&gt;커피빈&lt;/option&gt;     &lt;option value=\"ediya\"&gt;이디야&lt;/option&gt;     &lt;option value=\"pascucci\"&gt;파스쿠찌&lt;/option&gt; &lt;/select&gt;      선택지에서 커피빈을 고른다 = cafe의 입력 값은 coffebean이다    📄 textarea   textarea는 여러 줄의 일반 텍스트를 입력할 수 있는 입력 요소입니다.   &lt;textarea name=\"letter\" rows=\"10\" cols=:10\"&gt;기본적으로 쓰여 있는 텍스트&lt;/textarea&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","select","textarea"],
        "url": "/html/html-select&textarea/",
        "teaser": null
      },{
        "title": "CSS box-sizing",
        "excerpt":"📄 box-sizing 속성   box-sizing 속성은 너비와 높이가 포함할 영역을 변경함으로써 너비와 높이의 계산 방법을 결정할 수 있습니다.      content-box: 기본값. 너비와 높이가 콘텐츠 영역만을 포함합니다. padding이 추가 되어도 content크기는 보장받고 싶을 때 씁니다.   border-box: 너비와 높이가 안쪽 여백과 테두리까지 포함합니다.   div {   content-box: border-box; }      개발자도구를 통해 padding이 추가되어도 content크기는 변하지 않은 것을 확인할 수 있습니다.  ","categories": ["CSS"],
        "tags": ["content-box","border-box"],
        "url": "/css/css-boxsizing/",
        "teaser": null
      },{
        "title": "CSS 선택자",
        "excerpt":"📄 CSS 선택자   선택자는 어떤 요소에 대한 스타일을 정의할 것인지에 대한 정보입니다.   📄 선택자의 종류   1. 전체 선택자   애스터리스크(*)는 문서 내의 모든 요소를 의미합니다.   * {   color: blue; }   2. 태그 선택자(유형 선택자)   주어진 이름을 가진 요소를 선택합니다.   p {   color: blue; }   3. 클래스 선택자   주어진 class 속성값을 가진 요소를 선택합니다.   .text {   color: blue; }   4. 아이디 선택자   주어진 id 속성값을 가진 요소를 선택합니다.   #topic {   color: blue; }   5. 그룹 선택자   다양한 유형의 요소를 한꺼번에 선택하고자 할 때 사용합니다.  쉼표(,)를 이용해 선택자를 그룹화 합니다.   h1, p, div {   color: blue; }   📄 선택자의 우선순위   아이디 선택자 &gt; 클래스 선택자 &gt; 태그 선택자   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["css 선택자"],
        "url": "/css/css-cssSelector/",
        "teaser": null
      },{
        "title": "CSS기본문법",
        "excerpt":"📄 CSS란?   ▪ Cascading: 계단식  ▪ Style: 멋을 내다  ▪ Sheets: (종이)한 장    즉, 계단식으로 스타일을 정의하는 문서입니다.    css는 웹문서를 꾸며주기 위해 사용하는 언어입니다.    확장자는 *.css입니다.    css문서는 html문서와 함께 작업을 수행합니다.   &lt;link href=\"style.css\" rel=\"stylesheet\"&gt;   이와 같이 html문서에 css문서의 링크를 걸어주어 작업을 수행하게 됩니다.   📄 CSS 기본 구성   선택자 {   속성명: 속성값; }      선택자: 어떤 요소에 스타일을 적용할지에 대한 정보   {중괄호}: 선택한 요소에 적용할 스타일을 정의하는 영역   속성명: 어떤 스타일을 정의하고 싶은지에 대한 정보(색상, 크기 등)   속성값: 어떻게 정의하고 싶은지에 대한 정보   📄 주석   p {   /* 이 안에 작성하면 주석으로 처리됩니다. */ }   📄 HTML에 CSS문서를 적용하는 법      인라인 스타일: 태그에 직접 기술합니다.   스타일 태그: 스타일시트를 위한 태그를 추가하여 기술합니다   문서 간의 연결: 스타일시트 문서를 따로 작성하여 HTML 문서와 연결합니다.   &lt;link href=\"./style.css\" rel=\"stylesheet\" /&gt;      href: 연결하고자 하는 외부 소스의 url을 기술하는 속성   rel: 현재 문서(HTML)와 외부 소스의 연관 관계를 기술하는 속성    출처      유노코딩  ","categories": ["CSS"],
        "tags": ["css 구성","css 주석"],
        "url": "/css/css-cssgrammer/",
        "teaser": null
      },{
        "title": "display속성&border속성",
        "excerpt":"📄 display 속성   display 속성은 요소를 블록과 인라인 요소 중 어느 쪽으로 처리할지 정의합니다.   display 속성 값      inline: 인라인으로 처리   block: 블록 레벨로 처리   inline-block: 인라인으로 배치하되, 블록 레벨 요소의 속성을 추가할 수 있도록 처리   none: 존재는 하되, 디스플레이하지 않음   div {   display: inline; } div {   display: block; } div {   display: inline-block; } div {   display: none; }   📄 border 속성   요소가 차지하고 있는 영역에 테두리를 그릴 수 있습니다.  border 속성에는 속성값으로 테두리의 두께, 모양, 크기 등을 함께 지정할 수 있는데,  이러한 속성을 ‘단축속성’이라고 합니다.   &lt;!--두께가 2px인 직선 모양(solid)의 초록(green) 테두리를 만들어줘-- &gt; span {   border: 2px solid green; }   border 속성의 하위 속성      border-color: color 정의 방식과 동일   border-width: thin, medium, thick 등의 키워드 또는 px, em, rem 등의 단위   border-style: none, solid, dotted, dashed 등   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["display","border"],
        "url": "/css/css-display&border/",
        "teaser": null
      },{
        "title": "margin&padding 다루기",
        "excerpt":"📄 하위 속성 정의하기   div {   padding-top: 10px;   padding-right: 20px;   padding-bottom: 30px;   padding-lefr: 40px; }   위와 같이 margin에도 동일한 접미사를 붙여 개별 정의할 수 있습니다.   📄 여러 값을 한 번에 정의하기   span {   display: inline-block;   width: 100px;   height: 100px;   margin: 10px 20px 30px 40px;   &lt;!--순서: top-right-bottom-left--&gt;; }   위와 같이 padding에도 동일한 접미사를 붙여 개별 정의할 수 있습니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["margin","padding"],
        "url": "/css/css-margin&padding/",
        "teaser": null
      },{
        "title": "특성 선택자와 결합자",
        "excerpt":"📄 특성 선택자   특성 선택자(속성 선택자)는 주어진 속성의 존재 여부나 그 값에 따라 요소를 선택합니다.   [class] {   background-color: tomato; // 클래스 속성을 가진 요소에 컬러 적용. }  [class=\"item\"] {   background-color: tomato; // 클래스가 item인 요소에 컬러 적용. }  [class*=\"it\"] {   color: white; // 클래스 값에 \"it\"가 포함되는 요소에 컬러 적용. }  [class^=\"it\"] {   color: white; // 클래스 값이 \"it\"으로 시작하는 요소에 컬러 적용. }  [class$=\"it\"] {   color: white; //클래스 값이 \"it\"으로 끝나는 요소에 컬러 적용. }   📄 결합 선택자   결합 선택자(결합자)는 두 개 이상의 선택자를 결합시켜 결합된 조건을 만족하는 요소를 선택합니다.   ▪ 자손 결합자   두 개의 선택자 중 첫 번째 선택자 요소의 자손을 선택할 수 있습니다.   div p {   color: white; // div요소 안에 위치하는 모든 p 요소에 컬러 적용. }  div &gt; p {   color: white; // div 요소의 바로 아래에 위치하는 모든 p 요소에 컬러 적용. }   ▪ 형제 결합자   두 개의 선택자 중 첫 번째 선택자 요소의 형제를 선택할 수 있다.   h1 ~ p {   color: red; // h1 요소의 뒤에 오는 형제 중 모든 p 요소에 컬러 적용. }  h1 + p {   color: red; } // h1 요소의 바로 뒤에 오는 형제 p 요소에 컬러 적용.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["특성 선택자","자손 결합자","형제 결합자"],
        "url": "/css/css-Attribute_selectors/",
        "teaser": null
      },{
        "title": "fixed&sticky",
        "excerpt":"📄 position: fixed;   요소를 일반적인 문서의 흐름에서 제거하고, 지정된 위치에 고정시킵니다.   .pos {   position: fixed;   top: 50px;   left: 50px; }      위에서부터 50px 왼쪽에서부터 50px 떨어진 자리에서 움직이지 않는다.    📄 position: sticky;   요소를 일반적인 문서 흐름에 따라 배치하고, 스크롤(roll)되는 가장 가까운 상위 요소에 대해 오프셋을 적용합니다.   .pos {   position: sticky; }      스크롤 이동으로 요소가 움직여도 스티키 요소는 고정된 상태를 유지한다.    출처      유노코딩  ","categories": ["CSS"],
        "tags": ["fixed","sticky"],
        "url": "/css/css-fixed&sticky/",
        "teaser": null
      },{
        "title": "float&clear",
        "excerpt":"📄 float   float속성은 요소가 문서의 흐름에서 제외되어 자신을 포함하고 있는 컨테이너의 왼쪽이나 오른쪽에 배치되게 합니다.  문서의 흐름에선 제외되지만, 필요한 만큼의 공간은 차지합니다.   주로 레이아웃을 구성할 때 블록레벨 요소를 가로 정렬하기 위해 사용됩니다.   float의 속성값      none: 기본값   left: 왼쪽부터 가로정렬   right: 오른쪽부터 가로정렬   float: left; float: right; margin: 0 auto; /* 중앙 정렬 */   📄 clear   clear속성은 float 요소 이후에 표시되는 요소의 동작들을 조절합니다.   컨테이너 요소에 float요소를 적용하고 이후 요소에 더이상 float을 적용하고 싶지 않을 때 사용합니다.   clear의 속성값      none: 기본값   left: float이 left인 요소의 아래로 내려가겠다    right: float이 right인 요소의 아래로 내려가겠다    both: float이 left및 right인 요소의 아래로 내려가겠다    .left {   background-color: #ff8c00;   width: 150px;   height: 50px;   float: left; } .right {   background-color: #9932cc;   width: 150px;   height: 50px;   float: right; } p {   clear: both; }   출처           유노코딩            Inpa Dev - Float 속성 간단 정리      ","categories": ["CSS"],
        "tags": ["fixed","sticky"],
        "url": "/css/css-float&clear/",
        "teaser": null
      },{
        "title": "GIT에 대한 이해",
        "excerpt":"📄 GIT에 대한 이해   GIT은 VCS(VersionControlSystem)중 하나 입니다.  서버에만 히스토리 정보가 있는것이 아니라 모든 개발자들이 동일한 히스토리 정보를 가지고 있는 것을 분산형 버전관리 시스템이라고 합니다.  분산된 시스템을 이용하게 되면 서버에 문제가 생기거나 인터넷이 없어도 각각의 개발자 들이 일을 진행 할 수 있습니다.  깃에는 원격 저장소가 중앙서버 역할을 하여 사용자의 컴퓨터에 있는 로컬 저장소와 소스코드를 주고 받습니다.  따라서 다른 사용자와 협업할 때도 유용하며 코드의 변경내역을 기록하기 때문에 안전하게 소스를 작성할 수 있습니다.   📄 용어 정리      초기화: 폴더를 깃 저장소로 변경합니다. 아래와 같이 커맨드창에 입력하여 초기화 할 수도 있습니다.   git init      커밋: 변경된 코드의 이력을 기록합니다.   브랜치: 분리 격리된 코드의 이력을 기록합니다.   병합: 기존 이력과 분리된 이력을 통합합니다.   푸시: 로컬 저장소의 이력을 서버로 전송 및 공유합니다.   공부한 곳   [더 북] https://thebook.io/080212/ [강 의] 드림코딩     깃을 이해하여 보다 나은 코드 작성을 위해 차근차근 익혀 나간다.  그냥 넘겼었던 용어를 다시 보고 이해가 안되는 부분이 있으면 강의를 듣고 검색을 하며  깃의 근본을 이해해고 파악하는 중이다.   ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git-git/",
        "teaser": null
      },{
        "title": "리눅스 터미널 명령어 정리",
        "excerpt":"📄 Manual   man(manual)   매뉴얼(manual)을 뜻합니다.  나가고 싶을 때 q를 입력합니다.   clear   터미널에 있는 모든 텍스트를 깔끔하게 청소합니다.   📄 Navigating file system   pwd   현재 어떤 경로에 있는지 전체 경로를 프린트합니다.  윈도우버전 - Get-Location   ls(list)   현재 경로에 어떤 폴더와 파일들이 있는지 프린트합니다.  윈도우버전 - Dir        ls-l(list-long): 파일의 상세 속성을 확인합니다.    ls -a(list-all): 숨겨진 파일들도 모두 확인합니다.(윈도우버전 - ls -force)    open .   현재 경로를 파일 탐색기에서 엽니다.   윈도우버전 - explorer .     cd(change directory)   해당 폴더로 이동합니다.        cd..: 상위 경로로 이동합니다.    cd~ : 현재 설정된 사용자의 최상위 경로로 이동합니다.    cd - : 바로 이전 경로로 이동합니다.    find   특정한 파일이나 폴더를 찾습니다.   윈도우 버전- get-childitem       find . -type file -name “.text” : 파일 안의 모든 text파일을 찾습니다. 다양한 파일 유형으로 변경하여 활용가능합니다.  윈도우 버전 - get-childitem -File -Filter “.txt” -Recurse    find . -type directory -name “*2” : 이름이 2로 끝나는 폴더를 찾습니다.    which   실행하고자 하는 프로그램이 어디에 설치되어 있는지 경로를 확인할 때 사용합니다.  윈도우 버전 : get-command      📄 Create and manage files   touch 파일이름   파일을 생성합니다.  윈도우 버전 - new-item 파일이름     cat 파일이름   파일 안의 내용을 확인합니다.     echo “문자열” &gt; 파일   문자열을 파일에 작성합니다.       echo “문자열” » 파일 내용을 덮어 씌우지 않고 추가로 작성합니다.     mkdir   새로운 경로를 생성합니다.       mkdir -p 원하는경로/원하는경로/원하는경로 : 원하는 경로를 쭉 생성합니다.    cp 파일이름 경로/   파일을 복사합니다.     mv 파일이름 경로/   파일을 이동합니다.     rm 파일이름   파일을 삭제합니다.       rm -r 폴더이름 : 폴더 삭제     grep(Global Regular Expression Print)   특정 키워드를 검색합니다.  윈도우 버전 - select-string      grep “world” .txt    grep -n “world” *.txt : 모든 텍스트파일안의 word가 몇번째 줄에 있는지 검색합니다.    grep -nir “world” . : 현재경로를 포함한 모든 하위경로 내에서 검색합니다.     📄 Work with environment variables(환경 변수 설정하기)   export   ex. export MY_DIR=”dir1”   윈도우 버전 - $env:MU_DIR = “dir1”       cd $MY_DIR: 환경변수를 사용하고 작업 수행이 가능합니다.    unset MU_DIR: 환경변수를 제거합니다.  윈도우 버전 - $env:MY_DIR = ““     📄 vim   수정모드: i  나가기: esc + :W 수정 내용 저장 후 종료 / q: 저장하지 않고 종료     📄 새로 알게 된 용어   WSL   Windows Subsustem for Linux 윈도우 안에 리눅스시스템이 적용되어 있다.   alias   이미 정의된 데이터 오브젝트에 대해 좀더 이해하기 쉽고, 보다 의미있게 붙인 이름.   사용자가 명령어를 새로운 이름으로 정의할 수 있도록 허용한다.     학교다닐때 제일 어려워하고 싫어했던 리눅스 명령어를 제대로 파고들어봤다.  명령어 자체가 배울 땐 지루하고 따분하지만  사실 코딩을 하고 직접 경로를 다룰때는 이만큼 편한게 없는 듯 싶다.  공부를 하면 할 수록  맥북 사고 싶다ㅎㅎ  ","categories": ["Git"],
        "tags": ["리눅스"],
        "url": "/git/git-%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%84%B0%EB%AF%B8%EB%84%90-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/",
        "teaser": null
      },{
        "title": "z-index",
        "excerpt":"📄 z-index   z-index 속성은 요소의 쌓임 순서(stack order)를 정의합니다.  정수 값을 지정하여 쌓임 맥락(stacking context)에서의 레벨을 정의하는 방식으로 적용됩니다.  위치 지정 요소에 대해 적용할 수 있는 속성입니다.    .first {   z-index: 1; } .second {   z-index: 2; } .third {   z-index: 3; } .fourth {   z-index: 1; }   간단히 말해, 요소들의 z축 순서를 결정해 주는 속성입니다.      z-index은 정해진 정수 값이 있는 것이 아니라, 상대적인 수로 쌓임 맥락이 결정됩니다.   z-index의 숫자가 같을 경우에는, 나중에 쌓은 요소가 위로 오게 됩니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["z-index"],
        "url": "/css/css-z-index/",
        "teaser": null
      },{
        "title": "GIT 기본 명령어 정리",
        "excerpt":"📄 GIT 명령어 정리   ▪ git status   git status   파일 정보를 확인할 수 있습니다.   git status -s   파일 정보를 더 간단히 확인 할 수 있습니다.   ▪ git init   git init   깃을 초기화 합니다.  깃을 초기화하면 commit해서 버전을 관리하는 master branch가 생성이 됩니다.  open .git(start .git)을 입력하여 깃폴더가 생성된 것을 확인할 수 있습니다.   ▪ git rm   git rm (파일)   원격저장소와 로컬저장소의 파일을 삭제합니다.  더이상 깃 프로젝트로 활용하지 않습니다.    git rm --cached (파일)   원격저장소에 있는 파일을 삭제합니다.  로컬저장소에 있는 파일은 삭제하지 않습니다.    ▪ git add   git add (파일)   untracking 파일을 staging area에 추가합니다.  이로써 staging area에 추가된 파일은 commit할 준비가 되었습니다.    ▪ git echo   git echo (파일) &gt;&gt; .gitignore   특정 파일을 버전관리에서 제외시킵니다.    ▪ git diff   git diff   commit이나 branch 사이의 다른 점 혹은 파일이나 repository와 working directory 사이의 다른 점을 보여줍니다.  즉, 수정된 파일의 내용을 상세히 확인할 수 있습니다.    git diff --staged   staging area에 있는 파일의 수정 내용을 확인할 수 있습니다.    ▪ git commit   git commit   commit은 로컬 저장소에 코드 변경 이력을 남기기 위한 작업입니다.  staging area에 있는 파일들을 원격 저장소에 업로드할 준비를 합니다.     commit 할때 팁!      변경내용을 commit할 때는 해당내용만 변경하여 commit message에 작성한다.    commit은 너무 커도 문제가 되지만, 너무 작아도 적합하지 않다. 적당한 크기는 프로젝트를 진행하면서 감을 익힌다.   출처      드림코딩  ","categories": ["Git"],
        "tags": ["Git","status","init","rm","echo","diff"],
        "url": "/git/git-commands/",
        "teaser": null
      },{
        "title": "커밋 리셋하기(reset)",
        "excerpt":"📄 커밋 리셋하기(reset)   리셋은 특정한 커밋으로 모든 것을 초기화 시키는 명령어 입니다.   📄 작업 내용 리셋하고 working directory로 가져오기   git reset HEAD~n   이와 같은 명령어를 이용하면 HEAD부터 n번째에 있는 커밋들을 reset합니다.  작업하던 내용은 사라지지 않고 working directory로 이동합니다.   📄 작업 내용 리셋하고 staging area로 가져오기   git reset --soft HEAD~n   이와 같은 명령어를 이용하면 HEAD부터 n번째에 있는 커밋들을 reset합니다.  작업하던 내용은 사라지지 않고 staging area로 이동합니다.     아직 작업 중인 내용이 있지만 커밋을 하지 않으면 불안하고 작업단위를 구분하고자 임시 저장 내용으로 커밋하고 자 할때 유용하게 사용할 수 있는 명령어 입니다.     이렇게 사용하면 무분별한 커밋메시지가 쌓이지 않게 됩니다.   📄 작업 내용 완전히 리셋하기   git reset --hard  작업내용을 working directory, staging area로 가져오지 않고 완전히 리셋하여 파일 내용이 완전히 삭제됩니다.   포인터가 첫 번쨰 commit을 가리키는데 이 상태로 초기화 하는 것은,  마지막으로 커밋한 이후에 수정한 모든 local의 파일들을 초기화하는 것을 뜻합니다.           working directory가 비워진 것을 확인할 수 있습니다.   ","categories": ["Git"],
        "tags": ["커밋 리셋","git reset"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EB%A6%AC%EC%85%8B%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "Commit Head란?",
        "excerpt":"📄 HEAD란?   파일을 commit할 때, 현재 commit한 파일은 이전 commit한 파일을 참조합니다.   a b c d 순으로 commit한다고 가정할 때, b는 a를 가리키고 c는 b를 가리킵니다.   이런식으로 commit을 해 나가는 기본 줄기를 master branch 라고 합니다.      a &lt;- b&lt;- c&lt;- d (시각적 표현)    이 master brach에서 HEAD는 마지막으로 commit한 d파일을 가리키게 됩니다.   이때 c는 head~1이 되어 head가 있는 곳에서 첫 번째 부모임을 설명합니다.   b도 마찬가지로 head~2가 됩니다.   만약, b로 돌아가고 싶다면   git checkout b해쉬태그   를 입력하여 b로 돌아갈 수 있습니다.      git checkout master   위와 같이 입력하면 다시 원상태로 돌아옵니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["commit","Head"],
        "url": "/git/Commit-Head/",
        "teaser": null
      },{
        "title": "[flex-box] flex-direction & flex-wrap",
        "excerpt":"📄 flex-direction &amp; flex-wrap   플렉스박스는 행 또는 열을 주축으로 설정하여 웹 요소를 배치 및 정렬하는 1차원 레이아웃 방식   📄 flex-direction   플렉스 컨테이너의 주축을 결정하는 속성입니다.   flex-direction: row; /*플렉스의 진행방향이 가로축이다.*/ flex-direction: row-reverse; /*플렉스의 진행방향이 가로축 반대방향이다.*/ flex-direction: column; /*플렉스의 진행방향이 세로축이다.*/ flex-direction: column-reverse; /*플렉스의 진행방향이 세로축 반대방향이다.*/   📄 flex-wrap   플렉스 아이템들이 강제로 한줄에 배치되게 할 것인지,  또는 가능한 영역 내에서 벗어나지 않고 여러행으로 나누어 표현 할 것인지 결정하는 속성입니다.   flex-wrap: nowrap; /*기본값: 반드시 한줄로 배치된다.*/ flex-wrap: wrap; /*플렉스 컨테이너의 영역이 좁아짐에 따라 플렉스 아이템이 새로운 행으로 형성된다.*/ flex-wrap: wrap-reverse; /* 역순으로 wrap이 된다.*/   📄 flex-flow   wrap속성을 한번에 여러개 지정할 수 있는 단축 속성입니다.   flex-flow: row-reverse wrap;   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["flex-direction","flex-wrap","flex-flow"],
        "url": "/css/css-flex-direction&flex-wrap/",
        "teaser": null
      },{
        "title": "[flex-box] flex-grow & flex-shrink & flex-basis",
        "excerpt":"📄 flex-grow (기본값:0)   플렉스아이템이 기본 크기보다 더 커질 수 있는지를 결정하고,  플렉스컨테이너 내부의 할당받을 공간을 상대적으로 정의하는 속성입니다.    속성값(숫자)는 음수는 적용되지 않습니다.   li:nth-child(2) {   /*컨테이너가 커질 때, 두번째 아이템이 상대적으로 더 큰 크기를 가지게 된다.*/   flex-grow: 1; }  li:nth-child(3) {   /*flex-grow가 1인 아이템보다 더 큰 크기를 가진다.*/   flex-grow: 2; }   📄 flex-shrink (기본값:1)   플렉스 아이템이 기본 크기보다 더 작아질 수 있는지를 결정합니다.  플렉스컨테이너 내부의 할당받을 공간을 상대적으로 정의하는 속성입니다.       속성값(숫자)는 음수는 적용되지 않습니다.    li:nth-child(2) {   /*컨테이너 크기가 작아질 때, 두번째 아이템은 더 크기가 작아진다.*/   flex-shrink: 2; }  li:nth-child(3) {   /*flex-shrink가 2인 아이템보다 더 많이 줄어든다.*/   flex-shrink: 3; }     주로 반응형 웹을 만들 때 주로 사용하는 속성들입니다.  화면이 줄어들 때 어떤요소가 더 커지고 줄어들지 상대적으로 지정할 때 적절히 사용하면 유용합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["flex-grow","flex-shrink","flex-basis"],
        "url": "/css/css-flex-grow&flex-shrink/",
        "teaser": null
      },{
        "title": "[flex-box] justify-content",
        "excerpt":"📄 justify-content   플렉스아이템들이 플렉스박스 주축을 따라 배치될 때,   요소 사이의 공간을 분배하는 방식을 결정합니다.   justify-content: flex-start; /* 기본값*/ justify-content: flex-end; /*순서는 그대로 유지한채 뒤로 붙음. 리버스가 아님.*/ justify-self: center; /*가운데 정렬*/ justify-content: space-around; /*요소들이 동일한 여백을 가진다.*/ justify-content: space-between; /*양끝에 여백 없이 요소들을 동일한 간격으로 펼친다.*/ justify-content: space-evenly; /*플렉스 컨테이너가 요소 사이에 동일한 여백을 만든다.*/   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["justify-content"],
        "url": "/css/css-justify-content/",
        "teaser": null
      },{
        "title": "[flex-box] order",
        "excerpt":"📄 order   플렉스 아이템의 배치 순서를 결정합니다.  지정한 숫자(정수)에 맞춰 오름차순으로 배치합니다.  코드에 영향을 끼치는 것이 아닌, 보여지는 순서에만 영향을 줍니다.    li:nth-child(1) {   order: 5; } li:nth-child(2) {   order: -4; } li:nth-child(3) {   order: 3; } li:nth-child(4) {   order: -2; } li:nth-child(5) {   order: 1; }   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["order"],
        "url": "/css/css-order/",
        "teaser": null
      },{
        "title": "취소사항을 버전으로 남기기 (revert)",
        "excerpt":"📄 취소사항을 버전으로 남기기   reset이나 restore같은 명령어들은 history에 돌아갔다는 기록이 남지 않습니다.   이떄 기록을 남기기 위해서 revert명령어를 사용합니다.   git revert 해쉬코드 또는 HEAD~n을 사용하여 커밋을 취소하고 기록을 남깁니다.        이렇게 커밋에서 변경했던 모든 내용을 다 삭제 해주는 새로운 커밋이 생긴 것을 확인할 수 있습니다.    📄 버전을 남기지 않고 revert하기   revert에 –no-commit이라는 옵션을 남깁니다.   git revert --no-commit 해쉬코드 또는 HEAD~n   위와 같은 명령어를 이용해 커밋을 취소하면 기록이 남지 않게 됩니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["commit","revert"],
        "url": "/git/git-%EC%9E%91%EC%97%85%EC%83%81%ED%83%9C-%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "[grid] 그리드 레이아웃",
        "excerpt":"📄 그리드(grid) 레이아웃   그리드 레이아웃은 그리드 컨테이너 안의 그리드 아이템을 행과 열을 통해 정렬해 주는 2차원 레이아웃 방식을 뜻합니다.   그리드 레이아웃은 기본적으로 블록라인 컨테이너 입니다.  display: inline-grid;로 인라인 레벨 요소로 만들어 줄 수 있습니다.       그리드 컨테이너: 그리드 방식으로 레이아웃을 결정할 요소   그리드 아이템: 그리드 컨테이너 내부에서 그리드 방식으로 배치되는 요소들   📄 grid-template-columns   그리드 컨테이너의 트랙 중 열트랙에 있는 아이템들의 크기를 정해주는 속성입니다.  트랙은 그리드 컨테이너의 행 또는 열을 뜻합니다.   grid-template-columns: 100px 1fr; /*열 크기&amp;개수를 지정한다.*/      fr: 남아있는 공간에서 비율로 나눈다.    📄 grid-template-rows   그리드 컨테이너의 트랙 중 행트랙에 있는 아이템들의 크기를 정해주는 속성입니다.   grid-template-rows: 200px 1fr 1fr; /*행 크기&amp;개수를 지정한다.*/   📄 gap(grid-gap)   gap은 그리드 아이템의 간격 사이사이의 간격을 결정해주는 속성입니다.  아래와 같이 단축속성으로도 작성가능합니다.   gap: 20px 10px; /*행사이의 간격은 20px, 열사이의 간격은 10px*/   📄 트랙 관련 함수   ▪ repeat(): 반복되는 값을 자동으로 처리하는 함수  ▪ minmax(): 최솟값과 최댓값을 각각 지정할 수 있는 함수  ▪ auto-fill &amp; auto-fit: 반응형을 고려해 사용할 수 있는 키워드들(함수x)     auto-fil: 컨테이너의 여백을 남긴다.   auto-fit: 컨테이너의 여백을 채워준다.   grid-template-columns: repeat(auto-fit, minmax(100px, auto)); /*컨테이너의 여백없이 그리드 아이템의 크기의 최솟값은 100px, 최댓값은 자동으로 만든다.*/      📄 grid-column &amp; row   그리드 컨테이너의 줄번호를 이용하여 아이템을 배치하고 크기를 지정합니다.    grid-row: 1 / 2; /*1번 아이템이 행의 1~2번까지 크기를 차지한다.*/ grid-column: 1 / 3; /*1번 아이템이 열의 1~3번까지 크기를 차지한다.*/   다른 방식으로도 크기를 지정할 수 있습니다.   grid-row-start: 1; /* 행의 1번줄부터 3번줄까지 크기 차지*/ grid-row-end: 3; grid-column-start: 2; /* 열의 2번줄부터 4번줄까지 크기 차지*/ grid-column-end: 4;   📄 align &amp; justify   ▪ align-items   그리드 아이템들을 수직(열) 정렬합니다.  그리드 컨테이너에 지정합니다.   align-items: stretch; /*기본값: 열의 높이만큼 늘어난다.*/ align-items: start; /*열의 시작부분에 붙는다.*/ align-items: end; /*열의 끝에 붙는다.*/   ▪ align-self   각각의 그리드 아이템이 어떤 식으로 배치될 것인지를 스스로 결정합니다.   li:nth-child(2) {   align-self: start; } /*2번 아이템에만 start적용*/   ▪ justify-items   그리드 아이템들을 수평(행) 정렬합니다. 그리드 컨테이너에 지정합니다.    justify-items: stretch; justify-items: start; /*행너비의 시작부분에 붙는다.*/ justify-items: end; /*행너비의 끝에 붙는다.*/   ▪ justify-self   수평축(행)을 따라 각각의 그리드 아이템이 어떤 식으로 배치될 것인지를 스스로 결정합니다.    li:nth-child(3) {   justify-items: end; } /*3q번 아이템에만 end적용*/   📄 align-content &amp; justify-content   align-content와 justify-content의 속성들은 진행방향만 다른채  같은 성격을 공유합니다.   ▪ align-content   그리드 컨테이너의 열방향의 정렬방식을 지정합니다.    align-content: start; /*기본값*/ align-content: end; /*컨테이너 전체의 공간 밑에 붙는다.*/ align-content: space-around; /*각각의 아이템이 진행방향으로의 여백을 동일하게 가진다.*/ align-content: space-between; /*컨테이너의 위, 아래에 붙인 상태의 여백이 동일하다.*/ align-content: space-evenly; /*모든 여백이 똑같다.*/   ▪ justify-content   그리드 컨테이너의 행방향의 정렬방식을 지정합니다.   justify-content: center; /* 행의 가운데에 정렬한다.*/ justify-content: space-between; /*컨테이너의 왼쪽, 오른쪽에 붙인 상태의 여백이 동일하다.*/   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["grid"],
        "url": "/css/css-grid/",
        "teaser": null
      },{
        "title": "브랜치(branch)란 무엇인가",
        "excerpt":"📄 브랜치(branch)란 무엇인가   브랜치는 하나의 줄기에서 뻗어나온 과정들을 의미합니다.  즉, 저장공간 하나에서 빠져나오는 또다른 가상의 저장공간들을 생성하는 것을 뜻합니다.   📄 브랜치 과정   별도로 브랜치를 따로 작성하지 않으면 master 브랜치에서 계속 작성됩니다.  만약 새로운 기능을 만든다면, 새로운 브랜치를 만들어서 작업을 해나아가는 것이 중요합니다.  이런식으로 커밋을 하면 다수의 개발자들이 다수의 작업을 병렬적으로 처리하는 것이 가능해집니다.  이후 master 브랜치 외 featureA브랜치에서 작업이 완료가 되었다면, featureA의 커밋들을 master브랜치에 merge를 하게 되어 master브랜치에 병합합니다.  이때 featureA의 커밋들을 모두 master 브랜치로 가져오는 것 보다는, 커밋들을 합해서 새로운 하나의 커밋을 만들어 준 후에 master 브랜치로 가지고 오는 방법도 있습니다.   이후 featureA 브랜치는 삭제를 하여 깔끔하게 정리합니다.   📄 브랜치 관련 명령어   브랜치 확인하기   ▪ git branch   생성된 모든 브랜치를 확인할 수 있습니다.        ▪ git branch -all   서버를 포함한 생성된 모든 브랜치를 확인할 수 있습니다.   브랜치 생성하기   ▪ git branch (브랜치명)   브랜치를 생성합니다. 다만, 생성한 브랜치는 만들어지기만 하고 현재의 브랜치는 변하지 않습니다.      📌 로컬 브랜치에서 생성 후 원격 브랜치에 연동하기   git branch -b (브랜치명)  git push origin (브랜치명)   매번 브런치 명을 입력하기 번거로우므로 config설정을 해줍니다.   git config --global push.default current // 현재 브랜치를 기준으로 같은 이름의 브랜치에 push한다.   브랜치 이동하기   ▪ git switch (브랜치명)   원하는 브랜치로 이동합니다.   ▪ git switch -C new-branch1   새로운 브랜치를 생성함과 동시에 바로 이동합니다.   브랜치 삭제하기   ▪ git branch -d (브랜치명)   해당 브랜치를 삭제합니다.   ▪ git push origin --delete (브랜치명)   원격 저장소의 브랜치를 삭제합니다.   브랜치 이름 변경하기   ▪ git branch --move (브랜치명) (변경할 브랜치명)   브랜치 이름을 새롭게 변경합니다.   ▪ git push --set-upstream origin (변경할 브랜치명)      변경할 브랜치명을 원격저장소에 업데이트 합니다.    출처      드림코딩  ","categories": ["Git"],
        "tags": ["브랜치"],
        "url": "/git/git-branch/",
        "teaser": null
      },{
        "title": "log 관련 명령어",
        "excerpt":"📄 log 관련 명령어   log는 커밋한 히스토리를 볼 수 있는 명령어입니다.   git log를 통해 확인할 수 있는 것은 다음과 같습니다.      commit 아이디   작성자   commit 시간   타이틀      ▪ git log oneline      해쉬코드의 앞자리 문자열과 간단한 커밋메세지를 간단하게 확인할 수 있습니다.       ▪ git log -3      최근 히스토리 3개를 보여줍니다.     ▪ git log --author=\"sujin\"       sujin이라는 이름의 사용자가 커밋한 히스토리를 보여줍니다.    ▪ git log --before=\"2020-07-24\"       2020-07-24 이전의 커밋한 히스토리를 보여줍니다.     ▪ git log --grep=\"project\"      project가 들어간 커밋 타이틀을 보여줍니다.     ▪ git log -S \"about\"      커밋 내용에 about이 들어간 히스토리를 보여줍니다.     ▪ git log about.txt      about.txt에 해당하는 히스토리를 볼 수 있습니다.     ▪ git log -p         patch 옵션을 사용하면 수정된 파일의 내용들도 확인할 수 있습니다.     ▪ git log -p \"about.txt\"       about.txt.에 해당하는 좀 더 자세한 히스토리를 볼 수 있습니다.     ▪ git log HEAD~1       git log의 HEAD에서 이전 부모부터 히스토리를 볼 수 있습니다.     ▪ git show (해당 해쉬코드)       해당하는 커밋의 내용을 볼 수 있습니다.    ▪ git diff (해쉬코드1) (해쉬코드2)       두가지 커밋 내용을 비교하며 내용을 확인 할 수 있습니다.    참고      드림코딩  ","categories": ["Git"],
        "tags": ["log","show","diff"],
        "url": "/git/git-log-%EA%B4%80%EB%A0%A8-%EB%AA%85%EB%A0%B9%EC%96%B4/",
        "teaser": null
      },{
        "title": "머지(merge)",
        "excerpt":"📄 머지(merge)   독립된 브랜치에서 작업이 끝나면 다시 원본 브랜치에 작업한 결과를 반영하는 것을 말합니다.   📄 fast-forward merges   새로운 브랜치를 생성했을 때 merge를 할 경우,  master 브랜치가 가리키던 포인터를 새로운 브랜치로 이동시키는 것을 말합니다..  이때, 히스토리에 merge가 되었다는 사실이 남지 않고 깔끔하게 merge를 할 수 있습니다.    순서      git checkout master   master 브랜치로 이동합니다.    git merge (독립된 브랜치명)  브랜치를 병합합니다.    git branch -d (병합된 브랜치명)  더이상 필요없게 된 브랜치를 삭제합니다.   📄 fast-forward가 하기 싫을 때   히스토리를 상세히 남기는 것을 선호할 경우  git merge --no-ff feature를 사용하면 자동으로 fast-forward merges가 되는것을 방지할 수 있습니다.     📄 fast-forward가 불가능할 때   새로운 브랜치가 생성이 되고 마스터 브랜치에 새로운 커밋이 발생한 경우, fast-forward가 불가능하게 됩니다.  이렇게 되면 Three-way merge를 이용해야 합니다.  master 브랜치와 파생된 브랜치의 변동사항을 모두 합해서 merge commit을 만든 다음,   master branch에 commit을 하게 됩니다.      이렇게 merge commit된 것을 확인할 수 있습니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["merge","머지"],
        "url": "/git/git-merge/",
        "teaser": null
      },{
        "title": "cherry pick",
        "excerpt":"📄 cherry pick   작업들 중 특정 부분을 master branch로 가져오고 싶을 때 사용하는 유용한 기능입니다.   git cherry-pick 커밋해쉬코드를 입력하여 특정 커밋을 master brach로 가져옵니다.       참고      드림코딩  ","categories": ["Git"],
        "tags": ["cherry pick"],
        "url": "/git/git-cherry-pick/",
        "teaser": null
      },{
        "title": "Git Conflict 해결 방법",
        "excerpt":"📄 merge conflict   merge를 하는 과정에서 자동적으로 해결이 안되는 충돌이 발생한 상황을 말합니다.  예를 들어, 서로 다른 브랜치에서 동일한 파일을 수정했을 때 충돌이 발생할 수 있습니다.   아래와 같이 merge conflict가 발생한 것을 확인 할 수 있습니다.          Automatic merge failed: 자동 merge가 실패 됨.    git status를 입력해 확인해 보면 동시에 수정된 파일을 확인할 수 있습니다.       cat (파일명)을 입력하면 conflict가 발생한 부분을 알려주기 위해 자동으로 삽입된 문자열을 확인할 수 있습니다.       📄 merge conflict 수동적 해결방법           open 해당 파일 (윈도우: start 해당파일)명령어를 이용하여 conflict가 발생한 파일을 열어줍니다.              사용할 부분을 제외하고 삭제하거나, 모두 다 사용하고 싶다면 메세지만 삭제 한채 저장한 뒤 파일을 닫습니다.            git add를 이용해 conflict가 해결되었음을 알려줍니다.              git merge --continue를 입력해 merge를 마무리합니다.           📄 merge conflict tool을 이용한 해결방법: vscode           git config --global -e를 입력해서 vscode를 열어줍니다.            아래 코드를 입력해서 merge tool을 vscode로 다룰 수 있게 적용합니다.              conlict가 발생했을 때, git mergetool을 입력하면 vscode로 툴이 열리는 것을 확인 할 수 있습니다.       📄 merge conflict tool을 이용한 해결방법: p4merge           p4merge를 검색 후 다운받습니다.              아래 코드를 입력해서 merge tool을 p4code로 다룰 수 있게 합니다.              conlict가 발생했을 때, git mergetool을 입력하면 vscode로 툴이 열리는 것을 확인 할 수 있습니다.         참고      드림코딩  ","categories": ["Git"],
        "tags": ["git conflict","깃 충돌"],
        "url": "/git/git-conflict-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "리베이스(Rebase)",
        "excerpt":"📄 리베이스(Rebase)   리베이스는 파생된 브랜치의 기준이 되는 베이스 커밋을 변경하는 것입니다.   이런 방법으로 브랜치를 합칠 수 있습니다.   그렇다면 머지와 차이점이 뭘까요?   merge vs rebase      우선 rebase와 merge의 공통점은 브랜치를 합친다는 것입니다.   차이점은 rebase를 하는 경우는 merge보다 깨끗한 commit history를 만들 수 있다는 점입니다.   그림처럼 머지는 새로운 커밋을 생성해서 파생된 브랜치에 적용되지만,   리베이스는 베이스 커밋을 재설정 한 것이기 때문에 마치 처음부터 커밋된 것처럼 선형 브랜치 형태를 띄게 됩니다.   📄 주의할 점!   리베이스를 하는 경우 Base가 바뀐 커밋들은 복사되어 새로 만들어지는데, 이 과정에서 commit Id가 변경됩니다.   이때 다른 개발자와 함께 파생된 브랜치에서 작업을 할 경우, 리베이스를 하면 merge conflict가 발생할 수 있습니다.   그러므로 서버에 업로드된 히스토리는 절대 리베이스하면 안됩니다   📄 순서           git checkout (파생된 브랜치)를 이용해 파생된 브랜치로 이동합니다.            git rebase master를 입력해 master 브랜치의 최신버전으로 포인터를 이동시킵니다.              git merge (파생된 브랜치)를 이용하면 merge가 가능한 것을 확인할 수 있습니다.            이후 git branch -d (브랜치명)을 입력해 쓸모 없어진 브랜치를 삭제해 깔끔하게 정리해 줍니다.       📄 rebase –onto   파생된 브랜치에서 다시 파생된 브랜치의 포인터를 master 브랜치에 옮겨주는 것을 뜻합니다.  이때 rebase --onto옵션을 사용합니다.   위와 같이 포인터를 옮겨 준 후, merge를 하면 성공적으로 merge된 것을 확인할 수 있습니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["rebase"],
        "url": "/git/git-%EB%A6%AC%EB%B2%A0%EC%9D%B4%EC%8A%A4/",
        "teaser": null
      },{
        "title": "뷰포트(viewport)",
        "excerpt":"📄 뷰포트(viewport)   현재 화면에 보여지고 있는 영역을 의미합니다.   기기별로 뷰포트가 다르기때문에 보여지는 화면의 배율에 따라 화면이 다르게 보입니다.   html문서에서 이름이 뷰포트인 메타태그 설정을 확인할 수 있습니다.   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;      width=device-width : 너비를 기기의 너비 기준으로 초기화 한다. initial-scale=1.0 : 기기의 너비에 맞게 초기 scale를 지정한다.    이 메타태그 설정은 기기에 맞게 화면 배율을 조정해주기 때문에, 모바일 화면에서도 pc화면과 동일하게 콘텐츠의 크기가 유지되는 것을 확인할 수 있습니다.   📄 뷰포트 단위   뷰포트 크기를 기반으로 값을 계산하여 크기를 결정하는 가변단위들이 있습니다.   이는 반응형 웹을 만들 때 매우 유용하게 사용되는 단위들입니다.   ▪ font-size: 1vw;      화면 사이즈에서 너비의 100분의 1    화면 너비의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vh;      화면 사이즈에서 높이의 100분의 1    화면 높이의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vmin;      화면 사이즈에서 너비와 높이 중 작은것의 100분의 1 너비와 높이 중 작은 것에 백분율을 맞춘다    ▪ font-size: 1vmax;      화면 사이즈에서 너비와 높이 중 큰것의 100분의 1 너비와 높이 중 큰 것에 백분율을 맞춘다.   ","categories": ["HTML"],
        "tags": ["HTML","뷰포트"],
        "url": "/html/html-viewport/",
        "teaser": null
      },{
        "title": "미디어 쿼리(media query)",
        "excerpt":"📄 미디어 쿼리(media query)   미디어 쿼리는 미디어 타입을 인식하고, 콘텐츠를 읽어들이는 기기나 브라우저의 물리적 속성을 감지할 수 있는 기능입니다.      @media: 미디어 쿼리문 선언   screen: 가장 자주 사용되는 미디어 타입 중 하나. 화면을 뜻합니다.   /*미디어 쿼리문*/ @media screen and (min-width: 800px) {   /*800px 보다 화면이 커졌을 경우에 적용한다.*/   img {     width: 400px;     height: 400px;   } }   📄 미디어 쿼리 적용의 다른 형태   ▪ link 태그에 미디어 쿼리 추가   &lt;link rel=\"stylesheet\" href=\"style.css\" media=\"screen and (max-width: 768px)\"&gt;   ▪ @import 구문을 이용한 추가   @import url(\"style.css\") screen and (max-width: 768px);   참조      유노코딩 초보자를 위한 반응형 웹 기초 강의  ","categories": ["CSS"],
        "tags": ["미디어 쿼리"],
        "url": "/css/css-media-query/",
        "teaser": null
      },{
        "title": "git stash란?",
        "excerpt":"📄 stash란?   working directory에서 작업 도중 깃 history에 저장하지 않고도 작업 내용을 저장해 놓을 수 있는 보관소를 뜻합니다.  임시보관소로 생각하면 이해하기 편합니다.    📄 stash stack에 파일을 push하기   ▪ git stash  파일을 stash stack에 push합니다.   ▪ git stash -m \"타이틀\"  타이틀을 지정해 stash stack에 push합니다.   이렇게 파일들을 stash하게 되면 working directory와 staging area에 파일이 남지 않게 됩니다.   ▪ git stash push -m \"타이틀\" --keep-indext  만약 staging area에 있는 것을 유지하면서 stash에 저장하고 싶을 때 위와 같은 명령어를 입력하면 작업하던 내용이 유지가 됩니다.     📄 untracking 파일 stash하기   tracking되지 않은 파일은 자동으로 stash에 저장되지 않습니다.    ▪ git stash -u  위와 같은 명령어를 입력하면 모두다 stash stack에 들어가게 됩니다.     📄 stash 이력 확인하기   ▪ git stash list  위와 같은 명령어를 입력하면 stash stack을 확인할 수 있습니다.          ▪ git stash show (stash 아이디)  stash list에서 확인할 수 있는 stash아이디를 입력하면 각각 stash에서 어떤 것이 수정되었는지 확인할 수 있습니다.       만약 powershell 사용자라면, 따옴표를 추가하여 `git stash show “(stash 아이디)”으로 입력해야합니다.    ▪ git stash show (stash 아이디) -p  p라는 옵션을 이용하면 더 자세한 내용을 확인할 수 있습니다.   📄 stash 에서 다시 가져오기   ▪ git stash apply stash stack의 가장 위에 있는 부분을 working directory에 가져옵니다.  목록은 그대로 유지됩니다.   ▪ git stash apply (stash 아이디)  특정한 stash를 적용하고 싶다면 stash 아이디를 지정하여 명령어를 입력해 주면 됩니다.     ▪ git stash branch (브랜치 이름)  stash를 적용하면서 새로운 브랜치를 만들게 됩니다.   ▪ git stash pop  stash stack의 가장 위에 있는 부분을 working directory에 가져옵니다.  가지고 나온 stash는 목록에서 삭제됩니다.     📄 stash 삭제하기   ▪ git stash drop (stash 아이디)  특정 stash를 삭제합니다.     ▪ git stash clear  전체 stash를 삭제합니다.    ","categories": ["Git"],
        "tags": ["stash"],
        "url": "/git/git-stash/",
        "teaser": null
      },{
        "title": "이전 commit 수정하기",
        "excerpt":"📄 이전 commit 수정하기   최신 커밋이 아닌 이전 커밋을 수정할 때는 rebase명령어를 사용합니다.    📄 순서   1. git rebase i 해쉬코드       i는 interactive의 약자 입니다.       위와 같이 명령어를 입력하면 아래처럼 설정해둔 vscode가 열립니다.    이렇게 업데이트 될 커밋 목록을 확인할 수 있습니다.    2. 변경사항 입력   Pick은 변경없이 커밋을 그래도 사용하겠다는 뜻이므로   변경을 원하는 커밋에 PICK 대신 R(Reword)를 작성해주면 커밋메세지 입력 창이 열립니다.        이렇게 원하는 명령으로 변경합니다.    3. 변경사항 확인   히스토리를 통해 변경내역이 적용된 것을 확인할 수 있습니다.     주의할 점      수정한 커밋 뒤로 이어진 모든 커밋들도 함께 업데이트 됩니다.   참조      드림코딩 GIT마스터 과정  ","categories": ["Git"],
        "tags": ["commit","rebase"],
        "url": "/git/git-%EC%9D%B4%EC%A0%84-%EC%BB%A4%EB%B0%8B-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "git 태그(tag)",
        "excerpt":"📄 태그(tag)   태그는 특정 커밋을 북마크 해두고 싶을 때 사용하는 기능입니다.   📄 semantic versioning   숫자 세가지를 이용해서 major버전과 minor버전과 fix버전을 구분하여 나타냅니다.      major버전: 특정한 기능이 추가 되는 등 전체적인 변화가 일어났을 때 업데이트 되는 버전.   minor버전: 커다란 기능 중에서 조금의 기능이 업데이트 되거나 개선되었을 때 업데이트 되는 버전.   fix버전: 존재하는 기능 중 오류수정을 했을 때 업데이트 되는 버전.       📄 태그 확인하기   git tag (태그명)  위와 같은 명령어로 태그를 만들면 log내역을 통해서 확인 할 수 있습니다.          📄 태그 달기   git tag (태그명) (해쉬태그)  해쉬태그를 통해서 특정한 커밋에 태그를 달 수 있습니다.         📄 태그에 메세지 달기   git tag (태그명) (해쉬태그) -am (메세지)   해쉬태그를 통해 특정 커밋에 메세지를 작성 할 수 있습니다.      git show를 이용해 확인할 수 있습니다.      📄 태그 검색하기   git tag -l \"문자열\"   특정 문자열이 들어있는 모든 태그를 검색 할 수 있습니다.   📄 태그 삭제하기   git tag -d (태그명)   아래와 같이 태그를 삭제할 수 있습니다.      📄 새로운 브랜치에 태그 생성하기   git checkout -b (브랜치 이름) (태그명)   새로운 브랜치를 생성하여 태그를 만들어줍니다.      출처      드림코딩  ","categories": ["Git"],
        "tags": ["tag"],
        "url": "/git/git-%EC%B7%A8%EC%86%8C%EC%82%AC%ED%95%AD%EC%9D%84-%EB%B2%84%EC%A0%84%EC%9C%BC%EB%A1%9C-%EB%82%A8%EA%B8%B0%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "커밋 수정하기",
        "excerpt":"📄 commit 수정하기   열심히 여러가지 파일들을 커밋하다보면 커밋 메세지를 잘못 작성하는 등 커밋을 수정해야할 상황이 발생합니다.  이때 amend 명령어를 이용해 최신 커밋파일을 수정할 수 있습니다.    📄 커밋 메세지 수정하기   git commit --amend -m \"수정될 커밋 메세지\"  커밋 메세지를 수정할 경우 위와 같은 명령어를 통해 수정이 가능합니다.     📄 파일 내용 수정하기           vim 또는 직접 파일을 열어 내용을 수정합니다.              git commit amend를 이용해 커밋 파일에 수정내용을 적용합니다.         느낀점   오늘 이후로 깃을 다루는 방법이 많이 달라질 듯 하다.  commit파일 수정하는 법을 몰라서 그냥 push하고 수정파일을 다시 커밋하고 push했었는데  더 이상 번잡한 과정은 겪지 않게 되었다.   ","categories": ["Git"],
        "tags": ["amend","commit"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "가변 동영상",
        "excerpt":"📄 가변 동영상   동영상도 이미지와 마찬가지로 화면 배율에 따라 가변적으로 크기를 설정할 수 있습니다.   다만 유튜브 등 동영상 서비스에 따라 성질이 다를 수 있어 주의해야 합니다.   📄 가변 동영상 설정 1 | vedio 태그   &lt;video src=\"./my-cat.mp4\" controls&gt;&lt;/video&gt;   동영상 파일을 직접 가지고 있다면, 이렇게 body태그안에서 video태그를 설정하면 됩니다.   컨트롤 속성으로 컨트롤 패널을 추가했습니다.   style태그에서 너비를 %단위로 지정하게 되면 화면 크기에 따라 동영상 화면 크기가 변합니다.   📄 가변 동영상 설정 2 | iframe 태그   하지만 동영상 파일을 직접 가지고 있지 않다면 유튜브 등 동영상 서비스를 이용하는 방법이 있습니다.   유튜브에서 원하는 동영상을 선택후 공유 &gt; 퍼가기를 선택합니다.      유튜브는 이렇게 iframe태그를 제공합니다.   이 iframe 태그를 body태그로 가져오면 웹페이지에 동영상을 설정할 수 있습니다.   ▪ iframe 태그의 문제점   style태그에서 iframe태그의 너비를 100%로 설정해주면 생각보다 동영상 화면 크기 전환이 자연스럽지 않은 것을 확인할 수 있습니다.   제공받은 iframe태그는 동영상 서비스에서 다양한 속성을 설정하는 등 단순하지 않은게 이유가 됩니다.   이 문제는 여백을 만들어주고 그 여백에 동영상 크기를 맞춤으로써 해결할 수 있습니다.   &lt;div class=\"player\"&gt;         &lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BYMM5Dh_tSY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;      여백을 설정해줄 div를 설정해준 후 iframe태그를 넣었습니다.   &lt;style&gt;      .player{        padding-top: 56.25%;        position: relative;       }      iframe{        position: absolute;        top: 0; left: 0;        width: 100%;        height: 100%;      } &lt;/style&gt;      스타일 태그안에서 클래스 선택자를 이용해 player로 설정한 div의 padding-top크기를 동영상의 종횡비에 맞추어 %단위로 지정했습니다.   iframe은 position을 이용해 위치를 고정시키고 너비와 높이를 부모 요소인 player에 맞게 100%설정했습니다.   이렇게 iframe태그로 동영상을 가져오면 크기 전환이 더 자연스럽고 보다 나은 웹 구현이 가능하게 됩니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["가변 동영상","video","iframe"],
        "url": "/css/css-variable-video/",
        "teaser": null
      },{
        "title": "[git] mac os 환경에서 깃허브 아이디 여러개 관리하기",
        "excerpt":"📄SSH(Secure Shell)란?   회사 계정으로 깃허브 저장소를 관리하게 되었다. 깃허브 계정 두개를 하나의 로컬에서 관리해야하는데 이때 permission denied 에러가 발생하며 ssh키로 계정을 관리하는 방법을 찾아보았다.           정의: 컴퓨터와 컴퓨터 사이에서 안전하게 통신할 수 있는 프로토콜            특징             네트워크를 통해 다른 컴퓨터에 안전하게 접속       컴퓨터와 컴퓨터 간 중요한 정보를 주고 받을 때 외부에서 개입되지 않도록 정보를 암호화       주로 원격서버에 안전하게 접속하고 명령을 실행할 때 사용       다수의 깃허브 계정을 하나의 로컬 환경에서 관리할 때 보안상 ssh key를 등록해 사용한다.           📄 순서   1. 로컬 환경에서 ssh key 생성하기   a. ssh key를 관리하는 폴더로 이동   $ cd ~/.ssh $ ls -al   b. ssh key 생성하기      각 계정에 사용할 key를 생성한다. 두개면 두개, 세개면 세개   id는 계정 용도에 맞게 지어야 구별하기 쉽다.   ex) ssh-keygen -t rsa -C “github@gmail.com” -f “id_github_work”   $ ssh-keygen -t rsa -C {github 이메일 계정} -f {key id} $ ls -al ~/.ssh   c. ssh key 확인하기      ls 명령어를 통해 생성한 ssh key를 확인할 수 있다.   확장자가 .pub인 파일에 생성된 ssh key가 저장되어 있다.    2. ssh key 등록      setting &gt; SSH keys and GPS keys 로 이동해 New SSH key를 생성한다.   하나의 계정이 아닌 생성한 key 들을 각 계정에 등록한다.       3. 각 ssh key host 지시자 설정하기      설정한 host 지시자는 프로젝틐 클론시 사용하기에 복잡하게 하지 않는게 좋다.   ssh key가 있는 폴더에서 config 파일을 연다.     $ cd ~/.ssh $ code config                Host 지시자를 설정한다.       # 개인 계정 # ------------- Host github.com-{호스트 지시자 이름1} HostName github.com IdentityFile ~/.ssh/id_github_개인계정 User Sujin   # 회사 계정 # ------------ Host github.com-{호스트 지시자 이름1} HostName github.com IdentityFile ~/.ssh/id_github_회사 User Sujin           ssh key가 잘 등록되었는지 테스트 해본다.     $ ssh -T git@github.com-SJ0826 Hi SJ0826! You've successfully authenticated, but GitHub does not provide shell access. // 👍           4. ssh key를 이용해 프로젝트 클론하기           이제 https url이 아닌 ssh key를 이용해 프로젝트를 클론할 수 있다.        ⭐️ 체크한 부분처럼 그대로 등록한 ssh key host 지시자를 입력해야 한다.   그렇지 않으면 permission denied error가 발생할 것이다.    출처      드림코딩  ","categories": ["Git"],
        "tags": ["SSH"],
        "url": "/git/git-SSH%EB%A1%9C-%EA%B0%84%ED%8E%B8%ED%95%98%EA%B2%8C-push%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "🚨 The following untracked working tree files would be overwritten by merge",
        "excerpt":"🚨 The following untracked working tree files would be overwritten by merge   git 저장소에서 파일을 당겨 오는데 오류가 발생했다.   error: The following untracked working tree files would be overwritten by merge: 오류 발생한 파일 위치 및 이름 Please move or remove them before you can merge.   깔끔하게 하고 싶어서 자꾸 이것저것 해서 그런가 overwritten 됐단다.  역시나 하라는 대로 해준다.   git clean -d -f -f   하고 다시 git pull 해주면    빠른 해결~  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git-The-following-untracked-working-tree-files/",
        "teaser": null
      },{
        "title": "🚨 Too many revisions specified",
        "excerpt":"🚨 Too many revisions specified   git 공부를 하던 도중 에러가 났다.   git stash show stash{3}   stash 변경사항을 확인하려고 명령어를 입력했는데 내 명령어를 받아주질 않는다..       너무 많은 개정이 지정되었다니..뭔말일까..   What does the error message mean, and what should I do?   구글링 gogo~   ❔ 원인   그냥 쓰던 powershell 문제 였다.   powershell은 중괄호를 좋아하지 않는다니 어쩔 수 없다.   🔨 해결   따옴표를 써서 달래주자.   git stash show \"stash{3}\"      참조      stackoverfow   느낀 점   일부러 에러가 났을 때 국내 사이트보다 해외사이트에서 해결책을 찾았다.   그러다보니 점점 해외 사이트가 눈에 익고 익숙해지는게 느껴진다.  이번 에러를 찾는 과정에선 번역기를 돌리지 않고 해결책을 찾았다.  외국이나 한국이나 웃긴점.  -&gt; 저도 이게 왜 되는지 모르겠는데 해결됐어요.  라는 글을 심심치 않게 볼 수 있다.  역시 코딩으로 하나되는 우리 지구.  ","categories": ["Git"],
        "tags": ["Git","powershell"],
        "url": "/git/git-Too-many-revisions-specified/",
        "teaser": null
      },{
        "title": "🚨 Can’t push refs to remote",
        "excerpt":"🚨 Can’t push refs to remote. Try running ‘Pull’ first to integrate your changes      파일 저장 경로가 잘못 되어 수정했더니 해결되었다. 저장 경로는 항상 주의할 것.       눌렀더니 해결. 에러 메세지를 잘 읽어보자.  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/git-cant-push-refs-to-remote/",
        "teaser": null
      },{
        "title": "fetch vs pull 차이점",
        "excerpt":"📄 fetch vs pull 차이점   서버에서 commit이 발생하여 변경사항을 나의 로컬 저장소로 가져오는 상황에서 두 명령어는 차이점을 가지게 됩니다.     📄 fetch를 사용했을 경우   fetch를 사용하게 되면 나의 로컬 브랜치의 origin은 서버에서 가져온 커밋으로 위치를 바꾸지만      현재 작업중인 로컬 master 브랜치 즉, HEAD의 위치는 변하지 않습니다.     서버에 업데이트된 히스토리의 정보만 로컬로 가지고 올 때 fetch를 유용하게 사용할 수 있습니다.        git fetch origin 브랜치명  위와 같은 명령어 입력시 특정한 브랜치만 가지고 올 수 도 있습니다.     📄 pull을 사용했을 경우   pull을 사용하게 되면 origin은 물론, HEAD의 위치도 서버에서 가져온 커밋으로 위치를 변경합니다.    ","categories": ["Git"],
        "tags": ["fetch","commit","pull"],
        "url": "/git/git-fetch-vs-pull-%EC%B0%A8%EC%9D%B4%EC%A0%90/",
        "teaser": null
      },{
        "title": "서버와 로컬의 커밋이 충돌할 때",
        "excerpt":"📄 서버와 로컬의 커밋이 충돌할 때   서버와 로컬에서 동일한 파일을 수정해 커밋을 하는 경우 conflict가 발생하게 됩니다.   📄 git pull 명령어를 사용한 경우      git mergetool로 mergetool을 열어서 원하는 내용을 병합 후 저장합니다.   git add .로 모두 staging area로 이동시킵니다.   git merge --continue을 하면 로컬에서 작성한 커밋과 서버에서 작성한 커밋이 병합한 새로운 커밋을 생성하게 됩니다.   📄 git pull -rebase 명령어를 사용한 경우      git mergetool로 mergetool을 열어서 원하는 내용을 병합 후 저장합니다.   git rebase --continue로 rebase를 진행시킵니다.   기존 로컬의 커밋을 rebase했기 때문에 로컬의 커밋만 다시 새로운 커밋이 되었고 서버에서 가져온 커밋은 그대로 유지됩니다.   마지막으로 git push를 해서 로컬의 파일과 서버의 파일을 동일하게 만들어줍니다.   참고      드림코딩  ","categories": ["Git"],
        "tags": ["commit","Head"],
        "url": "/git/git-%EC%84%9C%EB%B2%84%EC%99%80-%EB%A1%9C%EC%BB%AC%EC%9D%98-%EC%BB%A4%EB%B0%8B%EC%9D%B4-%EC%B6%A9%EB%8F%8C%ED%95%A0-%EB%95%8C/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "커밋 분할하기",
        "excerpt":"📄 커밋 분할하기   개발자들과 협업을 할 때는 하나의 커밋에는 하나의 내용이 있어야 합니다.   너무 많은 내용을 커밋하게 되었을 때는 커밋을 분할해야 합니다.   📄 순서   1. git rebase -i 해쉬코드 또는 HEAD~n   위와 같은 명령어를 입력하여 분할해야하는 커밋을 수정하기 위해 에디터를 띄웁니다.   에디터에서 해당 커밋의 명령어를 e(edit)로 고칩니다.   저장 후 히스토리 내역을 확인하면 HEAD가 해당 커밋으로 이동한 것을 확인할 수 있습니다.         2. git reset    명령어를 입력해 해당 커밋을 리셋시켜 파일을 working directory로 가져옵니다.       git status를 입력해 확인해 보면 rebase가 진행중이며 두개의 파일이 working directory로 온 것을 확인할 수 있습니다.   3. 각각 파일 하나씩 다시 커밋하기   파일들을 하나씩 staging area에 추가하고 다시 커밋합니다.   4. git rebase --continue   명령어를 입력해 rebase를 진행합니다.       이렇게 커밋이 분할 된 것을 확인할 수 있습니다.   참조      더 북   [강 의] 드림코딩  ","categories": ["Git"],
        "tags": ["Git","rebase","reset"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EB%B6%84%ED%95%A0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "커밋 삭제하기",
        "excerpt":"📄 commit 삭제하기   커밋 삭제 순서           히스토리 내역에 삭제하기를 원하는 커밋을 확인합니다.              git rebase -i (해쉬코드 또는 HEAD~n)  rebase 명령어를 이용해 해당 커밋까지의 내역을 수정하는 창을 띄웁니다.              삭제를 원하는 커밋에 d(drop)옵션을 입력합니다.  이렇게 되면 삭제된 파일의 다음 커밋에서 수정사항이 발생했기 때문에 conflict가 생기게 됩니다.               git status를 입력해 상태를 확인해보면, 다음과 같이 출력된 것을 확인할 수 있습니다.                 interactive rebase가 진행중인데 payment-ui.txt(삭제된 커밋 다음 커밋의 파일)이 삭제되었다.                 git add . 를 통해 삭제된 파일을 다시 추가합니다.              git rebase --continue를 통해 rebase를 계속 진행합니다.              히스토리 내역을 확인하면 해당 커밋이 삭제된 것을 확인 할 수 있습니다.      ","categories": ["Git"],
        "tags": ["Git","rebase","reset","커밋 삭제"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "커밋 전 취소하기",
        "excerpt":"📄 working directory에 있는 파일 수정 취소하기(초기화 하기)   ▪ git restore .  working directory에 있는 전체 파일을 초기화 합니다.     ▪ git restore (파일 이름)  working directory에 있는 특정 파일을 초기화 합니다.     ▪ git restore --source=(해쉬코드 또는 HEAD~n) (파일명) 파일에 대해서 특정커밋 이전 상태로 초기화 합니다.     📄 staging area에 있는 파일 수정 취소하기(초기화 하기)   ▪ git restore --staged .  staging area에 있는 전체 파일을 초기화 합니다.     ▪ git restore --staged (파일 이름)  staging area에 있는 특정 파일을 초기화 합니다.       WIP(Working In Progress): 아직 작업이 진행 중인 것을 뜻합니다.    ","categories": ["Git"],
        "tags": ["restore","commit","커밋 전 취소"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%EC%A0%84-%EC%B7%A8%EC%86%8C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "커밋 합치기",
        "excerpt":"📄 커밋 합치기 순서   1. git rebase -i 해쉬코드 또는 HEAD~n   rebase해서 에디터를 열어줍니다.   2. commit을 합칠 때는 squash   커밋 명령어를 s(squash)로 바꿉니다.   다만, 병합할 커밋들 중 제일 첫번째에 있는 커밋은 바꾸지 않고 그대로 pick으로 입력합니다.   간단하게 확인   history명령어를 이용해 커밋 내역을 확인하면 병합된 커밋들을 확인할 수 있습니다.   📄 주의할 점   커밋을 병합하게 되면 병합된 커밋뿐만 아니라 이후에 커밋들도 해쉬코드가 바뀝니다.   따라서 다른 개발자들과 협업을 할 경우에는 서버에 올라간 커밋들을 수정해서는 안됩니다.   참조      더 북   [강 의] 드림코딩  ","categories": ["Git"],
        "tags": ["rebase","commit","squash"],
        "url": "/git/git-%EC%BB%A4%EB%B0%8B-%ED%95%A9%EC%B9%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "가변 이미지",
        "excerpt":"📄 가변 이미지   화면의 배율에 따라 크기가 달라지는 이미지 입니다.   보통 px로 고정을 시켜놓는 경우도 있지만, 그렇지 않은 경우에는 화면이 커질 수록 픽셀이 깨져보이는 현상이 발생합니다.   📄 가변 이미지 설정 1 | max-width 사용   이미지 너비를 %단위로 지정하고 max-width를 사용하면 화면이 커질수록 이미지크기가 증가하다가,  일정 크기에 도달하면 더이상 증가하지 않음으로써 이미지를 보호할 수 있습니다.    &lt;style&gt;         div{             width: 50%;/* body의 50%로 크기지정*/         }         img{              max-width: 640px; /*이미지 최대크기 지정*/         }  &lt;/style&gt;   주의할 점   width는 너비를 지정하는 속성이고, max-width는 최대 넓이 제한 길이를 지정하는 속성입니다.   혼동하지 않도록 조심해야 합니다.   📄 가변이미지 설정 2 | picture 태그 사용   주로 해상도 별로 이미지의 비율을 바꾸고 싶을때 picture태그를 사용합니다.   source태그를 통해서 이미지를 미디어 조건에 맞게 불러올 수 있습니다.    &lt;picture&gt;         &lt;source srcset=\"jake2.jpg\" media=\"(min-width: 800px)\"&gt;&lt;!--800px보다 이미지가 커지면 jake2이미지를 보여준다.--&gt;         &lt;img src=\"jake..jpg\"&gt;  &lt;/picture&gt;   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["가변 이미지","max-width","picture"],
        "url": "/css/variable-image/",
        "teaser": null
      },{
        "title": "[flex-box] align-items/self/content",
        "excerpt":"📄 align-items (Flex Item이 한줄일 때 사용)   플렉스 컨테이너의 플렉스 아이템들이 어떤 식으로 정렬될 것인지 결정합니다.    align-items: stretch; /*기본값, 아이템들이 교차축에 스트레치되어 크기가 늘어남.*/ align-items: flex-start; /*stretch가 되지 않고 교차축의 앞쪽에 배치됨*/ align-items: flex-end; /*교차축의 끝점으로부터 시작점을 향해 배치*/ align-items: center; /* 교차축의 중심부에 배치*/   📄 align-self   각각의 플렉스아이템이 교차축에서 어떤 식으로 정렬될 것인지 스스로 결정합니다.    li:nth-child(3) {   align-self: flex-start;   /*ul(컨테이너)목록 중 3번째 li(아이템)에만 flex-start적용*/ }   📄 align-content(Flex Item이 한줄이상일 때 사용)   교차축 위에서 justify-content와 동일하게 사용할 수 있는 속성입니다.      flex-wrap의 값이 wrap으로 지정되어 있을 때   아이템을 배치하기 위해 필요한 공간보다 플렉스 컨테이너가 더 클 때   align-content: space-around; /*행이 여러개가 되었을 때 요소들이 동일한 여백을 가지게 됨.*/ align-content: space-between; /*양쪽 여백이 사라진 상태에서 요소들이 동일한 여백을 가지게 됨.*/     간단히 말해, align-items는 flex-wrap이 nowrap(기본값)일때의 교차축 배치방법이고  align-content는 flex-wrap이 wrap일때의 교차축 배치방법입니다.   📄 flex-basis(기본값 : auto)   플렉스 아이템의 초기 크기를 지정합니다.  box-sizing이 따로 설정되지 않은 경우, 콘텐츠 박스의 크기를 결정합니다.    li:nth-child(2) {   /*플렉스 컨테이너가 처음 만들어졌을 때 기본 크기를 정해줌.*/   flex-basis: 100px; /*두번째 아이템 기본 크기: 100px*/   flex-shrink: 2; }   📄 flex   flex-grow, flex-shrink, flex-basis의 세 가지 속성을 한번에 정의할 수 있는 단축 속성입니다.   .item {   flex: 0 0 200px; /* 200px보다 크거나 작을 수 없음*/   flex: 0 1 200px; /*늘어나진 않지만 줄어들 수는 있음.*/ }   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["align-items","align-self","align-content"],
        "url": "/css/css-align-items/",
        "teaser": null
      },{
        "title": "CSS 텍스트 꾸미기",
        "excerpt":"📄 font-family   글꼴을 정의합니다.   여러 개의 글꼴을 연달아 작성하여 우선순위를 정할 수 있습니다.   p {   font-family: Times.monospace, serif; }   📄 font-size   글자 크기를 정의합니다.      px: 모니터 상의 화소 하나 크기에 대응하는 절대적인 크기   span {   font-size: 16px; }      rem: &lt;html&gt; 태그의 font-size에 대응하는 상대적인 크기   span {   font-size: 2rem; }      em: 부모태그(상위태그)의 font-size에 대응하는 상대적인 크기   span {   font-size: 1.5em; }   📄 text-align   정렬 방식 정의합니다.      left/right: 왼쪽 또는 오른쪽 정렬한다.   center: 가운데 정렬한다.   justify: 양끝 정렬한다.(마지막 줄 제외)   p {   text-align: right; }   📄 color   글자 색상을 정의합니다.      키워드: 미리 정의된 색상별 키워드를 정의한다.   RGB 색상 코드: # + 여섯자리 16진수 값 형태로 지정한다.   RGB 함수: Red, Green, Blue의 수준을 각각 정의해 지정한다.   span {   color: red; } span {   color: #FF000; } span {   color: rgb(100%, 0%, 0%); }   📄 line-height   글자가 위치한 높이의 크기(행간)를 의미합니다.   단위를 입력하지 않으면 브라우저가 자동으로 배율로 인식합니다.   line-height: 52px;   📄 letter-spacing   텍스트의 자간을 설정합니다.   해당 수치만큼 자간이 가까워집니다.   letter-spacing: 20px; letter-spacing: -2px;   📄 word-spacing   띄어쓰기를 기준으로한 단어의 간격을 의미합니다.   word-spacing: 20px;   📄 text-indent   텍스트의 들여쓰기를 결정합니다.   text-indent: 50px;   📄 text-transform   영문 텍스트의 대/소문자를 바꿀 수 있습니다.   text-transform: none; text-transform: capitalize; text-transform: uppercase; text-transform: lowercase;   📄 overflow   콘텐츠가 커서 요소 안에서 내용을 다 보여주기 힘들 때, 어떤 방식으로 보여줄지 결정합니다.   overflow: visible(기본값); overflow: hidden; overflow: scroll; // 무조건 스크롤 적용 overflow: auto; // 콘텐츠 밖으로 텍스트가 넘쳤을때만 스크롤 적용   📄 text-overflow   텍스트가 한줄일 때, 요소 밖으로 넘치는 text를 어떻게 표기할지 결정합니다.   선행 조건      white-space: nowrap;   overflow: hidden;   text-overflow: clip(기본값); // 공간에 맞게 텍스트가 잘림 text-overflow: ellipsis; // 잘린 텍스트를 말줄임표를 이용해 표현     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["font","text","line-height","letter","word","overflow"],
        "url": "/css/css-font/",
        "teaser": null
      },{
        "title": "상속&공용 키워드",
        "excerpt":"📄 상속(Inheritance)   상속(Inheritance)이란 하위 요소가 상위 요소의 스타일 속성값을 물려받는 것을 의미합니다.  상속 가능 여부는 속성마다 다릅니다.    상속되는 속성      color   font-family   font-size   상속되지 않는 속성      padding   margin   border   ul {   color: tamato; }   하위요소인 li 혹은 ol태그는 상위요소인 ul태그의 color에 대한 속성 값을 물려받아 color: tomato라는 값을 사용할 수 있습니다.   📄 공용 키워드   모든 CSS 속성에 사용 가능한 키워드 입니다.  ‘전역값’이라고 부르기도 합니다.      inherit: 상위 요소로부터 해당 속성의 값을 받아 사용한다.   initial: 해당 속성의 기본값을 요소에 적용한다.   unset: 상속 속성에 대해서는 inherit처럼, 상속되지 않는 속성에 대해서는 initial처럼 적용한다.  즉, 상속을 받지 않는 요소에 unset을 쓴다는 것은 initial로 쓰겠다는 말과 같다고 볼 수 있습니다.   다음은 공용키워드 inherit을 사용한 예시입니다.   &lt;section&gt;   인사말   &lt;p&gt;&lt;a href=\"#\"&gt;홍길동&lt;/a&gt;님, 안녕하세요!&lt;/p&gt; &lt;/section&gt;   a {   color: inherit; }   a태그는 브라우저의 내장 스타일이 적용되어 방문 전에는 파란색, 방문 후에는 보라색으로 표시됩니다.  이러한 내장 스타일이 마음에 들지 않는다면 color를 inherit으로 설정해주면 됩니다.   출처      유노코딩   DaleSeo - CSS의 상속  ","categories": ["CSS"],
        "tags": ["CSS 상속","inherit"],
        "url": "/css/css-inheritance/",
        "teaser": null
      },{
        "title": "의사클래스(가상클래스)",
        "excerpt":"📄 의사클래스(가상클래스)   의사클래스는 선택자에 추가하는 키워드로, 요소가 어떤 특정한 상태가 되었을 때 요소를 선택하겠다는 의미입니다.   📄 의사클래스 종류      hover: 마우스 포인터가 요소에 올라가 있다.   [type=\"button\"]:hover{ 버튼에 마우스 커서 댔을 때 배경 색깔 변경                 background-color: gray;                 }      active: 사용자가 요소를 활성화했다.(ex. 마우스 클릭)     [type=\"button\"]:active{버튼을 마우스로 클릭하면 배경 색깔 변경                 background-color: black;                 }      focus: 요소가 포커스를 받고 있다.    input:focus{ 포커스 상태일 때 색 변경             color: white;             background-color: red;             }      visited: 방문한적 있는 링크에 효과를 준다.    .link1:visited {   color: red; }      disabled: 비활성 상태의 요소이다.    &lt;input type=\"text\" placeholder=\"아무거나 쓰기\" disabled&gt;      nth-child(): 형제 사이에서의 순서에 따라 요소를 선택한다.    .box:nth-child(3) {   /*.box의 세번째 요소에 배경 색 적용*/   background-color: red; }      nth-of-type: :nth-of-type이라는 가상 클래스가 적용된 선택자에 해당 되는 요소만 카운트한다.   .container p:first-of-type {   /* container안에 있는 p 태그 중 첫번째 요소 선택*/   background: blue; }   📄 가상요소 선택자   가상 요소 선택자를 이용하면 html요소를 수정하지 않고, css만으로 가상 요소를 추가할 수 있습니다.      before   after   .box1 {   width: 200px;   height: 300px;   background-color: yellow; } .box1:after {   content: \"나는 박스2입니다.\";   display: block;   background-color: blue; }   중요하지 않은 간단한 css작업에 사용된다. content애 값을 추가해서 직접 html에 코드를 추가하지 않고 css를 다룰 수 있습니다.  콘텐츠 자체적인 내용 뿐 아니라 사용자와의 상호작용과 관련된 경우에도 스타일을 적용할 수 있어 유용합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["hover","active","before","after"],
        "url": "/css/css-pseudo-class/",
        "teaser": null
      },{
        "title": "웹폰트(Web Font)",
        "excerpt":"📄 웹폰트(Web Font)   웹 폰트란 사용자가 로컬에 폰트를 설치하지 않아도, 특정 서버에 위치한 폰트를 다운받아 웹페이지에 표시되는 폰트입니다.   📄 웹폰트 적용 방법   1. @font-face 이용      웹폰트 파일을 준비한다.   CSS 문서에서 @font-family를 이용해 폰트 파일을 불러온다.   불러온 폰트 파일을 이용해 새로운 font-family를 만든다.   만든 font-family를 사용한다.   @font-face를 사용하는 방법보다 더 간편한 방법이 있습니다.   2. import 이용      구글 폰트에 접속해서 원하는 폰트를 찾는다.   원하는 굵기의 폰트 옆에 있는 Select this style를 클릭한다.   Use on web 항목에서 import를 선택하고 해당 import 구문을 css파일 내에 입력한다.   // index.css  @import url(\"https://fonts.googleapis.com/css2?family=Nanum+Pen+Script&amp;display=swap\");  div {   font-family: \"Nanum Pen Script\", cursive; }  ","categories": ["CSS"],
        "tags": ["@font-face"],
        "url": "/css/css-web-font/",
        "teaser": null
      },{
        "title": "[애니메이션] CSS 애니메이션(animation)",
        "excerpt":"📄 animation 관련 속성    1. animation-name   : 어떤 keyframes를 요소에 적용할 것인지 지정   animation-name: moveright;    2. animation-duration   : 애니메이션을 한 번 재생하는데 걸리는 시간을 설정   animation-duration: 2s;    3. animation-direction   : 애니메이션의 재생 방향을 정의   animation-direction: normal; // 기본값(정방향) animation-direction: reverse; // 역방향 animation-direction: alternate; // 정방향으로 재생, 단 반복시 정방향/역방향을 번갈아 재생 animation-direction: alternate-reverse: 역방향으로 재생, 단 반복시 역방향/정방향을 번갈아 재생    4. animation-iteration-count   : 애니메이션 재생 횟수를 정의한다.   따로 지정하지 않으면 한번 재생되고 끝난다.   animation-iteration-count: inifinite // 무한 반복;; ; ; ; ; ; ; ; ; ; ;    5. animation-timing-function   : 애니메이션 재생 패턴을 정의한다.   animation-timing-function: ease-in-out;    6. animation-delay   : 애니메이션 시작을 얼마나 지연할 지 설정   animation-delay: 2s;    animation 단축속성 순서    animation: moveRight(name) 0.4 (duration) linear(timing-function) 1s (delay)   infinite(iteration-count) alternate(direction);     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["animation"],
        "url": "/css/css-animation/",
        "teaser": null
      },{
        "title": "CSS background",
        "excerpt":"📄 background   background는 콘텐츠의 배경을 정의합니다.   📄 background의 하위 속성   ▪ background-color   : 배경색을 정의합니다.   ▪ background-image   : 배경 이미지를 정의합니다.   background-image: url(이미지);   ▪ background-position   : 배경 이미지의 초기 위치를 정의합니다.   ▪ background-size   : 배경 이미지의 크기를 정의합니다.      cover: 이미지가 찌그러지지 않는 한도 내에서 최대로 설정합니다.   contain: 이미지가 찌그러지거나 잘리지 않는 한도 내에서 최대로 설정합니다.   ▪ background-repeat   : 배경 이미지의 반복 방법을 정의합니다.      no-repeat: 이미지를 반복하지 않습니다.(이미지가 콘텐츠보다 작을 경우 활용)   div {   background-image: url(이미지);   background-repeat: no-repeat;   background-position: center;   background-size: contain; }     background는 하위 속성을 연달아 정의할 수 있습니다.  매우 다양하여 사용자는 속성값을 정확한 값으로만 정의하면 됩니다.   background: no-repeat url(이미지);  ","categories": ["CSS"],
        "tags": ["backgroud"],
        "url": "/css/css-background/",
        "teaser": null
      },{
        "title": "CSS 상대단위",
        "excerpt":"📄 절대 길이 단위 px   px는 절대길이 단위입니다.  따라서 가변성이 없으며 반응형 웹에 적합하지 않습니다.    📄 상대 단위   상대단위는 고정되지 않고 어떤 기준에 따라 변하는 단위입니다.  반응형 웹에는 상대적으로 크기로 조정할 수 있는 상대단위를 사용합니다.    1. %   부모 요소의 해당 속성 값에 비례하여 지정한 비율의 값을 적용합니다.   2. em   스타일 지정 요소의 font-size 속성 값에 비례하여 값을 결정합니다. %는 부모 요소에 비례해서 크기르 결정하지만 em은 본인에 비례해서 크기를 결정합니다.   /* font-size : 16px 인 경우 */  1em =&gt; 16 * 1 = 16px 0.8em =&gt; 16 * 0.8 = 12.8px 3em =&gt; 16 * 3 = 48px   3. rem   최상위 html 요소의 font-size 속성 값에 비례하여 값을 결정합니다.   /* font-size : 16px 인 경우 */  1rem =&gt; 16 * 1 = 16px 0.8rem =&gt; 16 * 0.8 = 12.8px 3rem =&gt; 16 * 3 = 48px     4. vw / vh      viewport란? 화면 display상의 표시 영역            vw: viewport의 너비값에 비례            vh: viewport의 높이값에 비례       /* viewport가 1200(px)x920(px)인 경우 */  10vw =&gt; 1200x0.1 = 120px 50vh =&gt; 920x0.5 = 460px 100px =&gt; 1200x1 = 1200px   📄 상대단위의 장점      상대적인 크기의 단위를 이용하면 박스의 레이아웃 스타일을 수정할 때 유용합니다.   박스의 비율을 고려해가며 크기를 정할 수 있어서 계산이 수월합니다.   📄 주의할 점      em과 rem은 주변 상황에 따라 그 크기를 달리할 수 있는 가변성을 지니고 있지만, 브라우저나 기기 화면에 크기에 따라 크기가 달라지는 단위는 아닙니다.   em으로 margin이나 padding등 내, 외부의 여백크기를 정할 때는 부모요소로 부터 상대적인 크기를 가지는 것이 아니라, 스스로 크기를 지정하게 되므로 주의해서 사용해야 합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["%","em","rem","vw/vh"],
        "url": "/css/css-em-rem/",
        "teaser": null
      },{
        "title": "[애니메이션] @keyframes",
        "excerpt":"📄 @keyframes   : css 애니메이션의 시작, 중간, 끝 등의 중간 상태를 정의한다.   /* keyframe 작성 방법 */ @keyframes 애니메이션이름 {   from {     left: 0;   }   to {     left: 200px;   } }   %로 진행도를 표기하기도 한다.   /* keyframe 작성 방법 */ @keyframes 애니메이션이름{ \t0% { \t\tleft : 0; \t} \t50%{ \t\tleft : 200px; \t} \t100%{ \t\ttop : 200px; \t\tleft :  200px; \t} }   작성한 keyframe은 animation 속성에서 사용한다.     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["@keyframes"],
        "url": "/css/css-keyframes/",
        "teaser": null
      },{
        "title": "position(relative & absolute)",
        "excerpt":"📄 position   position은 HTML 요소가 배치되는 방식을 방법을 정의합니다.   📄 position의 속성값    1. static: 기본값   position이 기본 속성일 때는 위치 조정이 불가능한 기본 HTML 요소의 상태가 됩니다.   따라서 top, left, bottom right를 사용할 수 없습니다.   .item2 {   position: static;   top: 30px; // 의미없는 코드   left: 30px; // 의미없는 코드 }    2. relative: 기본값   : 원래 있던 자리를 기준으로 요소의 위치를 조정할 수 있습니다.   div {   width: 100px;   height: 100px;   background-color: red;    position: relative;   top: 100px;   left: 100px; // 위에서부터 100px, 왼쪽에서부터 100px이동 }      원래 위치보다 위에서부터 100px, 왼쪽에서부터 100px 떨어진다.     3. absolute   : 요소를 일반적인 문서의 흐름에서 제거하고,   대상의 부모 요소 중 relative가 적용된 요소가 있다면 해당 위치를 절대 좌표의 기준으로 정합니다.   relative가 적용된 요소가 없다면 body태그를 기준으로 절대 위치를 정합니다.   div {   width: 100px;   height: 100px;   background-color: red;    position: absolute;   top: 100px;   left: 100px; }    4. fixed   : 스크롤과 무관하게 뷰포트를 기준으로 요소의 위치를 설정합니다.   스크롤을 내려도 화면에 고정되어 위치가 변하지 않습니다.   .item2 {   position: fixed;   top: 30px;   left: 30px; }    4. sticky   : 요소의 원래 위치에 있다가 스크롤이 내려가면 지정된 좌표에 고정됩니다.   기준은 부모 요소의 좌표입니다.   스크롤이 내려가지 않았을 때는 static처럼 작동하다가, 해당요소의 위치 아래로 스크롤이 내려가면 지정한 좌표에 고정됩니다.   .item2 {   position: sticky;   top: 30px;   left: 30px; } ---  ## 출처  - [강력한 CSS](https://www.inflearn.com/course/%EA%B0%95%EB%A0%A5-css-%EC%BD%94%EB%93%9C%EC%BA%A0%ED%94%84)  ","categories": ["CSS"],
        "tags": ["position","relative","absolute"],
        "url": "/css/css-position/",
        "teaser": null
      },{
        "title": "[애니메이션] transform",
        "excerpt":"📄 transform   : 대상이 되는 요소에 이동, 회전, 확대/축소, 비틀기 등의 변형 효과를 줍니다.   📄 transform의 속성값   ▪ translate(x, y)   : 요소의 좌표를 움직인다.   transform: translate(20px, 25%);   대상 요소를 x축으로 20px만큼, y축으로 25%만큼 움직입니다.   괄호안에 값이 하나만 입력된 경우, 두 영역에 동일한 값이 입력된 것으로 간주합니다.   ▪ translateX(n) / translateY(n)    : 요소를 x축이나 y축 한방향으로 움직이고 싶을 때 사용한다.   transform: translateX(20px);   ▪ scale(x, y)    : X축으로 x만큼, Y축으로 y만큼 요소를 축소 혹은 확대합니다.   transform: translateX(0.75, 1.1);   ▪ skewX(x) / skewY(y)    : 요소를 X, Y축으로 x도 만큼 또는 y도 만큼 기울입니다.   transform: skewX(15deg);   ▪ rotate(n)    : 요소를 n만큼 회전합니다.   transform: rotate(45deg);     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["transform"],
        "url": "/css/css-transform/",
        "teaser": null
      },{
        "title": "[애니메이션] transition",
        "excerpt":"📄 transition   : CSS 속성을 이용한 변화의 전, 후 사이에 애니메이션을 추가해 움직임을 부드럽게 만들어주는 속성   📄 transition 속성   1. transition-property   : 어떠한 속성(property)에 transition을 적용할지 정합니다.   trasition-property: color, transform;   2. transition-duration   : transition에 걸리는 시간을 지정합니다.   transition-duration: 0.2s;   3. transition-timing-function   transition의 속도 패턴을 정합니다.   transition-duration: ease-in-out | linear | ease | ease-in | ease-out;   CSS-Transition timing function sample에서 각각의 속성들을 확인할 수 있습니다.   4. transition-delay   : transition 요청을 받은 후 실제로 실행되기까지 기다려야 하는 시간의 양을 지정합니다.   transition-delay: 2s;   transition의 속성을 한번에 적어줄 수도 있습니다.   transition: color 0.4s (duration) ease-in-out(timing-function) 1s (delay);   출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["transition"],
        "url": "/css/css-transition/",
        "teaser": null
      },{
        "title": "[JavaScript] 식별자(Identifier)",
        "excerpt":"📄 식별자(Identifier)   코드 내의 변수, 함수 혹은 속성을 식별하는 문자열을 식별자라고 합니다.   식별자를 통해서 이름을 지어주게 됩니다.   ▪ 식별자를 만들 때 규칙           식별자는 대소문자를 구분합니다.            유니코드 문자, $, 숫자를 사용할 수는 있지만, 숫자로 시작할 수는 없습니다.            예약어는 사용할 수 없고, 공백 문자도 사용할 수 없습니다.            한글도 가능은 하지만, 보통 영문을 사용합니다.       ▪ 주의할 점      식별자를 만들 때는 의미없는 이름보다는, 역할에 맞는 적절한 이름을 짓도록 해야합니다.   ▪ 식별자 가능 유무 확인하기   [식별자]https://mothereff.in/js-variables       사용가능한 식별자를 확인하는 페이지 입니다.    출처      패스트 캠퍼스 프론트엔드 올인원 패키지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","식별자"],
        "url": "/javascript/js-identifier/",
        "teaser": null
      },{
        "title": "조건문",
        "excerpt":"📄 조건문   조건문은 표현식이 참으로 평가될 때, 실행되는 블럭입니다.   if (true) {   console.log(\"항상 실행\"); // 출력됨. }  if (false) {   console.log(\"항상 실행되지 않음\"); // 출력되지 않음. }   조건이 참인 경우는 출력이 되고 거짓인 경우는 출력되지 않습니다.                  TIP       블록에 코드가 한줄이면, 중괄호는 생략 가능합니다.           if (true) console.log(\"항상 실행\");  if (false) console.log(\"항상 실행되지 않음\");   📄 표현식이 거짓으로 평가될 때   표현식이 거짓으로 평가될 때는 false만 있는 것이 아닙니다.   if (false) console.log(false); if (0) console.log(0); if (\"\") console.log(\"\"); if (null) console.log(null); if (undefined) console.log(undefined); if (NaN) console.log(NaN);   위의 경우 모두 거짓으로 평가되어 출력되지 않습니다.   📄 표현식이 참으로 평가될 때   마찬가지로 참인 경우도 여러가지 경우가 있습니다.   if (true) console.log(true); if (37) console.log(37); if (-37) console.log(-37); if (\"Mark\") console.log(\"Mark\"); if ({}) console.log({}); if ([]) console.log([]);   📄 if에 해당하지 않을 때 | else   if문으로 조건식을 작성하고 반대의 경우에는 간단하게 else로 작성할 수 있습니다.   const n = 15;  if (n % 3 === 0) {   console.log(\"n은 3의 배수 입니다.\"); } else if (n % 5 === 0) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   마찬가지로 한줄로 작성할 경우 중괄호 생략이 가능합니다.   if (n &gt; 0) console.log(\"n이 0보다 큰 경우\"); else console.log(\"n이 0보다 크지 않은 경우\");   📄 조건이 여러번 반복되는 경우   조건이 여러번 반복되는 경우에는, 조건을 변수나 상수에 넣어 작성할 수 있습니다.    const multipleOfThree = n % 3 === 0; const multipleOfFive = n % 5 === 0;  if (multipleOfThree &amp;&amp; multipleOfFive) {   console.log(\"n은 15의 배수입니다.\"); } else if (multipleOfThree) {   console.log(\"n은 3의 배수입니다.\"); } else if (multipleOfFive) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   📄 삼항 연산자를 이용한 조건부 실행   조건 ? 조건이 참이면 실행되는 표현식 : 조건이 거짓이면 실행되는 표현식   삼항 연산자를 이용한 조건부 실행은 위의 형식으로 나타납니다.   중괄호 {}를 사용할 수 없는 문법이기 때문에 하나의 표현식으로 작성합니다.   let n = 5;  const message = n % 5 === 0 ? \"5의 배수 입니다.\" : \"5의 배수가 아닙니다.\"; console.log(message);   주의할 점   삼항연산자를 남발하면 오히려 보기 헷갈릴 수 있으니 가급적 여러번 사용하는 것은 지양합니다.    📄 switch를 이용한 조건문   switch뒤 괄호 안에 있는 값이 무엇인지 중괄호 안에 있는 코드들을 비교해서 실행합니다.   복수의 if문을 switch문으로 정리할 수 있습니다.      5의 배수 일 경우 case0으로 출력하는 조건문   switch (n % 5) {   case 0: {     console.log(\"5의 배수입니다.\");     break;   }   case 1:   case 2:   case 3:   case 4:     console.log(\"5의 배수가 아닙니다.\");    default:     console.log(n); }   만약에 해당 블럭이 실행된 후 다음 블럭을 거치지 않고 switch문을 나가고 싶다면, case문 안에서 break;를 실행합니다.   break와 case 문의 순서를 잘 조정하여, 원하는 코드를 만들어 낼 수 있도록 제대로 이해해야 합니다.   출처      패스트캠퍼스 프론트엔드 강의   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","조건문"],
        "url": "/javascript/js-conditional/",
        "teaser": null
      },{
        "title": "객체(Object)",
        "excerpt":"📄 객체란 무엇인가?   객체는 이름과 값으로 구성된 프로퍼티의 정렬되지 않은 집합체입니다.   객체를 생성할 때는 함수나 클래스를 이용할 수 있습니다.   쉽게 말해 함수나 클래스를 큰 틀로 생각하고 하나하나 찍어내는 것을 각각 객체라고 생각하면 됩니다.   이 객체는 인스턴스라고 부르기도 합니다.   new라는 키워드를 통해 객체를 생성합니다.   function A() {}  const a = new A(); // new를 통해서 함수 A의 객체가 만들어져 변수 a에 할당된다. console.log(a, typeof a); console.log(A());   📄 객체에 속성(프로퍼티)추가하기   함수에서 프로퍼티를 만들어 객체에 할당할 수 있습니다.   프로퍼티를 설정하면 각각의 성질을 가지는 속성을 만들게 됩니다.   function A(name) {   this.name = name; }  const a = new A(\"Mark\"); console.log(a);   함수를 속성으로 넣기   함수를 프로퍼티로 넣는 것또한 가능합니다.   function B() {   this.hello = function () {     console.log(\"hello\");   }; }  new B().hello();      함수B의 프로퍼티 hello에 ‘hello’를 출력하는 함수를 설정함.    📄 객체 리터럴   객체 리터럴은 중괄호 안에 프로퍼티를 정의하여 객체를 생성하는 방식입니다.   프로퍼티는 쉼표(,)로 구분합니다.   const b = {   name: \"Mark\", // name이라는 프로퍼티에 'Mark'라는 값 할당 };  console.log(b, typeof b);   결과   {   name: \"Mark\"; } object;   프로퍼티에 함수도 할당할 수 있습니다.   const c = {   name: \"Mark\",   hello1() {     console.log(\"hello1\", this.name);   },   hello2: function () {     console.log(\"hello2\", this.name);   },   hello3: () =&gt; {     console.log(\"hello3\", this);   }, };  c.hello1(); c.hello2(); c.hello3();   결과   hello1 Mark hello2 Mark hello3 {}  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체"],
        "url": "/javascript/javascript-object/",
        "teaser": null
      },{
        "title": "[클래스] 상속",
        "excerpt":"📄 클래스 상속   extends라는 키워들를 통해서 자식클래스가 부모클래스를 상속받습니다.   class Parent {}  class Child extends Parent {}   오버라이딩(override)   오버라이딩은 부모클래스에서 구현한 함수나 변수를 자식클래스에서 다시 구현하는 것입니다. 즉, 자식이 만든 함수가 부모가 만든 함수를 덮어씌우는 것을 오버라이딩이라고 합니다.   class Parent {   name = \"Lee\";    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age = 37;    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }      자식 클래스에서 부모클래스의 hello 함수를 오버라이딩 함.   📄 super (새로운 속성 추가하기)   자식클래스가 부모클래스로부터 상속을 받을 때, 새로운 속성을 추가하려면 super()로 부모클래스로부터 생성자를 호출해 초기값을 세팅합니다.   super은 생성자안에서 사용합니다.    class Parent {   name;    constructor(name) {     // name값을 받는 생성자     this.name = name;   }    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age;    constructor(name, age) {     super(name); //부모클래스의 생성자를 호출해 초기값 세팅     this.age = age;   }    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }   출처      패스트클래스  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스","상속"],
        "url": "/javascript/js-class2/",
        "teaser": null
      },{
        "title": "데이터 타입(Data type)",
        "excerpt":"📄 데이터 타입(Data type)   프로그램에서 다뤄지는 모든 데이터에는 다양한 종류가 있습니다.   그 종류들을 데이터 타입이라고 부릅니다.   📄 String   String은 데이터를 문자열로 표현합니다.   데이터를 문자열로 지정하는 경우 따옴표 혹은 쌍따옴표를 이용합니다.   let text = \"hello\"; let name = \"하이요\";   📄 boolean   boolean은 데이터의 참과 거짓을 지정하는 타입입니다.   let good = true; let loading = false;   📄 null과 undefined   null과 undifined는 둘다 의미가 없음을 뜻합니다.   하지만 분명한 차이점이 존재합니다.   null은 의미가 진짜 없다는 뜻을 가지고 있고,   undefined는 의미가 아직 정해지지 않았다는 뜻입니다.   let friend = null; let criminal;   위 코드를 출력하면   friend는 null을 그대로 출력하지만,   아무것도 값이 지정되지 않은 criminal은 undefined를 출력합니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","데이터타입"],
        "url": "/javascript/javascript-datatype/",
        "teaser": null
      },{
        "title": "배열(Array)",
        "excerpt":"📄 배열(Array)   배열은 여러개의 항목이 들어있는 리스트를 뜻합니다.   배열은 대괄호([])를 사용하여 선언합니다.   대괄호 안에 들어가는 항목들은 숫자, 문자열 배열, 객체 등 이 있습니다.   const array = [1, 2, 3, 4, 5];      이름이 array인 배열을 선언함.    📄 배열에 새로운 항목 추가   배열에 새로운 항목을 추가할 때는 push라는 키워드를 사용합니다.   array.push(6);      배열에 6이라는 값을 추가함    이렇게 배열에 값을 추가하면 배열의 마지막에 추가 됩니다.    📄 배열의 크기 조회   배열의 크기를 조회 한다는 것은 배열에 몇개의 항목이 있는지 계산한다는 뜻입니다.   배열의 크기를 조회할 때는 length라는 키워드를 사용합니다.   console.log(array.length);      배열 array의 크기를 조회해서 출력한다.    출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","배열"],
        "url": "/javascript/javascript-array/",
        "teaser": null
      },{
        "title": "get & set 함수",
        "excerpt":"📄 get &amp; set 함수   클래스 내부에서 get과 set 함수를 이용해 값을 저장하고 불러올 수 있습니다.      get: 값을 조회한다.   set: 값을 저장한다.   📄 Getter함수   Getter함수는 특정 값을 실행이 아닌 조회하려고 할 때 사용됩니다.   조회하려는 값을 return키워드를 사용해 조회합니다.   const numbers = {   a: 1,   b: 2,   get sum() {     console.log(\"sum함수가 실행됩니다.\");     return this.a + this.b;   }, };      const numbers라는 객체의 a와 b를 합한 값을 조회하는 Getter함수 sum.    📄 Setter함수   Setter함수는 객체나 함수 밖에서 값을 설정하려고 할 때 사용됩니다.   그렇기 때문에 Getter함수와는 다르게 파라미터 값 설정은 필수입니다.   const dog = {   _a: 1,    set name(value) {     this._a = value;   }, };   출처      패스트캠퍼스 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","get","set"],
        "url": "/javascript/javascript-get&set/",
        "teaser": null
      },{
        "title": "[WEB] WEB API란?",
        "excerpt":"📄 API란?   API는 Application Programming Interface의 약자입니다.  직역하자면 프로그램이 서로 상호작용하게 도와주는 매개체(어플리케이션)입니다.  우리는 자판기가 어떻게 동작하는지 전혀모르지만 몇번의 버튼 클릭으로 원하는 상품을 얻습니다.   마찬가지로 프로그램들이 서로 어떻게 상호작용하는지 로직을 구체적으로 들여다 보지 않아도  간단한 동작으로 프로그램이 서로 상호작용하게 도와주는 것을 API라고 할 수 있습니다.   📄 WEB API란?   WEB API는 웹브라우저에서 제공하는 API를 뜻합니다.  브라우저마다 공통적으로 제공하는 API의 종류는 굉장히 다양합니다.  브라우저는 사용자의 정보를 보호할 의무가 있어 정보보안에 매우 민감합니다.  따라서 어떤 브라우저는 사용자의 권한을 요청하거나 HTTPS에서만 동작합니다.   ▪ Window.scroll()   window.scroll() 함수는 윈도우의 원하는 위치로 스크롤하게 해주는 WEB API입니다.   ✔ 사용방법      scroll(x좌표, y좌표)   첫번째 방법은 파라미터값을 받아오는 방법입니다.   &lt;button onclick=\"scroll(0,100);\"&gt;&lt;/button&gt; //창 상단에 수직 100번째 픽셀을 배치한다.      OPTION들   window.scroll({   top: 100,   left: 100,   behavior: \"smooth\", });      top: Y축을 따라 픽셀 수를 지정   left: X축을 따라 픽셀 수를 지정   behavior: smooth를 지정하면 스크롤이 부드럽게 애니메이션 된다.   ▪ Window.scrollBy()   Window.scrollBy()는 주어진 값만큼 윈도우에서 스크롤링하는 함수입니다.   ✔ 사용방법   사용방법은 window.scrollBy()와 크게 다르지 않습니다.      scrollby(x축 방향 크기, y축 방향 크기)   첫번째 방법은 파라미터값을 받아오는 방법입니다.   // 창 상단에 수직 100번째 픽셀을 배치한다. window.scrollBy(0, window.innerHeight); // 페이지 아래로 스크롤 할때 window.scrollBy(0, -window.innerHeight); // 페이비 위로 스크롤 할때      OPTION들   window.scroll({   top: 100,   left: 100,   behavior: \"smooth\", });      top: Y축을 따라 픽셀 수를 지정   left: X축을 따라 픽셀 수를 지정   behavior: smooth를 지정하면 스크롤이 부드럽게 애니메이션 되고, instant를 지정하면 즉시 해당 위치로 점프하게 됩니다.   📌 HTTP란?   HTTP는 Hypertext Transfer Protocol의 약자입니다.  HTTP는 웹 클라이언트와 서버가 통신하는 통신규약을 정해놓은 것입니다.  클라이언트가 서버에 정보를 요청하고 받아오는 방식으로 이루어져 있습니다.   📌 HTTPS란?   HTTPS는 Hypertext Transfer Protocal Secure의 약자입니다.  HTTP에 보안처리를 더해준 것입니다.  보안처리가 되지 않은 HTTP에서 패스워드를 입력해서 데이터를 서버에 보내면,  아무런 보안처리가 되지 않았기 때문에 해커가 내용을 볼 수 있습니다.    반면  HTTPS는 encrypt가 되어서 내용이 해커가 알아볼 수 없는 암호키를 이용해서 보안처리 되어 있습니다.  몇몇의 API는 HTTPS환경에서만 동작하기 때문에 잘 확인하고 사용해야 합니다.   출처      드림코딩  ","categories": ["WEB"],
        "tags": ["WEP API"],
        "url": "/web/web-WEB-API%EB%9E%80/",
        "teaser": null
      },{
        "title": "[WEB] 브라우저 구조",
        "excerpt":"📄 브라우저 구조   브라우저에서 웹페이지를 열면 윈도우라는 전체적인 오브젝트가 존재합니다   윈도우 안에는 DOM, BOM, JavaScript라고 하는 것들이 있습니다.   📄 DOM   페이지를 브라우저에서 열게되면 윈도우라는 전체적인 오브젝트가 있고 그 윈도우 안에는 DOM 즉,*Document Object Model들이 있습니다.   DOM은 웹페이지의 모든 콘텐츠를 수정가능한 객체로 나타냅니다.   윈도우에서 페이지가 표기되는 부분이 document입니다.      우리가 html문서를 작성하면 docmument에 표기됩니다.   📄 BOM   BOM은 Browser Object Model의 약자로 브라우저에 관련된 오브젝트들이 들어있습니다.   BOM은 문서 이외의 모든 것을 제공하기 위해 브라우저에서 추가적으로 제공하는 객체 입니다.   📄 JavaScript   자바스크립트는 웹 페이지에서 발생하는 어떤 이벤트에 코드가 응답하도록 합니다.   JavaScript는 DOM API를 통해 HTML과 CSS를 동적으로 수정, 사용자 인터페이스를 업데이트하는 일에 가장 많이 쓰입니다.     브라우저에서 윈도우는 최고의 글로벌 오브젝터입니다.   console.log(this)를 입력하면 window가 출력됩니다.   아무런 오브젝트를 지정하지 않아도 윈도우가 글로벌 오브젝트이기 때문에 자동으로 윈도우가 설정된 것입니다.   브라우저에서 우리가 이용할 수 있는 API를 제공해주고, 우리는 그 API를 호출하면서 브라우저에 있는 다양한 기능을 쓸 수 있습니다.   출처           드림코딩            JavaScript INFO            MDN      ","categories": ["WEB"],
        "tags": ["브라우저","DOM","BOM"],
        "url": "/web/web-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B5%AC%EC%A1%B0/",
        "teaser": null
      },{
        "title": "[WEB] 윈도우 사이즈 표기",
        "excerpt":"📄 윈도우 사이즈 표기 속성값   윈도우의 사이즈를 알아낼 때는, 글로벌 오브젝트인 window의 API를 사용합니다.       window.screen : 모니터의 해상도 즉 브라우저 바깥에 있는 부분까지 다 합한 것   window.outer : 브라우저의 URL, 탭, 전체적인 브라우저 사이즈   window.inner : 웹페이지 뿐만 아니라 웹페이지 스크롤바까지 합한 것.   documentElement.clientWidth : 스크롤바를 제외한 순수 문서 자체를 의미.   📄 실습코드   ▪ HTML   &lt;div class=\"tag\"&gt;Window size&lt;/div&gt;      ‘tag’라는 이름을 가진 클래스를 dive컨테이너로 설정했습니다.   ▪ CSS   .tag {   display: inline-block;   background-color: thistle;   padding: 16px;   margin-top: 16px;   font-size: 48px; }           div컨테이너를 인라인 요소로 변경했습니다.            배경과 크기를 적절히 설정해 가시성을 높였습니다.       ▪ JavaScript   const tag = document.querySelector(\".tag\"); function updateTag() {   tag.innerHTML = `       window.screen: ${window.screen.width}, ${window.screen.height} &lt;br&gt;       window.outer: ${window.outerWidth}, ${window.outerHeight} &lt;br&gt;       window.inner: ${window.innerWidth}, ${window.innerHeight} &lt;br&gt;       documentElement.clientWidth: ${document.documentElement.clientWidth}, ${document.documentElement.clientHeight} &lt;br&gt;       `; } window.addEventListener(\"resize\", () =&gt; {   updateTag(); }); updateTag();      DOM요소 중에서 첫번째로 발견되는 태그가 변수로 선언한 tag에 할당됩니다.   WEB API중 하나인 innerHTML을 사용해 윈도우의 크기를 보여주는 API들을 tag에 포함된 HTML에 설정합니다.   addEventListener 메서드로 resize가 변결될때마다 함수를 호출합니다.   📌 querySelector란?   Document.querySelector()는 제공한 선택자 또는 선택자 뭉치와 일치하는 문서 내 첫 번째 Element를 반환합니다.   일치하는 요소가 없으면 null을 반환합니다.   📌 addEventLitener란?   EventTarget 인터페이스의 addEventListener() 메서드는 지정한 유형의 이벤트를 대상이 수신할 때마다 호출할 함수를 설정합니다.   📌 resize란?   resize 이벤트는 document view의 크기가 변경될 때 발생합니다.   출처           MDN Document.querySelector            드림코딩      ","categories": ["WEB"],
        "tags": ["윈도우 사이즈"],
        "url": "/web/web-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%82%AC%EC%9D%B4%EC%A6%88-%ED%91%9C%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[WEB] 브라우저 좌표",
        "excerpt":"📄 브라우저 좌표   브라우저는 엑스축과 와이축으로 나뉘어져 있습니다.   좌표는 왼쪽 제일 최상위에서 시작합니다.   📄 Element.getBoundingclientRect()   Element.getBoundingclientRect()는 Elment오브젝트안에 들어있는 API함수입니다.   Elment오브젝트이기 때문에 코드안에 있는 모든 요소들이 getBoundingclientRect를 가지고 있습니다.   📄 기능   Element.getBoundingClientRect() 메서드는 엘리먼트의 크기와 뷰포트의 상대적인 위치 정보를 제공하는 DOMRect 객체를 반환합니다.   domRect = element.getBoundingClientRect();   요소에 관련된 사이즈나 위치에 관련된 정보를 얻을 수 있습니다.   x축과 y축을 통해 요소가 윈도우 위에서 얼마나 멀리 떨어져 있는지, 크기는 얼마인지 알아낼 수 있습니다.   📄 주의할 점   좌표의 시작점이 CSS는 오른쪽 아래이지만, JavaScript는 좌표의 시작점이 왼쪽 위입니다.      출처           드림코딩            MDN      ","categories": ["WEB"],
        "tags": ["getBoundingclientRect"],
        "url": "/web/web-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A2%8C%ED%91%9C/",
        "teaser": null
      },{
        "title": "[WEB] 윈도우 스크롤링",
        "excerpt":"📄 Window.scroll()   window.scroll() 함수는 윈도우의 원하는 위치로 스크롤하게 해주는 API입니다.   &lt;button onclick=\"scroll(0,100);\"&gt;button&lt;/button&gt;      창 상단에 수직 100번째 픽셀을 배치한다.    OPTION들   window.scroll({   top: 100,   left: 100,   behavior: \"smooth\", });      top: Y축을 따라 픽셀 수를 지정   left: X축을 따라 픽셀 수를 지정   behavior: smooth를 지정하면 스크롤이 부드럽게 애니메이션 된다.   📄 Window.scrollBy()   주어진 값만큼 윈도우에서 스크롤링하는 함수입니다.   사용방법은 window.scrollBy()와 크게 다르지 않습니다.   window.scrollBy(0, 100); // 페이지 아래로 스크롤 할때 window.scrollBy(0, -100); // 페이비 위로 스크롤 할때   OPTION들   window.scroll({   top: 100,   left: 100,   behavior: \"smooth\", });      top: Y축을 따라 픽셀 수를 지정   left: X축을 따라 픽셀 수를 지정   behavior: smooth를 지정하면 스크롤이 부드럽게 애니메이션 되고, instant를 지정하면 즉시 해당 위치로 점프하게 됩니다.   출처      드림코딩  ","categories": ["WEB"],
        "tags": ["scroll","scrollBy"],
        "url": "/web/web-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%8A%A4%ED%81%AC%EB%A1%A4%EB%A7%81/",
        "teaser": null
      },{
        "title": "비구조화 할당",
        "excerpt":"📄 비구조화 할당   비구조화 할당을 다른 말로 표현하면 객체 구조 분해라고 할 수 있습니다. 말 그대로 객체의 구조를 분해해서 특정값을 추출하는 과정을 비구조화 할당이라고 합니다.   const ironMan = {   name: \"토니 스타크\",   actor: \"로버트 다우니 주니어\",   alias: \"아이언맨\", };  const { name } = ironMan; //객체 ironMan에서 name이란 값을 추출함. console.log(name);   결과   토니 스타크   중괄호({})를 사용해서 선언한 객체의 원하는 키를 뽑아냅니다.   객체뿐만아니라 배열에서도 비구조화 할당을 할수 있습니다.   const array = [1, 2];  const [one, two = 2] = array;  console.log(one); console.log(two);   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체","비구조화 할당"],
        "url": "/javascript/javascript-destructuringAssignment/",
        "teaser": null
      },{
        "title": "spread & rest",
        "excerpt":"📄 spread 연산자   spread연산자는 ES6문법에서 처음으로 등장했습니다.   spread연산자는 객체나 배열의 엘리먼트를 요소 하나하나로 펼쳐서 사용할 수 있게 합니다.   ...라는 키워드를 사용합니다.   기존 객체나 배열을 복사하고 추가적인 값을 넣어줄 때 주로 사용합니다.   const first = {   one: 1, };  const second = {   ...first, //first의 엘리먼트를 가져옴.   two: 2, };  consol.log(first); consol.log(second);   ✔ 결과   { one: 1} { one: 1, two: 2}   장점           spread연산자는 기존객체를 변경시키지 않고 복사해옵니다.            코드의 재사용성이 높아집니다.       📄 rest 연산자   rest연산자도 마찬가지로 ...키워드를 사용합니다.   차이점은 ‘나머지’라는 뜻을 가진것처럼 정해준 값 이외의 값을 복사해온다는 것입니다.   const numbers = [0, 1, 2, 3, 4, 5, 6];  const [one, ...rest] = numbers; //첫번째 값을 제외한 값을 rest로 가져온다. console.log(one); console.log(rest);   ✔ 결과   0; [(1, 2, 3, 4, 5, 6)];   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","spread","rest"],
        "url": "/javascript/javascript-spread&rest/",
        "teaser": null
      },{
        "title": "[WEB] DOM이란?",
        "excerpt":"📄 DOM이란?      DOM은 Document Object Model의 줄임말로, 웹 페이지의 문서 구조를 객체로 나타낸 프로그래밍 인터페이스입니다.   웹 페이지의 HTML 등의 웹 문서를 트리 형태로 표현하고 각각 요소를 객체로 취급합니다.   DOM은 웹 페이지의 내용, 구조, 스타일 등을 동적으로 조작할 수 있는 기능을 제공합니다.   📄 DOM 요소에 접근하기   ▪ 하나의 노드 선택      document.getElementById   // id로 하나의 요소를 선택한다. const elem = document.getElementById(\"one\"); // 클래스 어트리뷰트의 값을 변경한다. elem.className = \"blue\";  console.log(elem); // &lt;li id=\"one\" class=\"blue\"&gt;Seoul&lt;/li&gt; console.log(elem.__proto__); // HTMLLIElement console.log(elem.__proto__.__proto__); // HTMLElement console.log(elem.__proto__.__proto__.__proto__); // Element console.log(elem.__proto__.__proto__.__proto__.__proto__); // Node      document.querySelector   // CSS 셀렉터를 이용해 요소를 선택한다 const elem = document.querySelector(\"li.red\"); // 클래스 어트리뷰트의 값을 변경한다. elem.className = \"blue\";   ▪ 여러개의 노드 선택      document.getElementsByClassName   document.getElementsByTagName   document.querySelectorAll   참고           Virtual DOM: ReactJS implementation            https://poiemaweb.com/js-dom      ","categories": ["WEB"],
        "tags": ["DOM","브라우저"],
        "url": "/web/web-DOM%EC%9D%B4%EB%9E%80/",
        "teaser": null
      },{
        "title": "[WEB] CSSOM이란?",
        "excerpt":"📄 CSSOM이란?   CSSOM은 CSS Object Model의 약자입니다.   브라우저에서 dom을 만들게 되면, css을 병합해서 cssom을 만듭니다.   HTML문서를 파싱하여 DOM트리를 만드는 것처럼, CSS를 파싱해서 자료를 트리 형태로 구조화한 것을 CSSOM이라고 합니다.   CSSOM에서 CSS에는 cascading이라는 규칙이 존재하기 때문에 따로 CSS를 정의하지 않아도 브라우저에서 설정된 기본적인 CSS파일이 있다면 그것들이 전부 다 적용됩니다.   dom과 cssom을 합해서 최종적으로 rendertree를 만듭니다.   rendertree에는 사용자에게 궁극적으로 보여지는 요소만 선별됩니다.   opacity: 0; visibility: hidden;      Render Tree에 포함됨.    display: none;      Render Tree에 포함되지 않음.    출처      드림코딩  ","categories": ["WEB"],
        "tags": ["CSSOM","브라우저"],
        "url": "/web/web-cssom/",
        "teaser": null
      },{
        "title": "[WEB] innerHTML vs element",
        "excerpt":"📄 innerHTML vs element   JavaScript에서 html내용을 변경하는 경우 방법은 여러가지가 있습니다   innerHTML을 사용하거나 element를 업데이트 해주는 방법이 있는데 두가지 방법은 차이점이 있습니다.   📄 innerHTML을 사용하는 경우   innerHTML은 해당 태그의 전체적인 HTML을 모두 업데이트합니다.   그렇게 되면 새로 추가한 요소들의 DOM Tree를 만들고 Render Tree를 만들게 되어 매우 번잡한 과정이 이어집니다.   따라서 한번 innerHTML을 만든 다음에 변경사항이 없다면 사용하는 것이 적합합니다.   📄 Element를 사용하는 경우   전체가 아닌 부분적으로 변경이 일어나는 경우라면 해당한는 Element를 업데이트하는 것이 효과적입니다.   따라서 Element의 reference 즉, Element의 변수를 가지고 있으면서 조금 더 많은 동작을 해야한다면 element를 개별적으로 변경하는것이 적합합니다.   출처      드림코딩  ","categories": ["WEB"],
        "tags": ["innerHTML","element"],
        "url": "/web/web-innerHTMLvselement/",
        "teaser": null
      },{
        "title": "[WEB] 브라우저 기능 취소하기",
        "excerpt":"📄 브라우저 기능 취소하기   브라우저에 있는 자체적인 기능 취소할때는 preventDefalt()라는 키워드를 사용합니다.   const checkbox = document.querySelector(input); checkbox.addEventListener(‘click’, event =&gt; { consol.log(‘checked’); event.preventDefault(); // 체크박스에 체크마크가 발생하지 않음. });   📄 주의할 점   빠르게 동작하는 이벤트에서는 브라우저가 사용자보다 코드처리를 더 빨리 하기 때문에 브라우저의 기본값을 취소할 수 없습니다.   document.addEventListner(‘wheel’, event =&gt; { consol.log(‘Scrolling’); event.preventDefault; //Erorr 발생! });   그럼에도 불구하고 브라우저 자체 기능을 취소하고 싶다면 option값을 추가해야 합니다.   passive는 boolean이므로 false로 지정하면 EventListener의 수동값이 해제 되므로 preventDefault를 호출할 수 있습니다.   document.addEventListner(‘wheel’, event =&gt; { consol.log(‘Scrolling’); event.preventDefault; }, passive: false}); // Event Listener가 active되어 PreventDefault 호출 가능.   하지만, 기본적으로 passive가 true로 설정된 event는 false로 설정하지 않는 것이 좋습니다.   출처      드림코딩  ","categories": ["WEB"],
        "tags": ["preventDefalt","브라우저"],
        "url": "/web/web-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B8%B0%EB%8A%A5-%EC%B7%A8%EC%86%8C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[WEB] Event(이벤트)",
        "excerpt":"📄 Event란?      프로그래밍 하고 있는 시스템에서 일어나는 사건입니다.   이벤트에 대한 반응을 코드로 작성시켜 이벤트가 발생되었을 때 자동적으로 상호작용이 가능하도록 합니다.   📄 Event Handler(이벤트 핸들러)란?      특정한 이벤트가 발생했을 때, 실행되는 코드 블럭입니다.   Event Handler를 등록할 수 있는 모든 요소는 Node를 상속하고, Node는 Event Target을 상속하므로 모든 Element는 Event Target이 될 수 있습니다.   따라서 모든 Element는 Event Target입니다.      Event Target이란? Event가 등록되어 있는 요소    Event Handler는 Event Listner라고 부르기도 합니다.   📄 Event 발생 과정           특정한 요소에 Event Handler를 등록한다.            나중에 사용자가 이벤트를 발생시키면, 브라우저는 Event Object를 만들어서 등록한 callback 함수에 전달한다.       📄 Event Target의 API   이벤트 타겟에서는 세개의 API가 있습니다.           EventTarget.addEventListener(): 이벤트 타겟에 특정한 이벤트 핸들러를 등록.            EventTarget.removeEventListener(): 이벤트 타겟으로부터 특정한 이젠트 리스너를 지움            EventTarget.dispatchEvent(): 이벤트 타겟에 인공적으로 이벤트를 발생시킴.       📄 Capturing(캡쳐링)과 Bubbling(버블링)   ▪ Capturing   Element들이 부모와 자식노드들이 경우, 브라우저는 이벤트가 발생할 경우 이 노드들을 거쳐 이벤트가 발생하는 캡쳐링 과정이 진행됩니다.   부모 컨테이너에서부터 시작해서 자식 컨테이너까지 캡쳐링을 통해 내려오고 자식 컨테이너에 등록된 Event Handler를 호출합니다.   ▪ Bubbling   버블링은 자식노드에서 시작해 상위의 부모에게 등록된 이벤트를 호출하는 것입니다.   엔지니어가 호출하는 것이 아니라 브라우저에서 자동적으로 실행됩니다.   버블링을 멈추고 싶다면 stopPropagation()을 사용하고, 하나의 엘리먼트에 함께 등록된 이벤트도 무시하고 싶다면 stopImmediatePrpagation()을 사용합니다.   하지만 다른 엔지니어를 고려하지 않고 이벤트를 무시하게 되면 예상치 못한 오류가 발생할 확률이 크므로 조심해서 사용해야 합니다.     대신에 event.target과 event.currnetTart가 같지 않은 경우 return을 함으로써 필요하지 않은 이벤트를 무시할 수 있습니다.   if (event.target !== event.currentTarget) {   return; }   출처           드림코딩            MDN      ","categories": ["WEB"],
        "tags": ["Event"],
        "url": "/web/web-%EC%9D%B4%EB%B2%A4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[WEB] Event Loop 02 | 이벤트 루프 과정",
        "excerpt":"📄 이벤트 루프      🎲 이벤트 루프를 이해하기 전 포인트 체크          자바스크립트는 멀티 스레드를 지원하지 않는다.      따라서 브라우저의 WEP API를 통해서 마치 멀티 스레드가 되는 것처럼 작업을 수행한다.      ▪ 어떻게 자바스크립트의 엔진과 웹 API가 서로 상호작용 할까?   자바스크립트 엔진에 있는 Call Stack과 WEB API들을 순환하며 관찰하는 것을 이벤트 루프라고 부릅니다.   브라우저는 사용자에게 1초동안 60개의 프레임을 보여줍니다.   즉, 16.7ms동안 업데이트가 일어나야 합니다.   이벤트 루프는 매우 빨라 한바퀴 도는데 1ms도 걸리지 않습니다.   📄 이벤트 루프 순서         브라우저에 이벤트가 발생하면 Microtask Queue 또는 Task Queue또는 Request Animation Frame Queue에 작업이 저장된다.   콜 스택이 비워질 때까지 기다렸다가 콜 스택이 비워지면 작업을 콜 스택으로 이동시킨다.   콜 스택에서 모든 작업을 끝낸 후 렌더링되고 브라우저에 표시된다.   ⭐ 포인트      콜스택에서 수행중인 작업는 끝날 때까지 보장이 되기 때문에, 중간에 다른일을 할 수 없고 수행중인 코드 블럭이 끝날때까지 이벤트 루프가 기다린다.   콜백함수의 내용은 어떤 순서로 작성되어있든지 상관없다. 자바스크립트 엔진이 콜백에 들어 있는 코드블럭이 다 완료될때까지 기다렸다가 나중에 렌더링이 발생하기 때문이다!   콜스택에 등록할 콜백함수를 작성할 때는 오랫동안 머물지 않게 하는 것이 좋다. loop나 재귀함수등은 조심해서 사용해야한다.   const button = document.querySelector(\"button\"); button.addEventListener(\"click\", () =&gt; {   while (true) {     // 콜 스택이 계속되고 있음. 브라우저가 반응하지 않음.     //repeat   } });      콜 스택에서 함수가 무한루프되고 있어 브라우저에 에러가 발생한다.    📄 함수가 Task Queue에 저장될 경우      브라우저에서 지정된 이벤트가 발생한다.   웹 API는 콜백함수를 태스크 큐에 넣어준다.   이벤트 루프는 계속 관찰을 하다가 콜 스택에 할일이 남아 있으면 콜스택이 비워질 떄까지 기다린다.   콜스택이 비어서 자바스크립트 엔진이 더이상 일을 하지 않을 때 태스크 큐에 있는 함수를 콜 스택으로 가져온다.   자바스크립트 엔진이 콜 스택에 들어온 콜백함수를 실행한다.   ⭐ 포인트      이벤트 루프는 콜스택에 있는 함수를 하나씩만 가져온다.   function handleClick() {   console.log(\"handleClick\");   setTimeout(() =&gt; {     console.log(\"setTimeout\");     handleClick(); // 콜스택에 무한으로 추가되어 동일한 내용의 이벤트루프가 반복된다.   }, 0); }  const button = document.querySelector(\"button\"); button.addEventListener(\"click\", () =&gt; {   handleClick(); });   콜백함수 내에서 다시 콜백함수를 호출하기 때문에 Task Queue에 무한으로 함수가 추가됩니다.    📄 함수가 Microtask Queue에 저장될 경우           콜 스택에서 프로미스를 만들고 프로미스에 등록된 콜백, 즉 프로미스가 다 수행이 되고나면 실행되는 then과 mutation observer라는 웹 API에 등록된 콜백이 마이크로 큐에 들어온다.             이벤트루프는 마이크로 태스크 큐에 있는 프로미스 then 콜백을 비어있는 콜스택으로 가져간다.             프로미스 then이 끝나면 mutation obsever를 콜 스택으로 가져간다.        ⭐ 포인트      이 과정에서 마이크로 태스크 큐에 새로운 함수가 들어온다면, 나중에 들어온 함수도 모두 끝날때까지 계속 콜스택으로 가지고 와서 수행한다.    마이크로 태스크 큐가 텅텅비면 테스크 큐로 넘어간다.   (태스크 큐와의 차이점: 태스크 큐에서는 아이템 하나만 콜스택으로 보내고 기다린다.)    function handleClick() {   console.log(\"handleClick\");   Promise.resolve(0) // promise 의 콜백은 Microtask que를 이용한다.     .then(() =&gt; {       console.log(\"then\");       handleClick();     }); }  const button = document.querySelector(\"button\"); button.addEventListener(\"click\", () =&gt; {   handleClick(); });   이벤트루프는 마이크로태스크 큐에 등록된 콜백이 모두 빌때까지 기다리기때문에 이벤트루프가 멈춰 브라우저가 반응하지 않습니다.   📄 함수가 Request Animation Frame Queue에 저장될 경우   Request Animation Frame Queue는 렌더링이 되기 전 브라우저가 콜백함수를 실행하는 것을 보장합니다.   render안의 Request Animation Frame이라는 웹 API를 통해서 콜백을 차곡차곡 등록해 놓으면 브라우저가 업데이트 되기 전에 콜백을 실행합니다.   브라우저를 다시 업데이트 할 때는 render안의 request Animation Frame 에 등록된 콜백들을 거친 후 렌더 트리를 만들고 그 트리를 이용해서 레이아웃을 계산한 뒤에 페인트를 통해서 브라우저에 업데이트를 한 다음에 이벤트루프가 재개됩니다.   const button = document.querySelector(\"button\"); button.addEventListener(\"click\", () =&gt; {   requestAnimationFrame(() =&gt; {     // 렌더링이 되기 전 브라우저가 콜백함수를 실행하는 것을 보장해준다.     document.body.style.backgroundColor = \"beige\";   });   requestAnimationFrame(() =&gt; {     document.body.style.backgroundColor = \"orange\";   });   requestAnimationFrame(() =&gt; {     document.body.style.backgroundColor = \"red\";   }); });   QUE는 FIFO의 구조를 가지고 있기 때문에 마지막에 들어온 코드가 적용되기 때문에 최종적으로 빨간색이 적용된 상태에서 렌더트리가 만들어지고 브라우저에 표기가 완료됩니다.   느낀점   자바스크립트 기초 문법을 배울 때 비동기 함수에 대해 이해하기 어려웠다.  오늘 이렇게 이벤트함수에 대해 공부하니 비동기 함수가 어떤식으로 처리되는지 감이 잡히고 이해하기 수월해졌다.  그동안 언어를 공부하면서 엔진에 대해 공부해본적이 없던 것 같은데 아는 것과 모르는 것에 큰 차이가 있다는 것을 새삼 느꼈다.   출처      드림코딩  ","categories": ["WEB"],
        "tags": ["자바스크립트","이벤트 루프"],
        "url": "/web/web-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B3%BC%EC%A0%95/",
        "teaser": null
      },{
        "title": "[WEB] Event Loop 01 | 자바스크립트 런타임 환경",
        "excerpt":"📄 자바스크립트 런타임 환경   JavaScript는 Single Threaded Language체제로 돌아가는 언어이며 다른 언어들과 다르게 언어 자체에 멀티스레딩이 없습니다.   하나의 프로세스가 하나의 일만 처리한다는 뜻입니다.   하지만, 브라우저 안에는 여러가지 스레드가 들어있습니다.   따라서 JavaScript가 아닌 브라우저의 WEB API를 이용해서 멀티스레딩을 합니다.   📄 자바스크립트는 어떻게 돌아갈까?   작성한 웹 어플리케이션이 브라우저에 올라가는 순간, 자바스크립트의 웹 엔진이 작성한 소스코드를 한 줄 한 줄씩 해석합니다.   자바스크립트 엔진의 구조는 다음과 같다.      Memory Heap      선언된 변수들의 메모리 할당이 이루어진다.   비구조적으로 데이터가 저장된다.      Call Stack      call stack에는 함수들이 실행하는 순서에 따라 차곡차곡 쌓인다.   LIFO(선입후출) 자료구조 형식으로 일처리가 진행된다.   function second() {   console.log(\"hello\");   return; } function first() {   second();   return; } function main() {   first();   return; } main();   위 코드의 실행이 콜스택에 쌓이는 과정은 다음과 같습니다.      ▪ 재귀함수   함수안에서 자기 자신을 계속 부르는 것을 재귀함수라고 한다.   function endless() {   endless(); } endless();   이 코드를 실행시키면 Call Stack에는 무한으로 데이터가 쌓이게 됩니다.   상황에 따라 유용하게 쓸 수 있지만 지정된 콜스택 사이즈를 초과하면 에러를 발생시키므로 주의해야 한다.   출처      드림코딩   미라클 그라운드  ","categories": ["WEB"],
        "tags": ["자바스크립트","프로세스"],
        "url": "/web/web-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%9F%B0%ED%83%80%EC%9E%84-%ED%99%98%EA%B2%BD/",
        "teaser": null
      },{
        "title": "[WEB] Event Loop 00 | 프로세스와 스레드",
        "excerpt":"📄 프로세스란?      프로세스는 운영체제 내에서 독립적으로 실행되고 있는 프로그램들입니다.   독립적으로 실행되기 때문에 문제가 생기면 문제가 생긴 프로세스만 다룰 수 있습니다.   ▪ 프로세스의 구조   각각의 프로세스는 리소스(자원)이 정해져 있고 프로세스마다 할당된 메모리나 데이터들이 지정되어 있습니다.      code   stack: 코드내 함수등이 동작하고 있는 순서를 기억한다.   heap: 동적인 데이터를 저장한다.   data: 정적인 데이터를 저장한다.   📄 Thread(스레드)란?   스레드는 프로세스 내에서 실제로 작업을 수행하는 주체입니다.   스레드는 각각 저마다 해야 되는 업무를 배정받습니다.   한 프로세스 안에서 여러개의 Thread가 동작할 수 있습니다.   이것을 멀티스레드 프로세스(multi-threaded process)라고 한다.   스레드는 저마다 필요한 일을 수행하고, 수행해야하는 함수의 호출을 기억해야하기 때문에 쓰레드마다 스택이 할당되어 있습니다.   저마다 스택은 갖고 있지만, 한 프로그램을 위해 동작하므로 코드와 힙 데이터에 공통적으로 접근해서 공통적으로 업데이트가 가능합니다.   스레드는 일의 흐름을 기억하고있는 고유의 스택이 있지만, 코드 힙 데이터와 같은 공통적인 리소스는 프로세스에 있기 때문에 스레드들은 이 프로세스에 공통적으로 할당된 리소스에 동시다발적으로 접속해서 동시다발적으로 업데이트 해야해서 서로 공유하면 사용합니다.   출처      드림 코딩  ","categories": ["WEB"],
        "tags": ["프로세스","스레드"],
        "url": "/web/web-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C/",
        "teaser": null
      },{
        "title": "불변객체(Immutable Object )",
        "excerpt":"📄 불변 객체란?   변수에 새로운 객체를 할당하더라도, 객체의 주소가 변하지 않는 객체   불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역메모리입니다.   불변 객체는 언제 필요할까?   모든 참조형 데이터가 가변성을 띠는 것은 아닙니다.   참조형 데이터가 가변성을 가질 때는 데이터 자체가 아닌 내부 프로퍼티를 변경하는 경우입니다.   내부 프로퍼티를 변경하면 변수가 가르키고 있는 데이터의 주소가 변경되기 때문입니다.   이러한 상황에서 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 불변객체가 필요합니다.   var user = {   name: \"Jaenam\",   gender: \"male\", };  var chanegeName = function (user, newName) {   var newUser = user;   newUser.name = newName;   return newUser; };  var user2 = chanegeName(user, \"Jung\");  if (user !== user2) {   console.log(\"유저 정보가 변경되었습니다.\"); // 실행되지 않음 } console.log(user.name, user2.name); console.log(user === user2);   결과    Jung Jung true   user과 newUser이 같은 데이터 주소를 참조하게 되어 newUser의 데이터가 변경될때 마다 user의 데이터도 변경됩니다.   따라서 user를 불변 객체로 만들어 줄 필요성이 보입니다.   📄 얕은 복사와 깊은 복사   1. 얕은 복사   중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.   얕은 복사를 하면 해당 프로퍼티에 대한 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키고, 사본을 바꾸면 원본이 바뀌고 원본을 바꾸면 사본이 바뀌는 현상이 일어납니다.   var copyObject = function (target) {   var result = {};   for (var prop in target) {     result[prop] = target[prop];   }   return result; };  var user = {   name: \"Jaenam\",   urls: {     portfolio: \"http://github.com/abc\",     blog: \"http://blog.com\",     facebood: \"http://facebook.com/abc\",   }, }; var user2 = copyObject(user);  user.name = \"Jung\"; console.log(user.name === user2.name); //false  user.urls.portfolio = \"http://portfolio.com\"; console.log(user.urls.portfolio === user2.urls.portfolio); // true  user2.urls.blog = \"\"; console.log(user.urls.blog === user2.urls.blog); //true   결과    false true true   user객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것을 확인할 수 있습니다..   user.urls의 프로퍼티에 대해서도 불변 객체로 만들 필요성이 생겼습니다.   깊은 복사   깊은 복사는 얕은 복사에서 한 단계 더 복사를 하는 것입니다.   객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하고, 참조형 데이터에는 다시 그 내부의 프로퍼티를 복사합니다.   var copyObjectDeep = function (target) {   var result = {};   if (typeof target === \"object\" &amp;&amp; target !== null) {     for (var prop in target) {       result[prop] = copyObjectDeep(target[prop]);     }   } else {     result = target;   }   return result; };   target이 객체인 경우 내부 프로퍼티를 순회하여 copyObjectDeep함수를 재귀적으로 호출하고, 원본과 사본이 서로 다른 객체를 참조하게 됩니다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","불변객체"],
        "url": "/javascript/javascript-immutableObject/",
        "teaser": null
      },{
        "title": "호이스팅(hoisting)",
        "excerpt":"📄 호이스팅(hoisting)      정의: 자바스크립트 엔진이 식별자들을 최상으로 끌어올리는 것      ⭐ 규칙      변수는 선언부만 끌어올린다.   함수 선언은 전체를 끌어올린다.   함수 표현식은 할당된 변수 선언부만 끌어올린다.   let을 이용한 호이스팅은 불가능하다.   hello2(); // 함수 호출  function hello2() {   //함수 선언   console.log(\"hello2\"); }   함수뿐만 아니라 var키워드를 통한 호이스팅도 가능합니다.   age = 6; age++; console.log(age);  var age;   주의할 점   var로 변수를 선언함과 동시에 값을 지정했다면, 값을 제외한 선언만 호이스팅 됩니다.   console.log(name);  name = \"Mark\";  console.log(name);  var name = \"Sujin\";   결과      이렇게 호이스팅되어 먼저 출력된 name은 값을 제외한 선언만 끌어올리기 때문에 undifined라고 출력됩니다.   함수를 선언했을 때는 함수 전체를 끌어올립니다.   function a() {   var b; // 수집 대상 1. 변수는 선언부만 끌어올립니다.   function b() {} // 수집 대상 2. 함수 선언은 전체를 끌어올립니다.    console.log(b);   b = \"bbb\";   console.log(b);   console.log(b); } a();   결과   [Function: b] bbb bbb   만약 함수 표현식을 이용해서 함수를 선언했다면, 전체가 아닌 변수 선언부만 끌어올립니다.   📄 let을 이용한 호이스팅은 불가능!   let을 이용한 호이스팅은 불가능 합니다.   let은 무조건 선언이 우선시 되어야 합니다.   console.log(name);  name = \"MARK\";  console.log(name);  let name;   결과      출처      패스트캠퍼스 프론트엔드 강의   코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","호이스팅"],
        "url": "/javascript/javascript-hoisting/",
        "teaser": null
      },{
        "title": "명시적으로 this를 바인딩 하는 방법",
        "excerpt":"📄 명시적으로 this를 바인딩 하는 방법   this는 함수를 호출할 때 결정됩니다.   하지만 this가 가리키는 대상을 명시적으로 바인딩할 수 있습니다.   📄 call 메서드   call메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.   Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])      첫 번째 인자를 this로 바인딩한다.   이후 인자들은 호출할 함수의 매개변수이다.   var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, };  obj.method(2, 3); obj.method.call({ a: 4 }, 5, 6);   call메서드의 첫번째 인자로 this가 가리키는 a값을 4로 변경합니다.   ✔ 결과   1 2 3 4 5 6   📄 apply 메서드   Function.prototype.apply(thisArg[, argsArray])      첫 번째 인자를 this로 바인딩한다.   두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다.   var func = function (a, b, c) {   console.log(this, a, b, c); }; func.apply({ x: 1 }, [4, 5, 6]);  var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, }; obj.method.apply({ a: 4 }, [5, 6]);   ✔ 결과   { x: 1 } 4 5 6 4 5 6   call/apply 메서드는 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있지만, 그럼에도 불구하고 ES5이하의 환경에서는 마땅한 대안이 없어 실무에서 광범위하게 활용됩니다.   📄 bind 메서드   Function.prototype.bind(thisArg[, arg1, arg2, ...])   bind메서드는 call과 비슷하지만,  즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 함수이다.      함수에 this를 미리 적용한다.   부분 적용 함수를 구현한다.   var func = function (a, b, c, d) {   console.log(this, a, b, c, d); }; func(1, 2, 3, 4); // Window{...} 1 2 3 4  var bindFunc1 = func.bind({ x: 1 }); bindFunc1(5, 6, 7, 8); // (1) {x: 1} 5 6 7 8  var bindFunc2 = func.bind({ x: 1 }, 4, 5); bindFunc2(6, 7); // (2) {x: 1} 4 5 6 7 bindFunc2(8, 9); // {x: 1} 4 5 8 9      this를 { x: 1}로 지정했다.    매개변수로 6, 7을 넘기면 this값이 바뀐 겂을 제외하고는 최초 func함수에 4, 5, 6, 7을 넘긴 것과 같은 동작을 한다. this의 지정과 함께 부분 적용 함수를 구현한 것이다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","this"],
        "url": "/javascript/javascript-thisbinding/",
        "teaser": null
      },{
        "title": "[JS] 클로저란 무엇일까?",
        "excerpt":"📄 클로저란   클로저란   어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상이다.      클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말합니다.   by 코어 자바스크립트    📄 클로저의 동작 원리   var outer = function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; }; var outer2 = outer(); console.log(outer2()); console.log(outer2());   ✔ 결과   2; 3;   inner함수의 실행 시점에는 outer함수가 이미 종료 되었는데 outer함수의 LexicalEnvitonment에 접근했다.   바로 가비지 컬렉터의 동작 방식 때문이다.   가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함하지 않는다.   외부함수인 outer의 실행이 종료 되더라도  내부함수인 inner함수는 언젠가 outer2를 실행함으로써 호출될 가능성이 열렸기 때문에   가비지 컬렉터의 수집대상에 포함되지 않는다.   클로저와 메모리 관리   클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수의 메모리를 소모하도록 함으로써 발생한다.   하지만 클로저의 필요성이 사라진 시점에는 더이상 메모리를 소모하지 않게 해주어야 한다.   방법은 참조 카운터를 0으로 만들어 주는 것이다.   식별자에 참조형이 아닌 기본형 데이터(보통null 또는 undefined)를 할당해주면 가비지 컬렉터가 값을 수거해 갈 것이다.   var outer = (function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; })(); console.log(outer()); console.log(outer()); outer = null; // outer 식별자의 inner 함수 참조를 끊음   (function () {   var a = 0;   var intervalId = null;   var inner = function () {     if (++a &gt;= 10) {       clearInterval(intervalId);       inner = null; // inner 식별자의 함수 참조를 끊음     }     console.log(a);   };   intervalId = setInterval(inner, 1000); })();   이렇게 식별자에 기본형 데이터 값을 대입해서 함수 참조를 끊으면 메모리를 효율적으로 관리할 수 있다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클로저"],
        "url": "/javascript/js-closer/",
        "teaser": null
      },{
        "title": "옵셔널 체이닝",
        "excerpt":"📄 옵셔널 체이닝   옵셔널 체이닝(optional chaining) ?.을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.     ?.은 ?.‘앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.   let user = null;  alert( user?.address ); // undefined alert( user?.address.street ); // undefined   user?.address로 주소를 읽으면 아래와 같이 user 객체가 존재하지 않더라도 에러가 발생하지 않습니다.   📄 주의할 점      ?.는 존재하지 않아도 되는 괜찮은 대상에만 사용해아 합니다.   ?.앞의 변수는 꼭 선언되어 있어야 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","옵셔널체이닝"],
        "url": "/javascript/js-optionalchaning/",
        "teaser": null
      },{
        "title": "원시값의 메서드",
        "excerpt":"📄 원시값이란?   원시값은 객체가 아니면서 메서드도 가지지 않는 데이터를 뜻한다.   자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다.   원시값에서도 객체에서처럼 메서드를 호출할 수 있다는 뜻이다.   📄 원시값을 객체처럼 사용하는 과정   let str = \"Hello\";  alert(str.toUpperCase()); // HELLO      문자열 str은 원시값이므로 프로퍼티 toUpperCase에 접근하는 순간 특별한 객체가 만들어진다.   메서드가 실행되고, 새로운 문자열이 반환된다.   특별한 객체는 파괴되고 원시값 str만 남는다.   📄 왜 이런 내부 프로세스가 생겨난 것일까?   자바스크립트는 다양한 고유한 프로퍼티와 메서드를 가지는 내장 객체를 제공한다.  하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다.  객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.  따라서 원시값에 메서드를 호출해 임시객체를 만들고 작업이 완료되면 임시객체를 파괴한다.   📄 주의할 점   원시값은 추가 데이터를 저장할 수 없다.   let str = \"Hello\";  str.test = 5;  alert(str.test);   엄격모드에서는 래퍼 객체를 수정하려 할 때 에러가 발생하고,  비 엄격 모드에서는 에러가 발생하진 않고 래퍼 객체에 프로퍼티 test가 추가되지만 래퍼 객체는 바로 삭제되기 때문에 마지막 줄이 실행될 땐 프로퍼티 test를 찾을 수 없다.   출처      모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","원시값"],
        "url": "/javascript/js-primitive/",
        "teaser": null
      },{
        "title": "반복문(Iteration)",
        "excerpt":"📄 반복문 for   for문은 어떤 유한한 횟수만큼 반복할 때 사용합니다.   for(초기화; 반복 조건; 반복이 된 후 실행되는 코드) {     반복이 되는 코드 블럭  }   초기화 하면서 선언된 변수를 중괄호 안 반복 블럭에서 사용할 수 있습니다.   반복문 종료하기 | break   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &gt; 2) {     break;   }   console.log(\"안녕하세요\", i); }      i가 0부터 4까지 1씩 증가하면서 출력하는데, 만약 i가 2보타 큰 경우는 반복을 종료한다.    결과     반복문 넘기기 | continue   반복되는 블럭 안에서 continue를 만나면 거기서 바로 해당 블럭은 종료됩니다.   그리고 이와 같이 다음 반복이 있으면 다음 반복으로 넘어갑니다.   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &lt; 2) {     continue;   }   console.log(\"안녕하세요\", i); }   결과    for 무한 루프   소괄호 ()안에 아무것도 적지 않고 세미콜론 ;만 작성하면 조건이 생성되지 않아 무한으로 출력합니다.   이런 경우 보통 for문 안에서 if문으로 조건을 생성하기도 합니다.   for (;;) {   console.log(\"안녕하세요\");   if (Math.random * 100 &gt; 90) {     break;   } }      랜덤숫자*100 이 90보다 크면 반복문 종료    📄 for in   for in반복문은 객체의 속성들을 반복하여 작업을 수행합니다.   객체의 key값에는 접근할 수 있지만 value에는 접근할 수 없습니다.   for(let(또는 const) in 객체이름) {}  console.log(Object.keys(객체이름)); // 객체의 키 받아오기 console.log(Object.values(객체이름)); //키의 값 받아오기 console.log(Object.entries(객체이름)); //배열 형태로 키와 값을 반환   📄 for of   ES6에 추가된 for...of반복문은 배열안의 것들을 반복할 때 사용합니다.   for of 구문을 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.   var iterable = [10, 20, 30];  for (let value of iterable) {   console.log(value); // 10, 20, 30 }   주의할 점   for..in은 배열에 사용할 순 있지만 되도록 쓰지 않는 편이 좋습니다.  for..in반복문은 모든 프로퍼티를 대상으로 순회하기 때문에 키가 숫자가 아닌 프로퍼티도 순회 대상이 되어 필요 없는 프로퍼티들이 문제를 일으킬 가능성이 생깁니다.  또한 for..in반복문은 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다.    📌 객체에는 for...in, 배열에는 for...of를 사용하자   📄 while   무한 반복 루프를 작성할 때 for문 뿐만 아니라 while문으로도 작성할 수 있습니다.   while (true) {   console.log(\"안녕하세요\");   if (Math.random() * 100 &gt; 90) {     break;   } }      Math.random() * 100이 90보다 크면 반복문 종료    do while   while문이 최초로 한번은 무조건 실행하도록 합니다.   do {   // 최초 한번은 무조건 실행   console.log(\"안녕하세요\"); } while (Math.random() * 100 &gt; 90);   출처      패스트캠퍼스   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","반복문"],
        "url": "/javascript/javascript-iteration/",
        "teaser": null
      },{
        "title": "[클래스] 클래스(Class)",
        "excerpt":"📄 클래스(Class)란   자바스크립트는 기본적으로 객체지향언어를 지원합니다.   es6문법에 class가 추가되어 좀더 강력한 객체지향언어를 지향하게 되었습니다.   Class는 객체를 생성하기 위한 템플릿이자 함수의 한 종류입니다.   클래스는 데이터와 이를 조작하는 코드를 하나로 추상화합니다.   📄 선언적 방식   class A {     constructor() {...}     method1() {...}     method2() {...} } //class A 생성  console.log(new A()); // class A의 세로운 객체를 출력   결과   A {}   클래스를 만들고 new A()를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성됩니다.  클래스 내부에서 정의한 메서드는 A.prototype에 저장됩니다.  객체의 기본 상태를 설정해주는 생성자 메서드 constructor()는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화할 수 있습니다.   주의할 점      메서드 사이에는 쉼표가 없습니다.        클래스의 선언적 방식에서 호이스팅은 일어나지 않습니다.       new키워들를 통해 호출하지 않으면 에러가 발생합니다.   클래스에 정의된 메서드는 열거할 수 없습니다. 클래스의 prototype프로퍼티에 추가된 메서드의 enumerable플래그는 false입니다.   클래스는 항상 엄격모드로 실행됩니다.(use strict)   📄 클래스 표현식   클래스의 표현식을 변수에 할당하는 방식으로 사용됩니다.   const B = class {};  console.log(new B());   결과   B {}   📄 클래스 필드로 바인딩 된 메서드   자바스크립트에서 this는 동적으로 결정됩니다.   따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출하게 되면 this는 메서드가 정의된 객체를 참조하지 않습니다.   class Button {   constructor(value) {     this.value = value;   }    click() {     cosole.log(this.value);   } }  let button = new Button(\"안녕하세요\");  setTimeout(button.click, 1000);   결과   undefined;   this의 컨텍스트를 알 수 없게 된 현상을 ‘잃어버린 this‘라고 합니다.  이러한 현상을 해결하기 위해 클래스 필드를 사용할 수 있습니다.    class Button {   constructor(value) {     this.value = value;   }    click = () =&gt; {     // 수정한 부분     alert(this.value);   }; }  let button = new Button(\"안녕하세요.\");  setTimeout(button.click, 1000);   결과   안녕하세요.   클래스 필스 click = () =&gt; {...}는 각 Button객체마다 독립적인 함수를 만들어주고 이 함수의 this를 해당 객체에 바인딩시켜줍니다.  클래스의 이러한 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야할 때 특히 유용합니다.   📄 멤버변수   멤버 변수는 메소드 밖에서 선언된 변수를 뜻합니다. 클래스의 멤버변수는 this라는 키워드를 사용하여 반드시 생성자에 만들어야 합니다.   class C {   name = \"no name\"; // 초기값 설정   age = 0;    constructor(name, age) {     // 생성자를 통해서 새로 할당.     this.name = name; // 멤버변수     this.age = age; // 멤버변수   } }  console.log(new C(\"Mark\", 37));   결과   C { name: 'Mark', age: 37 }   📄 멤버 함수   클래스에는 멤버변수 뿐만 아니라 멤버 함수도 생성할 수 있습니다.   class A {   // 방법1: 함수의 이름과 중괄호를 이용해 설정   hello1() {     console.log(\"hello1\", this);   }   // 방법2: 멤버변수 이름에 함수를 할당하는 방법   hello2 = () =&gt; {     console.log(\"hello2\", this);   }; }  new A().hello1(); new A().hello2();   결과   hello1 A { hello2: [Function: hello2] } hello2 A { hello2: [Function: hello2] }   출처           패스트캠퍼스              MDN web docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스"],
        "url": "/javascript/js-class/",
        "teaser": null
      },{
        "title": "프로토타입(prototype)",
        "excerpt":"📄 프로토타입이란?   프로토타입의 한국어 뜻은 원형입니다.   프로토타입은 말 그대로 객체의 원형이라고 할 수 있는 것입니다.   Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용합니다.           생성자 함수에 기본으로 세팅되는 프로퍼티(F.prototype)는 [[Prototype]]과 다릅니다. F.prototype은 new F()를 호출할 때 만들어지는 새로운 객체의 [[Prototype]]을 설정합니다.       F.prototype의 값은 객체나 null만 가능합니다. 다른 값은 무시됩니다.   굳이 this라는 자기참조변수를 사용하지 않고 prototype으로 변수 p에 hello라는 함수를 할당했다.   function Person(name, age) {   this.name = name;   this.age = age;   //this.hello = function() {   //    console.log('hello', this.name, this.age);   //} }  Person.prototype.hello = function () {   console.log(\"hello\", this.name, this.age); };  const p = new Person(\"Mark\", 37);  p.hello();   결과   hello Mark 37   function Person() {} //Person함수 생성  Person.prototype.hello = function () {   //Person의 프로토타입으로 hello 함수 생성   console.log(\"hello\"); };  function Korean(region) {   //Korean 함수 생성   this.region = region;   this.where = function () {     console.log(\"where\", this.region);   }; }  Korean.prototype = Person.prototype; // 프로토타입을 이용해 부모의 프로퍼티를 자식의 프로퍼티에 할당  const k = new Korean(\"Seoul\"); // 변수 k에 객체 할당  k.hello(); k.where();   결과   hello1 where Seoul   📄 프로토타입 장점   프로토타입의 장점은 함수의 재사용성을 높인다는 것입니다.   프로토 타입을 사용해서 함수 밖에서 새로운 함수나 값을 선언한다면,   새로운 함수나 값을 기존 함수에 할당할 필요없이 prototype이라는 키워드 하나로 바로 사용가능하기 때문에 코드가 훨씬 간결해집니다.   📄 프로토타입 체인   프로토타입을 이용해 서로 이어져 있는 집합을 프로토타입 체인이라고 합니다.   위의 코드에 다음과 같은 코드를 이어서 작성합니다.   console.log(k instanceof Korean); console.log(k instanceof Person); console.log(k instanceof Object);   true; true; true;      Korean이 Person을 상속하고, Person이 Object를 상속하므로 true값이 나왔다.   느낀 점   자바스크립트 공부하면서 제일 난관에 봉착했다.  뭔가 알듯 말듯 헷갈리는 개념이다.  강의를 끝나면 모던자바스크립트튜토리얼도 보고 책도 보고 할텐데 그 과정에서 익숙해지며 습득될 수 있도록 꼼꼼히 학습해야겠다.     출처           패스트캠퍼스 프론트엔드 강의              생활코딩              MDN Web Docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","프로토타입"],
        "url": "/javascript/js-prototype/",
        "teaser": null
      },{
        "title": "[클래스] 정적 메서드와 정적 프로퍼티",
        "excerpt":"📄 정적 메서드(static method)   정적 메서드는 프로토타입이 아닌 클래스 함수 자체에 설정되어 있는 메서드이다.  클래스 안에서 static이라는 키워드를 사용해서 설정한다.   class User {   static staticMethod() {...} }   정적 메서드의 this는 무엇을 가리킬까?   클래스의 메서드가 호출될 때  this의 값은 클래스 생성자 그자체가 된다.    정적 메서드는 언제 사용할까?   정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 사용한다.  데이터베이스 관련 클래스에도 사용되곤한다.    📄 정적 프로퍼티(static property)   정적 프로퍼티또한 static이라는 키워드를 사용한다.   class User {   static staticProperty = \"John\"; }   정적 프로퍼티는 언제 사용할까?   정적 프로퍼티는 데이터를 클래스 수순에 저장하고 싶을 때 사용한다.  정적 프로퍼티 역시 개별 인스턴스에 묶이지 않는다.   정적 프로퍼티와 메서드의 상속   정적 프로퍼티와 정적 메서드는 상속이 가능하다.    class Animal {} class Rabbit extends Animal {}  // 정적 메서드 consol.log(Rabbit.__proto__ === Animal); // true  // 일반 메서드 consol.log(Rabbit.prototype.__proto__ === Animal.prototype); // true   클래스 Rabbit의 프로토타입이 클래스 Animal을 가리키게 한다.  따라서 Rabbit에서 원하는 프로퍼티나 메서드를 찾지 못하면 Animal로 검색이 이어진다.   출처   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","정적메서드","정적프로퍼티"],
        "url": "/javascript/js-static-method/",
        "teaser": null
      },{
        "title": "콜백(Callback)",
        "excerpt":"📄 콜백   콜백 함수는 다른 코드를 인자로 넘겨주는 함수이다.  다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한다. 자바스크립트는 호스트 환경이 제공하는 여러 함수를 사용하면 비동기 동작을 수행할 수 있다.   📄 콜백은 어떤 경우에 사용될까?   function loadScript(src) {   // &lt;script&gt; 태그를 만들고 페이지에 태그를 추가합니다.   // 태그가 페이지에 추가되면 src에 있는 스크립트를 로딩하고 실행합니다.   let script = document.createElement(\"script\");   script.src = src;   document.head.append(script); }  loadScript(\"/my/script.js\"); // script.js엔 \"function newFunction() {…}\"이 있습니다.  newFunction(); // 함수가 존재하지 않는다는 에러가 발생합니다!   new Function()에서 에러가 발생하는 이유는 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문이다.    function loadScript(src, callback) {   let script = document.createElement('script');   script.src = src;    script.onload = () =&gt; callback(script);    document.head.append(script); }  loadScript('/my/script.js', function() {   // 콜백 함수는 스크립트 로드가 끝나면 실행됩니다.   newFunction(); // 이제 함수 호출이 제대로 동작합니다.   ... });   loadScript의 두 번째 인수에 스크립트 로딩이 끝난 후 실행될 함수인 콜백 함수를 추가했다.  두 번째 인수로 전달되 함수는 원하는 동작이 완료되었을 떄 실행된다.     이것을 콜백 기반 비동기 프로그래밍이라고 부른다.  비동기적으로 수행되어야할 필요성을 가진 코드에 콜백을 기반으로 접근할 수 있다.   📄 오류 우선 콜백   콜백함수를 이용해서 에러를 핸들링할 수 있다.   function loadScript(src, callback) {   let script = document.createElement(\"script\");   script.src = src;    script.onload = () =&gt; callback(null, script);   script.onerror = () =&gt;     callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));    document.head.append(script); }  loadScript(\"/my/script.js\", function (error, script) {   if (error) {     // 에러 처리   } else {     // 스크립트 로딩이 성공적으로 끝남   } });   오류 우선 콜백의 관례      callback의 첫 번째 인수는 에러를 위해 남겨둔다. 에러가 발생하면 이 인수를 이용해 callback(err)이 호출된다.   두 번째 인수는 에러가 발생하지 않았을 때를 위해 남겨둔다. 원하는 동작이 성공한 경우엔 callback(null, result1, result2)가 호출된다.   오류 우선 콜백의 장점   오류 우선 콜백을 사용하면, 단일 콜백 함수에서 에러 케이스와 성공 케이스 모두를 처리할 수 있다.   출처      코어 자바스크립트   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","콜백"],
        "url": "/javascript/js-callback/",
        "teaser": null
      },{
        "title": "[네트워크] IP(인터넷 프로토콜)",
        "excerpt":"IP(인터넷 프로토콜)      IP는 인터넷상에서 데이터를 주고 받기 위한 통신 규약입니다.   이 IP를 기반으로 네트워크 상에서 컴퓨터(노드)를 식별하기 위해 부여된 위치 주소가 IP 주소입니다.   서버와 클라이언트 사이에는 인터넷이 있습니다.   통신을 위해 클라이언트와 서버는 각 IP주소를 부여받습니다.   IP를 이용해 특정 PC에서 다른 PC까지 데이터를 보내는 엔드투엔드 통신을 합니다.   노트북 같은 경우는 유선 이더넷 인터페이스와 무선 LAN 인터페이스가 같이 탑재된 경우가 많은데, 이런 경우 인터페이스마다 IP주소를 설정할 수 있습니다.   따라서, IP주소는 호스트 자체가 아니라 정확하게는 호스트의 인터페이스를 식별하는 역할을 합니다.   📄 IP(인터넷 프로토콜)의 역할      지정한 IP 주소(IP Adress)에 데이터 전달   패킷(Packet)이라는 통신 단위로 데이터 전달   ▪ 클라이언트 패킷 전달      출발지 IP주소와 목적지 IP주소와 메세지를 담은 IP패킷을 인터넷 망에 던진다.    노드끼리 서로 소통하고 목적지까지 IP패킷이 도착한다.   ▪ 서버 패킷 전달      서버도 마찬가지로 서버패킷을 던진다.   📄 데이터의 목적지에 따른 캐스트 분류   1. 유니캐스트      목적지 IP: 유니캐스트   출발지 IP: 유니캐스트   단 하나의 목적지에 데이터를 전송   TCP/IP 통신의 대부분은 유니캐스트   IP 주소 구성            네트워크부: 네트워크를 식별       호스트부: 네트워크 내 호스트를 식별           2. 브로드캐스트      목적지 IP: 브로드캐스트   출발지 IP: 유니캐스트   같은 네트워크 상의 모든 호스트에 데이터를 전송   IP주소 구성            같은 네트워크에 있는 모든 호스트에 일괄적으로 데이터를 전송하므로 32비트가 모두 ‘1’       10진 표기로 바꾸면 255.255.255.255           3. 멀티캐스트      목적지 IP: 멀티캐스트   출발지 IP: 유니캐스트   특정 그룹에 포함되는 호스트에 데이터를 전송   멀티캐스트 그룹에 포함되는 호스트가 반드시 같은 네트워크라고 할 수 없다.   IP주소 구성            멀티캐스트 IP주소를 244.0.0.0 ~ 239.255.255.255로 정해져 있음.       멀티캐스트 IP주소를 미리 정할 수도 있다. (ex. 224.0.0.2 = 같은 네트워크 상의 모든 라우터)           📄 IP프로토콜의 한계           비연결성               패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송가능       클라이언트는 대상서버가 서비스 가능한 상태인지 알지 못한다.                비신뢰성              중간에 패킷이 사라질 가능성       패킷이 순서대로 오지 않을 가능성            메세지가 대략 1500 바이트가 넘으면 메세지를 끊어서 전송합니다.   이때 끊어진 메세지가 순서대로 도착한다는 보장이 없는데 IP 프로토콜 만으로는 이 문제를 해결할 수 없습니다. 이를 보완하기 위해 사용되는 것이 TCP프로토콜 입니다.   출처      모든 개발자를 위한 HTTP 웹 기본 지식  ","categories": ["network"],
        "tags": ["IP","HTTP"],
        "url": "/network/IP/",
        "teaser": null
      },{
        "title": "[네트워크] PORT",
        "excerpt":"📄 IP주소의 한계   IP라는 개념만으로는 클라이언트가 여러개의 서버와 통신하는 과정에서 여러개의 IP패킷을 받을 때 어떤 패킷인지 구별할 수가 없습니다.   이러한 문제점을 해결해주는 것이 PORT입니다.   📄 PORT      TCP패킷에는 출발지 PORT와 목적지 PORT가 있습니다.   포트는 서버안에서 돌아가는 프로세스를 구분하는 역할을 합니다.      200.200.200.2라는 IP에 있는 11200포트로 패킷을 전송한다.    포트는 간단하게 한 아파트안에 동호수로 비유할 수 있다.   포트를 결정하는 규칙      0 ~ 65535 까지 할당 가능   0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음   FTP - 20, 21   TELNET -23   HTTP - 80   HTTPS - 443   출처      모든 개발자를 위한 HTTP 웹 기본 지식  ","categories": ["network"],
        "tags": ["PORT","TCP"],
        "url": "/network/PORT/",
        "teaser": null
      },{
        "title": "[네트워크] TCP, UDP",
        "excerpt":"📄 프로토콜 계층에서의 메세지 전송과정         프로그램이 Hello, world! 메시지 생성   SOCKET 라이브러리에서 OS계층에 메시지 전달   OS에서 메시지에 TCP정보를 생성하고 IP 패킷을 생성한다.   네트워크 인터페이스에서 LAN카드를 통해서 나갈 때 Ethernet frame과 함께 나간다.      📌 패킷이란? 인터넷에서 데이터를 보내는 과정을 설정(라우팅)할 때 효율적으로 처리하기 위해 데이터를 여러조각으로 나누는데 이 조각을 패킷이라 한다.    📄 TCP란?      TCP 인터넷상에서 데이터를 메세지형태로 보내기 위해 IP와 함께 사용 하는 전송 제어 프로토콜(Transmission Control Protocl)입니다.   ▪ TCP특징      연결지향성(TCP 3 way handshake)  먼저 연결을 하고 메시지를 보낸다. 서버와 클라이언트가 모두 연결 가능상태여야 동작한다.    TCP 3 way handshake 과정         클라이언트에서 SYN(접속요청)이라는 메시지를 보낸다.   서버가 메시지를 받으면 Syn(접속요청)과 ACK(요청 수락)이라는 메시지를 보낸다.   메시지를 받은 클라이언트가 서버에 ACL(요청수락)을 보낸다. (이 과정에서 데이터도 함께 전송하는 경우도 있다.)   연결이 되고나면 데이터가 전송된다.   연결 과정에 문제가 생기면 메시지를 보내 않기 때문에 안정성이 보장되고 클라이언트와 서버간의 신뢰가 생성됩니다.  하지만 이러한 연결과정 때문에 UDP보다 속도가 느리다는 단점이 있습니다. 따라서 신뢰성이 요구되는 전송에 우선 사용합니다. 3 way handshake 과정은 실제로(물리적으로) 연결된 것이 아닙니다. 중간의 노드들은 연결과정에서 제외되고 클라이언트와 최종 서버 간의 논리적 연결일 뿐입니다.       데이터 전달 보증  패킷이 중간에 누락이 되면 상대방이 알 수 있습니다.   순서 보장  만약 서버에 순서가 맞지 않게 도착했다면(= 데이터가 손실되었다면), 클라이언트에 문제점부터 다시 보내라고 데이터 요청을 합니다.(재요청)   신뢰할 수 있는 프로토콜   현재는 대부분 TCP 사용   📄UDP란?   UDP는 사용자 데이터그램 프로토콜(User Datagram Protocol)을 뜻하며 데이터를 데이트그램 단위로 처리하는 프로토콜입니다.   UDP는 TCP와 다르게 비연결 서비스로 연결을 설정하고 해제하는 과정이 존재하지 않습니다.   UDP 특징      하얀 도화지에 비유(기능이 거의 없음)   비연결성 - TCP 3 way hankshacke x   데이터 전달 보증 x   순서 보장 x        데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름       신뢰성보다 연속성이 중요한 서비스에 사용(실시간 스트리밍 서비스)   출처      모든 개발자를 위한 HTTP 웹 기본 지식  ","categories": ["network"],
        "tags": ["TCP","UDP"],
        "url": "/network/TCP,UDP/",
        "teaser": null
      },{
        "title": "[네트워크] DNS",
        "excerpt":"📄 DNS란?   DNS는 도메인 네임 시스템(Domain Name System)입니다.      전화번호부와 같은 역할   도메인 명을 IP 주소로 변환   IP주소를 사람이 기억하기 쉬운 이름으로 사용하는 것이 도메인 입니다.   사용자가 도메인을 입력하면 네트워크 상에서 IP주소로 바꾸고 해당 IP 주소로 접속합니다.   📄 DNS를 왜 사용할까?      기존의 IP주소에는 문제점들이 있습니다.      기존의 IP주소는 기억하기 어렵다.   IP는 변경될 수 있다.   이 문제를 해결하기 위해 DNS를 사용합니다.      DNS서버에 도메인 명을 등록한다.    DNS에 도메인 명을 요청하고 IP주소를 받는다.    출처      모든 개발자를 위한 HTTP 웹 기본 지식  ","categories": ["network"],
        "tags": ["DNS","IP"],
        "url": "/network/DNS/",
        "teaser": null
      },{
        "title": "[네트워크] URI",
        "excerpt":"URI   📄 URI(Uniform Resource Identifier)란?      Uniform: 리소스를 식별하는 통일된 방식   Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음)   Identifier: 다른 항목과 구분하는데 필요한 정보   URI는 인터넷 상의 리소스 즉, 자원 자체를 식별하는 식별자 역할을 합니다.   📄 URI와 URL의 차이점      URI: 식별자            google.com           URL: 식별자 + 리소스의 위치 (프로토콜 포함)            https://google.com           URI는 URL보다 상위 개념이며, 모든 URI가 URL이 되는 것은 아닙니다. (URI는 URL을 포괄한다.)   따라서, URL은 URI의 일종이라고 할 수 있습니다.   URL은 리소스에 접근하는 방법을 지정한 방식인 프로토콜(ex. https)을 사용해 리소스의 위치에 도달합니다.   📄 URI 문법    scheme://[userinfo@]host[:port][/path][?query][#fragment]    ex) http://www.google.com:443/search?q=hello&amp;hl=ko     ▪ schme      주로 프로토콜이 사용된다.   프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 규칙 ex) http, https, ftp 등등   http는 80포트, https는 443포트를 주로 사용, 포트는 생략 가능   https는 http에 보안 추가(HTTP Secure)   ▪ userinfo      URL에 사용자정보를 포함해서 인증   거의 사용하지 않음   ▪ 호스트명(www.google.com)      도메인명 또는 IP 주소를 직접 사용가능   ▪ port(443)      접속 포트   일반적으로 생략가능, 생략시 http는 80, https는 443   ▪ path      리소스 경로, 계층적 구조   ex) /home/file1.jpg   ▪ query      key = value 형태   ?로 시작, &amp;로 추가 가능 ex&gt; ?keyA=value&amp;keyB=valueB   query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태   ▪ fragment      html 내부 북마크 등에 사용   서버에 전송하는 정보가 아님.   출처      모든 개발자를 위한 HTTP 웹 기본 지식  ","categories": ["network"],
        "tags": ["URI","URL"],
        "url": "/network/web-URI/",
        "teaser": null
      },{
        "title": "[네트워크] HTTP",
        "excerpt":"📄 HTTP란?   HyperText Transfer Protocol의 약자로 HTML문서와 같은 리소스를 서버로부터 가져올 수 있도록 해주는 프로토콜입니다.   클라이언트와 서버간의 전송뿐만 아니라 서버간의 전송에도 HTTP를 사용해 데이터를 전송하며 거의 모든 형태의 데이터를 전송할 수 있습니다.   ▪ 기반 프로토콜      TCP: HTTP.1.1, HTTP/2: HTTP/1.1, HTTP/2   UDP: HTTP/3   현재 HTTP/1.1 주로 사용, HTTP/2, HTTP/3도 점점 증가   📄 HTTP 특징   1. 클라이언트 서버 구조      Request Response 구조   클라이언트는 서버에 요청을 보내고, 응답을 대기한다.   서버가 요청에 대한 결과를 만들어서 응답한다.   2. 무상태 프로토콜(스테이트리스 Stateless: 상태를 보존하지 않음), 비연결성              Stateless              서버가 클라이언트의 상태를 보존하지 않는다.       클라이언트가 필요한 데이터를 계속 넘긴다.       필요한 데이터를 클라이언트가 보내기 때문에 갑자기 클라이언트의 요청이 증가해도 서버를 대거 투입할 수 있다.       따라서 무상태는 응답 서버를 쉽게 바꿀 수 있어 무한한 서버 증설이 가능하고 스케일 아웃(수평 확장)에 유리하다.                Stateless 한계              로그인이 필요한 페이지의 경우 등에는 서버가 상태를 유지해야한다.       이러한 경우에는 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태를 유지한다.       상태 유지는 최소한만 사용하는 것이 좋다. 또한 데이터를 너무 많이 보낸다는 단점이 있다.           비연결성            서버가 클라이언트의 요청에 응답을 하고 연결을 유지하지 않음.       HTTP는 기본적으로 연결을 유지하지 않는 모델       일반적으로 초 단위 이하의 빠른 속도로 응답       1시간 동안 수천명이 서비스를 이용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 작음       서버 자원을 매우 효율적으로 사용할 수 있음.           비연결성의 한계와 극복            TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가       웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등등 수많은 자원이 함께 다운로드       지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결       HTTP/2, HTTP/3에서 더 많은 최적화           3. HTTP 메시지를 통해서 통신      🔴 시작 라인            요청 메시지              HTTP 메서드 (ex. GET: 조회): 서버가 수행해야 할 동작 지정       요청 대상 (/search?q=hello&amp;hl=ko): 절대경로=”/”로 시작하는 경로       HTTP Version                응답 메시지             HTTP 버전       HTTP 상태 코드: 요청 성공 또는 실패(200: 성공, 400: 클라이언트 요청 오류. 500: 서버 내부 오류)       이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글           🟡 HTTP 헤더      header-filed = field-name “:” OWS field-value OWS (OWS: 띄어쓰기 허용)   field-name 은 대소문자 구분 없음   용도            HTTP 전송에 필요한 모든 부가정보       예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증..       표준헤더가 많음. . 필요시 임의의 헤더 추가 가능           🔵 HTTP 메시지 바디      실제 전송할 데이터   HTML문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능   출처           모든 개발자를 위한 HTTP 웹 기본 지식            MDN      ","categories": ["network"],
        "tags": ["HTTP"],
        "url": "/network/web-HTTP/",
        "teaser": null
      },{
        "title": "[네트워크] Cookie",
        "excerpt":"📄 Cookie   HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각입니다.   서버가 HTTP요청을 수신할 때, 서버는 응답과 함께 Set-Cookie헤더를 전송합니다.   클라이언트는 서버에서 받은 쿠키를 저장하고, HTTP 요청시 쿠키를 서버로 전달합니다.   📄 쿠키는 왜 필요할까?   HTTP는 Stateless상태이기 때문입니다.   서로 상태를 유지하지 않기 때문에 클라이언트와 서버가 요청을 주고 받으면 연결이 끊어집니다.   따라서 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못합니다.   모든 요청과 링크에 사용자 정보를 포함한다면 개발자가 모든 요청에 사용자 정보를 추가해서 개발해야 하기 때문에 비효율적입니다.   이러한 상황에서 쿠키를 써서 웹 브라우저의 쿠키 저장소에 사용자 정보를 저장해 놓을 수 있습니다.      이렇게 웹 브라우저의 쿠키 저장소에 사용자 정보를 저장해 놓고 모든 요청에 쿠키 정보를 자동으로 포함시킬 수 있습니다.   📄 쿠키는 언제 사용할까?   쿠키의 주된 사용처는 다음과 같습니다.      사용자 로그인 세션 관리   광고 정보 트래킹   보통 사용자 정보를 저장해 로그인 세션을 관리하고,  웹 브라우저 사용자의 광고 선호도를 파악하기 위해 사용합니다.   📄 쿠키를 사용할 때 주의할 점           최소한의 정보만 사용하자  쿠키의 정보는 항상 서버에 전송되기 때문에 네트워크 트래픽이 추가로 유발됩니다. 이런 일을 방지하기 위해 세션 id나 인증 토큰 등 최소한의 정보만 사용하는 것이 좋습니다.            보안에 민감한 데이터는 저장하지 않는다. 웹 브라우저의 쿠키 저장소에 있는 정보들은 서버에 보내는 요청에 자동으로 포함되기 때문에 주민번호, 신용카드 번호 등 보안에 민감한 데이터는 저장하지 않는 것이 좋습니다.       📄 쿠키의 생명주기   ▪ 영속 쿠키   만료 날짜를 입력하면 브라우저 종료시 까지만 유지합니다. 0이나 음수를 입력하면 쿠키가 삭제됩니다.   예) Set-Cookie: expires=Sat, 26-Dec2020 04:39:21 GMT   ▪ 세션 쿠키   만료 날짜를 생략하면 브라우저 종료시 까지만 유지한다.   📄 쿠키 - 도메인(Domain)           도메인 명시  헤더에 도메인을 명시하면 명시한 문서 기준 도메인 + 서브 도메인을 포함해서 쿠키를 전송합니다.  domain=example.org를 지정해서 쿠키를 생성하면  example.org+dev.example.org를 포함해서 쿠키를 전송합니다.            도메인 생략  example.org에서 쿠키를 생략하고 domain지정을 생략한다면  example.org에서만 쿠키 접근이 가능하고 dev.example.org는 쿠키가 접근할 수 없습니다.       📄 쿠키 - 경로(Path)   쿠키는 지정한 경로를 포함한 하위 경로 페이지만 접근이 가능합니다.   일반적으로 path=/ 루트로 지정합니다.   📄 쿠키 - 보안           Secure  원래 쿠키는 http, https를 구분하지 않고 전송하지만 Secure를 적용하면 https인 경우에만 전송합니다.            HttpOnly  XSS공격을 방지하기 위해 사용합니다. 자바스크립트에서 접근이 불가능하며 HTTP전송에만 사용합니다.            SameSite  XSRF공격을 방지하기 위해 사용합니다. 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송합니다.       출처           모든 개발자를 위한 HTTP 웹 기본 지식            MDN      ","categories": ["network"],
        "tags": ["쿠키","HTTP"],
        "url": "/network/Cookie/",
        "teaser": null
      },{
        "title": "[React] 바벨 (Babel)",
        "excerpt":"📄 바벨   바벨은 최신 자바스크립트 문법을 지원하지 않는 환경에서도 최신 문법을 사용 가능하게 자바스크립트 코드를 변환해주는 컴파일러입니다.   // Babel Input: ES2015 arrow function [1, 2, 3].map((n) =&gt; n + 1);  // Babel Output: ES5 equivalent [1, 2, 3].map(function (n) {   return n + 1; });   리액트에서는 JSX 문법을 createElement함수로 호출하기 위해 바벨을 사용합니다.   📄 바벨 설치   npm install @babel/core @babel/cli @babel/preset-react      @babel/core: 바벨의 핵심 기능을 가지고 있는 패키지   @babel/cli: cli에서 사용할 바이너리가 들어있다.   @babel/preset-react: 리액트를 위한 플러그인 여러개를 모아놓은 것   npx babel --watch src --out-dir , --presets @babel/preset-react   src디렉토리의 모든 JS파일을 분석하고 변환한 내용을 적용합니다.   한번 컴파일 하고 끝나는 것이 아니라 파일이 바뀔 때마다 자동으로 컴파일을 합니다.   📄 Plugins   바벨에는 프리셋과 플러그인이 있다.      플러그인(Prugins): 코드를 변환하게 하는 작은 js프로그램   프리셋(Preset): 여러개의 플러그인을 모아놓은 것.   플러그인와 프리셋은 공식으로 정해진 것을 사용할 수도 있고 직접 자신만의 플러그인을 작성하여 변환을 코드에 적용할 수도 있다.   출처      실전 리액트 프로그래밍   BABEL 공식문서  ","categories": ["React"],
        "tags": ["바벨"],
        "url": "/react/react-babel/",
        "teaser": null
      },{
        "title": "TypeScript 기본 타입",
        "excerpt":"📄 TS 기본 타입   타입이란 자바스크립트에서 다루는 값의 형태에 대한 설명입니다.  타입스크립트에서의 가장 기본적인 타입은 자바스크립트의 7가지 기본 원시타입과 동일합니다.      null   undefined   boolean   string   number   bigint   symbol   📄 타입 애너테이션 (type annotation)   타입 애너테이션은 변수에 초깃값을 할당하지 않고도 변수의 타입을 설정할 수 있는 방법입니다.  변수에 초깃값을 할당한다면, 타입스크립트는 자동으로 타입을 추론합니다.   let user = \"sujin\";   이 코드에서 타입을 직접 알려주지 않아도 타입스크립트는 타입 시스템을 통해 user가 string타입이라는 것을 추론할 수 있습니다.  하지만, 초깃값이 없는 경우에는 타입을 추론할 수 없어 자동으로 any타입으로 간주합니다.  이렇게 초기에 타입을 유추할 수 없는 변수를 진화하는 any라고 부릅니다.   let user; // 타입: any user = \"sujin\";  user.toUpperCase(); // ok  user = 28; // 타입: number로 진화! user.toPrecision(1); // ok  user.toUpperCase(); // Error. 'toUpperCase' does not exist on type 'number'.   user의 타입이 any - string - number로 진화했습니다.  마지막으로 진화된 타입이 number이기 때문에 toUpperCase메소드를 호출하면 에러를 내뱉습니다.  이렇게 타입이 계속 변화하면 해당 변수가 어떤 타입을 가지고 있는지 확정지을 수 없고, 에러를 유발해 타입스크립트를 사용하는 이유를 손상케합니다.   타입 애너테이션은 변수의 초깃값을 할당하지 않았을 때, 타입을 확정지을 수 있게 합니다.   let user: string; user: \"sujin\";   📌 타입 애너테이션은 타입스크립트에만 존재하며 컴파일 되었을 때 자바스크립트로 복사되지 않아 자바스크립트에 아무 영향을 주지 않습니다.   📌 타입을 즉시 유추할 수 있는 변수에 타입 애너테이션을 설정하면 중복 설정입니다.   let user: string = \"sujin\";   출처           캡틴 판교-타입스크립트 입문 강의            Learning Typescript      ","categories": ["TypeScript"],
        "tags": ["type"],
        "url": "/typescript/typescript-type/",
        "teaser": null
      },{
        "title": "🚨 tsc: 이 시스템에서 스크립트를 실행할 수 없으므로...",
        "excerpt":"🚨 에러 발생      tsc명령어를 이용해서 ts파일을 js파일로 변환하는 작업을 하려고 하는데 터미널에서 에러가 발생했습니다.   🔨 해결방법      Visual Studio Code 관리자 권한으로 실행   terminal에 순서대로 입력   $ Get-ExecutionPolicy   $ Set-ExecutionPolicy RemoteSigned   Restricted에서 RemoteSigned로 변경하는 과정입니다.      Restrcted: (제한된) 기본 실행 정책, 명령어 하나씩 실행 가능, 스크립트 파일을 로드하여 실행할 수 없음.   RomotedSigned: 로컬 컴퓨터에서 본인이 생성한 스크립트만 실행 가능, 인터넷에서 다운로드한 스크립트는 신뢰된 배포자에 의해 서명된 것만 실행할 수 있음.   출처   꿀벌 코딩  ","categories": ["TypeScript"],
        "tags": ["에러"],
        "url": "/typescript/typescript-%EC%9D%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90%EC%84%9C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%A0-%EC%88%98-%EC%97%86%EC%9C%BC%EB%AF%80%EB%A1%9C/",
        "teaser": null
      },{
        "title": "TypeScript 함수 타입",
        "excerpt":"📄 TS 함수 타입   타입 스크립트는 함수에 타입을 정의할 수 있습니다.   ▪ 함수의 파라미터 타입을 정의하는 방식   // 함수 `sum`의 파라미터의 타입을 `number`로 지정  function sum(a: number, b: number) {   return a + b; }  sum(10, 20);   ▪ 함수의 반환 값에 타입을 정의하는 방식   // 함수 `add`의 반환 값을 `number`타입으로 지정  function add(): number {   return 10; }   📄 파라미터를 제한하는 특성   Type Script는 추가 인자를 받지 않습니다.   그리고 인자 수가 적어도 에러가 발생합니다.   function sum2(a: number, b: number): number {   return a + b; }  sum(10, 20, 30, 40, 50); // Expected 2 arguments, but got 5.   📄 함수의 옵셔널 파라미터   함수의 옵셔널 파라미터를 사용하면 파라미터를 선택적으로 사용할 수 있습니다.   function log(a: string, b?: string, c?: string) {}  log(\"hello world\"); log(\"hello ts\", \"abc\");   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["type","함수"],
        "url": "/typescript/typescript-TypeScript-%EA%B8%B0%EB%B3%B8-%ED%83%80%EC%9E%85/",
        "teaser": null
      },{
        "title": "[TypeScript] 타입이 아직 정해져 있지 않을 때",
        "excerpt":"📄 any   any는 모든 데이터 타입을 통칭한 타입입니다.   처음 타입을 정의할 때 any로 모든 데이터 타입을 지정하고 코드를 작성하면서 타입을 차근차근 적용하는 것도 정석적인 방법 중 하나입니다.   //tsconfig.json \"noImplicitAny\": true // 데이터 타입을 비워놓지 말고 any라도 붙여라   let todoItems: any;   ⭐ any 대신 unknown을 사용하자   any는 정말 유용해보이지만 치명적인 문제점이 있습니다.   any는 해당 값에 대한 할당 가능성과 멤버에 대한 타입 검사를 수행하지 않도록 지시하기 때문입니다.   만약 숫자에 toUpperCase() 함수를 사용한다면 에러가 발생할 것입니다.   하지만 런타임 에러일뿐 타입 에러는 아닙니다.   이런 일을 방지하기 위해 unknown을 사용할 수 있습니다.   타입스크립트는 unknown타입 값을 훨 씬 더 제한적으로 취급합니다.   // 타입이 any인 경우 function greetComedian(name: any) {   console.log(`Announcing ${name.toUpperCase()}!`); // 에러 x }  // 타입이 unknown인 경우 function greetComedian(name: unknown) {   console.log(`Announcing ${name.toUpperCase()}!`); // Error: Object is of type 'unknown' }   📄 void   함수의 리턴타입을 정의해야 하는데 만약 반환타입이 정해지지 않았다면 void로 정의해주는 것이 좋습니다.   function addTodo(todo): void {   todoItems.push(todo); }   출처           캡틴 판교-타입스크립트 입문 강의            러닝타입스크립트(책)      ","categories": ["TypeScript"],
        "tags": ["any","void","unknown"],
        "url": "/typescript/typescript-%ED%83%80%EC%9E%85%EC%9D%B4-%EC%95%84%EC%A7%81-%EC%A0%95%ED%95%B4%EC%A0%B8-%EC%9E%88%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C/",
        "teaser": null
      },{
        "title": "[TypeScript] 인터페이스",
        "excerpt":"📄 인터페이스   인터페이스는 상호 간에 정의한 약속 혹은 규칙을 쓰도록 규격을 정해놓은 것 입니다.   ▪ 변수에 인터페이스 활용한 경우      User라는 인터페이스를 정의해서 age와 name의 데이터 타입을 규칙으로 정했다.   interface User {   age: number;   name: string; }  // 변수에 인터페이스 활용 var seho: User = {   age: 33,   name: \"세호\", };   변수로 선언한 seho는 User라는 인터페이스를 지정받았기 때문에 age와 name을 정해진 데이터 타입에 맞춰 꼭 선언해야 하고 하나라도 빠지면 에러를 발생시킵니다.   ▪ 함수에 인터페이스 활용      함수의 인자에 User인터페이스를 적용시켰다.   function getUser(user: User) {   console.log(user); } const capt = {   age: 27,   name: \"캡틴\", }; getUser(capt);   ▪ 함수의 스펙(구조)에 인터페이스 활용      인터페이스 SumFunction에 함수의 인자와 반환값에 데이터 타입을 정의했다.   interface SumFunction {   (a: number, b: number): number; // 인자와 반환 타입 정의 }  var sum: SumFunction; sum = function (a: number, b: number): number {   return a + b; };   📄 인덱싱   인덱싱은 인터페이스에 배열의 데이터타입을 정의한 것입니다.      StringArray는 인덱스를 숫자로 받고 배열의 값을 string으로 정의했다.   interface StringArray {   [index: number]: string; }  var arr: StringArray = [\"a\", \"b\", \"c\"]; //arr[0] = 10; // Error   📄 딕셔너리 패턴   딕셔너리의 key와 value의 타입을 지정하면 생성된 인터페이스를 사용해 만든 객체는 정해진 key와 value의 값만 입력받아야 합니다.   interface StringRegexDictionary {   [key: string]: RegExp; }  var obj: StringRegexDictionary = {   sth: /abc/,   cssFile: /\\.css$/, // css 확장자를 가진 모든 파일을 가져온다는 정규식.   jsFile: /\\.js$/, // js 확장자를 가진 모든 파일을 가져온다는 정규식. };  Object.keys(obj).forEach(function (value) {});   📄 인터페이스 확장   extend키워드를 사용해서 기존의 인터페이스를 상속받을 수 있습니다.   interface Person {   name: string;   age: number; }  interface Developer extends Person {   language: string; }  var cap: Developer = {   name: \"캡틴\",   age: 100,   language: \"ts\", };   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["인터페이스"],
        "url": "/typescript/typescript-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[React] 컴포넌트 함수의 반환값",
        "excerpt":"📄 컴포넌트 함수의 반환값   리액트의 컴포넌트는 다양한 리액트 요소를 반합니다.   export default function App() {   return \"hi\"; // 문자열을 반환했다. }   컴포넌트가 배열을 반환 할 때는 리액트 요소가 key를 가지고 있어야 합니다.   key는 랜더링을 효율적으로 하기 위해서 필요한 값입니다.   리액트가 이 값을 이용해서 가상돔에서 연산을 진행합니다.   export default function App() {   return [&lt;pkey={1}&gt;안녕&lt;/p&gt;, &lt;p key={2}&gt;하세요&lt;/p&gt;]; // }   fragment   컴포넌트는 fragment를 반환할 수 있습니다.   fragment 여러개의 요소를 반환할 때 사용합니다.   fragment는 일종의 key역할을 합니다.   export default function App() {   return (     &lt;React.Fragment&gt;       &lt;p&gt;안녕&lt;/p&gt;       &lt;p&gt;하세요&lt;/p&gt;     &lt;/React.Fragment&gt;   ); }   fragment는 불필요한 div태그를 남발하지 않게 해줍니다.   아무것도 입력하지 않고 태그의 괄호만 입력하면 fragment로 작동합니다.   fragment에서는 null또는 boolean값이 무시됩니다.   potal   컴포넌트는 potal을 반환할 수 있습니다.   potal이란 html에서 root엘리먼트가 아닌 다른 엘리먼트에 렌더링하고 싶을 때 사용합니다.   potal을 사용하기 위해서는 ReactDom에 있는 함수를 사용합니다.   두번째 매개변수는 html에 있는 요소를 지정한다.   import ReactDom from \"react-dom\";  export default function App() {   return (     &lt;&gt;       &lt;p&gt;안녕&lt;/p&gt;       &lt;Counter /&gt;       {ReactDom.createPortal(         &lt;div&gt;           &lt;p&gt;안녕하세요&lt;/p&gt;           &lt;p&gt;실전 리액트 프로그래밍 입니다.&lt;/p&gt;         &lt;/div&gt;,         document.getElementId(\"something\")       )}     &lt;/&gt;   ); }   출처      실전 리액트 프로그래밍  ","categories": ["React"],
        "tags": ["컴포넌트"],
        "url": "/react/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%95%A8%EC%88%98%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92/",
        "teaser": null
      },{
        "title": "타입 별칭",
        "excerpt":"📄 타입 별칭   : 특정 타입이나 인터페이스를 참조할 수 있는 타입 변수   타입 별칭은 재사용하는 타입에 더 쉬운 이름을 할당하는 방법입니다.  type이라는 키워들를 사용해 선언합니다.   type Person = {   name: string;   age: number; };  var seho: Person = {   name: \"sujin\",   age: 28, };   📌 타입 별칭과 인터페이스의 차이점   인터페이스는 확장이 가능하지만 타입 별칭은 확장이 불가능합니다.   계속 타입을 확장할 필요가 있는 경우에는 타입 별칭보다는 인터페이스로 선언해서 필요할 때 마다 확장하는 것이 좋습니다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["타입 별칭"],
        "url": "/typescript/typescript-type-alias/",
        "teaser": null
      },{
        "title": "유니언(Union)과 리터럴(literal)",
        "excerpt":"📄 유니언 타입 (Union Type)   : 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입   유니온 타입은 값이 정확히 어떤 타입인지 모르나 두개 이상의 타입 중 하나라는 것을 알고 있는 경우에 사용합니다.   키워드 : |   let sujin: string | number | boolean;   ▪ 타입 애너테이션으로 유니언타입을 명시적으로 표시하는 방법   변수에 초깃값이 있더라도 타입이 변경될 가능성이 있을 때, 타입 애너테이션으로 유니언타입을 표시할 수 있습니다.   let sujin: string | null = \"null\";  if (Math.random() &gt; 0.5) {   sujin = \"dreamer\"; }   초깃값으로 null을 할당했지만 타입 애너테이션으로 string타입이 올 수 있다는 것을 명시했습니다.   📄 유니온 타입 특징   1. 유니온 타입은 타입 가드가 가능하다.    타입 가드(type guard)는 타입을 좁히는 것에 사용할 수 있는 논리적 검사를 뜻합니다.  이런 타입 가드를 통해 이전에 유추된 타입보다 더 구체적인 타입을 유추하는 과정을 내로잉이라고 합니다.   ✔ 값 할당을 통한 내로잉   admiral변수는 초기에 number와 string타입으로 선언되었지만, \"Grace Hopper\"라는 값을 할당하므로써 string타입으로 타입이 구체화되었습니다.   let admiral: number | string;  admiral: \"Grace Hopper\";  admiral.toUpperCase();  admiral.toFixed(); // Error: Property 'toFixed' does not exist on type 'string'   ✔ 조건 검사를 통한 내로잉   function logMessage(value: string | number) {   if (typeof value === \"number\") {     value.toLocaleString();   }   if (typeof value === \"string\") {     value.toString();   }   throw new TypeError(\"value must be string or number\"); } logMessage(\"hello\"); logMessage(100);   2. 유니온 타입은 인터페이스 두개를 연결했을 때 공통된 속성만 제공한다.   유니온 타입은 OR연산자와 의미가 비슷합니다.  따라서 설정한 타입이 모두 공통적으로 가지고 있는 속성만 사용할 수 있습니다.   let pysicist = Math.random() &gt; 0.5 ? \"Sujin\" : 28;  pysicist.toString(); // ok  pysicist.toUpperCase(); // Error: Property 'toUpperCase' does not exist on type 'string' | 'number'   pysicist는 ‘string’ 타입과 ‘number’ 타입으로 추론됩니다.  toString메소드는 string과 number타입에 모두 사용할 수 있지만,  toUpperCase메소드는 string타입에만 사용할 수 있기 때문에 에러를 내뱉습니다.   📄 유니온 타입(Union Type)과 인터셉션(Intersection)   인터셉션은 공통된 속성만 제공하는 유니온 타입과는 달리 설정한 타입의 모든 속성을 제공합니다.   따라서 인터페이스를 모두 합친 하나의 타입이라고 정의할 수 있습니다.   실무에서는 상대적으로 유니온 타입을 더 많이 사용한다고 합니다.   function askSomeone(someone: Developer &amp; Person) {   someone.name;   someone.skill;   someone.age; }   인터셉션은 정의한 타입의 속성을 모두 넘겨야 하는 특징이 있습니다.   askSomeone({ name: \"디벨로퍼\", skill: \"웹 개발\", age: 34 });   📄 리터럴 타입 (Literal Type)   : 원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입   저는 리터럴 타입의 개념을 커스텀 타입으로 이해했습니다.  string이나 number같은 원시 타입이 아닌 사용자가 설정하고 싶은 값을 타입으로 지정할 수 있기 때문입니다.   const philosopher = \"Hypatia\";   이렇게 const로 선언한 변수에 문자열로 된 Hypatia라는 값을 할당하면 타입스크립트는 해당 값을 리터럴 타입으로 설정합니다.      여기서 const를 let으로 바꾼다면, 해당 타입의 가능한 모든 리터럴 값의 집합이 되는 원시 타입으로 설정하게 됩니다.   let philosopher = \"Hypatia\";      출처           캡틴 판교-타입스크립트 입문 강의            Learning TypeScript      ","categories": ["TypeScript"],
        "tags": ["유니언 타입","리터럴 타입","내로잉","타입 가드"],
        "url": "/typescript/typescript-union&literal/",
        "teaser": null
      },{
        "title": "[TypeScript] 이넘(enum)",
        "excerpt":"📄 이넘(enum)   이넘은 특정한 값들의 집합을 의미하는 자료형입니다.      키워드: enum   enum example {   A   B   C }   📄 숫자형 이넘   이넘을 만들때 별도의 값을 지정하지 않으면 숫자형 이넘으로 생성됩니다.   첫번째 값은 0이 할당되고 두번째 값부터 1씩 증가합니다.   enum Shoes {   Nike = 5,   Adidas, }   첫번째만 값을 지정해도 두번째값부터 1씩 증가하여 Adidas에는 6이 할당됩니다.   📄 문자형 이넘   이넘의 값을 string값으로 할당할 수 있습니다.   enum Shoes {   Nike = \"나이키\",   Adidas = \"아디다스\", }   이넘에 문자와 숫자를 혼합하여 생성하는 것도 가능합니다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["이넘"],
        "url": "/typescript/typescript-%EC%9D%B4%EB%84%98/",
        "teaser": null
      },{
        "title": "[TypeScript] 제네릭(Generics)",
        "excerpt":"📄 제네릭(Generics)   제네릭은 타입을 함수의 파라미터에 갖게 하는 문법입니다.   제네릭은 함수를 호출하는 시점에 타입을 넘겨줍니다.   키워드: T   function logText&lt;T&gt;(text: T): T {   console.log(text);   return text; } logText(\"하이\");   한가지 타입보다 여러 가지 타입에서 동작하는 컴포넌트를 생성하는데 사용되며 재사용성이 높은 컴포넌트를 만들 때 자주 활용됩니다.   📄 왜 제네릭을 사용할까?   단순히 타입을 바꿔 사용하기 위해서 중복코드가 있는 함수를 계속 생성하는 것은 유지보수에 좋지않습니다.   function logText(text: string) {   console.log(text);   return text; }  function logNumber(num: number) {   console.log(num);   return num; }      logText와 logNumber는 같은 내용의 함수지만 파라미터의 타입이 다른 이유로 따로 생성되었다.   function logText&lt;T&gt;(text: T): T {   console.log(text);   return text; }  const str = logText&lt;string&gt;(\"abc\"); str.split(\"\"); const login = logText&lt;boolean&gt;(true);   이렇게 제네릭을 사용해서 함수의 파라미터값을 지정한다면 함수를 호출할때 어떤 타입을 지정해도 코드를 진행할 수 있습니다.   📄 어떤 경우에 유니온타입이 아닌 제네릭을 사용할까?   여러 타입으로 함수의 파라미터를 정의할 경우 유니온을 사용하는 방법도 있습니다.   하지만 유니온타입은 반환값에서 문제가 생길 수 있습니다.   function logText(text: string | number) {   console.log(text);   return text; }  const a = logText(\"a\"); a.split(10); //에러. 타입을 정확히 선언해야만 내장함수를 사용할 수 있음. logText(10);   text가 유니온타입으로 string과 number로 지정되었기 때문에 내장함수를 사용할 수 없는 문제점이 발생합니다.   따라서 상황에 적절히 유니온 타입과 제네릭 타입을 사용해야 합니다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["제네릭"],
        "url": "/typescript/typescript-%EC%A0%9C%EB%84%A4%EB%A6%AD(Generic)/",
        "teaser": null
      },{
        "title": "[TypeScript] 타입 호환(Type Compatibility)",
        "excerpt":"📄 타입 호환(Type Compatibility)   타입 호환은 타입스크립트 코드에서 특정 타입이 다른 타입에 잘 맞는지 알려주는 특징입니다.   interface Developer {   name: string;   skill: string; }  interface Person {   name: string; }  var developer: Developer; var person: Person;  developer = person; // Error person = developer;   타입 호환은 부분 집합 개념으로 접근하면 이해하기 쉽습니다.   에러가 난 이유는 developer(왼쪽)가 더 많은 타입을 가지고 있기 때문입니다.   오른쪽의 타입이 더 많아야 타입 호환이 이루어질 수 있습니다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["타입 호환"],
        "url": "/typescript/typescript-%ED%83%80%EC%9E%85-%ED%98%B8%ED%99%98/",
        "teaser": null
      },{
        "title": "[TypeScript] 유틸리티 타입",
        "excerpt":"📄 유틸리티 타입   유틸리티 타입은 이미 정의해 놓은 타입을 변환할 때 사용하는 문법입니다.   유틸리티 타입을 사용하면 불필요한 타입을 지정하는 것을 줄일 수 있습니다.   ▪ Partial      목적: 특정 타입의 부분 집합을 만족하는 타입을 정의   interface Address {   email: string;   address: string; }  type MayHaveEmail = Partial&lt;Address&gt;; const me: MayHaveEmail = {}; // 가능 const you: MayHaveEmail = { email: \"test@abc.com\" }; // 가능 const all: MayHaveEmail = { email: \"capt@hero.com\", address: \"Pangyo\" }; // 가능   ▪ Pick      목적: 특정 타입에서 몇 개의 속성을 선택하여 타입을 정의   interface Hero {   name: string;   skill: string; } const human: Pick&lt;Hero, \"name\"&gt; = {   name: \"스킬이 없는 사람\", };   ▪ Omit      목적: 특정 타입에서 지정된 속성만 제거한 타입을 정의   interface AddressBook {   name: string;   phone: number;   address: string;   company: string; } const phoneBook: Omit&lt;AddressBook, \"address\"&gt; = {   name: \"재택근무\",   phone: 12342223333,   company: \"내 방\", };   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["유틸리티"],
        "url": "/typescript/typescript-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%ED%83%80%EC%9E%85/",
        "teaser": null
      },{
        "title": "[TypeScript] 맵드 타입(Mapped Type)",
        "excerpt":"📄 맵드 타입(Mapped Type)   맵드 타입은 기존에 정의되어 있는 타입을 새로운 타입으로 변환해 주는 문법입니다.   자바스크립트 map() API 함수를 타입에 적용한 것과 같은 효과를 가집니다.   📄 맵드 타입 기본 문법   { [ P in  K ] : T } { [ P in  K ] ? : T } { readonly [ P in  K ] : T } { readonly [ P in  K ] ? : T }   📄 맵드 타입 예제      Heroes 는 Hulk, Capt, Thor라는 키를 유니온 타입으로 가진다.   HeroAges에 Heroes의 키의 타입을 number로 바꾸는 맵드 타입 문법을 적용했다.   상수 ages는 키값이 number인 HeroAges를 타입으로 가진다.   type Heroes = \"Hulk\" | \"Capt\" | \"Thor\"; type HeroAges = { [K in Heroes]: number }; const ages: HeroAges = {   Hulk: 33,   Capt: 100,   Thor: 1000, };   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["맵드 타입"],
        "url": "/typescript/typescript-%EB%A7%B5%EB%93%9C-%ED%83%80%EC%9E%85/",
        "teaser": null
      },{
        "title": "Props(Properties)란?",
        "excerpt":"📄 Props 란?   Props는 컴포넌트를 사용하는 과정에서 특정 값을 전달하는 역할을 수행합니다.      Props는 외부에서 제공받은 값을 컴포넌트에 전달합니다.   상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용합니다.(단방향 데이터 흐름)   프로퍼티는 수정할 수 없습니다.   📄 왜 Props를 사용할까?   가장 큰 이유는 컴포넌트의 재사용성을 높일 수 있기 때문입니다.   상황에 따라서 데이터를 전달받아 데이터에 맞게 UI를 구현할 수 있습니다.   // App.js import React from \"react\"; import Hello from \"./Hello\"; import Wrapper from \"./Wrapper\";  function App() {   return (     &lt;Wrapper&gt;       &lt;Hello name=\"react\" color=\"red\" /&gt;       &lt;Hello color=\"pink\" /&gt;     &lt;/Wrapper&gt;   ); }  export default App;   Hello컴포넌트에서 태그의 속성값을 사용하기 위해 파라미터에 props을 입력합니다.   import React from \"react\";  function Hello(props) {   // 컴포넌트 이름은 대문자로 시작   console.log(props);   return (     &lt;div       style=     &gt;       안녕하세요 {props.name}     &lt;/div&gt;   ); }  Hello.defaultProps = {   // 특정값을 빠뜨렸을때 기본값으로 사용할 값   name: \"이름없음\", }; export default Hello; // Hello라는 컴포넌트를 내보낸다.   📄 props.children   컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 땐 props.children을 사용합니다.   import React from \"react\";  function Wrapper({ children }) {   const style = {     border: \"2px solid black\",     padding: \"16px\",   };   return &lt;div style={style}&gt;{children}&lt;/div&gt;; }  export default Wrapper;   전달된 인자들이 오브젝트로 묶어져서 LikeButton컴포넌트 안에서 this.props로 할당됩니다.      드림코딩   https://goddaehee.tistory.com/300   벨로퍼트와 함께하는 모던 리액트  ","categories": ["React"],
        "tags": ["Props","Default Props"],
        "url": "/react/react-props/",
        "teaser": null
      },{
        "title": "[React-React Hooks] useRef",
        "excerpt":"📄 useRef로 특정 DOM 선택하기   리액트로 코드를 작성하다 보면 직접 DOM요소에 접근해야하는 경우가 있습니다.   useRef를 사용하며 특정 DOM요소에 접근할 수 있습니다.   const nameInput = useRef(); // DOM 접근   변수 혹은 상수에 useRef를 호출하면 특정 객체가 생성됩니다.   &lt;input   name=\"name\"   placeholder=\"이름\"   onChange={onChange}   value={name}   ref={nameInput} // useRef /&gt;   원하는 곳에 useRef를 호출해 변수를 지정합니다.   const onReset = () =&gt; {   // 초기화 기능   setInputs({     name: \"\",     nickname: \"\",   });   nameInput.current.focus(); };   onReset함수를 호출하면 nameInput을 지정한 DOM요소에 접근하여 focus기능을 호출합니다.   📄 useRef로 컴포넌트 안의 변수 만들기   useRef는 DOM요소에 접근할 때도 사용하지만 어떤 값을 계속 기억하고 싶을 때도 사용합니다.   useRef로 만든 컴포넌트안의 변수는 변경되어도 리렌더링 되지 않습니다.   function App() {   ...    const nextId = useRef(4);    const onCreate = () =&gt; {      console.log(nextId.current); // 4     nextId.current += 1;   }    ... }   nextId의 값이 변경되어도 컴포넌트가 리렌더링되지 않는다.   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React Hooks","useRef","성능 최적화"],
        "url": "/react/react-useRef%EB%A1%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%95%88%EC%97%90-%EB%B3%80%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "🚨 DOM 함수 타입 오류 해결 방법",
        "excerpt":"🚨 DOM 함수 타입 오류 해결 방법   타입스크립트 코드에서 DOM요소의 타입을 정의할 때 에러가 발생하는 경우가 있습니다.   // app.ts const confirmedTotal: HTMLSpanElement = $(\".confirmed-total\"); // Error      ❔ 에러 발생 이유   Element타입이 HTMLSpanElement의 프로퍼티 값을 가지지 않는다는 뜻입니다.   confirmedTotal은 HTMLSpanElement타입을 지정하기 전에 Element타입으로 정의되어 있었지만 HTMLSpanElement을 지정하자 에러가 발생했습니다.   타입간에 호환할 수 있는 형태가 아니기 때문에 에러가 발생한 것입니다.   HTMLSpanElement는 Element를 상속합니다.   에러 메세지에 있는 것 처럼 Element가 가지고 있지 않은 속성이 100개가 넘기 때문에 타입이 호환되지 않아 에러가 발생한 것입니다.   🔨 해결 방법   타입 단언을 사용하면 이를 해결할 수 있습니다.   // app.ts const confirmedTotal = $(\".confirmed-total\") as HTMLSpanElement;   타입 단언을 사용해서 $('.confirmed-total') 타입을 지정했습니다.   HTMLSpanElement로 타입을 지정한 이유는 confirmed-total이 html코드에서 span태그를 사용했기 때문입니다.   // index.html &lt;span class=\"confirmed-total\"&gt;&lt;/span&gt;   이처럼 각 태그에 맞게 타입 단언을 하면 에러가 해결 될 수 있습니다.   출처      캡틴 판교-타입스크립트 실전 강의  ","categories": ["TypeScript"],
        "tags": ["DOM","에러"],
        "url": "/typescript/typescript-DOM-%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[React] 리액트",
        "excerpt":"📄 리액트(React)   리액트는 사용자에게 보여지는 유저 인터페이스를 만들 수 있게 하는 라이브러리.입니다.   리액트는 2013년 페이스북에서 시작되어 현재 많은 웹 어플리케이션이 리액트를 사용하고 있습니다.   리액트는 컴포넌트의 집합체로서 유저 인터페이스를 보여주고 이벤트를 처리합니다.   📄 리액트 컴포넌트   import React, { Component } from 'react';  /* component */ class LikeButton extends Component {   /* state */   state = {     numnerOfLikes: 0,   };   /* render */   render() {     return &lt;button&gt;       {this.state.numberOfLikes}     &lt;/button&gt;;   } }  export defalut LikeButton;      state: 컴포넌트에 들어있는 데이터   render: 사용자에 어떻게 표시 될지 표현    리액트는 위와 같은 코드의 형식으로 돌아갑니다.   컴포넌트 안의 state가 변경이 되면 render에 적용되어 업데이트할 때 사용자에게 보여지는 내용이 바뀝니다.   만약 render함수 안에 자식요소가 들어있다면 자식요소의 render함수가 모두 업데이트 됩니다.   하지만 모든 변경 요소들이 DOM Tree에 적용되는 것은 아닙니다.   리액트의 Virtual Dom Tree는 이전 트리와 비교해 변경된 사항만 구별하여 Dom Tree에 적용시킵니다.   📄 리액트의 장점           리액트는 컴포넌트로 구성되어 있기 때문에 독립적이고 재사용성이 높다.            리액트에는 Virtual Dom Tree가 있다. 변경사항이 Virtual Dom Tree에 적용되고 이전 트리와 비교해 변경된 사항만 구별하여 Dom Tree에 적용시킨다. 모든 내용이 업데이트되지 않고 변경사항만 업데이트 되기 때문에 불필요한 동작을 줄임으로써 성능을 높일 수 있다.            위와 같은 과정은 리액트에서 직접 데이터가 변경이 될 때 마다 어플리케이션 전체를 다시 렌더링 한다. 개발자가 다른 요소를 하나하나 일일히 손댈 필요 없이 리액트 자체에서 업데이트를 해주기 때문에 효율성을 추구할 수 있다.            리액트는 기본적으로 60fps를 보장하기 때문에 성능이 보장된다.       📄 컴포넌트를 만드는 방법           클래스              컴포넌트를 상속해서 만든다.       컴포넌트가 주기적으로 업데이트 될 때 사용한다.       관련된 데이터, 함수가 묶어져 있다.       state가 들어있어 컴포넌트가 업데이트 되면 Render함수가 업데이트된다.           class LikeButton extends Component {...}                함수             업데이트가 없고 정적인 경우에 사용한다.       한가지의 기능을 수행하는 단위이며, state나 lifecycle method가 없다. 하지만 React 16.8 버전부터는 React Hook이 도입되어 state, lifecycle method를 사용할 수 있음.           function App() {   return &lt;h1&gt;Hello&lt;/h1&gt;; }   출처           드림코딩            생활코딩      ","categories": ["React"],
        "tags": ["리액트"],
        "url": "/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%9B%85(hook)/",
        "teaser": null
      },{
        "title": "[React-React Hooks] useMemo",
        "excerpt":"📄 useMemo   useMemo는 성능 최적화 단계에서 연산된 값을 재사용하기 위해 사용합니다.   import { useMemo } from \"react\";  const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);      첫 번째 인자: 콜백 함수   두 번째 인자: 의존성 배열   두 번째 인자인 배열의 요소 값이 업데이트될 때만 콜백 함수를 다시 호출합니다.   만약 빈 배열을 넘겨주면 맨 처음 컴포넌트가 마운트 되었을 때만 값을 계산하고 이후에는 memoizaton된 값을 꺼내서 사용합니다.   원하는 값이 바뀌지 않으면 리렌더링할 때 이전의 값을 재사용합니다.   📄 useMemo 사용목적      이전에 연산된 값을 재사용한다.   컴포넌트가 렌더링된 결과를 재사용한다.   📄 주의할 점   useMemo는 꼭 필요한 경우에만 사용합니다.   값을 재활용하기 위해 따로 메모리에 값을 저장해 놓기 때문입니다.   불필요한 값을 저장하면 성능이 안좋아질 수 있습니다.   출처           코딩병원            패스트캠퍼스 for velopert      ","categories": ["React"],
        "tags": ["React Hooks","useMemo","성능 최적화"],
        "url": "/react/react-useMemo/",
        "teaser": null
      },{
        "title": "[React-React Hooks] useReducer",
        "excerpt":"📄 useReducer   useReducer는 useState처럼 State를 관리하고 업데이트 할 수 있는 Hook입니다.   useReducer를 사용하면 컴포넌트 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있습니다.   📄 useReducer 구조   const [number, dispath] = useReducer(reducer, initialState, init);  function reducer(state, action) {   switch (action.type) {     case \"INCREMENT\":       return state + 1;     case \"DECREMENT\":       return state - 1;     default:       return state;   } }   action이라는 객체를 기반으로 상태를 업데이트 한다.      dispath: reducer함수를 실행시키고 action을 발생시킨다.   action: 업데이트를 위한 정보를 가지고 있다.   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React Hooks","useReducer","성능 최적화"],
        "url": "/react/react-useReducer/",
        "teaser": null
      },{
        "title": "immer 라이브러리를 통해 불변성 유지하기",
        "excerpt":"📄 immer   : 불변성을 해치는 코드를 작성해도 대신 불변성 유지를 해주는 라이브러리   immer 라이브러리를 사용하면 불변성을 유지하면서 새로운 객체를 만들 수 있습니다.   📄 React의 불변성   그렇다면 불변성은 무엇을 뜻하는 것일까요?   리액트에서 불변성은 메모리 영역에서 값을 변경할 수 없다는 뜻입니다.   자바스크립트는 원시타입과 참조타입의 값 저장방식이 다릅니다.      원시타입( Boolean, String, Number, null, undefined, Symbol)            콜스택의 value에 변수 값 저장       변수 값이 변경되면 새로운 메모리 영역을 생성해 변경된 값 저장 (불변성 유지 o)           참조 타입 (Object, Array)            콜스택의 value에 메모리 힙의 주소를 저장       변수 값이 변경되면 새로운 메모리 영역을 생성하지 않고 (콜스택 변화 x), 메모리 힙의 value값만 변경 (불변성 유지 x)       기존의 변수를 변경한 새로운 변수를 반환하는 경우(map, filter, spread operator…)에는 새로운 메모리 영역 생성 (불변성 유지 o)           리액트의 불변성을 지키면 어떤 것이 좋을까요?   리액트는 콜스택의 주소 값을 통해 상태 변화를 감지 하는 얕은 비교를 합니다.      원시타입은 불변성을 유지해 값이 변경되는 경우, 상태의 변화를 감지할 수 있습니다.   참조타입은 불변성이 유지되지 않는 경우, 리액트가 상태 변화를 감지할 수 없어 재렌더링되지 않습니다.   이렇게 보니 불변성을 유지하는 것은 꼭 필요해 보이네요.   📄 immer 사용하기           커맨드창 혹은 터미널에서 yarn add immer를 입력해 라이브러리를 설치합니다.            App.js에 import produce from 'immer'를 입력해 해당 라이브러리를 import한다.       📄 immer 구조   const 변수 = produce(바꾸고 싶은 값, draft =&gt; {   ... });      draft: 어떻게 바꿀지 알려주는 함수   📄 예시   import produce from \"immer\";  const state = {   number: 1,   donChangeMe: 2, };  const nextState = produce(state, (draft) =&gt; {   draft.number += 1; });  nextState();   불변성을 지키지 않으면서 코드를 작성(참조 타입 사용)했지만 produce함수가 불변성을 유지해주고 있습니다.   참고      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["immer","불변성"],
        "url": "/react/react-immer/",
        "teaser": null
      },{
        "title": "🚨 Object is possibly 'null'.ts(2531)",
        "excerpt":"🚨 Object is possibly ‘null’.ts(2531)   tsconfig파일에서 안전한 코드 가동을 위해 strict을 true로 설정했더니 여러가지 에러가 발생했습니다.   ...     deathsList.appendChild(li); ...   이 코드의 에러메세지는 다음과 같습니다.   const deathsList: Element | null; // 🚨 Object is possibly 'null'.ts(2531)   deathsList의 타입이 Element 혹은 null이 될 수 있는데 확실하게 해달라는 뜻입니다.   애초에 deathList를 선언할때 타입단언을 확실히 해주면 되는 일이지만 이 외에도 다양한 해결 방법이 있습니다.   🔨 해결 방법   1. if문 사용   코드의 바로 윗줄에 if문을 사용하여 null일 경우 return합니다.   if (!deathList) {   return; } deathsList.appendChild(li);   deathListh가 null이 되면 return되어 버리기 때문에 해당 코드까지 내려가지 않고 에러가 발생하지 않습니다.   하지만 이렇게 모든 해당 에러 코드를 if문으로 작성하면 코드가 길어져 효율성이 떨어질 수 있습니다.   2. assertion 사용(타입 단언)   deathsList!.appendChild(li);   assertion 기호 !를 사용하면 해당 데이터가 null이 아니라고 타입스크립트에 알려주게 됩니다.   하지만 assertion을 사용해서 타입 단언을 하게 되면 esLint에서 위험하다고 경고를 줍니다.   📌 타입 단언 문법 사용시 주의해야 할 점   타입 단언을 사용하면 주의해야할 점이 있습니다.   interface Hero {   name: string;   skill: string; }  const capt = {} as Hero;  // capt.name = 'capt';   타입 단언을 사용하면 인터페이스의 속성 값을 사용하지 않아도 에러가 나지 않는 위험성을 가지고 있습니다.   따라서 타입 단언은 확신이 있을 경우에만 사용하는 것을 권장한다.   3. 옵셔널 체이닝 연산자 사용하기   옵셔널 체이닝 문법을 사용하면 ?기호로 간단히 에러를 잡을 수 있습니다.   ...     deathsList?.appendChild(li); ...   deathList가 null 이나 undefined면 평가를 멈추고 undefined를 반환한다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["null","에러"],
        "url": "/typescript/typescript-Object-is-possibly-'null'/",
        "teaser": null
      },{
        "title": "[TypeScript] 타입 추론(Type Inference)",
        "excerpt":"📄 타입 추론(Type Inference)   타입 추론은 타입 스크립트가 코드를 해석해 나가는 동작을 뜻합니다.   let x = 3;   타입 스크립트는 x에 타입을 지정하지 않아도 number라는 타입을 추론합니다.   변수를 선언하거나 속성, 인자의 기본 값, 함수의 반환 값 등을 설정할 때도 타입 추론이 일어납니다.   📄 인터페이스와 제네릭을 이용한 타입 추론   interface Dropdown&lt;T&gt; {   value: T;   title: string; } interface DertailedDropdown&lt;K&gt; extends Dropdown&lt;K&gt; {   description: string;   tag: K; }  var detailedItem: DertailedDropdown&lt;string&gt; = {   title: \"abc\",   description: \"ab\",   value: \"a\",   tag: \"a\", };   📄 Best Common Type 추론 방식   타입 스크립트가 추론하는 가장 근접한 타입을 Best Common Type이라고 합니다.   let arr = [0, 1, null]; // type: number | null   타입스크립트는 추론되는 타입들을 유니온으로 지정합니다.   출처      캡틴 판교-타입스크립트 입문 강의  ","categories": ["TypeScript"],
        "tags": ["타입 추론"],
        "url": "/typescript/typescript-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0(Type-Inference)/",
        "teaser": null
      },{
        "title": "[React] 리액트 라우터",
        "excerpt":"📄 라우팅이란?   라우팅은 어떤 주소에 어떤 UI를 보여줄지 규칙을 정하는 작업입니다.   싱글 페이지 어플리케이션(SPA)에서 클라이언트가 라우팅을 담당합니다.   📄 SPA란?   SPA는 html을 한번만 받아와서 실행시킨 후 이후에는 필요한 데이터만 받아와서 화면에 업데이트하는 페이지입니다.   실질적으로는 하나의 페이지에서 작업하지만 사용자는 여러개의 페이지를 불러오는 것처럼 느낍니다.   ▪ SPA 단점      앱의 규모가 너무 커지면 JS파일의 크기가 너무 커질 수 있습니다.   브라우저에서 자바스크립트가 구동 되지 않으면 UI를 볼 수 없습니다. 예) 검색엔진에서 크롤링 불가능   📄 리액트에서 사용되는 라우터 라이브러리      리액트 라우터 리액트 라우터는 컴포넌트를 기반으로 라우팅합니다.   Next.js 서버사이드 렌더링을 쉽게 구현 가능합니다. 파일 경로, 이름을 기반으로 라우팅합니다.   📄 리액트 라우터   ▪ 설치 방법   npm install react-router-dom // npm  yarn add react-router-dom // yarn   ▪ BrowserRouter   &lt;BrowserRouter&gt;   basename: string   getUserConfrimation: func   forceRefresh: bool   keyLength: number   children: node      HTML5를 지원하는 브러우저의 주소를 감지합니다.   주소만 바꾸고 페이지는 다시 불러오지 않습니다.   HashRouter   &lt;HashRouter&gt;   basename: string   getUserConfirmation: func   hashType: string   children: node      #를 사용합니다.   옛날 브라우저 전용입니다.   example.com/#/path/to/route   ▪ MemoryRouter   &lt;MemoryRouter&gt;   initialEntries: array   initialIndex: number   getUserConfirmation: func   keyLength: number   children: node      브라우저의 주소와 무관합니다. 따라서 브라우저가 아닌 환경에서 쓰기 좋습니다.   임베디드 웹앱, 리액트 네이티브 등에서 사용합니다.   ▪ StaticRouter   &lt;StaticRouter&gt;   basename: string;   location: string;   location: string;   context: object   children: node      서버사이드 렌더링에서 사용하는 용도입니다.   ▪ Route   &lt;Route&gt;   Route render methods   Route props   component   render: func   ...      라우트를 정의할 때 사용하는 컴포넌트입니다.   ▪ Link   &lt;Link&gt;   to: string   to: object   replace: bool   innerRef: function   others      사용한 Router의 주소를 바꿉니다.   a 태그지만 새로고침되지 않습니다.   📄 리액트 라우터의 파라미터와 쿼리   라우너의 파라미터와 쿼리는 주소를 통해서 어떤 동적인 값을 읽어와야 할 때 사용합니다.   ▪ URL 파라미터      /profiles/velopert   정해진 특정 데이터를 조회할 때 사용합니다. ex) 아이디   ▪ Query      /filter?type=book&amp;sort_by=date   다양한 옵션을 줘서 조회할 때 사용한다. ex) 검색   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["라우터","SPA"],
        "url": "/react/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%9D%BC%EC%9A%B0%ED%84%B0/",
        "teaser": null
      },{
        "title": "[React] 리덕스 (Redux)",
        "excerpt":"📄 리덕스   리덕스는 컴포넌트 외부에서 상태 관리를 할 수 있는 리액트의 대표적인 전역 상태 관리 라이브러리입니다.   수많은 컴포넌트와 state가 있다면 props문법을 쓰기 어려울 때가 있습니다.   이런 경우에 redux를 사용합니다.   Redux를 설치하면 state를 보관할 수 있는 파일이 만들어집니다.   모든 컴포넌트들이 파일에서 state를 꺼내 쓸 수 있기 때문에 간편한 코드 작성이 가능합니다.   📄 리덕스의 장점   1. 상태관리가 용이하다.   상태관리가 용이하는 것은 state관리가 용이하다는 뜻입니다.   state를 수정해야 하는 상황에서 컴포넌트의 데이터를 직접 수정하는 것이 아니라 컴포넌트들이 Redux에 수정요청을 합니다.   수정요청을 받은 Redux는 state를 수정합니다.   2. 미들웨어를 활용한 다양한 기능 추가   데이터를 처리하는 중간과정에서 어떤 로직을 넣어서 필요한 기능을 추가할 수 있습니다.   미들웨어에서 로컬 스토리지에 데이터를 저장하거나 로컬 스토리지에서 데이터를 불러오는 기능을 간단하게 구현할 수 있습니다.   3. SSR시 데이터 전달이 간편하다.   리덕스의 상태값은 하나의 객체로 표현이 가능합니다.   서버는 상태값을 객체로 만들어 문자열로 변환해서 클라이언트로 전달하는데, 클라이언트는 받은 문자열을 하나의 객체로 변환해서 사용합니다.   하나의 객체로 관리가 되기 때문에 과거의 상태로 저장했다가 과거의 상태로 돌아가는 것을 간단히 구현할 수 있습니다.   4. 리액트 콘텍스트보다 효율적인 렌더링이 가능하다.   📄 리덕스를 사용할 때 규칙      하나의 애플리케이션엔 하나의 스토어가 있다. 스토어를 한개 이상 만들면 안된다.   상태는 읽기전용이다. 즉, 불변성을 지켜주어야 한다.   변화를 일으키는 함수 리듀서는 순수한 함수여야 한다. 동일한 값을 받아서 동일한 값을 반환해야 한다. ex) new Date() xxx   📄 리덕스에서 쓰는 키워드   1. action      상태에 어떤 변화가 필요할 때 action을 발생시킨다.   하나의 객체로 표현된다.   action객체는 type값을 필수로 가지고 있다.   {   type: 'TOGGLE_VALUE'   data: {     id: 0,     text: \"리덕스 배우기\"   } }   2. 액션 생성함수(Action Creator)      액션을 발생시키는 함수   파라미터를 받아와서 액션 객체를 만들어주는 함수   리덕스에서 액션 생성함수가 필수적이진 않지만 액션 객체를 더 편하게 만들 수 있다.   export function addTodo(data) {   return {     type: \"ADD_TODO\",     data   }; }  // 화살표 함수 버전  export function changeInput = text =&gt; ({   type: \"CHANGE_INPUT\",   text  });   3. 리듀서(Reducer)      변화를 일으키는 함수   state, action 이라는 파라미터를 가져온다.   리듀서에서는 불변성을 유지해야하므로 기존의 객체나 배열을 건드리지 않고 새로운 객체나 배열로 만들어야한다. ex) concat, spread…   default에서는 기존의 state를 반환하는 것이 일반적이다.   function counter(state, action) {   switch (action.type) {     case \"INCREASE\":       return state + 1;     case \"DECREASE\":       return (state = 1);     default:       return state;   } }   4. 스토어(store)      리덕스에선 하나의 애플리케이션당 하나의 스토어를 만든다.   스토어 안에는 현재 앱의 상태와 리듀서, 내장함수들이 들어있다.   4. 디스패치(dispatch)      스토어의 내장함수들 중 하나   액션을 발생시키는 것   액션을 스토어에 전달한다.   dispatch({ type: \"INCREASE\" });   5. 구독 (subscribe)      스토어의 내장함수들 중 하나   subscribe함수를 호출할 때 파라미터로 특정 함수를 넣어주면 액션이 디스패치될 때 마다 받아온 함수를 호출한다.   리듀서를 사용할 때 직접 사용하는 일은 없다.   출처           실전 리액트 프로그래밍            코딩애플      ","categories": ["React"],
        "tags": ["리덕스","상태 관리"],
        "url": "/react/react-%EB%A6%AC%EB%8D%95%EC%8A%A4/",
        "teaser": null
      },{
        "title": "JSON Server로 가짜 RestAPI 호출하기",
        "excerpt":"📄 JSON Server로 가짜 RestAPI 호출하기   프론트 작업을 할때 매번 백엔드를 개발해서 RestAPI를 호출하는 대신 JSON Server를 사용하면 손쉽게 연습용 RestAPI를 호출할 수 있는 방법이 있습니다.   📄 JSON 서버 만들기   1. data.json 폴더 만들기   폴더 안에 사용할 데이터를 작성합니다.   {   \"posts\": [     {       \"id\": 1,       \"title\": \"JSON 연습 1\",       \"body\": \"JSON 연습하기\"     },     {       \"id\": 2,       \"title\": \"JSON 연습 2\",       \"body\": \"JSON 연습하기\"     },     {       \"id\": 3,       \"title\": \"JSON 연습 3\",       \"body\": \"JSON 연습하기\"     }   ] }   2. 작성한 파일을 기반으로 서버를 연다.   $ npx json-server ./data.json --port 4000   이렇게 터미널에 입력하면 가짜 API 서버가 4000 포트로 열립니다.   3. axios를 사용하여 API 요청하기   프로젝트에 REST API Client인 axios를 설치합니다.   $ yarn add axios   만들어진 서버를 axios를 사용하여 호출해서 데이터를 받아옵니다.   // post.js import axios from \"axios\";  // 포스트 목록을 가져오는 비동기 함수 export const getPosts = async () =&gt; {   const response = await axios.get(\"http://localhost:4000/posts\");   return response.data; };   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["JSON","RestAPI"],
        "url": "/react/react-JSON-Server%EB%A1%9C-%EA%B0%80%EC%A7%9C-RestAPI-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React with TypeScript] 타입스크립트로 리액트 상태관리하기",
        "excerpt":"📄 타입스크립트로 리액트 상태관리하기   타입스크립트를 사용한 프로젝트에서 리액트 상태관리 훅을 사용하는 경우가 있습니다.   📄 1. useState 타입스크립트로 관리하기   useState에 타입스크립트를 적용한 기본 구조는 다음과 같습니다.   // useState 타입스크립트 적용 기본 구조 useState&lt;state의 type&gt;(state 초기값);  // useState 예시 (카운터 예제) const [count, setCount] = useState&lt;number&gt;(0);   이와 같이 Generics를 사용하여 상태의 타입을 설정합니다.   하지만 Generics를 사용하지 않아도 알아서 타입유추를 해주기 때문에 일일이 사용할 필요는 없습니다.   꼭 사용해야 하는 경우는 상태가 null인 경우일 때입니다.   type Information = { name: string; description: string }; const [info, setInformation] = useState&lt;Information | null&gt;(null);   ▪ useState를 적용한 코드에서 인풋상태 관리하기   타입스크립트를 적용한 코드는 각각 어떤 타입을 사용하는지 쉽게 알아낼 수 있습니다.   타입이 궁금한 값에 마우스를 갖다 대기만 하면 타입을 알려주기 때문입니다.   // src/MyForm.tsx  import React, { useState } from \"react\";  type MyFormProps = {   onSubmit: (form: { name: string; description: string }) =&gt; void; };  function MyForm({ onSubmit }: MyFormProps) {   const [form, setForm] = useState({     name: \"\",     description: \"\",   });    const { name, description } = form;    const onChange = (e: any) =&gt; {     // 타입을 모를 때는 any로 설정합니다. 하지만 any타입은 최대한 지양해야합니다.   };    const handleSubmit = (e: any) =&gt; {};    return (     &lt;form onSubmit={handleSubmit}&gt;       &lt;input name=\"name\" value={name} onChange={onChange} /&gt;       &lt;input name=\"description\" value={description} onChange={onChange} /&gt;       &lt;button type=\"submit\"&gt;등록&lt;/button&gt;     &lt;/form&gt;   ); }  export default MyForm;   위 코드의 input태그의 onChange에 마우스 커서를 올려두면 타입스크립트가 타입을 알려줍니다..      onChange의 타입은 Reaact.ChangeEventHandler&lt;HTMLInputElement&gt; 또는 undefined라고 알려주고 있습니다..   🚨 주의할 점!!   여기서 주의할 점은 저 타입을 그대로 가져다 쓰면 에러가 난다는 것입니다.      e.target에서 에러가 발생합니다.   타입 위에 Handler가 붙어 있어 에러가 발생했습니다.   Handler를 제거하고 React.ChangeEvent&lt;HTMLInputElement&gt;로 타입을 지정해 에러가 발생하지 않게 작성해야 합니다.   onChange와 마찬가지로 handleSubmit의 타입을 지정해줍니다.   import React, { useState } from \"react\";  type MyFormProps = {   onSubmit: (form: { name: string; description: string }) =&gt; void; };  function MyForm({ onSubmit }: MyFormProps) {   const [form, setForm] = useState({     name: \"\",     description: \"\",   });    const { name, description } = form;    const onChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {     const { name, value } = e.target;     setForm({       ...form,       [name]: value,     });   };    const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {     e.preventDefault();     onSubmit(form);     setForm({       name: \"\",       description: \"\",     });   };    return (     &lt;form onSubmit={handleSubmit}&gt;       &lt;input name=\"name\" value={name} onChange={onChange} /&gt;       &lt;input name=\"description\" value={description} onChange={onChange} /&gt;       &lt;button type=\"submit\"&gt;등록&lt;/button&gt;     &lt;/form&gt;   ); }  export default MyForm;   📄 2. useReducer 타입스크립트로 관리하기   useReducer를 사용하면 action을 타입으로 만들어주고 타입의 액션을 OR연산자를 사용하여 나열합니다.   type Action = { type: \"INCREASE\" } | { type: \"DECREASE\" };   액션 객체를 생성할 때 필요한 값을 타입안에 명시해주면 추후 리듀서를 사용할 때 자동완성이 되며 dispatch할때 타입명시도 해주어 코드작성에 편리합니다.   // useReducer 사용 예시  import React, { useReducer } from \"react\";  type Color = \"red\" | \"orange\" | \"yellow\";  type State = {   count: number;   text: string;   color: Color;   isGood: boolean; };  type Action =   | { type: \"SET_COUNT\"; count: number }   | { type: \"SET_TEXT\"; text: string }   | { type: \"SET_COLOR\"; color: Color }   | { type: \"TOGGLE_GOOD\" };  function reducer(state: State, action: Action): State {   switch (action.type) {     case \"SET_COUNT\":       return {         ...state,         count: action.count, // count가 자동완성되며, number 타입인걸 알 수 있습니다.       };     case \"SET_TEXT\":       return {         ...state,         text: action.text, // text가 자동완성되며, string 타입인걸 알 수 있습니다.       };     case \"SET_COLOR\":       return {         ...state,         color: action.color, // color 가 자동완성되며 color 가 Color 타입인걸 알 수 있습니다.       };     case \"TOGGLE_GOOD\":       return {         ...state,         isGood: !state.isGood,       };     default:       throw new Error(\"Unhandled action\");   } }  function ReducerSample() {   const [state, dispatch] = useReducer(reducer, {     count: 0,     text: \"hello\",     color: \"red\",     isGood: true,   });    const setCount = () =&gt; dispatch({ type: \"SET_COUNT\", count: 5 }); // count 를 넣지 않으면 에러발생   const setText = () =&gt; dispatch({ type: \"SET_TEXT\", text: \"bye\" }); // text 를 넣지 않으면 에러 발생   const setColor = () =&gt; dispatch({ type: \"SET_COLOR\", color: \"orange\" }); // orange 를 넣지 않으면 에러 발생   const toggleGood = () =&gt; dispatch({ type: \"TOGGLE_GOOD\" });    return (     &lt;div&gt;       &lt;p&gt;         &lt;code&gt;count: &lt;/code&gt; {state.count}       &lt;/p&gt;       &lt;p&gt;         &lt;code&gt;text: &lt;/code&gt; {state.text}       &lt;/p&gt;       &lt;p&gt;         &lt;code&gt;color: &lt;/code&gt; {state.color}       &lt;/p&gt;       &lt;p&gt;         &lt;code&gt;isGood: &lt;/code&gt; {state.isGood ? \"true\" : \"false\"}       &lt;/p&gt;       &lt;div&gt;         &lt;button onClick={setCount}&gt;SET_COUNT&lt;/button&gt;         &lt;button onClick={setText}&gt;SET_TEXT&lt;/button&gt;         &lt;button onClick={setColor}&gt;SET_COLOR&lt;/button&gt;         &lt;button onClick={toggleGood}&gt;TOGGLE_GOOD&lt;/button&gt;       &lt;/div&gt;     &lt;/div&gt;   ); }  export default ReducerSample;   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React","TypeScript","상태관리"],
        "url": "/react/react-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React with TypeScript] 타입스크립트를 적용한 리액트 프로젝트 생성하기",
        "excerpt":"📄 타입스크립트를 적용한 리액트 프로젝트 생성하기   리액트에 타입스크립트를 적용한 프로젝트를 생성할 때는 다음과 같은 명령어를 사용합니다.   $ npx create-react-app ts-react-tutorial --template typescript   이렇게 프로젝트를 생성하면 src폴더 안에 App.tsx파일이 생성됩니다.   컴포넌트 App의 타입이 React.FC로 지정되어 있는것을 확인할 수 있습니다.   // App.tsx  import React from \"react\"; import logo from \"./logo.svg\"; import \"./App.css\";  const App: React.FC = () =&gt; {   return (     &lt;div className=\"App\"&gt;       &lt;header className=\"App-header\"&gt;         &lt;img src={logo} className=\"App-logo\" alt=\"logo\" /&gt;         &lt;p&gt;           Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to reload.         &lt;/p&gt;         &lt;a           className=\"App-link\"           href=\"https://reactjs.org\"           target=\"_blank\"           rel=\"noopener noreferrer\"         &gt;           Learn React         &lt;/a&gt;       &lt;/header&gt;     &lt;/div&gt;   ); };  export default App;   ▪ React.FC   React.FC를 사용할 때는 props의 타입을 Generics로 넣어서 사용합니다.   // Greetings.tsx  import React from \"react\";  type GreetingsProps = {   name: string; };  const Greetings: React.FC&lt;GreetingsProps&gt; = ({ name }) =&gt; (   &lt;div&gt;Hello, {name}&lt;/div&gt; );  export default Greetings;   ✔ React.FC의 장점      props에 기본적으로 children이 들어있다.   defaultProps, propTypes, contextTypes 를 설정할 때 자동완성이 된다.   ✔ React.FC의 단점      children이 옵셔널 형태로 들어가 있어 컴포넌트의 props타입이 명백하지 않다.   // src/Greetings.tsx  import React from \"react\";  type GreetingsProps = {   name: string;   mark: string; };  const Greetings: React.FC&lt;GreetingsProps&gt; = ({ name, mark }) =&gt; (   &lt;div&gt;     Hello, {name} {mark}   &lt;/div&gt; );  Greetings.defaultProps = {   mark: \"!\", };  export default Greetings;   // src/App.tsx  import React from \"react\"; import Greetings from \"./Greetings\";  const App: React.FC = () =&gt; {   return &lt;Greetings name=\"Hello\" /&gt;; };  export default App;   mark를 defaultProps에 넣었습니다.   하지만 App에서 해당 컴포넌트를 렌더링했을때 mark의 값이 없다고 알려주며 렌더링되지 않는 현상이 발생합니다.   이때 React.FC를 생략하면 정상적으로 렌더링되기 때문에 React.FC의 사용을 권장하지 않는 것을 권장하기도 합니다.   // React.FC를 사용하지 않은 Greetings.tsx  import React from \"react\";  type GreetingsProps = {   name: string;   mark: string; };  const Greetings = ({ name, mark }: GreetingsProps) =&gt; (   &lt;div&gt;     Hello, {name} {mark}   &lt;/div&gt; );  Greetings.defaultProps = {   mark: \"!\", };  export default Greetings;   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React","TypeScript"],
        "url": "/react/react-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React with TypeScript] 타입스크립트와 Context API 활용하기",
        "excerpt":"📄 타입스크립트와 Context API 활용하기   Context API를 사용할 때 state를 위한 Context와 dispatch를 위한 Context를 따로 만들어 줍니다.   이때 dispatch를 위한 타입을 설정하면 dispatch에서 리액트를 불러올 수 있습니다.   액션들의 타입을 dispatch의 Generics로 설정했습니다.   // 예시 type SampleDispatch = Dispatch&lt;Action&gt;;   // src/SampleContext.tsx  import React, { useReducer, useContext, createContext, Dispatch } from \"react\";  // 필요한 타입들을 미리 선언  type Color = \"red\" | \"orange\" | \"yellow\";  // 상태를 위한 타입 type State = {   count: number;   text: string;   color: Color;   isGood: boolean; };  // 모든 액션들을 위한 타입 type Action =   | { type: \"SET_COUNT\"; count: number }   | { type: \"SET_TEXT\"; text: string }   | { type: \"SET_COLOR\"; color: Color }   | { type: \"TOGGLE_GOOD\" };  // 디스패치를 위한 타입 (Dispatch 를 리액트에서 불러올 수 있음), 액션들의 타입을 Dispatch 의 Generics로 설정 type SampleDispatch = Dispatch&lt;Action&gt;;  // Context 만들기 const SampleStateContext = createContext&lt;State | null&gt;(null); const SampleDispatchContext = createContext&lt;SampleDispatch | null&gt;(null);  // 리듀서 function reducer(state: State, action: Action): State {   switch (action.type) {     case \"SET_COUNT\":       return {         ...state,         count: action.count, // count가 자동완성되며, number 타입인걸 알 수 있습니다.       };     case \"SET_TEXT\":       return {         ...state,         text: action.text, // text가 자동완성되며, string 타입인걸 알 수 있습니다.       };     case \"SET_COLOR\":       return {         ...state,         color: action.color, // color 가 자동완성되며 color 가 Color 타입인걸 알 수 있습니다.       };     case \"TOGGLE_GOOD\":       return {         ...state,         isGood: !state.isGood,       };     default:       throw new Error(\"Unhandled action\");   } }  // SampleProvider 에서 useReduer를 사용하고 // SampleStateContext.Provider 와 SampleDispatchContext.Provider 로 children 을 감싸서 반환합니다. export function SampleProvider({ children }: { children: React.ReactNode }) {   const [state, dispatch] = useReducer(reducer, {     count: 0,     text: \"hello\",     color: \"red\",     isGood: true,   });    return (     &lt;SampleStateContext.Provider value={state}&gt;       &lt;SampleDispatchContext.Provider value={dispatch}&gt;         {children}       &lt;/SampleDispatchContext.Provider&gt;     &lt;/SampleStateContext.Provider&gt;   ); }  // state 와 dispatch 를 쉽게 사용하기 위한 커스텀 Hooks export function useSampleState() {   const state = useContext(SampleStateContext);   if (!state) throw new Error(\"Cannot find SampleProvider\"); // 유효하지 않을땐 에러를 발생   return state; }  export function useSampleDispatch() {   const dispatch = useContext(SampleDispatchContext);   if (!dispatch) throw new Error(\"Cannot find SampleProvider\"); // 유효하지 않을땐 에러를 발생   return dispatch; }   null체킹을 해주는 커스텀 훅을 만드는 것은 큰 의미가 있습니다.   null체킹을 하지 않으면 useSampleState의 결과값의 타입은 State | null이 됩니다.   하지만 커스텀 훅을 통해 null체킹을 해준다면 유효한 코드의 타입을 보장할 수 있습니다.   Context API에 타입스크립트를 적용하면 Context 안에 들어있는 상태를 조회할 때, 새로운 액션을 디스패치해야 할 때 자동완성이되어 개발 생산성을 높여줄 수 있습니다.   출처      패스트캠퍼스 for velopert  ","categories": ["React"],
        "tags": ["React","TypeScript","Context API","null checking"],
        "url": "/react/react-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-Context-API-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Next.js] Next.j가 라우팅하는 방법",
        "excerpt":"📄 Next.js가 Routing 방법      💡 라우팅이란? 특정 주소에 도달해서 주소가 제공하는 데이터를 받아서 사용하는 과정    리액트에서 react-router-dom을 이용했다면, Next.js는 자체적인 router기능이 있다.   page폴더에 들어가는 파일과 폴더의 이름에 따라 URL이 정해진다.   폴더명으로 접근한다면 index.js파일로 접근해야한다.   📄 1. 정적 라우팅(Link)      💡 정적 라우팅이란? 사전에 지정된 주소로 이동하는 방법    13버전 이전에는 Link태그 안에 a태그를 사용해야 했지만 13버전 이후로 Link태그 하나로 라우팅이 가능하다.   &lt;Link href=\"해당경로\"&gt;...&lt;/Link&gt;   📄 2. 동적라우팅(slug)      💡 동적 라우팅이란? 페이지가 상황에 따라 동적으로 경로가 지정된다.    본래 slug는 중요한 의미를 포함하는 단어만을 이용해 제목을 작성하는 방법이다.   slug에 어떤 값을 넣어도 해당 파일로 이동한다.   파일뿐만 아니라 폴더에도 slug를 쓸 수 있다.   page/category/[slug].js =&gt; /category/:slug (ex. /category/food) pages/[username]/info.js =&gt; /:username/info (ex. /jimmy/info)   ⭐ slug의 값은 Next.js에서 제공하는 useRouter을 사용해 Router의 query로 컨트롤한다.   import { useRouter } from 'next/router' ... const router = useRouter() const {slug} = router.query ...   ▪ 다중 slug   ...을 쓰면 무한 경로로 사용할 수 있다.   ⭐ 슬래시가 하나 이상이면 slug페이지가 트리거 된다.   const router = useRouter();  const findEventHandler = (year, month) =&gt; {   const fullPath = `/events/${year}/${month}`;   router.push(fullPath); };   ▪ 옵셔널 slug   slug 값이 없어도 동작하게 만드려면 [[...slug]]처럼 대괄호를 두번씩 사용하면 된다.   📄 3. Shallow Routing   : getServerSideProps / getStaticProps 등을 다시 실행시키지 않으면서 현재 상태를 잃지 않고 url을 바꾸는 방법   Shallow의 뜻은 ‘얉은’이라는 뜻을 가지고 있다.   Shllow Routing을 사용하는 경우는 상태를 유지하면서 url을 바꾸고 싶을 때 이다.   예를 들어 사용자가 어떤 동작을 했고, 그 기록을 query로 남기고 싶을때, query로 남기면 사용자가 새로고침을 해도 유지된다.   url을 바꾸는 3가지 방법      location.replace(\"url\"): 로컬 state는 유지 안됨(리렌더)   router.push(url): 로컬 state는 유지 / data fetching은 일어남   router.push(url, as, {shallow: true }): 로컬 state 유지 / data fetching은 일어나지 않음   출처           패스트 캠퍼스 Next.js 완전 정복            https://merrily-code.tistory.com/52      ","categories": ["Nextjs"],
        "tags": ["Link","slug"],
        "url": "/nextjs/nextjs-nextjs%EA%B0%80-%EB%9D%BC%EC%9A%B0%ED%8C%85%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[Next.js] Image태그와 img 태그의 차이",
        "excerpt":"🗒️ Image 태그와 Img 태그의 차이   Next.js는 에서 Image 컴포넌트를 제공한다.   &lt;Image src=\"/images/profile.jpg\" width={144} height={144} alt=\"Jimmy\" /&gt; // Image 태그  &lt;Img src=\"/images/profile.jpg\" alt=\"Jimmy\" /&gt; // img 태그   🗒️ Next/Image 컴포넌트에서 제공하는 기능      Resizing(responsive 사이즈)   Lazy load(viewport에 들어오면 로드한다): 이미지를 로드하는 시점을 필요할 때까지 지연시킨다.   그외 optimization(webp 형태)   출처           패스트 캠퍼스 Next.js 완전 정복            카카오 FE 기술블로그      ","categories": ["Nextjs"],
        "tags": ["Image","img"],
        "url": "/nextjs/nextjs-Image%ED%83%9C%EA%B7%B8%EC%99%80-img-%ED%83%9C%EA%B7%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[Next.js] configuration",
        "excerpt":"📄 configuration   Next.js의 configuration을 커스텀하려면 next.config.js나 next.config.mjs를 생성해야 한다.   next.config.js는 Node.js의 모듈이다. (JSON 아님)   next.config.js는 Next.js의 서버로 사용되지만 브라우저 build 에 포함되지 않는다.   // next.config.js  /**  * @type {import('next').NextConfig}  */ const nextConfig = {   /* config options here */ };  module.exports = nextConfig;   만약 ECMAScript 모듈이 필요하다면 next.config.mjs를 사용한다.   /**  * @type {import('next').NextConfig}  */ const nextConfig = {   /* config options here */ };  export default nextConfig;   출처      Next.js 공식문서  ","categories": ["Nextjs"],
        "tags": ["configuration"],
        "url": "/nextjs/nextjs-configuration/",
        "teaser": null
      },{
        "title": "🚨 Component cannot be used as a JSX component. Its return type is not a valid JSX element",
        "excerpt":"🚨 에러 발생   프로젝트 진행 중 Layout 컴포넌트에서 에러가 발생했다.      ❔ 에러 원인   해당 컴포넌트를 함수형으로 작성했는데 return 문이 없었다.   🔨 에러 해결   // Page.tsx ... export default function Page({ children }: Props) {   return &lt;Container&gt;{children}&lt;/Container&gt; } ...   출처      stack overflow  ","categories": ["JavaScript"],
        "tags": ["에러"],
        "url": "/javascript/typescript-Component-canot-be-used/",
        "teaser": null
      },{
        "title": "🚨 Type '{...}' has no properties in common with type 'IntrinsicAttributes'",
        "excerpt":"🚨 에러 발생   프로젝트 과정 중 _app.tsx파일에서 에러가 발생했다.   Type '{...}' has no properties in common with type 'IntrinsicAttributes'      ❔ 에러 원인   해당 컴포넌트의 props인 children이 존재하지 않는다는 뜻이다.   🔨 에러 해결   props를 설정해서 타입을 지정해주자.   import React from \"react\";  interface Props {   children?: React.ReactNode;   [k: string]: any; }  export default function Layout({ children, ...props }: Props) {   return &lt;div&gt;Layout&lt;/div&gt;; }   Props를 interface로 설정해서 타입을 지정하고 컴포넌트에 설정해 주었다.  ","categories": ["TypeScript"],
        "tags": ["에러","props"],
        "url": "/typescript/typescript-Type-has-no-properties/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "🚨 refers to a value, but is being used as a type here.",
        "excerpt":"🚨 문제 발생   타입 스크립트로 React-Router-Dom에서 제공하는 Navigate 컴포넌트를 사용하려고 하는데 에러가 발생했다.   'Navigate' refers to a value, but is being used as a type here.      ❔문제 원인   타입스크립트 파일 확장자를 ts로 한 상태에서 컴포넌트를 사용해서 발생한 문제였다.   🔨 문제 해결    :thumbsup:   참고      StackOverFlow  ","categories": ["TypeScript"],
        "tags": ["에러","Navigate"],
        "url": "/typescript/typescript-refers-to-a-value.-but-is-being-used-as-a-type-here/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "[React] 컨텍스트 API (Context API)",
        "excerpt":"📄 컨텍스트 API   컨텍스트 API는 자신은 사용하지 않으면서 밑으로 내려줘야하는 코드가 있을 때 혹은 다른 멀리 있는 컴포넌트에 있는 값을 바로 사용할 경우 사용합니다.   컨텍스트를 사용하면 props로 일일이 데이터를 전달해주지 않아도 해당 데이터를 가지고 있는 상위 컴포넌트가 하위 컴포넌트에게 전달해 줄 수 있습니다.   컨텍스트를 사용하기 위해서 createContext함수를 호출하면 객체가 반환된다.   // 컨텍스트 함수 호출 const UserContext = createContext(\"unknown\");  // 컨텍스트 함수 사용 const ContextExample = useContext(UserContext);   createContext를 호출할 때 초기값을 설정하는데 컴포넌트가 값을 검색할때 해당 값이 없으면 초기값이 사용된다.   📄 주의할 점   context는 꼭 필요할 때만 사용한다.      Context를 사용하면 컴포넌트를 재사용하기 어려워 질 수 있다.   Prop drilling을 피하기 위한 목적이라면 Component Composition (컴포넌트 합성)을 먼저 고려하자.   📄 예제   import React, { createContext, useContext, useState } from \"react\";  const MyContext = createContext(\"defalutValue\");  function Child() {   const text = useContext(MyContext);   return &lt;div&gt;안녕하세요? {text} &lt;/div&gt;; }  function Parent() {   // 중간 컴포넌트인 Parent에 아무런 props도 전달되지 않았다.   return &lt;Child /&gt;; }  function GrandParent() {   return &lt;Parent /&gt;; }  function ContextSample() {   const [value, setValue] = useState(true);   return (     &lt;MyContext.Provider value={value ? \"Good\" : \"Bad\"}&gt;       &lt;GrandParent /&gt;       &lt;button onClick={() =&gt; setValue(!value)}&gt;CLICK ME&lt;/button&gt;     &lt;/MyContext.Provider&gt;   ); }  export default ContextSample;      MyContext에 createContext로 기본값이 defalutValue인 컨텍스트를 생성했다.   Child 컴포넌트의 text에 MyContext를 적용했다.   메인 컴포넌트인 ContextSample에서 text를 가져다 쓸 GrandParent컴포넌트를 MyContext태그로 감싸 사용한다.   기본값을 바꾸고 싶다면 Provider 컴포넌트를 사용해 value의 값을 설정한다.   객체 안에는 Provider 컴포넌트가 들어있습니다.   Provider에서 value에 값을 넣어주면 Context가 적용된 값이 바뀝니다.   Provider컴포넌트의 값이 변경되면 하위의 컴포넌트는 다시 랜더링 됩니다.   중간에 있는 컴포넌트가 렌더링 되지 않아도 해당 컴포넌트는 리렌더링됩니다.   출처           패스트캠퍼스 for velopert            별코딩-useContext + Context AP      ","categories": ["React"],
        "tags": ["컨텍스트"],
        "url": "/react/react-%EB%B0%B0%EC%97%B4-%EB%A0%8C%EB%8D%94%EB%A7%81/",
        "teaser": null
      },{
        "title": "🚨 setStateAction 타입에러",
        "excerpt":"🚨 에러 발생   todolist를 만드는데 궁금한 점이 생겼다.   const [createInput, setCreateInput] = useState(\"\");  const onChangeCreateInput = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {   const value = e.target;   setCreateInput(value);   // Error: Argument of type 'EventTarget &amp; HTMLInputElement' is not assignable to parameter of type 'SetStateAction&lt;string&gt;'.ts(2345) };   value의 중괄호의 의미가 궁금해졌다.   중괄호를 사용하여 객체로 선언했을때는 에러가 안나는데 중괄호를 없애니까 에러가 발생했다.   해결을 위해 okky에 질문해보았다.   ❔ 에러 원인   EventTarget &amp; HTMLInputElement 타입의 전달 인자(호출할 때)는 SetStateAction의 타입의 파라미터(정의할 때)에 할당할 수 없다.   즉, 이벤트 객체인 e의 타입과 setCreateInput의 파라미터의 타입이 다르다는 것이다.   에러가 발생한 부분의 코드에서   e.target의 타입을 받은 value의 타입은 EventTarget &amp; HTMLInputElement인데,   사용하는 상태 변경 함수 setCreateInput의 타입이 SetStateAction&lt;string&gt; 즉, string이기 때문에 타입에러가 발생한 것이다.   🔨 에러 해결   const{ value } = e.target은 const value = e.target.value와 같은 의미이다.   타입을 맞춰 쓰기 위해서는 객체 구조 분해 할당 문법을 사용하여 이벤트 객체 안의 값을 꺼내서 써야 한다.   출처   OKKY  ","categories": ["TypeScript"],
        "tags": ["에러","setStateAction"],
        "url": "/typescript/typescript-setStateAction-%ED%83%80%EC%9E%85%EC%97%90%EB%9F%AC/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "[React] 리액트 상태관리",
        "excerpt":"📄 리액트 상태관리   🎲 Key Point | 상태를 관리한다 = 데이터를 관리하고 저장한다.   상태(state)란, 웹 애플리케이션을 렌더링 하는데 있어 영향을 미칠 수 있는 값입니다.   상태 즉, State 관리는 지역상태와 전역상태가 있습니다.   props를 통해서 데이터를 전달하면 지역상태, 다른 저장소에서 데이터를 불러오면 전역 상태입니다.   보통 전역 상태로 핸들링하는게 항상 좋을 것이라 생각하지만 그렇지만은 않습니다.      기본적인 경우에는 지역 상태로 데이터를 관리   지역상태로 관리시 다수의 컴포넌트 간에 상태 의존성이 높아진다면 전역 상태로 데이터 관리   전역 상태 관리 시 서버에서 가져오는 데이터(db)와, 단순하게 UI 상태를 나타내는 데이터는 분리   서버 데이터 캐싱 시 전역 상태로 다루는 것은 추천하지 않음. 서버 상태를 관리 할때는 SWR이나 Reat-Query와 같은 서버 전용 라이브러리 사용 권장   📄 리액트의 다양한 상태관리 방법   1. Redux   Redux의 가장 큰 특징은 다음과 같습니다.      데이터의 흐름이 단방향이다. (Flux 패턴)   모든 상태를 store에 저장한다.   redux는 하나의 store를 가지고 있어 하나의 객체 트리를 가지고 있기 때문에 확장할 때 용이하다는 큰 장점을 가지고 있습니다.   또한 데이터 흐름이 단방향으로 일어나기 때문에 결과를 예측하기 쉽습니다.   다만 store는 외부요소기 때문에 리액트 내부에서 접근할 수 없어서 비동기 처리를 위해 react-saga같은 별도의 라이브러리를 추가해서 사용해야 합니다.   reducer은 순수함수이기 때문에 상태를 변경하는 것이 아니라 새로운 상태를 반환합니다.   2. MobX      store가 여러개다.   store의 데이터를 action발행 없이 업데이트 할 수 있다.   mobx는 redux와 달리 store가 여러개지만 상태 변경할 경우, 다수의 store가 영향을 받을 수 있습니다.   또한 action 없이 데이터를 발행할 수 있지만 테스트나 유지보수 측면에서 문제를 일으킬 가능성이 있어 큰 규모의 프로젝트를 다루기에는 부적합니다.   3. Context API   context API는 리액트에 내장되어 있습니다.      주로 정적인 데이터를 관리할 때 사용한다.   Provider로 감싸진 부분의 업데이트가 되지 않은 state에도 리렌더링이 발생한다.   4. Recoil      Recoil은 Atom과 Selector로 이루어져 있다.   Atom을 구독하고 있으면 해당 컴포넌트만 선택적으로 리렌더링된다.   Selector은 비동기 처리와 데이터 캐싱 기능을 담당한다. Recoil은 비교적 최근에 나온 라이브러리라 아직 버전이 낮아 안정성측면이 좋지 않다는 단점이 있다.  ","categories": ["React"],
        "tags": ["상태 관리"],
        "url": "/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[TodoList-Project] useQuery 적용하고 페이지 업데이트 멈추는 현상",
        "excerpt":"🚨 에러 발생 1   리액트 쿼리를 작성했던 투두리스트에 적용했다.   // todolist12.tsx  const { data: getTodo } = useQuery&lt;TodoItemType[]&gt;('getTodo', getTodoList)  ...   &lt;TodoList todos={getTodo} onToggleDone={onToggleDone} onClickDelete={onClickDelete} /&gt;   완료 버튼을 누르거나 삭제 버튼을 누르면 변경 데이터가 바로 브라우저에 보이지 않고 새로고침을 해야 반영이 되었다.   ❔ 에러 원인 1   react-query의 캐싱 기능 버튼을 눌러도 리렌더링을 하였을때 변경사항이 반영되지 않은 것이다.   🔨 에러 해결 1   react-query의 refetch 옵션을 사용하였다.   refetch는 말 그대로 다시 데이터를 fetch하는 것이다.    const { data: getTodo, refetch } = useQuery&lt;TodoItemType[]&gt;('getTodo', getTodoList)   ...   const onToggleDone = async (id: number, done: boolean) =&gt; {     await todoStore.toggleDone(id, done)     refetch()   }    const onClickDelete = (id: number) =&gt; {     todoStore.deleteTodo(id)     refetch()   }   액션을 보내는 함수 가장 뒷 부분에 refetch()를 작성하면 변경 사항이 화면에 보여진다.   하지만 곧바로 다른 이슈가 발생했다.     🚨 에러 발생 2   완료버튼이나 삭제버튼을 연달아 누르면 작동하는 순서가 밀리거나 너무 느리게 반영이 되었다.   ❔ 에러 원인 2   todoStore.toggleDone -&gt; refetch로 작동하면 비동기로 진행되기 때문에 순서가 보장되지 않는다. 완료 버튼을 눌렀을때 순서대로 작동되지 않고 refetch되고 나서 toggleDone이 되어 순서가 얽혀버린것이다.   🔨 에러 해결 3   const onSubmitCreate = async (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {   e.preventDefault();   await todoStore.createTodo(createInput);   setIsOpenCreate(false);   setCreateInput(\"\");   refetch(); };  const onToggleDone = async (id: number, done: boolean) =&gt; {   await todoStore.toggleDone(id, done);   refetch(); };  const onClickDelete = async (id: number) =&gt; {   await todoStore.deleteTodo(id);   refetch(); };   방법은 await를 걸어서 순서를 보장해주는 것이었다.   async 함수로 만들어 await를 걸어주니 문제없이 작동했다.  ","categories": ["React"],
        "tags": ["TodoList","react-query","useQuery","에러"],
        "url": "/react/todolist-useQuery%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0/",
        "teaser": null
      },{
        "title": "[React] Redux toolkit",
        "excerpt":"📄 Redux toolkit   리액트 환경에는 수많은 상태관리 방법이 있습니다.   리액트에 이미 내장되어 있는 Context API가 있으며, 이외에도 다양한 상태 관리 라이브러리들이 존재합니다.   그럼에도 불구하고 리덕스가 많은 개발자들에게 사용되고 있는 이유는 무엇일까요.   📄 Context API vs Redux   사실 Context API와 Redux는 비교대상이 아닙니다.   Context는 수단일 뿐, 상태관리 자체는 useState와 useReducer가 담당합니다.   Context API와 Redux의 가장 큰 차이점은 성능 최적화에서 보여집니다.   Context API는 성능 최적화가 이루어지지 않아 특정값을 의존하는 경우, 해당하는 특정값이 아닌 다른 값이 변경될 때도 컴포넌트가 리렌더링이 됩니다.   반면 Redux는 의존하지 않는 값이 바뀌게되면 그 값에 영향을 받지 않고 리렌더링이 발생하지 않습니다.   따라서 Context API를 사용할 경우에는 컴포넌트의 분리가 중요합니다.   📄 Redux tookit 시작하기   ▪ Installation   ▪ CRA를 사용하는 경우   # Redux + Plain JS template npx create-react-app my-app --template redux  # Redux + TypeScript template npx create-react-app my-app --template redux-typescript   ▪ 존재하는 앱에 추가하는 경우   # NPM npm install @reduxjs/toolkit # Yarn yarn add @reduxjs/toolkit   📄 Redux toolkit에 존재하는 API   ▪ configureStore()      createStores는 간단한 configuration 옵션들과 기본값을 제공한다.   자동으로 사용자의 slice reducers를 합쳐서 사용하는 middleware가 무엇이든 추가한다.   ▪ createReducer()      상태가 바뀌기 전에 사용자가 룩업 테이블을 제공하게 한다.            lookup table? 주어진 연산에 대해 미리 계산된 결과들의 집합(배열)            자동으로 immer라이브러리를 사용해서 간단한 immutable 업데이트를 작성하게 한다.   ▪ createAction()      주어진 액션 타입에 대해 string타입으로 액션함수를 발생시킨다.   이 함수는 toString()이 내장되어 있어, 상수 타입을 대신해서 쓰인다.   ▪ createSlice()      reducer 함수들, slice 이름, 초기 state 값을 허용하여 자동으로 slice reducer를 생성한다.   ▪ createAsyncThunk      string 타입의 액션과 프로미스를 반환하는 함수를 받아들인다.   자동으로 slice reducer를 생성한다.   ▪ createEntitiyAdapter      일련의 재사용 가능한 리듀서와 스토어 안에 데이터를 관리하기 위한 selectors를 생성한다.   📄 RTK Query   RTK Query는 @reduxjs/toolkit 패키지에 추가되어 있는 부가적인 옵션입니다.   API 인터페이스를 정의하기 위해 데이터를 fetching하고 caching하는 간단하지만 강력한 툴셋을 제공합니다.   📄 RTK Query에 포함된 API들   ▪ createApi()      RTK Query의 핵심적인 기능   데이터를 fetching하고 변환하는 방법을 포함해서 엔드포인트를 정의하고 엔드포인트로부터 데이터를 검색하는 방법을 허용한다.            endpoint? 컴퓨터 네트워크에 연결하고 컴퓨터 네트워크와정보를 교환하는 물리적 디바이스            ▪ fetchBaseQuery()      요청을 단순화하는 것을 목표로 하는 fetch를 감싼다. = 데이터 fetching을 단순화하기 위해 사용된다.   Redux toolkit 공홈은 createApi에서 baseQuery를 사용하는 것을 추천한다.   ▪ ApiProvider      아직 Redux Store가 없는 경우 사용할 수 있다.   ▪ setupListeners()      refetOnMount와 refetchOnReconnect를 위해 사용되는 유틸리티   📄 타입스크립트와 RDK 시작하기   ▪ Redux Toolkit 초기 설정   💾 app/store.ts   import { configureStore, ThunkAction, Action } from \"@reduxjs/toolkit\"; import counterReducer from \"../features/counter/counterSlice\";  export const store = configureStore({   reducer: {     counter: counterReducer,   }, });  export type AppDispatch = typeof store.dispatch; // 타입 에러를 막기 위해 스토어 설정 파일에서 직접 내보내고다른 파일로 직접가져오는 것이 안전하다. export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppThunk&lt;ReturnType = void&gt; = ThunkAction&lt;   ReturnType,   RootState,   unknown,   Action&lt;string&gt; &gt;;   💾 app/hooks.ts   사용하는 훅들의 타입을 지정해야 합니다. RootState와 AppDispatch의 타입은 각각 컴포넌트에서 import해서 사용하는 것이 가능하지만,   useDispatch와 useSelector는 타입이 지정된 훅으로 사용하는 것이 더 좋습니다.      useSelector의 경우, 매번 (state: RootState)의 타입을 지정해줄 필요가 없습니다.   useDispatch의 경우, 기본 Dispatch는 thunk를 알지못해서 thunk middleware 타입이 포함된 스토어에서 커스터마이징된 AppDispatch 타입을 사용해야합니다. useDispatch를 추가하면 필요할때 AppDispatch를 가져올 수 있습니다.   이 훅들은 타입이 아니라 변수이기 때문에 store 파일이 아니라 hooks파일에 지정해야한다. 이렇게 hooks파일에 지정해서 필요할때 마다 component파일에서 import해올 수 있다.   import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\"; import type { RootState, AppDispatch } from \"./store\";  // Use throughout your app instead of plain `useDispatch` and `useSelector` export const useAppDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;(); export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;   📄 Application 사용   ▪ Slice State와 Action Types   각각 slice 파일은 초기 state value에 대한 타입을 지정해서 createSlice가 각각 리듀서의 state에 대한 타입을 추론할 수 있습니다.   initial state type을 미리 지정하고 initial state 객체를 생성합니다.   // slice state 타입 정의 export interface CounterState {   value: number;   status: \"idle\" | \"loading\" | \"failed\"; }  // initial state 객체 생성 const initialState: CounterState = {   value: 0,   status: \"idle\", };   ▪ createSlice로 slice 생성   createSlice는 name, initialState, reducers가 있습니다.      name: action앞에 붙어 다른 slice의 action들과 중복을 피한다.   initialState: 미리 생성한 initialState가 들어있다.   reducer: reducer는 action 역할을 하고 state의 변화를 담당한다. immer.js를 내장하고 있어 state값을 자동으로 return한다.   const counterSlice = createSlice({   name: \"counter\",   initialState,   reducers: {     increment: (state) =&gt; {       state.value += 1;     },     decrement: (state) =&gt; {       state.value -= 1;     },     incrementByValue: (state, action: PayloadAction&lt;number&gt;) =&gt; {       state.value += action.payload;     },   }, });   ▪ export   slice 내의 actions과 reducer를 export합니다.   // export actions export const { increment, decrement, incrementByValue } = counterSlice.actions; // export default slice.reducer export default counterSlice.reducer;   ▪ Store 생성   store에는 state와 dispatch할 함수들이 들어있습니다.   타입스크립트를 사용하고 있다면 각각 state와 dispatch의 타입을 지정해 주어야 한다.      store 생성 명령어: configureStore   import { configureStore } from \"@reduxjs/toolkit\"; import CounterReducer from \"../features/counter/counter\";  export const store = configureStore({   reducer: {     counter: CounterReducer,   }, });  // store와 dispatch의 타입 export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppDispatch = typeof store.dispatch;   ▪ Provider 생성   Provider은 store와 app을 연결해서 컴포넌트들이 store에 있는 state나 dispatch를 사용할 수 있게 합니다. 가장 상위 컴포넌트에 store를 연결하면 하위 컴포넌트에서도 store를 사용할 수 있습니다.   // index.tsx import { Provider } from \"react-redux\"; import { store } from \"./app/store\";  ReactDOM.render(   &lt;React.StrictMode&gt;     &lt;Provider store={store}&gt;       &lt;App /&gt;     &lt;/Provider&gt;   &lt;/React.StrictMode&gt;,   document.getElementById(\"root\") );   ▪ 컴포넌트 안에서 사용하기   import React, { useState } from \"react\"; import { useAppDispatch, useAppSelector } from \"../../app/hooks\";  import { increment, decrement, incrementByValue } from \"./counter\";  function CounterView() {   // 설정한 hook들을 적용   const count = useAppSelector((state) =&gt; state.counter.value);   const dispatch = useAppDispatch();   // useState로 num값 관리   const [num, setNum] = useState&lt;number&gt;(0);   const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {     setNum(parseInt(e.currentTarget.value));   };    return (     &lt;&gt;       &lt;div         style=       &gt;         // 버튼이 눌리면 import해온 함수들이 dispatch된다.         &lt;button onClick={() =&gt; dispatch(decrement())}&gt;-1&lt;/button&gt;         &lt;h1 style=&gt;{count}&lt;/h1&gt;         &lt;button onClick={() =&gt; dispatch(increment())}&gt;+1&lt;/button&gt;       &lt;/div&gt;        &lt;div&gt;         &lt;input type=\"number\" onChange={handleChange} /&gt;         &lt;button onClick={() =&gt; dispatch(incrementByValue(num))}&gt;+{num}&lt;/button&gt;       &lt;/div&gt;     &lt;/&gt;   ); } export default CounterView;   참고      Redux tookit 공식 페이지   doobaloper.log-Redux-Toolkit이란?  ","categories": ["React"],
        "tags": ["Redux toolkit","상태 관리"],
        "url": "/react/react-redux-toolkit/",
        "teaser": null
      },{
        "title": "JS 문자열을 HTML 개체로 변환",
        "excerpt":"📄 JS 문자열을 HTML 개체로 변환   자바스크립트에서 작성한 문자열을 innerHTML 속성을 이용해 HTML로 변환시켜 주는 방법입니다.   const stringToHTML = function (str) {   const dom = document.createElement(\"div\");   dom.innerHTML = str;   return dom; }; console.log(stringToHTML(`&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;p&gt;How are you today?&lt;/p&gt;`));   결과   &lt;div&gt;   &lt;h1&gt;Hello world&lt;/h1&gt;   &lt;p&gt;How are you today?&lt;/p&gt; &lt;/div&gt;      domcument에 div 엘리먼트를 추가한다.   새로 생성된 div 인스턴스는 dom과 연결된다.   dom의 경우 innerHTML 속성을 설정해서 HTML 개체로 변환한다.   return은 strinToHTML 함수에 대한 dom 인스턴스가 된다.   출처      DelftStack-JavaScript에서 문자열을 HTML로 변환  ","categories": ["JavaScript"],
        "tags": ["JavaScript","문자열","HTML"],
        "url": "/javascript/javascript-stringtohtaml/",
        "teaser": null
      },{
        "title": "배열 내장 함수",
        "excerpt":"📄 배열 내장함수   자바스크립트 배열에는 자체적으로 내장되어 있는 함수들이 있습니다.   이 함수들을 잘 활용한다면 코드가 더욱 간결해지고 가독성이 높아질 수 있습니다.   📄 forEach   forEach함수는 기존의 for문을 대체할 수 있습니다.   const array = [a, b, c, d];  superheroes.forEach((item) =&gt; {   console.log(item); });   forEach의 파라미터로 각 원소에 대하여 처리하고 싶은 코드를 함수로 넣어줍니다.   이렇게 주어진 함수를 배열 요소 각각에 대해 실행합니다.   📄 map   map은 배열 안의 각 원소를 변환할 때 사용하며,   결과 값이 담긴 새로운 배열을 생성합니다.     map 함수의 파라미터로는 변화를 주는 함수를 전달해줍니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((n) =&gt; n * n);   map을 사용하면서 index값을 얻고 싶다면 함수의 두번째 파라미터를 이용하면 됩니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((currentElement, index) =&gt; {   console.log(\"The current iteration is: \" + index); // 배열의 인덱스 값   console.log(\"The current element is: \" + currElement); // 배열의 현재 값 });   📄 IndexOf   IndexOf는 배열에서 원하는 항목이 몇번째 원소인지 찾아주는 함수입니다.   const superheroes = [\"아이언맨\", \"캡틴 아메리카\", \"토르\", \"닥터 스트레인지\"];  const index = superheroes.indexOf(\"토르\");   함수의 파라미터로 원하는 값을 넣어주면 몇번째 함수인지 반환합니다.   📄 findIndex &amp; find   만약 찾고자 하는 배열안의 값이 숫자나 문자열이라면 indexOf를 사용하지만   배열안의 값이 객체이거나 배열인 경우에는 사용할 수 없습니다.   그럴경우 사용하는 함수가 findIndex와 find입니다.   findIndex함수를 사용하고자 하면 함수에 검사하고자 하는 조건을 반환하는 함수를 넣습니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   }, ];  const index = todos.findIndex((todo) =&gt; todo.id === 3);      배열 todos에서 id가 3인 값의 index를 반환한다.    결과   `2`;   만약 Index아닌 객체나 배열의 값 전체를 반환하고자 하면 find함수를 사용합니다.   const index2 = todos.find((todo) =&gt; todo.id === 3);   결과   { id: 3, text: '객체와 배열 배우기', done: true }   📄 filter   filter함수는 특정조건을 만족하는 원소를 찾아서 그 원소들을 새로운 배열로 만듭니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   },   {     id: 4,     text: \"배열 내장함수 배우기\",     done: false,   }, ];  const tasksNotDone = todos.filter((todo) =&gt; todo.done === false); console.log(tasksNotDone);   결과   [{ id: 4, text: \"배열 내장함수 배우기\", done: false }];   📄 splice &amp; slice   splice함수 사용법   const spliced = 배열.splice(index number, n);      index number인 원소부터 n개를 지우겠다.    slice함수 사용법   slice메소드는 배열에서 특정 범위를 잘라내 새로운 배열로 반환합니다.   const sliced = 배열.slice(start, end);  let nums = [0, 1, 2, 3, 4, 5, 6, 7]; nums.slice(2, 4);  // nums = [2, 3]   slice 메소드의 두번째 인자는 새로운 배열의 범위에 포함되지 않습니다.   공통점   두 함수 모두 배열을 잘라낼 때 사용합니다.   차이점   splice로 배열을 잘라내면 기존배열이 그대로 잘리지만, slice로 배열을 잘라내면 기존배열이 유지됩니다.   📄 shift &amp; unshift      shift: 배열의 첫번째 원소를 추출합니다.   unshift: 배열의 맨 앞에 원소를 추가합니다.   const value = numbers.shift(); // value라는 값에 배열 numbers의 첫번째 원소 할당. numbers.unshift(5); // 배열 numbers의 마지막 자리에 원소 5 추가.   📄 push &amp; pop      push: 배열의 마지막 원소를 추가합니다.   pop: 배열의 마지막 자리에 있는 원소를 추출합니다.   numbers.push(50); // numbers라는 배열에 값 50 추가 const value = numbers.pop(); // value에 numbers의 마지막 원소 할당   📄 reduce   reduce함수는 배열의 각 요소에 대해 주어진 리듀서 함수를 실행합니다.   배열안의 각 요소를 순회하며 callback함수의 실행 값을 누적하여 하나의 결과값을 반환합니다.   arr.reduce(callback, initialValue);   callback함수는 4개의 파라미터 값을 받습니다.      누산기 (acc): 콜백의 반환값을 누적합니다.   현재 값(cur): 처리할 현재 요소   현재 인덱스(idx): 처리할 현재 요소의 인덱스   원본 배열(src): reduce()를 호출한 배열   const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((acc, cur, idx) =&gt; {   return (acc += cur); }, 0); // 0은 초기값 console.log(result); // 15   출처           패스트캠퍼스 프론트엔드 강의            MDN      ","categories": ["JavaScript"],
        "tags": ["JavaScript","forEach","map","IndexOf","findIndex","filter","splice","slice","shift","push","pop","reduce"],
        "url": "/javascript/javascript-arrayfunction/",
        "teaser": null
      },{
        "title": "[WEB] 이벤트 버블링 (Event Bubbling), 이벤트 캡쳐 (Event Capture), 이벤트 위임 (Event Delegation)",
        "excerpt":"📄 이벤트 버블링 (Event Bubbling)   이벤트 버블링은 특정 요소에서 이벤트가 발생했을 때, 해당 이벤트가 더 상위 요소로 전달되는 과정입니다.   브라우저는 특정 요소에서 이벤트가 발생했을 때 그 이벤트를 최상위에 있는 요소까지 전파합니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;   // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   three two one   📄 이벤트 캡처 (Event Capture)   이벤트 캡쳐는 이벤트 버블링과 반대로 진행되는 이벤트 전달 과정입니다.   이벤트 캡처는 이벤트 버블링과 반대로 상위요소에서 하위요소로 이벤트 전달 과정이 진행됩니다.   &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;   var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   one two three   addEventListener의 세번째 파라미터로 capture: true를 설정해주면 이벤트 캡처가 진행되어 가장 상위 요소에 적용된 이벤트가 먼저 발생합니다.   📄 이벤트 진행을 막고싶을 때는 어떻게 할까?   이벤트 버블링이나 이벤트 캡처를 구현할때 적용한 모든 요소에 이벤트를 실행하지 않고 중간에 멈추기 위한 속성이 있습니다.   event.stopPropagation()을 사용하면 이벤트의 진행과정을 중단시킬 수 있다.   // 이벤트 버블링 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // three }  // 이벤트 캡쳐 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // one }   📄 이벤트 위임 (Event Delegation)   이벤트 위임은 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식입니다.   &lt;h1&gt;오늘의 할 일&lt;/h1&gt; &lt;ul class=\"itemList\"&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item1\" /&gt;     &lt;label for=\"item1\"&gt;이벤트 버블링 학습&lt;/label&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item2\" /&gt;     &lt;label for=\"item2\"&gt;이벤트 캡쳐 학습&lt;/label&gt;   &lt;/li&gt; &lt;/ul&gt;   // 새 리스트 아이템을 추가하는 코드 var itemList = document.querySelector(\".itemList\");  var li = document.createElement(\"li\"); var input = document.createElement(\"input\"); var label = document.createElement(\"label\"); var labelText = document.createTextNode(\"이벤트 위임 학습\");  input.setAttribute(\"type\", \"checkbox\"); input.setAttribute(\"id\", \"item3\"); label.setAttribute(\"for\", \"item3\"); label.appendChild(labelText); li.appendChild(input); li.appendChild(label); itemList.appendChild(li);  var itemList = document.querySelector(\".itemList\"); itemList.addEventListener(\"click\", function (event) {   alert(\"clicked\"); });   아이템이 새로 추가될 때마다 이벤트를 새로 추가하지 않고 상위 요소인 .itemList에 이벤트를 달아줌으로써 하위요소에도 이벤트가 등록되게 할 수 있습니다.   출처      캡틴 판교-이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지  ","categories": ["WEB"],
        "tags": ["이벤트 버블링","이벤트 캡쳐","이벤트 위임","stopPropagation"],
        "url": "/web/web-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84/",
        "teaser": null
      },{
        "title": "Fetch",
        "excerpt":"📄 Fetch   : 원격 API를 호출할 수 있는 자바스크립트 내장 함수   📄 Fetch 사용법   Fetch함수는 두가지의 인자를 받습니다.      URL   옵션객체   인자를 받아 Promise객체를 반환합니다.   반환된 객체는 API호출이 성공했을 때 응답(response) 객체를 resolve하고 실패했을 때는 예외(error)객체를 reject합니다.   fetch(url, options)   .then((response) =&gt; response.json())   .catch((error) =&gt; console.log(\"error:\", error));      Response: HTTP 응답 전체를 나타내는 객체. JSON 본문 콘텐츠를 추출하기 위해서는 json()메서드를 호출해야 합니다.   📄 GET 호출: 데이터 불러오기   fetch함수의 기본적인 동작은 GET입니다.   fetch(\"https://jsonplaceholder.typicode.com/posts/1\").then((response) =&gt;   console.log(response) );   ✔ 결과   Response {status: 200, ok: true, redirected: false, type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts/1\", …}   응답(response) 객체는 json메서드를 제공합니다.   json()을 호출하면 응답 객체로부터 JSON 포멧의 응답을 자바스크립트 객체로 변환해서 얻을 수 있습니다.   // json()을 활용하여 응답객체를 자바스크립트 객체로 변환 fetch(\"https://jsonplaceholder.typicode.com/posts/1\")   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   {   \"userId\": 1,   \"id\": 1,   \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",   \"body\": \"quia et suscipit↵suscipit recusandae consequuntur …strum rerum est autem sunt rem eveniet architecto\" }   📄 POST 호출: 데이터 생성하기   POST는 원격 API에서 관리하고 있는 데이터를 생성할 때 사용합니다.      method 옵션을 POST로 지정한다.   headers옵션을 통해 JSON포멧을 사용한다고 알려준다.   요청 전문을 JSON 포멧으로 직렬화하여 body옵션에 설정해준다.   fetch(\"https://jsonplaceholder.typicode.com/posts\", {   method: \"POST\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), }).then((response) =&gt; console.log(response));   ✔ 결과: 응답코드가 201 Created   Response {type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts\", redirected: false, status: 201, ok: true, …}  // json메서드로 응답객체를 호출했을 때(response.json()) {title: \"Test\", body: \"I am testing!\", userId: 1, id: 101}   📄 PUT, DELETE: 데이터 수정, 삭제하기   PUT과 DELETE는 데이터를 수정하거나 데이터를 삭제할 때 사용됩니다.   // PUT fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"PUT\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과     {title: \"Test\", body: \"I am testing!\", userId: 1, id: 1}   DELETE는 보낼 데이터가 없어 header와 body옵션이 필요하지 않습니다.   // DELETE fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"DELETE\", })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   { }   📄 fetch 함수 커스텀화 하기   async function post(host, path, body, headers = {}) {   const url = `https://${host}/${path}`;   const options = {     method: \"POST\",     headers: {       \"Content-Type\": \"application/json\",       ...headers,     },     body: JSON.stringify(body),   };   const res = await fetch(url, options);   const data = await res.json();   if (res.ok) {     return data;   } else {     throw Error(data);   } }  post(\"jsonplaceholder.typicode.com\", \"posts\", {   title: \"Test\",   body: \"I am testing!\",   userId: 1, })   .then((data) =&gt; console.log(data))   .catch((error) =&gt; console.log(error));   출처      MDN-Fetch 사용하기   DaleSeo-fetch()함수로 원격 API호출하기  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Fetch"],
        "url": "/javascript/javascript-fetch/",
        "teaser": null
      },{
        "title": "getElementById 와 querySelector 비교",
        "excerpt":"📄 getElementById 와 querySelector 비교   getElementById와 querySelector의 공통점은 엘리먼트를 검색해서 반환한다는 것입니다.   하지만 둘의 사용법은 다르며 사용하는 상황에서 차이점을 드러냅니다.   📄 getElementById와 querySelector의 차이점   getElementById      id를 통해 엘리먼트를 반환한다.   만약 document에 해당 id가 없다면 null을 반환한다.   querySelector      selector의 구체적인 그룹과 일치하는 document의 첫번째 엘리먼트를 반환한다.   일치하는 요소가 없다면 null을 반환한다.   ✔ 예시   &lt;form id=\"userForm\"&gt;   &lt;input id=\"username\" type=\"text\" value=\"Guilherme\"&gt; &lt;/form&gt;   getElementById로 username을 가져올 때:   var username = document.getElementById(\"username\");   querySelector로 username을 가져올 때:   var username = document.querySelector(\"#userForm #username\");   =&gt; 결과는 같지만 querySelector로 가져올 때 더 구체적이고 한정적이다.   📄 querySelectorAll vs selectElementByClassName   하나가 아니라 여러개의 요소를 하나의 이름으로 한번에 얻고 싶을 때 사용하는 방법이다.   ✔ 예시   &lt;form id=\"productForm\"&gt;   &lt;input id=\"productOne\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productTwo\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productThree\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt; &lt;/form&gt;   getElementByClassName으로 가져올 때: HTMLCollection에 리턴   var products = document.getElementByClassName(\"product\");   querySelectorAll로 가져올 때: NodeList에 리턴   var products = document.querySelectorAll(\"#productForm .product\");   둘다 인덱스를 제공해 인덱스 번호로 접근이 가능하지만, HTMLCollection항목은 name과 id속성으로도 접근할 수 있다.     엘리먼트에 접근할 때 방법이 두가지가 있어 어떤 상황에 어느 것을 사용하는지 궁금해서 정리를 시작했다.   구체적으로 엘리먼트를 선택하고 싶다면 querySelector를,   좀더 빠른 성능으로 접근하고 싶다면 getElementById를 사용하는 것이 좋다.   출처   *guinatal.github - qeurySelector vs getElementById  ","categories": ["JavaScript"],
        "tags": ["JavaScript","getElementById","querySelector"],
        "url": "/javascript/javascript-getElementById&querySelector/",
        "teaser": null
      },{
        "title": "JSON (JavaScript Object Notation)",
        "excerpt":"📄 JSON (JavaScript Object Notation)   : 데이터를 쉽게 교환하고 저장하기 위한 텍스트기반의 데이터 교환 표준   텍스트 기반이다 ❔   어떤 프로그래밍 언어에서도 JSON 데이터를 읽고 사용할 수 있다 ❕   즉, 데이터를 교환할때 어떤 프로그래밍언어도 쓸 수 있는 방법이다.   📄 JSON과 XML   XML(EXtensible Markup Language)은 문자기반의 마크업 언어로 데이터를 보여주는 것이 아닌 저장하고 전달하는 것 만을 목적으로 만들어졌다.   공통점      둘다 데이터를 저장하고 전달하기 위해 만들어졌다.   사람도 읽을 수 있다.   계층적인 데이터구조를 가진다.   다양한 프로그래밍 언어에 의해 파싱될 수 있다.   XMLHttpRequest 객체를 이용하여 서버로부터 데이터를 전송받을 수 있다.   차이점      JSON은 종료 태그를 사용하지 않는다.   JSON의 구문이 XML의 구문보다 짧다.   JSON 데이터가 XML 데이터보다 더 빨리 읽고 쓸 수 있다.   XML은 배열을 사용할 수 없지만, JSON은 배열을 사용할 수 있다.   XML은 XML 파서로 파싱되고, JSON은 자바스크립트 표준함수인 eval()함수로 파싱된다.   // XML 예제 &lt;dog&gt;     &lt;name&gt;식빵&lt;/name&gt;     &lt;family&gt;웰시코기&lt;family&gt;     &lt;age&gt;1&lt;/age&gt;     &lt;weight&gt;2.14&lt;/weight&gt; &lt;/dog&gt;  // JSON 예제 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }   JSON은 XML보다 더 빠른 처리속도를 가지고 있지만 전송받은 데이터의 무결성을 직접 인증해야하는 특징을 가지고 있다.   📄 JSON 문법   JSON은 객체 표기법 중 리터럴(literal)과 프로퍼티(property)를 표현하는 방법을 쓴다.      리터럴: 변수가 아닌 해석되는 값 자체 ex) 12(숫자 리터럴), “JSON”(문자열 리터럴), true(불리언 리터럴)   객체: 이름(name)과 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합   // 네쌍의 프로퍼티로 구성된 객체 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }      JSON에서 주석을 사용하는것은 권장하지 않는다.   undefined 와 null   JSON에서는 undefined타입을 제공하지 않는다. 자바스크립트와 다르게 JSON에서 null은 값을 가지고 있지 않다는 의미를 가지는 하나의 데이터값을 가지고 있기 때문에 유의해서 사용해야 한다.   📄 자바스크립트와 JSON   자바스크립트에서 JSON을 사용하기 위해 3가지의 메소드를 제공한다.      JSON.stringify(): 인수로 전달받은 자바스크립트 객체를 문자열로 변환   JSON.parse(text): 인수로 받은 문자열을 자바스크립트 객체로 변환   toJSON: 자바스크립트의 Date 객체의 데이터를 JSON 형식의 문자열로 변환. Date.prototype 객체에서만 사용할 수 있다.   // toJSON 예제 var date = new Date(); // 자바스크립트 Date 객체  var str = date.toJSON(); // Date 객체를 JSON 형식의 문자열로 변환함.  document.getElementById(\"json\").innerHTML = date + \"&lt;br&gt;\";  document.getElementById(\"json\").innerHTML += str;   출처      TCP SCHOOL.com-JSON  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Json"],
        "url": "/javascript/javascript-json/",
        "teaser": null
      },{
        "title": "디바운싱(Debouncing)",
        "excerpt":"📄 디바운싱(debouncing)      이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술   연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것   디바운싱 기술는 검색 기능을 구현하는 경우에 가장 많이 사용됩니다.   이런 경우에는   j ja jav java   처럼 키워드 하나하나 인식해서 키워드 하나에 매번 이벤트가 발생하게 됩니다.   이렇게 처리해야하는 일이 여러번의 요청이 있을때 최종(혹은 처음) 요청의 처리결과만 내놓게 하는게 디바운싱입니다.   var timer; document.querySelector(\"#input\").addEventListener(\"input\", function (e) {   if (timer) {     clearTimeout(timer);   }   timer = setTimeout(function () {     console.log(\"여기에 ajax 요청\", e.target.value);   }, 200); });      타자를 칠 때(input 이벤트 발생)마다 타이머를 설정한다.   200ms동안 입력이 없으면 입력이 끝난 것으로 한다. (시간 자유 설정 가능)   200ms 이전에 타자 입력이 발생하면 이전 타이머는 취소하고 새로운 타이머를 다시 설정한다.   출처      제로초-쓰로틀링과 디바운싱  ","categories": ["JavaScript"],
        "tags": ["JavaScript","디바운싱"],
        "url": "/javascript/javascript-debouncing/",
        "teaser": null
      },{
        "title": "배열 중복 요소 없애기 (Set)",
        "excerpt":"📄 Set   배열을 다룰때 Set함수를 사용하면 중복된 요소를 없애고 값을 한번만 보여줍니다.   Set은 객체로 다루어지지만 배열의 타입이 Object이기 때문에 사용할 수 있습니다.   📄 Set 사용하기   var mySet = new Set();   mySet은 중복된 요소가 있으면 하나만 남기고 사라집니다.   mySet.add(1); // Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add(\"some text\"); // Set { 1, 5, 'some text' }   5를 두번 추가했지만 한개만 남습니다.   this.setHistoryData = (histData) =&gt; {   const avoidDulpli = [...new Set([histData, ...this.state.historyList])];   if (avoidDulpli.length &gt; 5) {     avoidDulpli.pop();   }   this.setState({     ...this.state,     historyList: avoidDulpli,   }); };   구현하던 프로젝트에서 검색기록을 내는 코드입니다.   검색한 데이터(histData)를 받아서 새로운 배열 avoidDulpli를 만들고,   new Set을 이용해 중복된 값은 제거되는 새로운 배열을 만들어 받아온 데이터(histData)가 앞에 추가됩니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Set"],
        "url": "/javascript/javasrcipt-arraySet/",
        "teaser": null
      },{
        "title": "이미지 랜덤 배치",
        "excerpt":"📄 이미지 랜덤 배치하기   목표: Vanila JavaScript로 새로고침 될 때마다 이미지가 특정 범위에 랜덤으로 배치된다.   원하는 범위의 위치를 받아와서 이미지의 left와 right 값을 지정해주자!    📄 1. 원하는 feild의 위치를 파악한다.   const fieldRect = field.getBoundingClientRect(); function initGame() {   console.log(fieldRect); }   getBoundingClientRect를 이용해 출력하면 지정한 요소의 위치를 콘솔창에서 확인할 수 있다.   📄 2. feild에 추가하기 전에 이미지를 생성하는 함수를 만들어준다.   // 랜덤으로 숫자를 생성하는 함수 function randomNumber(min, max) {   return Math.random() * (max - min) + min; }  // 아이템을 생성하는 함수 function addItem(className, count, imgPath) {   const x1 = 0;   const y1 = 0;   // 이미지가 feild에서 벗어나는 것을 막기 위해 최댓값을 조정한다.   const x2 = fieldRect.width - CARROT_SIZE;   const y2 = fieldRect.height - CARROT_SIZE;    for (let i = 0; i &lt; count; i++) {     const item = document.createElement(\"img\"); // 이미지 추가!     item.setAttribute(\"class\", className); // 이미지에 클래스 속성추가!     item.setAttribute(\"src\", imgPath); // 이미지 경로 추가!     item.style.position = \"absolute\"; // feild에 상대적으로 오프셋 적용     const x = randomNumber(x1, x2); // 최솟값 x1와 최댓값 x2 사이에서 랜덤으로 숫자를 받아 상수 x에 할당!     const y = randomNumber(y1, y2); // 최솟값 y1와 최댓값 y2 사이에서 랜덤으로 숫자를 받아 상수 y에 할당!     item.style.left = `${x}px`; // 추가한 이미지의 left값에 x값 할당!     item.style.top = `${y}px`; // 추가한 이미지의 top에 y값 할당!     field.appendChild(item); // field에 해당 이미지를 추가   } }   📄 3. addItem함수에 값을 지정한다.   function initGame() {   addItem(\"carrot\", 5, \"carrot.png\"); // 당근 이미지 5개!   addItem(\"bug\", 5, \"bug.png\"); // 벌레 이미지 5개! }   결과      새로고침할 때 마다 당근 5개와 벌레 5개가 배치된다.   느낀점   강의 전혀 안보고 하려고 했는데 실패했다~   이미지를 랜덤으로 배치하는 함수가 따로 있는 줄 알았다.  모든게 함수나 API로 있진 않나보다.  구글링할때 많은 사람들이 제이쿼리를 쓰는 것을 보았다.  생각보다 바닐라로 구현하는 내용은 보지 못했다.  코드를 혼자서 완성시키는 것은 지금 당장 해내지 못할지라도 강의에서 보여주는 코드를 완벽하게 이해하고 넘어가서 다음에 사용하는 경우가 생긴다면 그때는 꼭 적용시켜서 스스로 해낼 것이다.    출처      드림코딩  ","categories": ["JavaScript"],
        "tags": ["JavaScript"],
        "url": "/javascript/js-image-random/",
        "teaser": null
      },{
        "title": "async 함수로 데이터 fetch하기",
        "excerpt":"📄 async 함수로 데이터 fetch하기   서버로부터 데이터를 fetch해오는 방법은 여러가지가 있다. 보통 promise를 사용하거나 async await문을 사용한다.   📄 Promise를 통한 비동기 코딩의 문제점   1. 디버깅   function fetchAuthorName(postId) {   return fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)     .then((response) =&gt; response.json())     .then((post) =&gt; post.userId)     .then((userId) =&gt; {       return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)         .then((response) =&gt; response.json())         .then((user) =&gt; user1.name); // 의도한 Error     }); }  fetchAuthorName(1).then((name) =&gt; console.log(\"name:\", name));   ✔ 결과   ReferenceError: user1 is not defined     at fetch.then.then.then.then.then (&lt;anonymous&gt;:7:29)   동일한 이름의 메소드인 여러개의 then()중에서 정확히 어디서 에러가 발생했는지 에러 메세지만 보고는 알 수 없다.   2. 예외처리   Promise를 사용하면 try/catch대신 catch()메서드만 사용하여 예외처리를 해야한다. 비동기, 동기 코드가 섞인 경우에는 예외 처리를 하는 과정이 복잡해질 수 있다.   3. 들여쓰기   실제 프로젝트에서 비동기 처리 코드는 길고 복잡하기 마련인데, 무한 then() 메서드에 빠지게 되면 코드의 가독성이 매우 떨어진다.   📄 aync/await를 통해 데이터 fetch해오기   async/await를 사용하면 Promise가 가진 문제점들을 해결해 줄 수 있다.   Promise 사용했을 때:   fetch(`https://api.idiots.band/api/search?keyword=${e.target.value}`)   .then((x) =&gt; x.json())   .then((data) =&gt; {     console.log(JSON.stringify(data, null, 2));   });   async-await 사용했을 때:   onSearchBand: async (inputValue) =&gt; {   const postResponse = await fetch(     `https://api.idiots.band/api/search?keyword=${inputValue}`   );   const post = await postResponse.json();   this.setState(post); };      fetch함수를 사용하는 함수를 aysnc 함수로 만들어준다.   fetch함수에 await를 걸어준다.   await로 가져온 데이터는 .json()을 호출해서 한번 더 await를 걸어준다.   예외처리 하기 주의사항   export const getSearchData = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const postResponse = await fetch(url);   if (postResponse.ok) {     const data = await postResponse.json();     return data;   } else {     throw new Error(data);   } };   이 코드는 에러는 나지 않지만 성능이 떨어진다.      async 함수는 모두 Promise를 리턴한다.   reponse.ok인 경우도 Promise가 리턴된다.   하지만 throw new Error(data)를 선언한다면 async 함수는 Promise&lt;Response&gt; | Promise&lt;void&gt;로 타입이 잡히게 된다.   따라서 reponse.ok를 선언했다면 예외처리를 할 경우도 Promise를 반환하게 하는 것이 바람직하다.   // 바람직한 코드  export const getSearchBand = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const response = await fetch(url);   if (response.ok) {     return response.json();   }   return Promise.reject(new Error(\"API 요청에 실패 했습니다.\")); };   출처      DaleSeo - 비동기 처리 3부 async/await  ","categories": ["JavaScript"],
        "tags": ["JavaScript","async"],
        "url": "/javascript/javascript-datafetchByAsync/",
        "teaser": null
      },{
        "title": "🚨 Type 'KeyboardEvent' is not generic.",
        "excerpt":"🚨 에러 발생   KeyboardEvent를 쓰려고 했는데 에러가 발생했다.   const onPressEnter = useCallback(   async (e: KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {     // Error. Type 'KeyboardEvent' is not generic.ts     if (e.key === \"Enter\" &amp;&amp; !isUserValidation) {       await onClickSignIn();     }   },   [isUserValidation] );   앞에 React.를 붙이면 해결 됐지만, 다른 이벤트를 쓸 때는 평소처럼 그냥 쓰여서 궁금해서 찾아봤다.   ❔ 에러 원인   사용하고 있던 이벤트가 React가 아닌 DOM에서 가져와서 생긴 에러였다. 코드의 import을 봤더니 KeyboardEvent만 빠져있었다.   import { ChangeEvent, useMemo, useState } from \"react\";   🔨 에러 해결   KeyboardEvent를 React에서 impot해올 수 있도록 변경해주었다.   import { ChangeEvent, KeyboardEvent, useMemo, useState } from \"react\";   참고      stack overflow-Why is the MouseEvent in the checkbox event handler not generic?  ","categories": ["TypeScript"],
        "tags": ["에러","React","TypeScript"],
        "url": "/typescript/typescript-Type-'KeyboardEvent'-is-not-generic.ts/",
        "teaser": null
      },{
        "title": "변수(variable)와 상수(constant)",
        "excerpt":"📄 선언이란?   특정 이름에 특정 값을 담는 것을 선언이라고 합니다.   선언을 하는 방식에는 두가지가 있습니다.   하나는 변수이고 다른 하나는 상수입니다.   📄 변수   변수에는 고정된 값이 아닌 바뀔 수 있는 값을 담습니다.   let이라는 키워드를 사용하여 변수를 선언합니다.   let value = 1;      value라는 변수를 선언하고, 1이라는 값을 담았다.    📄 상수   상수는 변수와 다르게 고정된 값을 가집니다.   상수를 선언할 때는 const라는 키워드를 사용합니다.   const a = 1; a = 2;   상수는 고정된 값을 담기 때문에 위와 같은 코드에는 오류가 발생합니다.   한번 선언되어 1이라는 값을 가지고 있는 상수 a에 다른 값을 다시 넣었기 때문입니다.    주의할 점   상수 객체는 수정될 수 있습니다.   const user = {   name: \"John\", };  user.name = \"Pete\";  console.log(user.name);      ```js Pete; ```  `const`는 `user`의 값을 고정하지만, 그 내용은 고정하지 않습니다.  `const`는 `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생합니다.  ## 📄 왜 변수와 상수를 사용할까?  복잡한 식을 컴퓨터가 매번 읽어낸다면 프로그래밍의 효율성이 떨어집니다.  변수와 상수에 값을 담아두면 컴퓨터가 매번 똑같은 일을 반복하지 않고 코드도 간결해집니다.  ```js const sum = 5 + 10;  if (sum % 3 === 0) {   console.log(\"야호\"); } ```  이렇게 값을 변수나 상수에 지정하면 컴퓨터가 5 + 10을 매번 계산하지 않고 코드를 실행할 수 있습니다.  ## 📄 변수 명명 규칙  - 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다. - 첫 글자는 숫자가 될 수 없습니다. - 대·소문자는 구별됩니다. `a`와 `A`는 다릅니다. - 비 라틴계 언어도 변수명에 사용할 수 있지만 권장하지 않습니다. - 예약어는 사용하지 않습니다. - 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하는 카멜표기법이 흔히 사용됩니다. - `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용합니다. - 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 a, b, c와 같은 짧은 이름은 피해야 합니다. - 최대한 서술적이고 간결하게 명명해 주세요. data와 value는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합니다. - 자신만의 규칙이나 소속된 팀의 규칙을 따릅니다. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 currentVisitor나 newManInTown이 아닌 currentUser나 newUser라는 이름으로 지어야 합니다. - 변수명은 클래스명과 관련지으면 좋습니다.  ## 출처  - 패스트캠퍼스 프론트엔드 강의  * [모던 자바스크립트 튜토리얼](https://ko.javascript.info/object)  ","categories": ["JavaScript"],
        "tags": ["JavaScript","변수","상수"],
        "url": "/javascript/javascript-variableConstant/",
        "teaser": null
      },{
        "title": "github-actions-tutorial",
        "excerpt":"📄 CI/CD   : 어플리케이션 개발 단계부터 배포때까지 모든 단계를 자동화하는 과정   🎲 Point (큰 틀로 먼저 생각하기)      CI - 새로운 변경 사항 머지, 빌드, 테스트 자동화        CD - 배포 자동화 (with AWS S3)       github actions: 자동화를 가능하게 해주는 하나의 가상 컴퓨터   ▪ CI (Continuos Integration) - 지속적인 통합   : 새로운 코드의 변경 사항이 빌드 및 테스트 되어 공유 레포지토리에 지속적으로(=자동적으로)통합되는 것           코드 변경사항을 주기적으로 빈번하게 머지해야 한다. = 작은 단위로 나누어 머지를 진행한다.            CI를 위해 작성된 스크립트를 통해 테스트의 과정이 자동으로 진행된다.       ▪ CD (Continuous Delivery(or Deployment)) - 지속적인 제공(or 배포)         Continuous Delivery는 개발환경 배포까지 자동화,   Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미   CD는 개발자의 변경 사항이 레포지토리를 넘어, 고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미합니다.   CI/CD를 위해 플랫폼을 사용하는데 설치형과 클라우드형이 있다.   대표적인 설치형 플랫폼은 Jenkins, 클라우드형 CI/CD 플랫폼은 Github Actions가 있다.      클라우드 서비스? 타사 제공업체가 호스팅하여 인터넷을 통해 사용자에게 제공하는 인프라, 플랫폼 또는 소프트웨어    ▪ 왜 CI/CD를 구축할까? (CI/CD의 장점)      개발 생산성을 향상 시켜준다.   문제점을 빠르게 발견할 수 있다.        발견된 버그를 빠르게 수정 또한 가능하다.       코드의 퀄리티 향상 &gt; 코드의 유닛 테스트가 가능하기 때문     📄 What is Github Actions !   : Github에서 제공하는 클라우드형 CI/CD 툴   🎲 Point (사용 이유를 명확히 이해하기)      CI/CD 자동화 파이프라인을 구축하기 위해서 사용한다.   자동화를 위해 github 에서 제공하는 하나의 가상 컴퓨터   ▪ 장점      툴(ex. Jekins)을 따로 설치하지 않고 Repository에서 관리   쉬운 설정   ▪ 알아야 할 개념 5가지      name: CI/CD  on:   push: // push event     branches:       - main    pull_request: // pr event     branches:       - main   workflow_dispatch: // github actions 페이지에서 workflow를 실행할 수 있는 기능을 추가하는 이벤트  jobs:   helloWorld:     runs-on: ubuntu-latest // runner     steps:       - run: echo HelloWorld       - uses: actions/checkout@master           Workflows              특정한 이벤트가 발생했을 때 어떤 일을 수행하는 지 알려주는 자동화된 프로세스       여러 Job으로 구성                Events              github에서 발생할 수 있는 이벤트(main 브랜치로 머지, 커밋을 푸쉬)                Jobs                       하나의 Runner에서 실행될 여러 step 모음, workflow의 job들은 동시에 실행(병렬로 실행), step은 순차적으로 실행               여러 step으로 구성되어 있음.       다른 Job에 의존할 수 있고, 독립적 또는 병렬적으로 실행 가능.                Actions              github workflow 라이브러리       남들이 만들어둔 일련의 step들을 가져다 씀.       use 키워드를 사용  marketplace에 설정된 actions가 많음. 가져다쓰면 된다.  직접 코드 수정시에도 확인가능                Runners              내가 직접 Job을 실행시킬 필요 없이 Job을 실행시키는 VM 머신(가상 컴퓨터)                workflow dispatch        📄 GitHub Actions으로 CI 파이프라인 구축하기   CRA에는 별도의 test 기능이 있기 때문에 jest와 같은 테스트 라이브러리를 설치할 필요가 없다.      App.js   import \"./App.css\";  function App() {   return &lt;h1&gt;Hello, World&lt;/h1&gt;; }  export default App;      App.test.js (테스트코드 예시)   import { render, screen } from \"@testing-library/react\"; import App from \"./App\";  test(\"renders learn react link\", () =&gt; {   render(&lt;App /&gt;); // App.js가 렌더링 되는지 확인    // h1 태그를 가지고 있는지 테스트   const heading = screen.getByRole(\"heading\");   expect(heading).toBeInTheDocument();    // App.js가 Hello, Deploy라는 글자를 가지고 있는지 테스트   expect(heading.textContent).toBe(\"Hello, Deploy\"); });      CICD.yml 프로젝트 경로에 .github\\workflows라는 폴더를 만들어 yml파일을 생성한다.   name: CI/CD  on:   push:     branches:       - main    pull_request:     branches:       - main   workflow_dispatch:  jobs:   helloWorld:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@master       - run: npm ci // clean install의 약자, npm package를 설치한다.       - run: npm run test       - run: echo SUCCESS   ✔ 잘못된 코드로 테스트 자동화 확인해보기   Hello deploy를 Hello World으로 바꾸어 테스트.   import \"./App.css\";  function App() {   return &lt;h1&gt;Hello, World&lt;/h1&gt;; }  export default App;      어느 부분에서 test를 통과하지 못했는지 확인할 수 있다.   ▪ 정상 코드로 테스트 자동화 실행하기      모든 step이 작동한 것을 확인할 수 있다.   ▪ PR할 때 제대로 test 되는지 확인해보기      코드를 작성할 브랜치(break-tests)생성        push후 pr 생성        바로 test결과를 알 수 있다. Detail을 클릭하면 action으로 넘어가 해당 work flow에서 어디가 잘못되었는지 확인 할 수 있다.        PR목록에서도 확인 가능하다.        테스트시 문제가 없으면 초록 뱃지가 뜨는 것을 확인 할 수 있다.       📌 참고. github 페이지에서 workflow 생성하기       CI/CD를 적용할 프로젝트의 action 탭에서 node.js 템플릿을 선택한다.    기본적인 템플릿에서 각자 상황에 맞게 수정한다.    📄 github actions를 사용해 CD 파이프라인 만들기 (with AWS S3)      AWS: 아마존에서 만든 클라우드 서비스   AWS S3: AWS에서 제공하는 인터넷 스토리지 서비스 like vercel   1. AWS에서 회원가입 후 버킷(= 저장소) 만들기      AWS 리전: 어디에 있는 컴퓨터를 빌려 쓰는가?   객체 소유권 - ACL 비활성화 (권장)     :star: 중요. 퍼블릭 엑세스 차단 해제 &gt; 우리가 만드는 웹에 모두가 접근하게 하기 위해서   주의(빨간 세모)박스에는 체크.   버킷 버전 관리 - 비활성화 체크   기본 암호화 - 비활성화 체크   버킷 만들기      2. 프로젝트 build 실행하고 버킷에 파일 업로드하기      프로젝트 build 폴더에 있는 파일을 업로드 합니다.         속성탭에서 정적 웹 사이트 호스팅을 활성화 합니다.            정적 웹 페이지: Client Side Rendering방식으로 진행되는 웹 페이지 (이미 저장된 html 문서를 클라이언트에게 전송)       동적 웹 페이지: Server Side Rendering방식으로 진행되는 웹 페이지 (사용자의 요청 정보를 처리한 후에 제작된 HTML문서를 클라이언트에게 전송)       따라서 AWS S3 기능으로는 Next.js로 만든 웹 페이지를 호스팅할 수 없음. AWS EC2라는 기능이 있다고 함.                인덱스 문서 - 특정한 웹사이트로 버킷에 접속하면 처음으로 보여줄 기본 페이지        호스팅을 활성화 하면 주소를 받습니다.       하지만 처음엔 403 Forbidden 에러가 발생합니다.       왜? 니가 누군지 아는데 닌 권한이 없다. 버킷안에 있는 객체에 접근할 권한이 없다.       차단 풀었는데 왜? 아까는 차단을 거는 것을 해제한것.       차단은 풀렸지만 권한은 따로 부여해주어야 한다.       권한을 부여하자       3. 웹페이지에 접근 권한을 부여한다.   권한 탭에 들어가서 버킷 정책으로 이동한다.      버킷 정책에서 엑세스 권한 설정이 가능하다. Json 파일로 제작   {   \"Version\": \"2012-10-17\", // 정책을 설정하는 aws문법의 마지막 업데이트   \"Statement\": [     {       \"Sid\": \"PublicReadGetObject\", // 사이드 아님. S아이디임. 고유한 ID.       \"Effect\": \"Allow\", // 권한을 허용할지 말아야할지       \"Principal\": \"*\", // 누구한테 권한을 허용할 것인지       \"Action\": \"s3:GetObject\", // 어떤 행동을 허락할 것인지       \"Resource\": \"arn:aws:s3:::&lt;bucket-name&gt;/*\" // 여러가지 버킷 또는 파일 중 권한을 허용할 리소스     }   ] }      버킷 정책에서 권한을 모두에게 허용하면, 403 forbidden error가 사라지고 잘 작동하는 것을 확인할 수 있습니다.   여기까지 aws에 파일을 올려서 한 수동적인 배포!   4. 터미널에서 AWS S3에 배포하고 github actions로 자동화하기!   자동화하기 위해 터미널에서 aws를 다룰 수 있도록 aws CLI를 설치한다. AWS 공식 DOC에서 AWS CLI를 설치한다. 설치 방법: Windows(OS) PC에 AWS CLI 설치하기      AWS CLI란? AWS Command Line Interface, 터미널에서 AWS 실행을 가능하게 해주는 오픈 소스 도구       유저탭을 클릭해 보안자격증명 페이지로 들어가 엑세스키 만들기 버튼을 클릭한다.    엑세스키 만들기 버튼을 눌러 단계를 진행하면 만들어진 엑세스키를 보여준다.      엑세스 키 = 사용자의 아이디   비밀 엑세스 키 = 사용자의 비밀번호 :star: 중요! 비밀 엑세스 키는 처음 만든 상황 이후에는 보이지 않으니 따로 저장해 두어야 한다.      터미널에서 aws configure --profile &lt;프로필 이름&gt;을 입력해 프로젝트 배포에 사용될 프로필을 설정한다.      Default region name: ap-northeast-2 // 서울      aws configure list-profiles명령어를 통해 생성된 프로필을 확인할 수 있다.         aws s3 sync build/ s3://&lt;aws 페이지에서 생성한 버킷 이름&gt; --delete --profile &lt;사용할 프로필 이름&gt;   aws 페이지에서 작성한 버킷의 객체를 모두 지우고 현재 루트에 있는 build파일을 모두 업로드 한다.      aws 페이지에서도 파일들이 업로드 된것을 확인할 수 있다. 프로젝트의 내용이 변경된 경우, build하고 다시 버킷에 파일을 업로드하면 변경된 내용을 확인할 수 있다.   5. 본격적으로 CD 파이프라인 구축하기   name: CI/CD  on:   push:     branches:       - main   workflow_dispatch:  jobs:   CICD:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@main       - run: npm ci       - run: npm run test       - run: echo SUCCESS       - run: npm run build       - name: deploy to s3          uses: jakejarvis/s3-sync-action@master // 이부분을 main으로 바꾸면 error발생          with:             args: --delete // 버킷에 있는 모든 객체 삭제          env: // 환경변수 세팅             AWS_S3_BUCKET: $             AWS_ACCESS_KEY_ID: $             AWS_SECRET_ACCESS_KEY: $             AWS_REGION: 'ap-northeast-2'             SOURCE_DIR: 'build'   엑세스 키 비밀번호를 숨기기 위해 깃헙에서 자체적으로 제공해주는 기능을 사용한다.    Settings&gt; secrets/Actions &gt; New repository secret 중요. 수정은 가능하지만 원래 저장했던 내용은 볼 수 없다.    환경변수는 생성했던 버킷 이름, ID, 비밀번호를 설정하면 된다.   main 브랜치에 push를 날리면    actions탭에서 CD가 성공적으로 구축된 것을 확인할 수 있다.   📄 팀원들과 토론할 점           develope 브랜치에 push &amp; pr할때 CI 작동            CD는 어느 이벤트에 작동하도록 설정해야 하는지?       출처           원티드 프리온보딩 프론트엔드 인턴십 강의            드림코딩 - CI/CD 5분 개념 정리       드림코딩 - 제발 깃허브 액션 모르는 개발자 없게 해주세요 :star: 정리 Good!        Github Actions 공식문서       CI/CD란 무엇인가   어쩐지 오늘은 - Github Action 사용법 정리 :star: 정리 Good!   DaleSeo - Jest로 기본적인 테스트 작성하기        Windows(OS) PC에 AWS CLI 설치하기       GitHub Docs - Understanding GitHub Actions  ","categories": ["Git"],
        "tags": ["github actions","CI","CD","스터디"],
        "url": "/git/git-github-actions-tutorial/",
        "teaser": "/assets%5Cimage%5Cgit%20logo.jpg"
      },{
        "title": "동적 임포트(Dynamic import)",
        "excerpt":"📄 동적 임포트(Dynamic import)   보통 코드의 최상단에서 import문을 사용해 클래스나 함수를 가져오는 것을 정적 import라고 합니다.   정적으로 모듈을 import한다면      import문에 동적 매개 변수를 사용할 수 없습니다. = 원시 문자열만 가능하기 때문에 함수 호출 결과값을 경로로 사용할 수 없습니다.   런타임이나 조건부로 모듈을 불러올 수 없습니다. = if문, 코드 블록에서 사용할 수 없습니다.   📄 동적으로 모듈 import 하는 방법   동적으로 모듈을 import한다면      프로미스 객체를 반환합니다. 프로미스 객체의 반환값은 불러온 모듈입니다.   코드의 위치에 관계없이 사용이 가능하기 때문에, 모듈들을 사용자가 필요로 할 때 불러올 수 있습니다.   import()를 호출하는 순간부터 로딩이 되기 때문에 성능을 향상시킬 수 있습니다.   import(\"./sum\").then((sum) =&gt; {   console.log(sum(1 + 2)); });  ","categories": ["JavaScript"],
        "tags": ["JavaScript","동적 임포트","import"],
        "url": "/javascript/javascript-dynamic-import/",
        "teaser": null
      },{
        "title": "[React] 리액트에서 컴포넌트 동적으로 불러오기 with React.lazy",
        "excerpt":"📄 React.lazy   React.lazy는 React에서 동적으로 컴포넌트 파일을 불러올 때 사용합니다.   규모가 큰 프로젝트의 경우 한 페이지에 수많은 컴포넌트를 import합니다.   정적으로 컴포넌트를 import한다면 첫 페이지를 로드하는 즉시 대규모 단일 Javascript번들이 사용자에게 전송됩니다.   따라서 동적으로 import하여 필요할때만 컴포넌트를 로드하는 작업을 할 수 있습니다.   📄 사용법   ▪ React.lazy()   const Home = lazy(() =&gt; import(\"./routes/Home\")); const About = lazy(() =&gt; import(\"./routes/About\"));      불러오는 파일은 React 컴포넌트를 포함해야 합니다.   default export를 가진 컴포넌트여야 합니다.   ▪ Suspense   const App = () =&gt; (   &lt;Router&gt;     &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;       &lt;Routes&gt;         &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;         &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;       &lt;/Routes&gt;     &lt;/Suspense&gt;   &lt;/Router&gt; );      fallback: 컴포넌트가 로드될 때까지 기다리는 동안 보여줄 React 엘리먼트입니다.   하나의 Suspense 컴포넌트가 여러개의 lazy컴포넌트를 감쌀 수 있습니다.      이를 시작하기 좋은 장소는 라우트입니다. 웹 페이지를 불러오는 시간은 페이지 전환에 어느 정도 발생하며 대부분 페이지를 한번에 렌더링하기 때문에 사용자가 페이지를 렌더링하는 동안 다른 요소와 상호작용하지 않습니다.    출처      리액트 공식문서 - 코드 분할  ","categories": ["React"],
        "tags": ["React.lazy"],
        "url": "/react/react-React.lazy/",
        "teaser": null
      },{
        "title": "[TodoList-Project] 클래스로 작성하는 로그인/회원가입 axios통신",
        "excerpt":"📑 axios통신 로직을 클래스로 작성한 이유   꽤 여러번 투두리스트를 만들어봤지지만 axios 통신 로직은 항상 함수로만 작성했다. 원티드에서 강의를 듣고 클래스에 대해 고민하게 되었다. 클래스는 객체 형태로 state를 저장할 수 있기 때문에 state를 가진 모듈이라면 클래스로 작성하는 것이 좋다고 한다. 로그인/회원가입을 구현하는 로직은 url과 token을 가지고 있기 때문에 클래스로 작성을 하기로 결정했다. 이번에 본격적으로 구글링을 하는 연습을 하기 위해서 영어로 된 문서도 적극적으로 참고했다.   📑 httpClient.ts | axios Client를 담당   import axios, { AxiosInstance, AxiosRequestConfig } from \"axios\"; import { getLocalStorageToken } from \"../store/localStorage\";  declare module \"axios\" {   type AxiosRequest&lt;T = unknown&gt; = Promise&lt;T&gt;; } // 0  abstract class HttpClient {   // 1   protected readonly instance: AxiosInstance;    public constructor(baseURL: string) {     // 2     this.instance = axios.create({       baseURL: BASE_URL,     });      this._initializeRequestInterceptor(); // 3   }    private _initializeRequestInterceptor = () =&gt; {     // 4     this.instance.interceptors.request.use(this._handleRequest);   };    private _handleRequest = (config: InternalAxiosRequestConfig) =&gt; {     const accessToken = getLocalStorageToken();     if (accessToken &amp;&amp; config.headers) {       config.headers.Authorization = `Bearer ${accessToken}`;     }     return config;   }; }  export default HttpClient;           타입스크립트를 사용하고 있기 때문에 AxiosRequest가 무슨일을 하는지 알려줘야 한다. 이렇게 하면 response를 순수 data로 사용할때 타입스크립트가 에러를 내지 않는다고 한다.            우선, HttpClient라는 추상 클래스를 만들어 instance를 생성할 수 없게 만들어주었다. instance를 생성할 클래스는 기능별로 따로 만들었기 때문이다.            axios-instance를 생성하는 constructor이다. constructor로부터 base URL을 얻을 수 있다. axios.create는 protected 멤버로 설정된 instance에 저장되어 외부 클래스에서 사용할 수 없게 했다. 하지만 상속받은 클래스에서는 접근할 수 있다.            데이터를 요청하기 전 토큰이 있는지 확인해야 하기 때문에 axios의 interceptor메소드를 활용할 것이다. _는 private 메소드라고 암시하는 뜻이다.            interceptor메소드는 _handleRequest라는 콜백함수를 가진다. axios 요청시 로컬스토리지에 있는 값을 꺼내서 헤더에 Authorization 키를 설정할 수 있다.         📑 authAPI.ts | 로그인/회원가입 axios 통신을 담당   import { AxiosResponse } from \"axios\"; import { SIGNIN_URL, SIGNUP_URL } from \"../../constants/constants\"; import HttpClient from \"../httpClient\"; import { UserParam } from \"../../types/auth/UserInterface\";  class AuthAPI extends HttpClient {   public constructor() {     super();      this._initializeResponseInterceptor();   }    private _initializeResponseInterceptor = () =&gt; {     this.instance.interceptors.response.use(       this._handleResponse,       this._handleError     );   };    private _handleResponse = (response: AxiosResponse) =&gt; {     const responseCode = response.status;      switch (responseCode) {       case 200:         alert(\"로그인되었습니다.\");         break;       case 201:         alert(\"회원가입에 성공했습니다. 로그인해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }     return response;   };    protected _handleError = (error: AxiosError) =&gt; {     const { response: errorResponse } = error;     const errorCode = errorResponse.status;      switch (errorCode) {       case 400:         alert(\"동일한 이메일이 이미 존재합니다.\");         break;       case 401:         alert(\"아이디와 비밀번호를 확인해주세요.\");         break;       case 404:         alert(\"해당 사용자가 존재하지 않습니다. 회원가입을 진행해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }   };    public SignIn = (data: UserParam) =&gt; this.instance.post(SIGNIN_URL, data);    public SignUp = (data: UserParam) =&gt; this.instance.post(SIGNUP_URL, data); }  const authApi = new AuthAPI(); export { authApi };     참고      Enhance Your HTTP  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","axios","클래스"],
        "url": "/todolist-project/projects-todolist-axios/",
        "teaser": null
      },{
        "title": "[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기",
        "excerpt":"📄 리덕스 툴킷을 사용하지 않은 이유   리덕스를 인강을 통해서 배웠지만 처음엔 이해가 잘 안갔다. 리듀서, 액션 등등 새로운 키워드가 많았고 컨셉도 어려웠다. 배우고 꾸준히 사용해보지 않아서 고이 묻어둔 상태였는데 원티드에서 리덕스를 다루게 되어 다시 꺼내 보았다. 그렇게 리덕스를 사용해서 만든 과제물에 대해 팀원분에게 피드백을 듣게 되었고 리덕스의 컨셉을 이해하지 않았다는 것을 알게 되었다.   기존의 나는 api를 호출할 때 store에서 따로 상태관련 로직을 작성하지 않았다. 예를 들어 Post요청을 한다고 가정했을 때, 데이터를 Put요청을 통해 수정하고 바로 다시 Get요청으로 데이터를 불러와 변경된 데이터를 화면에 렌더링해서 보여줬다. 이 과정에서는 api호출이 총 두번 발생한다.   하지만 store에서 상태 관리 로직을 작성한다면 따로 Get요청을 하지 않아도 클라이언트단에서 변경된 데이터를 바로 렌더링 할 수 있었다. 같은 과정이지만 api요청이 한번으로 줄어들게 되는 것이었다. 단점으로는 코드가 무거워진다는 부분이 있지만 api호출이 줄어드는 만큼 확실히 사용자 입장에선 더 빠르게 느껴질 것 같다.   📄 기존의 리덕스 사용 방식   const commentSlice = createSlice({   name: \"comment\",   initialState: initialState,   reducers: {},   extraReducers: (builder) =&gt; {     builder.addCase(getComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(createComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(editComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(deleteComment.fulfilled, (state, action) =&gt; action.payload);   }, });  export default commentSlice;   redux-toolkit에서 제공하는 createAsyncThunk를 이용해 비동기 로직을 처리하고 댓글의 상태를 관리하는 리듀서를 작성했다. 상태 관련 로직이 전혀 없기 때문에 리듀서가 깔끔하고 각 액션이 어떤 일을 수행하는지 알 수 없다.   📄 개선된 리덕스 사용 방식   const todoReducer = (   state: TodoParam[] = initialState,   action: TodoActionType ) =&gt; {   switch (action.type) {     case GET_TODOS:       return action.payload;     case CREATE_TODO:       return [...state, action.payload];     case DELETE_TODO:       return state.filter((todo) =&gt; todo.id !== action.payload);     case UPDATE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload.id           ? { ...todo, todo: action.payload.todo, isCompleted: false }           : todo       );     case DONE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload           ? { ...todo, isCompleted: !todo.isCompleted }           : todo       );     default:       return state;   } };   리덕스를 제대로 다시 공부하기 위해 툴킷을 사용하지 않고 구현해보았다. 한번 Get요청을 통해 받아온 데이터를 관리하는 리듀서를 만들었다. 상태가 변경될때마다 새로고침을 하는게 아니라면 다시 Get요청을 하지 않아도 되니 api요청이 훨씬 줄어들었다.   지금은 규모가 작은 프로젝트지만 큰 프로젝트의 경우라면 관련 로직이 꽤 길어질 것 같은데 그때도 이렇게 관리를 하는게 맞는지 궁금해졌다. 이 부분은 좀더 찾아봐야 알 것 같다.  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","Redux"],
        "url": "/todolist-project/projects-todoList-redux/",
        "teaser": null
      },{
        "title": "[자료구조] 배열(Array) by JS",
        "excerpt":"📄 배열   배열은 일반적으로 프로그래밍 언어에서 기본적으로 제공하는 자료구조입니다.   일반적인 배열과 자바스크립트의 배열은 메모리에 값을 할당하는 방식이 다릅니다.      📄 일반적인 배열 | 연속적 저장   일반적으로 배열을 만들 때는 배열의 크기를 정해서 선언합니다.   int arr[8] = {1,2,3,4,5}   배열을 선언했을 때 운영체제는 값을 메모리에 연속적인 형태로 저장합니다.   예시와 같이 크기가 8인 배열을 선언했을 때 숫자가 8개 들어갈 수 있는 연속된 빈공간을 찾아 값을 할당하게 됩니다.   할당하지 않은 부분에는 의미없는 쓰레기값이 저장됩니다.   이렇게 값을 미리 할당하면 문제가 생깁니다.   선언한 크기보다 더 큰 값을 배열에 저장한다면, 운영체제는 크기에 맞는 메모리를 다시 찾아서 값을 할당합니다.   기존에 존재했던 값들도 복사해서 새로 만든 공간에 저장하게 됩니다.   따라서 배열은 참조에는 O(1)의 성능을 가지지만, 배열의 크기를 변경하게 되는 삽입, 삭제 성능은 좋지 않다고 할 수 있습니다. 크기 예측이 힘들기 때문에 메모리 낭비가 발생할 수 있기 때문입니다.   자바스크립트의 배열 | 불연속적 저장   반면에 자바스크립트는 배열을 선언할때 크기를 지정하지 않습니다. 자바스크립트의 배열은 값을 선형이 아닌 불연속적으로 할당합니다.   따라서 더 큰값을 배열에 저장한다고 해서 새로운 메모리를 찾지 않습니다.     출처      그림으로 배우는 자료구조와 알고리즘  ","categories": ["structure"],
        "tags": ["자료구조","배열"],
        "url": "/structure/structure-%EB%B0%B0%EC%97%B4/",
        "teaser": null
      },{
        "title": "[자료구조] 연결리스트 (Linked List) by JS",
        "excerpt":"📄 연결리스트 (Linked List) 🖇      연결리스트는 노드를 중심으로 구성됩니다.   노드에는 데이터를 담는 변수하나와 다음 노드를 가리키는 변수를 가지고 있습니다.   이렇게 각각의 노드끼리 서로 연결되어 있기 때문에 연결리스트라고 부릅니다.   연결리스트는 첫 노드의 주소만 가지고 있으면 다른 모든 노드에 접근할 수 있습니다.   📄 연결리스트의 장점           초기 크기를 알 필요가 없습니다.  연결리스트에서 데이터를 추가하면 빈 메모리 공간 아무곳에 데이터를 생성합니다. 따라서 배열과 다르게 초기 크기에 신경쓰지 않아도 됩니다.            데이터를 삽입, 삭제할때 배열만큼 오버헤드를 요구하지 않습니다.  배열에서는 값 사이에 데이터를 삽입하면 데이터가 밀려 비교적 많은 오버헤드가 요구됩니다. 연결리스트는 중간에 데이터를 삽입해도 다음 노드를 가리키는 데이터만 바꿔주면 됩니다.             오버헤드란? 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 또는 메모리            📄 연결리스트의 단점      데이터 참조에는 비효율적입니다.  배열은 연속적이기 때문에 시작 주소만 알면 뒤에 있는 데이터 접근이 쉽습니다. 예를 들어 한 배열의 4번째 값을 참조한다면, 시작 인덱스 값에서 4만 더해서 데이터를 찾을 수 있습니다. 반면 연결리스트는 데이터들이 떨어져 있어 바로 접근할 수 없습니다. 네번째 데이터에 접근한다면 첫번째 노드에서 데이터를 찾고 다음노드에서 데이터를 찾는 순서대로 진행됩니다. 따라서 연결리스트에서 데이터를 찾을 때는 O(n)의 성능을 가집니다.   📄 배열과 연결리스트의 비교                          배열       연결리스트                       크기       고정       동적                 주소       연속       불연속                 데이터 참조       빠름 O(1)       느림 O(n)                 삽입과 삭제       O(n)       O(n)           데이터의 수가 바뀌지 않고 참조가 자주 일어난다면 배열,   데이터의 삽입과 삭제가 자주 일어나서 데이터의 수가 자주 바뀐다면 연결리스트를 사용하는 것이 좋습니다.   📄 연결리스트 자바스크립트로 구현해보기      추상 자료형(Abstract Data Type)이란? 어떠한 데이터와 그 데이터에 대한 연산을 표기하는 것 ex) 세탁물과 세탁기 기능    ✔ 연결리스트의 추상자료형   한글로 된 추상자료형을 자바스크립트로 표현해보자      모든 데이터를 출력하는 기능 &gt; printAll()   모든 데이터를 제거하는 기능 &gt; clear()   인덱스를 삽입하는 기능 &gt; insetAt(index, data)   마지막에 데이터를 삽입하는 기능 &gt; insertLast(data)   원하는 인덱스의 데이터를 삭제하는 기능 &gt; deleteAt(index)   마지막 데이터를 제거하는 기능 &gt; deleteLast()   원하는 인덱스에 있는 데이터를 읽는 기능 &gt; getNodeAt(index)   먼저 Node를 클래스로 작성합니다.   노드에는 데이터와 다음 노드를 가리키는 next값을 저장합니다.   class Node {   constructor(data, next = null) {     this.data = data;     this.next = next;   } }   다음으로 연결리스트를 나타내는 클래스를 작성합니다.   연결리스트에는 현재 가장 앞쪽에 위치하는 노드를 가리키는 head프로퍼티와 연결리스트의 크기를 나타내는 count프로퍼티를 정의합니다.   class LinkedList {   constructor() {     this.head = null;     this.count = 0;   } }   ▪ printAll() | 전체 연결리스트 출력   연결리스트를 출력하되 하나하나의 값을 따로 출력하는게 아니라 한줄로 정리해서 출력합니다.   printAll(){   let currentNode = this.head;   let text = \"[\";    while(currentNode != null) {     text += currentNode.data;     currentNode = currentNode.next;      if(currentNode != null){       text += \", \";     }   }    text += \"]\"   console.log(text) }   ▪ clear() | 전체 연결리스트 삭제   연결리스트는 연속적이기 때문에 가장 앞쪽에 위치한 head를 없애면 전체 연결리스트가 삭제 됩니다.   clear(){   this. head = null }   ▪ insertAt() | 인덱스 삽입   LinkedList클래스 안에 insertAt메서드를 작성합니다.   insetAt(index, data){   if(index &gt; this.count || index &lt; 0){     throw new Error(\"범위를 넘어갔습니다.\")   }    let newNode = new Node(data);    if(index == 0) {     newNode.next = this.head;     this.head = newNode;   } else {     let currentNode = this.head;      for(let i = 0; i &lt; index -1; i++){       currentNode = currentNode.next;     }     newNode.next = currentNode.next;     currentNode.next = newNode;   } }   ✔ index가 현재 연결리스트의 크기보다 크거나 음수인 경우   연결리스트에 노드를 삽입할 수 없으므로 에러를 발생시킵니다.   ✔ index가 0인 경우      새로운 노드의 next값은 현재 연결리스트의 head가 됩니다.   연결리스트의 head를 새로운 노드로 설정합니다.   ✔ index가 0이 아닌 경우   currentNode를 삽입할 인덱스 전까지 head부터 이동시켜야 합니다.      currentNode를 선언하고 현재 head값을 할당합니다.   삽입하고 싶은 index전까지 반복문을 돌려 currentNode를 이동시킵니다.   새로운 노드의 next에 currentNode의 next값을 할당합니다.   currentNode의 next에 새로운 노드의 값을 할당해서 새로운 노드를 연결리스트에 삽입합니다.   ▪ insertLast(data) | 마지막 노드 삭제   앞서 만들었던 insertAt메서드를 이용해 가장 마지막 자리에 새로운 노드를 삽입합니다.   insertLast(data){   this.insertAt(this.count, data); }   ▪ deleteAt | 노드 삭제   deleteAt(index){   if(index &gt;= this.count || index &lt; 0){     throw new Error(\"제거할 수 없습니다\")   }    let currentNode = this.head    if(index == 0){     let deleteNode = this.head;     this.head = this.head.next;     this.count--;   } else {     for(let i = 0; i &lt; index -1; i++){       currentNode = currentNode.next;     }      let deletedNode = currentNode.next; // 제거할 노드는 반환되어야 하므로 변수에 저장     currentNode.next = currentNode.next.next;     this.count --;     return deletedNode   } }   ▪ deleteLast() | 마지막 노드 삭제   앞서 만들었던 deleteAt함수를 이용해 마지막 노드를 삭제합니다.   deleteLast(){   return this.deleteAt(this.count - 1); }   출처      그림으로 배우는 자료구조와 알고리즘  ","categories": ["structure"],
        "tags": ["자료구조","연결리스트"],
        "url": "/structure/structure-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[React] 라우터를 이용한 접근 제한 처리",
        "excerpt":"📄 라우터를 이용한 접근 제한 처리   라우터를 사용해 단순하게 경로를 설정해주는 것이 아닌 토큰이나 쿠키의 여부에 따라 접근 제한처리를 하는 것도 가능합니다.   💾 [publicRoute.js]   const PublicRoute = ({ children }) =&gt; {   const isLogined = getLocalStorageToken();   return isLogined ? &lt;Navigate to=\"/todo\" /&gt; : children; };      PublicRoute는 로그인 여부와 상관없이 모든 사용자에게 제공된다.   토큰이 있을 경우 /todo경로로 리다이렉트한다.   💾 [privateRoute.js]   const PrivateRoute = ({ children }) =&gt; {   const isLogined = getLocalStorageToken();   return isLogined ? children : &lt;Navigate to=\"/\" /&gt;; };      PrivateRoute는 로그인한 사용자에게만 제공된다.   토큰이 없을 경우 /경로로 리다이렉트 한다.   💾 [Route.js]   function Router() {   return (     &lt;Routes&gt;       &lt;Route         path=\"/\"         element={           &lt;PublicRoute&gt;             &lt;Home /&gt;           &lt;/PublicRoute&gt;         }       /&gt;       &lt;Route         path=\"/todo\"         element={           &lt;PrivateRoute&gt;             &lt;Todos /&gt;           &lt;/PrivateRoute&gt;         }       /&gt;     &lt;/Routes&gt;   ); }      Route를 설정할 때 해당 컴포넌트를 PrivateRoute 또는 PublicRoute로 감싸서 사용한다.  ","categories": ["React"],
        "tags": ["React Hooks","라우터","publicRoute","privateRoute"],
        "url": "/react/react-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C-%EC%B2%98%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[자료구조] 스택(Stack) / 큐(Que) by JS",
        "excerpt":"📄 스택(Stack)      스택은 가장 먼저 들어온 데이터가 가장 먼저 나중에 나가는 선입후출구조 입니다.   코드를 작성할 때 많이 사용하는 Ctrl + z를 떠올리면 이해하기 쉽습니다.   📄 큐(Que)   큐는 먼저 들어간 데이터가 먼저 나오는 선입선출의 규칙을 가지고 있습니다.   일상생활에서 마트 계산대를 생각하면 이해하기 쉽습니다.   운영체제가 프로세스의 작업 요청을 들어온 순서대로 큐에 넣고 CPU가 순서대로 꺼내서 처리합니다.   이를 FIFO 스케줄링이라고 합니다.   📄 스택 구현해보기   자바스크립트로 연결리스트를 이용해 스택을 구현합니다.      import { LinkedList } from \"./LinkedList.mjs\";  class Stack {   constructor() {     this.list = new LinkedList();   }    push(data) {     this.list.insertAt(0, data);   }    pop() {     try {       return this.list.deleteAt(0);     } catch (e) {       return null;     }   }    // Top(head)에 있는 데이터를 참조만 하고 데이터를 제거하지는 않는다   peek() {     return this.list.getNodeAt(0);   }    isEmpty() {     return this.list.count == 0;   } }  export { Stack };   출처      그림으로 배우는 자료구조와 알고리즘  ","categories": ["structure"],
        "tags": ["자료구조","스택","큐"],
        "url": "/structure/structure-%EC%8A%A4%ED%83%9D/",
        "teaser": null
      },{
        "title": "[네트워크] 도커(Docker)",
        "excerpt":"도커(Docker) 🐳      도커란?   도커는 애플리케이션을 패키징할 수 있는 툴입니다.   도커를 통해 애플리케이션을 배포한다면, 컨테이너라는 하나의 작은 소프트웨어 유닛안에 애플리케이션, 시스템 툴, Dependencies를 담아 다른 서버로 배포하게 됩니다.   도커의 장점           런타임 환경 자체를 보내주기 때문에 버전 충돌같은 에러가 발생하지 않게 됩니다.            도커 런타임 환경을 사용하면 어떤 PC, 어떤 서버에서도 어플리케이션을 사용할 수 있습니다.       VM와 도커의 차이      VM은 하드웨어 Infrasturcture위에 VirtualBox같은 Hypervisor 소프트웨어를 이용해 각각의 가상의 머신을 만들어 줍니다.      VM(Virtual Machine)이란? 운영체제와 조건이 다른 환경을 가상으로 만들어 필요한 application을 구동할 수 있게 해주는 장치    한 운영체제 위에서 동일한 어플리케이션을 각각 고립된 다른 환경(ex. 윈도우와 리눅스)을 구동하기 위해서는 vm을 이용합니다.   하지만 각각 고립된 다른 환경을 운영한는 만큼 무게가 무겁고 시작하는데도 오래걸리고 리소스를 많이 요구합니다.   컨테이너를 사용하게 된다면?   컨테이너는 vm에서 좀더 경량화된 컨셉이며 하드웨어 설치된 운영체제인 Host OS에서 Container Engine이라는 소프트웨어를 설치만 하면 개별적인 컨테이너를 만들어서 각각의 애플리케이션을 고립된 환경에서 구동할 수 있다.   가장 큰 차이점은 컨테이너는 운영체제를 각각 설치하지 않고 컨테이너 엔진이 설치된 Host OS를 공유한다는 점입니다.   도커는 컨테이너 엔진 중 가장 사용량이 많은 플랫폼 입니다.   도커의 3대 구성요소   1. Dockerfile   컨테이너를 어떻게 만들어야 하는지 알려주는 설명서   2. Image   어플리케이션이 실행되는데 필요한 코드      런타임 환경 등 모든 세팅들이 포함되어 있다.   실행되고 있는 어플리케이션의 상태를 이미지화해서 변경이 불가능한 불변의 상태로 만든다.   컨테이너   이미지를 고립된 환경에서 실행할 수 있는 환경      컨테이너 안에서 만들어진 어플리케이션이 동작한다.   이미지는 클래스 각각의 컨테이너는 인스턴스와 비슷한 컨셉으로 이해할 수 있다.   도커 이미지 배포하는 과정      로컬에서 깃허브와 같은 Container Registry에 이미지를 배포합니다.   서버에서 이미지를 가져와 설치한 도커와 같은 컨테이너 환경에서 가져온 이미지를 토대로 어플리케이션을 실행합니다.   출처           CS지식의 정석       드림코딩 YouTube   weaveworks  ","categories": ["network"],
        "tags": [""],
        "url": "/network/network-docker/",
        "teaser": null
      },{
        "title": "[자료구조] 덱(Deque) by JS",
        "excerpt":"📄 덱(Deque)      덱(Deque)은 데이터의 삽입과 제거를 head와 tail 두 곳에서 자유롭게 할 수 있는 자료구조입니다.   📄 덱의 추상자료형      printAll - 모든 데이터 출력   addFirst - head에서 데이터 제거   removeFirst - head에서 데이터 제거   addLast - tail에 데이터 삽입   removeLast - tail엣 데이터 제거   isEmpty - 리스트가 비었는지 체크   📄 자바스크립트로 구현해보기   작성헀던 연결리스트로 구현해보았습니다.   자료구조 - 연결리스트   import { DoublyLinkedList } from \"./DoublyLinkedList.mjs\";  class Deque {   constructor() {     this.list = new DoublyLinkedList();   }    printAll() {     this.list.printAll();   }    addFirst(data) {     this.list.insertAt(0, data);   }    removeFirst() {     return this.list.deleteAt(0);   }    addLast(data) {     this.list.insertAt(this.list.count, data);   }    removeLast() {     return this.list.deleteLast();   }    isEmpty() {     return this.list.count == 0;   } }  export { Deque };   출처      그림으로 배우는 자료구조와 알고리즘  ","categories": ["structure"],
        "tags": ["자료구조","덱"],
        "url": "/structure/structure-%EB%8D%B1(Deque)/",
        "teaser": null
      },{
        "title": "Nodejs, npm, yarn",
        "excerpt":"📄 Node.js란?      Nodejs는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript의 런타임 입니다. (by Node 공식 페이지)       런타임이란? 특정 언어로 만든 프로그램을 실행할 수 있는 환경    Nodejs는 자바스크립트를 브라우저 내에서 말고도 다른환경에서 자바스크립트를 실행할 수 있게 합니다.   Node.js 의 유래   크롬같은 브라우저에는 html을 동적으로 움직일 수 있게하는 자바스크립트 해석 엔진이 있습니다.   크롬은 V8, 모질라는 SpiderMonkey를 사용합니다.   브라우저 중 크롬이 인기가 있는 이유중 하나는 빠른 속도입니다.   자바스크립트를 해석하는 속도가 빠르기 때문에 사용자가 브라우저를 이용할 때 속도가 빠르다고 느끼게 됩니다.   크롬은 사용하던 해석 엔진인 V8을 Node.js라는 이름으로 따로 출시합니다.   📄 npm(Node Packaged Manager)   npm은 Node.js의 패키지 관리자입니다.   npm은 Node.js로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램입니다.   npm을 사용하여 패키지를 설치하면 package.json에서 설치한 패키지가 자동으로 정리됩니다.   📄 yarn   yarn 또한 npm과 같이 javascript 패키지 매니저입니다.   yarn을 사용하면 npm 보다 더 나은 환경에서 자바스크립트를 실행할 수 있어 사용량이 높습니다.   yarn을 사용하는 이유   1. 속도   우선 npm보다 빠릅니다. 다운받은 패키지를 캐시에 저장하여 중복된 데이터는 다운로드하지 않고 캐시에 저장된 파일을 활용하기 때문입니다.   npm은 패키지를 설치할때 순차적으로 설치하는 반면, yarn은 병렬로 처리해 속도면에서 우수합니다.   2. 안정성과 보안   npm은 의존 관계를 가지는 다른 패키지들이 포함되지만 yarn은 package.json에 있는 파일만 설치한다고 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Nodejs","npm","yarn"],
        "url": "/javascript/javascript-jsruntime/",
        "teaser": null
      },{
        "title": "짝수와 홀수",
        "excerpt":"문제 📖   정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요.      num은 int 범위의 정수입니다.   0은 짝수입니다.   function solution(num) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(num) {   const answer = num % 2 === 0 ? \"Even\" : \"Odd\";   return answer; }  solution(4);   num을 2로 나누어 나머지값에 대한 유무를 삼항연산자로 표현하고, 상수 answer에 값을 할당에 결과값을 return시켰다.   Best Practice 👍   function evenOrOdd(num) {   return num % 2 ? \"Odd\" : \"Even\"; }   숫자 0은 false, 이외의 값은 true라는 점을 활용하니 코드가 더욱 간결해졌다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","짝수와홀수"],
        "url": "/programmers-lv1/evenandodd/",
        "teaser": null
      },{
        "title": "최댓값과 최솟값",
        "excerpt":"문제 📖   문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.   예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다.      s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.   function solution(s) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(s) {   const stringToArray = s.split(\" \");   const stringToNumber = stringToArray.map((element) =&gt; parseInt(element));   const maxValue = Math.max(...stringToNumber);   const minValue = Math.min(...stringToNumber);   const answer = `${minValue} ${maxValue}`;   return answer; }   먼저 split 배열 내장 함수를 통해 공백을 기준으로 문자열을 구분했다.   이후 최댓값과 최솟값을 구하기 위해 구분된 배열의 문자들을 숫자로 바꾸어 주고,   spread연산자로 배열을 분해해서 최댓값과 최솟값을 구했다.   문자열을 반환해야 한다고해서 백틱으로 maxValue minValue을 감싸 return시켰다.   Best Practice 👍   # 1   function solution(s) {   const arr = s.split(\" \");    return Math.min(...arr) + \" \" + Math.max(...arr); }   우선, 내가 작성한 코드보다 훨씬 간결한 것을 확인했다.   내가 몰랐던 점은 다음과 같다.      Math가 문자열도 취급한다는 것   굳이 따로 변수나 상수에 값을 할당하는 것보다 바로 return을 시키는게 더 나을 때도 있다는 것   # 2   function solution(s) {   let min = Math.min.apply(null, s.split(\" \").map(Number));   let max = Math.max.apply(null, s.split(\" \").map(Number));   var answer = min + \" \" + max;   return answer; }   이 코드가 인상적이었던 점은 map함수를 사용하는 방식 때문이었다.   내 풀이를 보면 map을 사용할때 각각 요소에 parseInt를 적용해서 숫자로 변환하는 방식이었는데, 그냥 Number라고 적기만 해도 식이 진행된다는 것을 알게 되었다.  ","categories": ["programmers-lv2"],
        "tags": ["프로그래머스","최댓값과 최솟값"],
        "url": "/programmers-lv2/programmers-maxandmin/",
        "teaser": null
      },{
        "title": "평균 구하기",
        "excerpt":"문제 📖   정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.      arr은 길이 1 이상, 100 이하인 배열입니다.   arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(arr) {   const answer = arr.reduce((a, c) =&gt; a + c) / arr.length;   return answer; }   배열 내장 함수인 reduce함수를 사용했다.   for문을 사용하는 것보다 훨씬 간결한 코드가 나왔다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","평균구하기","해시"],
        "url": "/programmers-lv1/programmers-arr/",
        "teaser": null
      },{
        "title": "폰켓몬",
        "excerpt":"문제 📖   당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.   홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.      첫 번째(3번), 두 번째(1번) 폰켓몬을 선택   첫 번째(3번), 세 번째(2번) 폰켓몬을 선택   첫 번째(3번), 네 번째(3번) 폰켓몬을 선택   두 번째(1번), 세 번째(2번) 폰켓몬을 선택   두 번째(1번), 네 번째(3번) 폰켓몬을 선택   세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.   당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.   나의 풀이 🙋‍♀️   function solution(nums) {   const totalNumber = Math.ceil(nums.length / 2);   const set = new Set(nums);   const newNums = [...set];    const answer =     Math.ceil(newNums.length) &gt; totalNumber       ? totalNumber       : Math.ceil(newNums.length);    return answer; }   우선 주어진 배열의 길이를 totalNumber에 저장해 answer에 최댓값으로 생각했다.   이후 set함수를 사용해서 배열의 중복요소를 제거했다.   최종 정답은 중복요소를 제거한 배열의 길이가 최댓값보다 크면 최댓값인 totalNumber, 작으면 중복요소를 제거한 배열의 길이로 설정했다.   Best Practice 👍   function solution(nums) {   const max = nums.length / 2;   const arr = [...new Set(nums)];    return arr.length &gt; max ? max : arr.length; }   다른 사람의 풀이를 보니 내가 너무 성급하게 정답을 제출했다는 것을 알았다.   내 풀이에서는 newNums.length에 쓸데없이 올림처리를 한 것을 지우지도 않았고, set함수를 사용할때 굳이 상수를 두번이나 선언한게 보인다.   답이 나와도 다시한번 보고 정리하는 습관을 가져야겠다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","폰켓몬","해시"],
        "url": "/programmers-lv1/programmers-phonecatmon/",
        "teaser": null
      },{
        "title": "약수의 합",
        "excerpt":"문제 📖   정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.      n은 0 이상 3000이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(n) {   let sum = n;   for (let i = 1; i &lt;= Math.floor(n / 2); i++) {     if (n % i === 0) sum += i;   }   return sum; }   간단하게 for문을 사용했다.   어차피 주어진 수 n의 절반까지만 정답의 유효 범위이기 때문에 반복 횟수를 조금이라도 줄이려고 신경썼다.   반복문을 통해 주어진 수 n을 정수로 나눈 값이 0일 경우, 총합 sum에 더해준다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","약수의 합"],
        "url": "/programmers-lv1/sumofdivisor/",
        "teaser": null
      },{
        "title": "2016년",
        "excerpt":"문제 📖   2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT   입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.      2016년은 윤년입니다.   2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   나의 풀이 🙋‍♀️   function solution(a, b) {   const dayOfTheWeek = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];   const daysOfMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   let sum = 0;    if (a === 1) {     sum = b;   } else {     for (let i = 0; i &lt;= a - 2; i++) {       // 1       sum += daysOfMonth[i];       if (i == a - 2) {         sum += b; //2       }     }   }    const index = sum - Math.floor(sum / 7) * 7; // 3    return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1]; }   내가 생각한 풀이의 순서는 다음과 같다.      주어진 월(a)전의 총 날짜를 더한 값을 구한다.. = sum   sum에 b를 더해 필요한 날짜를 모두 더한 값을 구한다.   sum에 7의 배수를 뺐을 때 나올 수 있는 한자리 수를 구해 dayOfTheWeek의 인덱스로 활용한다.   trouble shooting 1 💥   처음 코드   for (let i = 0; i &lt;= a - 2; i++) {   sum += daysOfMonth[i];   if (i == a - 2) {     sum += b;   } }   수정한 코드   if (a === 1) {   sum = b; } else {   for (let i = 0; i &lt;= a - 2; i++) {     sum += daysOfMonth[i];     if (i == a - 2) {       sum += b; //2     }   } }   이 부분은 왜 통과하지 못했는지 머리를 굴리다 1월인 경우, 2월인 경우 값을 대입해서 생각해보니 문제점을 찾을 수 있었다.   만약 1월이라면 a는 1이되는데 for문의 조건에 처음부터 충족되지 못해서 sum에 값이 들어가지 않았던 것이다.   if문으로 조건을 달아주긴 했지만 조건문속 반복문속 조건문.. 정말 맘에 들지 않는다..   trouble shooting 2 💥   처음 코드   return dayOfTheWeek[index - 1];   수정한 코드   return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1];   계산대로 하면 모든 케이스가 통과해야하는데 13개의 케이스 중 2개가 통과하지 못하고 계속 실패로 걸렸다.   테스트 케이스에 날짜를 하나 하나 추가해서 결과를 확인하던 중 이유를 알 수 있었다.   index가 0이 될 수도 있었던것이었다.   예를 들어 5월 5일인 경우, index가 126 - (18*7) = 0이 되는데 나는 결과값을 dayOfTheWeek[index-1]로만 리턴해서 결과가 undefined가 나왔던 것이다.   return할 때 삼항연산자를 이용해 index가 0이 될 경우의 케이스도 처리해주었다.   Best Practice #1 👍   function getDayName(a, b) {   var tempDate = new Date(2016, a - 1, b);    return tempDate.toString().slice(0, 3).toUpperCase(); }  //아래 코드는 테스트를 위한 코드입니다. console.log(getDayName(5, 24));   Date가 있는 걸 알긴 했지만 그러면 너무 단순해질것같아서 사용하지 않았다.   그래도 메소드를 사용한걸 보니 훨씬 보기 편하다.   Best Practice #2 👍   function solution(a, b) {   const monthDay = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   const weekDay = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\"];    let days = b;   for (let i = 0; i &lt; a - 1; i++) days += monthDay[i];    return weekDay[days % 7]; }   코드가 흘러가는 구성이 내가 작성한 코드와 크게 다르지 않다.   하지만 간결함과 가독성이 크게 다르다.   for문의 조건식에서 &lt;=을 &lt;로 고쳤을뿐인데 if문이 하나 줄었다.   굳이 sum이라는 변수를 새로 만들지 않고 b에 값을 더해주었다.   굳이… Math.floor()를 사용하지 않고도 그냥 %연산자로 나머지값 계산해서 index로 처리해주었다…   만약 다른 사람이 푼 답에 Best Practice가 있다면 배열 내장 함수를 사용했을 것이라고 생각했는데 아니었다.   물론 배열 내장 함수를 사용할 수도 있지만 이 코드가 가독성도 좋고 제일 좋아보였다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","2016년"],
        "url": "/programmers-lv1/2016/",
        "teaser": null
      },{
        "title": "투명도 설정하기",
        "excerpt":"📄 opacity 속성   div {   background-color: rgb(255, 255, 255);   opacity: 0.5; }           opacity로 0~1의 값을 설정한다.            0에 가까울수록 투명하다.       📄 rgba 속성   div {   background-color: rgb(255, 255, 255, 0.5); }   차이점   opacity는 해당 요소를 포함한 하위 요소까지 적용되고,  raga는 해당 요소에만 적용됩니다.  ","categories": ["CSS"],
        "tags": ["opacity","rgba"],
        "url": "/css/css-opacity/",
        "teaser": null
      },{
        "title": "🚨 Cannot find module",
        "excerpt":"🚨 Cannot find module   자바스크립트 강의를 들으며 실습 도중 파일이 실행이 안됐다.      경로 설정 문제 인줄 알았는데 파일 설정을 잘못했다.   🔨 해결           확장자 명이 js로 되어 있는지 확인하고 고친다.            끝^^       느낀점   항상 오류가 발생하면 사실 대부분 이런 사소한 문제들인것 같다.   모든 과정을 꼼꼼히 살피자.   참고      [stackoverflow]https://stackoverflow.com/questions/9023672/how-do-i-resolve-cannot-find-module-error-using-node-js  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/cannot-find-module/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 🚨 Could not find a declaration file of module",
        "excerpt":"🚨 에러 발생   모코숲 프로젝트 진행 중 react-persist를 설치해서 사용하려고 하는데 에러가 발생했습니다.      하라는대로 npm i --save-dev @types/redux-persist를 입력해도 계속 동일한 현상이 발생합니다.   🔨 에러 해결   react-app-env.d.ts파일에 다음과 같이 추가해주었습니다.   /// &lt;reference types=\"redux-persist\" /&gt;   평소에 크게 신경 쓰지 않았던 파일이기에 여기서 에러가 해결될 줄 몰랐다.   📌 react-app-env.d.ts 란?   d.ts 는 전역에서 사용할 타입 유형을 선언만 할 수 있는 파일입니다.   이 파일은 컴파일 이후 자바스크립트 코드로는 생성되지 않습니다.   CRA로 프로젝트 생성시 자동으로 react-app-env.d.ts파일이 생성됩니다.   /// &lt;reference types=\"react-scripts\" /&gt;   여기서 트리플 슬래시(///)로 작성된 내용은 컴파일러 지시어로 사용됩니다.   node_modules의 react-script라는 dependency를 불러와서 사용한다는 뜻입니다.   이런 지시어는 패키지에 대한 종속성을 선언하는데 사용됩니다.   참조   stack overflow - How to add redux-persist to typescript project?  ","categories": ["coding-swamp"],
        "tags": ["모코늪","redux-persist","react-app-env.d.ts"],
        "url": "/coding-swamp/coding-swamp-Could-not-find-a-declaration-file.md/",
        "teaser": null
      },{
        "title": "🚨 Assignment to constant variable.",
        "excerpt":"🚨 Assignment to constant variable.   자바스크립트 퀴즈를 푸는데 코드에 빨간 표시도 안났는데 에러가 떴다.   직역하면 상수값을 변수에 할당했다는 뜻이다.   function countBiggerThanTen(numbers) {   let sum = 0;   numbers.forEach((number) =&gt; {     if (number &gt; 10) {       sum += 1; // TypeError: Assignment to constant variable.     }   });   console.log(sum); }   원인   이미 선언한 const 변수에 새로운 값을 할당했을 때 발생한다.   위 코드에서 계속 값이 바뀌는 sum을 상수로 선언했다.   해결   값을 재할당에서 사용할 수 있는 let으로 바꾸어 주었더니 정상적으로 동작했다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/javascript-assignment-to-constant-variable/",
        "teaser": null
      },{
        "title": "🚨 Cannot use import statement outside a module",
        "excerpt":"🐞 에러 발생   공연 검색기 프로젝트 중 에러가 발생했다.    ❔ 원인   해당 스크립트를 모듈로 인식하지 못해 import문을 쓸 수 없다는 뜻이다.   직접 스크립트의 타입을 지정해주어야 한다.   ❕ 해결   [index.html]   &lt;script src=\"main.js\" type=\"module\"&gt;&lt;/script&gt;   이렇게 해당 스크립트 태그에서 타입을 모듈로 지정해주면 에러가 해결된다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","import"],
        "url": "/javascript/javascript-cannot-use-import-statement-outside-a-module/",
        "teaser": null
      },{
        "title": "이벤트 버블링 (Event Bubbling), 이벤트 캡쳐 (Event Capture), 이벤트 위임 (Event Delegation)",
        "excerpt":"📄 이벤트 버블링 (Event Bubbling)   이벤트 버블링은 특정 요소에서 이벤트가 발생했을 때, 해당 이벤트가 더 상위 요소로 전달되는 과정입니다.   브라우저는 특정 요소에서 이벤트가 발생했을 때 그 이벤트를 최상위에 있는 요소까지 전파합니다.   이러한 과정을 이벤트 버블링이라고 합니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   three; two; one;   📄 이벤트 캡처 (Event Capture)   이벤트 캡처는 이벤트 버블링과 반대로 진행되는 이벤트 전달 과정입니다.   이벤트 캡처는 이벤트 버블링과 반대로 상위요소에서 하위요소로 이벤트 전달 과정이 진행됩니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   one; two; three;   addEventListener의 세번째 파라미터로 capture: true를 설정해주면 이벤트 캡처가 진행되어 가장 상위 요소에 적용된 이벤트가 먼저 발생합니다.   📄 이벤트 진행을 막고싶을 때는 어떻게 할까?   이벤트 버블링이나 이벤트 캡처를 구현할때 적용한 모든 요소에 이벤트를 실행하지 않고 중간에 멈추기 위한 속성이 있습니다. event.stopPropagation()을 사용하면 이벤트의 진행과정을 중단시킬 수 있습니다.   // 이벤트 버블링 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // three }  // 이벤트 캡쳐 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // one }   📄 이벤트 위임 (Event Delegation)   이벤트 위임은 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식입니다.   &lt;h1&gt;오늘의 할 일&lt;/h1&gt; &lt;ul class=\"itemList\"&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item1\" /&gt;     &lt;label for=\"item1\"&gt;이벤트 버블링 학습&lt;/label&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item2\" /&gt;     &lt;label for=\"item2\"&gt;이벤트 캡쳐 학습&lt;/label&gt;   &lt;/li&gt; &lt;/ul&gt;   // 새 리스트 아이템을 추가하는 코드 var itemList = document.querySelector(\".itemList\");  var li = document.createElement(\"li\"); var input = document.createElement(\"input\"); var label = document.createElement(\"label\"); var labelText = document.createTextNode(\"이벤트 위임 학습\");  input.setAttribute(\"type\", \"checkbox\"); input.setAttribute(\"id\", \"item3\"); label.setAttribute(\"for\", \"item3\"); label.appendChild(labelText); li.appendChild(input); li.appendChild(label); itemList.appendChild(li);  var itemList = document.querySelector(\".itemList\"); itemList.addEventListener(\"click\", function (event) {   alert(\"clicked\"); });   아이템이 새로 추가될 때마다 이벤트를 새로 추가하지 않고 상위 요소인 .itemList에 이벤트를 달아줌으로써 하위요소에도 이벤트가 등록되었습니다.   출처      캡틴 판교-이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","이벤트 버블링","이벤트 캡처","이벤트 위임"],
        "url": "/javascript/javascript-eventBubbling/",
        "teaser": null
      },{
        "title": "[React] 새로 고침해도 state 유지하기 with Redux-Persist",
        "excerpt":"📄 Redux-Persist      Redux-Persist는 state를 Local Storage 혹은 Session Storage에 저장해 새로고침을 해도 state를 유지시키는 redux 라이브러리입니다.   모코숲 프로젝트를 진행하는 중 새로고침하면 리덕스 store에 저장되어 있던 데이터들이 reset되어 동일한 데이터를 매 페이지에서 요청해야 했습니다.   페이지가 처음 로딩될 때 api를 매번 요청할 수는 있지만, 더 효율적인 방법이 있을까 고민하던 중 Redux-Persist라는 라이브러리를 알게 되었습니다.   📄 사용방법   1. 설치 (yarn + typescript 환경)   yarn add redux-persist @types/redux-persist   2. Storage 종류에 따라 `import`      Local Storage를 사용할 경우   import storage from 'redux-persist/lib/storage      Session Storage를 사용할 경우   import sessionStorage from 'redux-persist/lib/storage   이 과정에서 발생한 에러로 redux-persist를 몇번이나 재설치했습니다.   🔗 TIL-Could not find a declaration file of module   에러는 TIL폴더에 정리해 두었습니다.   3. config 작성 후, rootReducer를 감싼다.   // store/index.ts  const persistConfig = {   // config 작성   key: \"root\",   storage,   whiteList: [\"studyItem\", \"member\", \"studyList\"], // 적용할 리듀서를 whiteList에 포함시킨다. };  const rootReducer = combineReducers({   userForm: userFormSlice,   signInForm: signInFormSlice,   member: memberSlice,   editMode: editModeSlice,   userMenu: userMenuSlice,   studyForm: studyFormSlice,   studyList: studyListSlice,   studyItem: studyItemSlice, });  const persistedReducer = persistReducer(persistConfig, rootReducer);  const store = configureStore({   reducer: persistedReducer,   middleware: (getDefaultMiddleware) =&gt;     getDefaultMiddleware({ serializableCheck: false }).concat(logger), });  export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppDispatch = typeof store.dispatch; export default store; export const persistor = persistStore(store); // 작성된 persistor은 index.tsx에서 사용된다.   4. index.tsx파일에 적용시키기   // index.tsx  const root = ReactDOM.createRoot(   document.getElementById(\"root\") as HTMLElement ); root.render(   &lt;Provider store={store}&gt;     &lt;PersistGate loading={null} persistor={persistor}&gt;       &lt;ThemeProvider theme={theme}&gt;         &lt;GlobalStyle /&gt;         &lt;Page&gt;           &lt;App /&gt;         &lt;/Page&gt;       &lt;/ThemeProvider&gt;     &lt;/PersistGate&gt;   &lt;/Provider&gt; );   5. 결과   이렇게 모든 과정을 거치면    localStorage에 persist:root라는 이름의 키로 값이 저장된 것을 확인할 수 있습니다.      logger에도 반영되어 console창에서도 확인할 수 있습니다.   REHYDRATE과정에서 storage에 저장된 값을 가져와 state로 설정합니다.   📄 storage에 있는 데이터 삭제하기   브라우저를 완전히 떠났을 때 데이터가 남아있으면 안되므로 로그아웃시 locas Storage에 저장된 state들을 삭제해 주었습니다.   const onClickLogout = async () =&gt; {   await persistor.purge();   navigator(\"/signin\");   removeToken(); };   참조      GROWNFRESH-Redux-Persist  ","categories": ["React"],
        "tags": ["Redux-Persist"],
        "url": "/react/react-Redux-Persist/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.   GitHub TIL레포에 공부내용을 기록해왔는데 이 블로그로 모든 내용을 옮겨야 한다.   내용이 꽤 많지만 전체적으로 한번씩 읽으면서 복습한다고 생각하고 여유롭게 이사해야겠다.   TIL 레포에서 GitHub 블로그로 이사하는 이유   우선, github 레포에서 보는 md파일은 가독성이 좋지 않다. 글씨의 크기나 간격이 편하게 읽기 좋은 정도는 아니다. 가장 큰 이유는 내가 지속적으로 관리하는 페이지를 가지고 싶었다. 이 블로그에 공부기록도 하지만 이외에 다양한 주제를 가지고 나를 표현하는 웹 사이트로 성장시킬 예정이다.  ","categories": ["일상"],
        "tags": ["Blog"],
        "url": "/%EC%9D%BC%EC%83%81/first-post/",
        "teaser": null
      },{
        "title": "완주하지 못한 선수",
        "excerpt":"문제 📖   수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.   마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.      마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.   completion의 길이는 participant의 길이보다 1 작습니다.   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.   참가자 중에는 동명이인이 있을 수 있습니다.   나의 풀이 #1 🙋‍♀️   function solution(participant, completion) {   const setParticipant = new Set(participant); // 1   if (setParticipant.size &lt; participant.length) {     // 2     const notCompletion = participant.filter((item) =&gt; {       if (setParticipant.has(item)) {         setParticipant.delete(item);       } else {         return item;       }     });     return notCompletion[0];   }   const answer = participant.filter((person) =&gt; !completion.includes(person)); // 3   return answer[0]; }      Set객체를 사용해서 participant 중복요소를 제거한다.   중복요소를 제거한 participant 객체(setParticipant)의 크기가 participant보다 작다면, 동명이인이 있다는 뜻이므로 filter함수를 사용해 완주하지 못한 선수의 이름을 구한다.   동명이인이 없는 경우 바로 완주하지 못한 선수의 이름을 구한다.   이 코드를 제출하며 정확성 체크는 통과하지만 효율성 체크는 통과하지 못한다.   효율성까지 테스트하는 문제는 처음이라 시간이 좀 걸려서 코드를 고쳤다.   나의 풀이 #2 🙋‍♀️   function solution(participant, completion) {   const sortedParticipant = participant.sort(); // 1   const sortedCompletion = completion.sort();    for (let i = 0; i &lt; sortedParticipant.length; i++) {     // 2     if (sortedParticipant[i] !== sortedCompletion[i]) {       // 3       return sortedParticipant[i];       break;     }   } }      참가자 배열과 완주자 배열의 문자열을 abc차순으로 정리한다.   for문을 사용해서 참가자 수만큼 반복문을 실행한다.   순차가 정리된 배열끼리 이름을 비교하게 되고, 이름이 같지 않으면 해당 이름을 정답으로 제출한다.   효율성 체크는 수행 시간과 메모리를 기준으로 평가된다.   코드의 시간복잡도와 저장된 메모리를 고려해야 통과할 수 있다.   반복문을 사용하는 경우에는 원하는 값이 도출되었을 때, 바로 반복문을 종료시킬 수 있어야 효율성이 증가한다.   그런면에서 배열에 for...in을 사용하는 것은 좋지 않다.   for...in은 모든 값을 조회해 효율성을 떨어뜨리기 때문이다.   Best Practice 👍   function solution(participant, completion) {   const map = new Map(); // 1    for (let i = 0; i &lt; participant.length; i++) {     let a = participant[i],       b = completion[i];      map.set(a, (map.get(a) || 0) + 1); // 2     map.set(b, (map.get(b) || 0) - 1); // 3   } // 4    for (let [k, v] of map) {     // 5     if (v &gt; 0) return k;   }    return \"nothing\"; }   해시의 컨셉을 정확히 접목시킨 풀이이다.   해시의 개념은 알고 있었지만 프로그래머스에서 이렇게 접목시킬 생각은 못했다.      우선 Map객체를 생성한다.   참가자 수만큼 반복문을 돌려 map에 키는 참가자 이름으로, 값은 기존에 1을 더해준다.   map에 완주자 이름의 키에 해당되는 값을 -1만큼 빼준다.   처음 for문을 나온 map의 키는 참가자이름이고 값은 0 또는 1이 된다.   완주하지 못한 참가자는 1의 값을 가지고 있으므로 해당 key의 값을 답으로 제출한다.   동명이인이 있을 경우에는 해당 이름의 값에 두번 1이 더해지고 한번 1이 빼지므로 마찬가지로 1이 된다.   풀이를 정리하자면 다음과 같게 된다.      sort로 풀면 O(NlogN)의 시간이 걸리지만 해시로 풀면 O(N)의 시간 복잡도를 가진다.   다음 해시 문제를 풀때는 꼭 Map을 사용해서 답을 낼 것이다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","완주하지 못한 선수","해시"],
        "url": "/programmers-lv1/programmers-notcolpletedplayer/",
        "teaser": null
      },{
        "title": "[자료구조] 해시(Hash) by JS",
        "excerpt":"📄 해시(Hash)      해시는 (Key, Value)로 데이터를 저장하는 자료구조입니다.   주어진 데이터를 해시함수에 적용하면 데이터를 기반으로 key를 만들어 해시 테이블에 저장합니다.   해시 함수는 똑같은 데이터들을 똑같이분류하는 기능을 담당합니다.   📄 장점   인덱스를 통한 검색이 이루어져 속도가 빠르다는 장점을 가지고 있습니다.   검색이 상수시간에 이루어지므로 O(1)의 시간복잡도를 가집니다.   📄 자바스크립트로 해시 함수 구현하기   function hashStringToInt(s, tableSize) {   let hash = 17;    for (let i = 0; i &lt; s.length; i++) {     // 인덱스의 크기가 커질 경우를 대비해 tableSize로 나눈 값을 쓴다.     hash = (13 * hash * s.charCodeAt(i)) % tableSize;   }   return hash; }  class HashTable {   table = new Array(100); // 크기가 100인 Hash Table    setItem = (key, value) =&gt; {     const index = hashStringToInt(key, this.table.length);     this.table[index] = value;   };    getItem = (key) =&gt; {     const index = hashStringToInt(key, this.table.length);     return this.table[index];   }; }   📄 해시 충돌   해시 충돌은 같은 인덱스에 데이터들이 들어오는 현상입니다.   ▪ 대처 방법   ✔ Separate Caining   해당 인덱스의 value에 배열이나 연결리스트를 사용해 값을 중첩으로 저장하는 방법입니다.   setItem = (key, value) =&gt; {   const idx = hashStringToInt(key, this.table.length);   if (this.table[idx]) {     this.table[idx].push([key, value]);   } else {     this.table[idx] = [[key, value]];   } };  getItem = (key) =&gt; {   const idx = hashStringToInt(key, this.table.length);   if (!this.table[idx]) return null;    // O(n)   return this.table[idx].find((el) =&gt; el[0] === key)[1]; };   ✔ Linear Probing   선형 탐색 데이터는 다음 버켓(인덱스)자리에 밀어넣는 방법입니다.   이 방법을 사용하면 최대 테이블 길이만큼만 저장할 수 있다는 단점이 있습니다.   ✔ Resizing   테이블의 크기를 늘린 후 전체 데이터를 재정렬한다.   테이블의 길이가 데이터의 크기에 따라 늘어난다는 특징을 가지고 있습니다.   function hashStringToInt(s, tableSize) {   let hash = 17;    for (let i = 0; i &lt; s.length; i++) {     hash = (13 * hash * s.charCodeAt(i)) % tableSize;   }   return hash; }  class HashTable {   table = new Array(3);   numItems = 0;    // resizing   resize = () =&gt; {     const newTable = new Array(this.table.length * 2);      // 새로 만들어진 해시테이블의 모든 요소 재정렬     this.table.forEach((item) =&gt; {       if (item) {         item.forEach(([key, value]) =&gt; {           const idx = hashStringToInt(key, newTable.length);           if (newTable[idx]) {             newTable[idx].push([key, value]);           } else {             newTable[idx] = [[key, value]];           }         });       }     });     this.table = newTable;   };    setItem = (key, value) =&gt; {     this.numItems++;      const loadFactor = this.numItems / this.table.length;     if (loadFactor &gt;= 0.8) {       // 해시 테이블이 80%이상 차있으면 재정렬한다.       this.resize();     }      const idx = hashStringToInt(key, this.table.length);     if (this.table[idx]) {       this.table[idx].push([key, value]);     } else {       this.table[idx] = [[key, value]];     }   }; }   참고           업비트 투자자보호센터            노마드 코더 - 개발자라면 꼭 알아야할 Hash table의 모든 것!      ","categories": ["structure"],
        "tags": ["자료구조","해시"],
        "url": "/structure/structure-hash/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 사용자 폼 관련 Slice 리팩토링 (state 객체로 관리하기)",
        "excerpt":"❔ 리팩토링 이유   좋은 코드는 코드만 보고 어떤 일을 하는지 알 수 있는 코드라고 배웠다.   하지만 나의 코드는 코드만 보고 무슨일을 하는 지 알 수 없었다.   기존의 MemberForm 데이터 구조   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   value: [     { key: \"imageFile\", value: null, isValidate: true },     { key: \"username\", value: \"\", isValidate: false, emailAuth: false },     { key: \"email\", value: \"\", isValidate: false },     { key: \"password\", value: \"\", isValidate: false },   ], };   데이터 구조가 이렇게 되어있으면 값에 접근할 때 값의 이름이 아니라 index로 접근해야 했다.   처음 프로젝트를 시작할때 File 타입에 null이 할당되지 않아 객체 안에 굳이 key라는 이름의 key를 생성했다.   imageFile: File: null; // error   아마 내가 ‘imageFile’의 타입을 오로지 File로만 했던 모양인데 시간이 지나고 보니 코드가 굉장히 가독성이 없다는 것이 보였다.   💾 Components/SignUpForm   const result: UserParam = {   imageFile: userData[0].value,   username: userData[1].value!,   email: userData[2].value!,   password: userData[3].value!, };   userData에 index로 접근하기 때문에 해당 변수가 어떤 값을 가지고 있는지 알 수 없다.   이를 고치기 위해선 memberForm의 state 구조를 변경해야 했다.   ❕ 리팩토링 결과   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   memberForm: {     imageFile: null,     username: \"\",     email: \"\",     password: \"\",   } as Omit&lt;MemberFormParam, \"profileUrl\" &amp; \"imageUrl\"&gt;,   emailAuth: false,   isEditMode: false, };   💾 Components/SignUpForm   const result: UserParam = {   imageFile: memberForm.imageFile,   username: memberForm.username,   email: memberForm.email,   password: memberForm.password, };   값에 이름으로 접근하니 어떤 데이터가 할당되는지 알 수 있게 되었다.   💬 나의 생각   분명 코드를 작성할 때는 최선인 것 같았는데 지나고 보니 아닌 경우가 꽤 많다.   완성된 프로젝트라 하더라도 다시 보고 리팩토링을 계속 해주는 것이 좋겠다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","redux-toolkit","데이터구조"],
        "url": "/coding-swamp/projects-coding-swamp/",
        "teaser": null
      },{
        "title": "논리 연산자를 이용한 조건문",
        "excerpt":"📄 논리 연산자를 이용한 조건문   조건문은 계산식뿐만 아니라 논리연산자를 이용해 완성할 수 있습니다.   📄 표현식 &amp;&amp; 표현식   &amp;&amp;는 and연산자로 불리며 조건 중 하나라도 거짓일 경우 거짓이 됩니다.   if (true &amp;&amp; true) {   console.log(\"두개 모두 참이면 참\"); }  if (true &amp;&amp; false) {   console.log(\"한개만 참이면 거짓\"); }  if (false &amp;&amp; false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 표현식 || 표현식   ||는 &amp;&amp;OR연산자**로 둘중 하나만 참이면 참이 됩니다.   if (true || true) {   console.log(\"두개 모두 참이면 참\"); }  if (true || false) {   console.log(\"한개만 참이면 참\"); }  if (false || false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 !표현식   !는 NOT연산자로 반대의 결과값을 출력합니다.   if (!true) {   console.log(\"참이면 거짓\"); // 거짓이므로 출력되지 않음. }  if (!false) {   console.log(\"거짓이면 참\"); }   결과      📄 논리연산자를 이용한 조건부 실행   표현식은 앞을 먼저 평가하고 뒤를 평가합니다.   앞 표현식을 평가를 해서 참 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤의 표현식이 실행됩니다.   n % 5;  // 앞이 참이기 때문에 뒤가 실행이 되지 않음. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");  n = 6;  // 앞이 거짓이기 때문에 뒤가 실행됨. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");   결과    📄 논리연산자 우선순위   논리연산자에는 우선순위가 있습니다.   NOT(!) &gt; AND(&amp;&amp;) &gt; OR(||) 순으로 NOT연산자가 제일 먼저 실행됩니다.   const value = !((true &amp;&amp; false) || (true &amp;&amp; false) || !false);   세가지 논리연산자가 동시에 쓰였지만,   우선순위가 적용되어 value는 false라는 값을 가지게 됩니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","논리연산자"],
        "url": "/javascript/javascript-logical-operator/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] useState 비동기 에러 처리하기",
        "excerpt":"🐞 문제발생   사용자의 프로필을 수정하는 과정에서 useState를 사용해 form을 변경하는데, state가 업데이트 되지 않았다.   ▪ 문제 코드    ... const initialEditForm = {   profileUrl: '',   imageFile: null,   username: '',   imageUrl: '', }  const [memberForm, setMemberForm] = useState(initialEditForm)  ...  const onChangeProfileImg = useCallback(     async (e: ChangeEvent&lt;HTMLElement&gt;) =&gt; {       const ImageFiles = (e.target as HTMLInputElement).files       if (ImageFiles &amp;&amp; ImageFiles[0]) {         const url = URL.createObjectURL(ImageFiles[0])         setMemberForm({ ...memberForm, imageFile: ImageFiles[0] }) // 문제부분         setMemberForm({ ...memberForm, imageUrl: url })       }     },     [imgInputRef],   )    이 부분을 해결하려고 imageFile만 담는 state를 생성했을 때는 값이 바뀌는 것을 확인했는데, 도대체 왜 처음 작성했던 코드에서는 state가 변경되지 않는지 너무 궁금해서 꽤 오래 코드를 수정하고 손봤다.   그래도 해결이 안되서 오키에 질문글을 작성하고 이유를 알 수 있었다.   🔨 문제해결   문제는 useState의 비동기 처리 방식이었다.   useState가 비동기로 동작한다는 것을 어렴풋이 알고있었지만 어떻게 처리가 진행되는지 몰라서 문제가 어디서 발생했는지 정확히 모르고 애먼 코드들만 뜯어보고 답답해했다.  왜 imageUrl은 변경이 적용되고 첫번째 setState를 호출해서 적용한 imageFile은 변경이 안될까?   💡 useState는 비동기적으로 처리가 진행되기 때문에 useState를 두번 호출할 때, 마지막 호출시 처음 state의 변경분은 반영되지 않기 때문이다!   리액트는 성능을 최적화하기 위해 setState가 연속 호출되면 배치처리를 통해 한번에 렌더링한다고 한다.      배치(batch)란? 리액트가 여러개의 state 업데이트를 하나의 리렌더링으로 묶는 것    따라서, 위 코드에서 문제가 발생한 이유는 기존 memberForm에 imageFile이 더해진 상태로 변경된 것이 state에 적용되기 전에 다시 memberForm을 재사용하기 때문에 imageFile에 관한 변경사항이 적용되지 않고 imageUrl이 더해진 값으로 state가 적용되기 때문이었던 것이다.   ▪ 변경된 코드   setMemberForm({ ...memberForm, imageFile: ..., imageUrl: url })   setState를 한번만 호출해서 비동기 상황을 발생시키지 않게 고쳤고, 문제는 해결되었다.  비동기에 관한 삽질은 api통신을 할 때만 생길줄 알았던 내 안일한 생각이 가장 큰 문제였다.  안다고 다 아는게 아니라는 것을 다시 한번 뇌에 새기게 되었다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","useState","비동기"],
        "url": "/coding-swamp/projects-codingswamp-useState-asynchronous/",
        "teaser": null
      },{
        "title": "tsconfig.json 파일 살펴보기",
        "excerpt":"📄 tsconfig.json 파일이란?  tsconfig.json 파일은 타입스크립트 프로젝트에서 타입스크립트에 관한 환경설정을 할 수 있는 타입스크립트 컴파일러 설정파일입니다.   📄 tsconfig.json 파일에서 사용하는 옵션   tsconfig.json 파일에는 다양한 옵션이 있지만, 자주 사용되는 옵션을 정리했습니다.   {   \"compilerOptions\": {     \"module\" :\"CommonJS\",     \"target\": \"es5\",       \"esModuleInterop\": true,                                 \"moduleResolution\": \"node\",                               \"outDir\": \"dist\",     \"baseUrl\": \".\",     \"sourceMap\": true,     \"downlevelIteration\": true,     \"noImplicitAny\": false,     \"paths\": {\"*\": [\"node_modules/*\"]}                                  },   \"include\": [\"src/**/*\"] }       include: 타입스크립트 컴파일러 대상이 되는 경로   ▪ module 키     컴파일된 ES5 자바스크립트 코드는 웹브라우저와 노드제이에스에서 양쪽에서 동작해야 한다.   하지만, 웹브라우저와 노드제이에스는 동작방식이 다르다. (웹 브라우저: amd, 노드제이에스: commonjs )   따라서, module키로 동작 대상 플랫폼이 무엇인지 구분해주는 역할을 한다.   ▪ moduleResolution 키     moduule이 어떤 값을 가지느냐에 따라 다르게 설정된다.   commonjs는 node로 설정하고, amd는 classic으로 설정한다.   ▪ target 키     트랜스파일할 대상 자바스크립트의 버전을 설정한다.   보통 es5를 설정한다.   ▪ baseUrl &amp; OutDir 키     트랜스파일된 자바스크립트 파일을 저장하는 경로   OutDir은 baseUrl 설정값을 기준으로 하위 디렉토리를 뜻한다.   ▪ paths 키     소스 파일의 import 문에서 from 부분을 해석할 때 찾아야 하는 디렉토리를 설정한다.   node-module을 포함한 이유는 찾아야하는 소스가 외부 패키지일 경우를 위해 설정한 것이다.   ▪ esModuleInterop 키     웹 브라우저에서 동작한다는 가정으로 만들어진 오픈소스 자바스크립트 라이브러리가 CommonJS방식으로 동작하는 타입스크립트 코드에서 실행될 수 있도록 설정   ▪ sourceMap 키     소스맵 파일 생성 유무를 설정한다.   소스맵 파일에는 변환된 자바스크립트 코드가 타입스크립트 코드의 어느 부분에 해당하는지 보여준다.   ▪ downlevelIteration 키     타입스크립트의 생성기(generator) 구문이 정상적으로 동작하도록 설정   ▪ nolmplicitAny 키     지정하지 않은 타입을 암시적으로 any로 설정하게 한다.   false로 설정하면 타입을 지정하지 않았을 때, 에러메세지가 표시되지 않고 넘어간다.   참고      Do It 타입스크립트 프로그래밍 (책)  ","categories": ["TypeScript"],
        "tags": ["tsconfig"],
        "url": "/typescript/typescript-tsconfig/",
        "teaser": null
      },{
        "title": "[Leaning Typescript 🦜] system of a clown",
        "excerpt":"🤡 system of a clown      🎈 Help me, please!  I planned an elaborate clown-themed surprise party for my best friend. The whole event was planned using a few files of TypeScript code I’d written.  My friend somehow caught wind of the party and enlisted the clowns’ help to vandalize the program. Not only did the clowns remove or make incorrect my TypeScript type annotations, they introduced subtle bugs by subtly changing some of the values.  Could you please add correct type annotations in my files and fix any bugs detected by TypeScript? You’re my surprise clown celebration’s last hope! 🤡    🎈 도와주라주!  내 베프를 위해 삐에로 컨셉의 깜짝 파티를 준비했어. 모든 이벤트가 내가 쓴 몇개의 타입스크립트 파일로 준비되어 있지.  근데 내 친구가 어떻게든 정보를 들어가지고 프로그램을 파괴하기 위해 삐에로들한테 도움을 요청한거야! 삐에로들은 내 타입스크립트 애너테이션을 지우고 망가뜨리는것 뿐만 아니라, 일부 값들을 교묘하게 바꿔버리며 버그마저 도입해버렸어.  내 파일에 올바른 애너테이션을 추가하고 버그를 잡아줄 수 있어? 너는 내 깜짝 삐에로 파티의 마지막 희망이야! 🤡      타입 애너테이션 (type annotation)? 타입에 주석을 다는 것으로 변수나 함수의 타입을 설정하는 것.  ex) let name: string = ‘sujin’    🎈 Step 1: Clowning Around      The first area of code I’ll need you to fix is the activity assignment engine. It repeatedly creates groups of size 5-10 guests. Each group is directed to go to an activity, which can hold up to a certain number of them at a time.   It looks like the clowns didn’t change too much on this one. They mostly just removed a few type annotations and changed one value.   Could you please add back missing type annotations to avoid evolving or implicit anys, and fix the wrong value?    ▪ 요약: 액티비티 할당 엔진에서 타입 애너테이션을 추가하고 오류난 부분을 고쳐라!   📃 문제 코드   let remainingGuests = 20; while (true) {   // Each group of guests will be size 5-10   const guestsToAssign = Math.floor(Math.random() * 5) + 5;   let activity; // Those were some nice type annotations you had here!   let capacity; // It'd be a shame if we ... *erased* them! 😈   let requiresSupplies;   switch (Math.floor(Math.random() * 5)) {     case 0:       activity = \"balloon animals\";       capacity = 5;       requiresSupplies = true;       break;     case 1:       activity = \"face painting\";       capacity = \"1\";       requiresSupplies = true;       break;     case 2:       activity = \"juggling\";       capacity = 3;       requiresSupplies = true;       break;     default:       activity = \"dancing\";       capacity = 10;       break;   }   console.log(`${guestsToAssign} of us will enjoy ${activity}.`);   for (let i = 0; i &lt; guestsToAssign; i += capacity) {     console.log(`\\t${capacity} will enter the ${activity} activity.`);   }   remainingGuests -= guestsToAssign;   if (remainingGuests &lt; 0) {     break;   }   console.log(`We have ${remainingGuests} remaining guests to entertain.\\n`); } console.log(\"\\nAll done!\"); export {};   문제로 나온 이 코드를 tsc명령어를 이용해 컴파일하면 다음과 같은 오류가 발생합니다.      산술 연산자에 string값이 할당되고 있는 상황입니다.   📃 풀이 과정   오류가 난 부분을 보니, 산술 연산자에 string값이 할당되어 컴파일과정에서 막혀버렸습니다.   해당 변수 capacity를 찾습니다.   switch문안에서 문자열로 되어 있는 capacity를 찾아 숫자로 고칩니다.    case 1:       activity = \"face painting\";       // capacity = \"1\";       capacity = 1; // 수정       requiresSupplies = true;       break;   요구사항대로 변수가 선언된 부분에서 타입 애너테이션도 추가합니다.   let activity; // Those were some nice type annotations you had here! let capacity; // It'd be a shame if we ... *erased* them! 😈 let requiresSupplies;   ✔ 수정된 전체 코드   let remainingGuests = 20;  while (true) {   // Each group of guests will be size 5-10   const guestsToAssign = Math.floor(Math.random() * 5) + 5;   let activity: string; // Those were some nice type annotations you had here!   let capacity: number; // It'd be a shame if we ... *erased* them! 😈   let requiresSupplies: boolean;    switch (Math.floor(Math.random() * 5)) {     case 0:       activity = \"balloon animals\";       capacity = 5;       requiresSupplies = true;       break;     case 1:       activity = \"face painting\";       capacity = 1;       requiresSupplies = true;       break;     case 2:       activity = \"juggling\";       capacity = 3;       requiresSupplies = true;       break;     default:       activity = \"dancing\";       capacity = 10;       break;   }    console.log(`${guestsToAssign} of us will enjoy ${activity}.`);    for (let i = 0; i &lt; guestsToAssign; i += capacity) {     console.log(`\\t${capacity} will enter the ${activity} activity.`);   }    remainingGuests -= guestsToAssign;   if (remainingGuests &lt; 0) {     break;   }    console.log(`We have ${remainingGuests} remaining guests to entertain.\\n`); }  console.log(\"\\nAll done!\");  export {};   🎈 Step 2: Clown Availability      The second and -thank heavens- final area of code I’ll need you to fix is my clown assignment planner. I use this to print which clowns will be partying with which guests.   Oh, and they introduced several unsettling clown puns in comments.  It’s because of those puns that I can’t fix the code myself.  The clowns again changed a few things around, but nothing more than an incorrect type annotation or different value for a variable.  «««&lt; HEAD Could you please fix up the file to have no TypeScript complaints? x ======= Could you please fix up the file to have no TypeScript complaints?    ▪ 요약: 고마운데 일하나 더 해라! 광대 배정 플래너에서 오류를 수정해라!   📄 문제 코드   // Note: I'm planning on inviting 20 guests in total. // Some clowns can only handle a certain number of guests. let guestCount: boolean = 20; let clownsCount = \"zilch!\";  let krustyAvailability = true; let ronaldAvailability = true; let pennywiseAvailability = true;  let matchingsDescription: any = \"\"; let lastClown;  do {   clownsCount += 1;    // Krusty says: I had a one-man show on Broadway...   // That's who showed up, one man!   if (krustyAvailability) {     guestCount -= 10;     krustyAvailability = false;     matchingsDescription += \"Krusty will handle the first ten guests.\\n\";     lastClown = \"Krusty\";     continue;   }    // Ronald says: McDonald's donated a large set of computers to a school...   // They were all Big Macs!   if (ronaldAvailability) {     guestCount -= 5;     ronaldAvailability = false;     matchingsDescription += \"Ronald will handle the next five guests.\\n\";     lastClown = \"Ronald\";     continue;   }    // Pennywise asks: what's a sewer's favorite data type?   // Pennywise answers: Floats!   if (pennywiseAvailability) {     pennywiseAvailability = false;     matchingsDescription += \"Pennywise w̺̞̠i̢͇͙l͇̞l͇͍̘ c͓͕̝o̡̠̞n̼̝s̡̞͎u͉̝͔m͚̪̞e̢͚̝ y̴̡̡͕͌̿́ó̸̢͇͚̾̕u̸̡̡͎͒͛r̸͕͓͖̈́͆͒ s̵̺̘̪͒͆̓o̵̡͚̟̽͆̚u̵̠͖̓͐͝l̸͓̘͇̐̓̚s̸̺͎̽̈́͆.\";     lastClown = \"Pennywise\";     continue;   }    throw new Error(`Oh no! We're out of clowns!`); } while (guestCount &gt; 0);  if (clownsCount &gt; 2) {   console.log(\"We've got a lot of clowns coming!\"); }  if (matchingsDescription.length()) {   console.log(`There will be ${clownsCount} clowns!\\n`);   clownsole.log(matchingsDescription);   console.log(`The last clown is: ${lastClown.toUpperCase()}!`); } else {   console.log(\"Nobody gets a clown. Terrible party. Goodbye.\"); }  export {};   1번 문제보다 많은 오류가 발생했습니다.      📄 풀이과정   ▪ Type 'number' is not assignable to type 'boolean'.   guestCount의 타입이 number인데 boolean으로 타입 애너테이션 설정이 잘못되어 있습니다.   // 문제 코드 let guestCount: boolean = 20;  // 수정된 코드 let guestCount: number = 20;    ▪  Operator '&gt;' cannot be applied types 'string' and 'number'.   clownCount에 산술연산자를 사용하고 있는데 선언부에 보면 문자열을 할당하고 있습니다.   zilch가 무슨 뜻인지 찾아보니 아무것도 없음이라는 뜻이라 값을 할당하지 않았습니다.   let으로 선언되었기 때문에 가능합니다.   // 문제 코드 let clownsCount = \"zilch!\"; ... if (clownsCount &gt; 2) { \tconsole.log(\"We've got a lot of clowns coming!\"); }  // 수정된 코드 let clownCount;      새로운 에러를 만들며 해결되지 않았습니다.   값이 할당되기 전에 산술연산자를 적용할 수 없기 때문입니다.   초기값으로 0을 할당해주었지만, 뭔가 답이 아닐것만 같은 느낌이 드네요.   // 수정된 코드 let clownCount: number = 0;   ▪ Cannot find name 'clownsole'. Did  you mean 'console'?   clownsole은 처음 들어봅니다. 문제가 저를 바보로 아나봅니다. 재밌네요.   // 문제 코드 clownsole.log(matchingsDescription);  // 수정된 코드 let clownCount: number = 0; console.log(matchingsDescription);   끝!   Found 0 errors. Watching for file changes.   📄 고쳐야 할 점   let guestCount = 20; let clownsCount = 0;   솔루션 코드를 보니 타입 애너테이션이 빠져있습니다.   책을 읽을 때 값을 할당할 경우 자동으로 타입추론이 되기 때문에 타입 애너테이션을 설정하면 중복으로 타입설정과정이 진행되는 것과 마찬가지라 불필요한 과정이라고 한 기억이 납니다.   ✔ 값을 할당해 타입추론이 될 경우에는, 타입 애너테이션을 생략하자   그래도 0을 할당하는게 맞았네요 🎉     문제 출처      learning typescript  ","categories": ["TypeScript"],
        "tags": ["learning typescript","러닝 타입스크립트","type system","clowning around"],
        "url": "/typescript/typescript-learning-typescript-clowning-around/",
        "teaser": "/assets%5Cimage%5Clearning-typescript.PNG"
      },{
        "title": "🍸 칵테일 러브 좀비",
        "excerpt":"   ▪ 제목: 칵테일, 러브, 좀비  ▪ 작가: 조예은  ▪ 출판사: 안전가옥  ▪ 독서 기간: ? ~ 2023/03/16  ▪ 읽은 방식: 전자책     칵테일, 러브, 좀비는 4개의 단편소설로 구성된 한국 미스터리소설이다. 반전과 미스테리를 좋아하는 독자라면 필수로 읽어야 하는 작품집이라 생각한다. 그만큼 유명하기도 하다.   수록된 작품 중 가장 인상깊었던 작품을 고르자면 습지와 오버랩 나이프, 나이프라 할 수 있겠는데 이유는 서로 다르다.   습지는 귀신이 나오지만 무섭지 않다. 오히려 긴장감 넘치는 책 분위기 속에서 살짝 긴장을 풀고 차분하게 읽을 수 있는 분위기를 풍기는 내용이다. 미스테리 스릴러 소설이라고 무조건 빠른 호흡과 높은 텐션이 필수일 필요가 없다는 점을 새로이 알게 해준 작품이다.   이에 반해 오버랩 나이프, 나이프는 읽는 내내 책 종이가 넘어가는게 아까울 정도로 빠져들었다. 이때 혼자 카페에 앉아 책을 읽었는데 반전을 맞이할 때마다 표정관리하느라 꽤나 힘들었다. 조예은 작가님의 작품은 스토리가 흔하지 않고 결말이 뻔하지 않다. 작품의 제목조차 처음에는 어떤 뜻인지 알 수 없다. 오버랩 나이프, 나이프. 어떤 내용이 전개될지 도통 알기 힘들다. 작품을 다 읽고 다시 제목을 보았을 때 제목에서 다 알려주고 있다는걸 깨닫고는 무언가 당해버린 기분이 든다. 미루고 미뤘던 젤리장수 대학살도 조만간 읽어야 겠다.  ","categories": ["books"],
        "tags": ["칵테일 러브 좀비","조예은","안전가옥","추리/미스테리"],
        "url": "/books/books-cocktail-love-jombie/",
        "teaser": "/assets%5Cimage%5CPenguin.jpg"
      },{
        "title": "[Leaning Typescript 🦜] Primitive Cooking",
        "excerpt":"🥗 Primitive Cooking      Those pesky Java programmers are at it again!  I wrote a few functions for a friend to help arrange meals when I have guests over. The friend worked with their enterprise application development team to “improve” the code. Next thing I know, they’ve replaced all my TypeScript-y literal and union types with plain old primitive types.  Those Java fans are perfectly good developers -and lovely people- but we don’t see eye-to-eye on type systems. Now TypeScript is reporting type errors on my code. Could you please correct the type annotations in my files – and maybe a couple bugs the improved types helped TypeScript find?    성가신 자바 프로그래머들이 또 시작이야!  나는 친구를 위해 손님들이 왔을 때 식사 준비를 도와줄 수 있도록 몇개의 기능을 작성했어. 친구는 코드를 ✌향상시키기 위해✌ 기업 애플리케이션 개발팀과 일해. 다음으로 내가 아는건, 그 사람들이 내 타입스크립트 코드의 리터럴과 유니언 타입을 오래된 순수 원시 타입으로 바꿨다는 거야.(읽기만 해도 열받음)  이 자바 팬들은 완전 좋은 개발자들이야(게다가 사랑스러움). 하지만 우린(자바와 자바스크립트) 타입 시스템이 일치하지 않잖아. 지금 타입스크립트가 내 코드에서 타입 에러들을 보고하고 있거든. 내 파일들에서 타입 애너테이션들을 올바르게 고쳐줄래?   🍽 Step 1: Ingredients      The first area of code I’ll need you to fix is my ingredients planner. I use this to print what kind of salad greens and dressings to use for meals.  Again, the runtime code is working fine. It’s just the type annotations you’ll need to correct.    ▪ 요약: 샐러드 야채와 드레싱 재료 플래너의 타입 애너테이션을 고쳐라!   📄 문제 코드   // Please correct any type annotation problems here! ✨ let arugula: number; let dressing: string; let lettuce: number; let mealDate: string;  arugula = 2; dressing = \"honey dijon\"; lettuce = undefined; mealDate = new Date(\"September 13, 2021\");  console.log(`We're starting on ${mealDate} with a dressing of ${dressing}.`);  if (arugula) {   console.log(`There are ${arugula} arugula serving(s) for this first meal.`); }  if (lettuce) {   console.log(`There are ${lettuce} lettuce serving(s) for this first meal.`); }  arugula = undefined; dressing = \"balsamic vinaigrette\"; lettuce = 1; mealDate = new Date(\"March 13, 2022\");  console.log(`Next up, a ${mealDate} meal with a dressing of ${dressing}.`);  if (arugula) {   console.log(`This time, there are ${arugula} arugula serving(s).`); }  if (lettuce) {   console.log(`This time, there are ${lettuce} lettuce serving(s).`); }  export {};   코드를 컴파일 하면 다음과 같은 에러가 발생합니다.      📄 풀이 과정   에러 메시지를 보고 변수 선언부에서 유니언 타입으로 타입을 확장해주었습니다.   let arugula: number | undefined; let dressing: string; let lettuce: number | undefined; let mealDate: string | Date;   정답 코드를 보니 고쳐야할 점이 있습니다.   let mealDate: Date;   변수 mealDate는 하나의 타입만 사용합니다.  따라서 유니언 타입을 통해 타입을 확장하는게 아니라, 타입 애너테이션에서 타입을 수정해주면 되는 것이었습니다.  낚였습니다.   🍽 Step 2: Recipes      Those salad ingredients are looking delectable, thank you! Next up is my list of favorite recipes.  It looks like these seem to pass the TypeScript compiler fine as-is. However, there’s a catch: I want to make sure future recipes keep to the same difficulty and group types. Could you please use unions of literal types for them? Both should only have three possible values.  This time, the runtime code is mostly working fine. Except I think I made a typo in one of the group values? You’ll need to fix that. Otherwise it’s just the type annotations you’ll need to correct.    ▪ 요약: 샐러드는 이제 되었으니, 미래의 요리법(?)이 동일한 난이도와 그룹 타입을 갖도록 리터럴 유니언 타입을 사용해라!      작성되는 유니언 타입은 세개의 타입으로 구성됩니다.   📄 문제 코드   이번 문제는 문제 코드를 컴파일해도 에러가 발생하지 않습니다.   목적은 에러 해결이 아닌, 유니언 타입을 사용한 코드 리팩토링입니다.   // Please clarify any overly wide (permissive) type annotations here! ✨ let difficulty: number; let group: string; let title: string;  // Start with something quick and painless to prepare... difficulty = 1; group = \"appetizer\"; title = \"Raspberry Vinaigrette Salad\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  // Next up, a nice hearty dish to center the meal... difficulty = 2; group = \"entree\"; title = \"Cauliflower Steaks\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  // Make a real impact with fancy delectable desserts... difficulty = 3; group = \"dessert\"; title = \"Coconut Chocolate Ganache\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  // Send everyone off with a nice closer. difficulty = 1; group = \"desert\"; title = \"Biscuits and Coffee\"; console.log(`[${group}] ${title}: ${difficulty}/3 difficulty`);  export {};   📄 풀이 과정   정해진 값을 사용하는 변수는 difficulty와 group으로 보입니다.   이 변수들이 사용하는 값을 리터럴 타입으로 사용해서 유니언 타입으로 타입을 구체화 시켜보겠습니다.   let difficulty: 1 | 2 | 3; let group: \"appetizer\" | \"entree\" | \"dessert\"; let title: string;   유니언 타입을 작성하다보니 문제 제공자의 오타가 보입니다.   설마 레시피에 ‘desert(사막)`를 뜻하는 단어를 사용하진 않을 것 같은데요.   정답 코드에는 dessert로 올바르게 작성되어 있습니다.   너무 사소한 실수라 해당 레포에 pr를 날려볼까 고민하다 어떤 사람은 a하나로도 pr를 작성하길래 pr를 작성해보기로 결심했습니다.   아니면 조슈아 골든버그씨가 말해주겠죠.   🖇 인생 처음 오픈소스 PR   🍽 Step3: Seating      You’re doing wonderfully, my friend. I can’t wait to invite you to my next fancy dinner party.  Speaking of which, I need to properly type the program to randomize invitations and seat assignments. My friends can be kind of childish -they’re babies, really- and are very picky about seating.  I also very much like what you did with the string literal union types in the last step. Could you please avoid using the string type altogether in this one? Just use literal types.  Oh, and I think there’s a typo in one of the names here too.    ▪ 요약: 저번 step에서 네가 만든 string 리터럴 유니언 타입 맘에 들었어. 이번엔 string타입을 사용하지말고 리터럴 타입만 사용해서 타입을 완성시켜봐라!   📄 문제 코드   // Please fill in any missing type annotations here... const headOfTable = \"Me!\"; let adjacentLeft; let adjacentRight; let furtherLeft; let furtherRight;  // I always invite Susie and Tommy! ♥ if (Math.random() &gt; 0.5) {   adjacentLeft = \"Susie\";   adjacentRight = \"Tommy\"; } else {   adjacentLeft = \"Tommy\";   adjacentRight = \"Susie\"; }  // I invite Angelica about half of the time. We're not as close as Susie and Tommy. It's a long story. // I try to fill `furtherLeft` first... if (Math.random() &gt; 0.5) {   furtherLeft = \"Angelica\"; }  // Same with Chuckie. I like them, but do I *really* like hanging out with them? Only sometimes. // ...then after that `furtherRight` if (Math.random() &gt; 0.5) {   if (furtherLeft) {     furtherRight = \"Chuckie\";   } else {     furtherLeft = \"Chuckie\";   } }  // If I invited Angelica but not Chuckie, I'll invite Kimi. They get along well with Angelica but not Chuckie. if (furtherLeft === \"Angelica\" &amp;&amp; furtherRight !== \"Chuckie\") {   furtherRight = \"Kimi\"; }  // If I invited Chuckie but not Angelica, I'll invite Timmy. They get along well with Chuckie but not Angelica. if (furtherLeft === \"Chuckie\") {   furtherRight = \"Timmy\"; }  console.log(`At the head of the table is... ${headOfTable}`);  console.log(`Adjacent to the left is: ${adjacentLeft}`); console.log(`Adjacent to the right is: ${adjacentRight}`);  console.log(`Further down on the left is: ${adjacentLeft ?? \"nobody\"}`); console.log(`Further down on the right is: ${adjacentRight ?? \"nobody\"}`);  export {};   📄 풀이 과정   변수 선언부를 보니 초깃값이 설정되어 있지 않아, 타입이 any로 추론되고 있습니다.   변수 선언부에서 리터럴 타입으로 각각 타입을 설정합니다.   let adjacentLeft: \"Susie\" | \"Tommy\"; let adjacentRight: \"Susie\" | \"Tommy\"; let furtherLeft: \"Angelica\" | \"Chuckie\"; let furtherRight: \"Kimi\" | \"Timmy\" | \"Chuckie\";      값이 할당되기 전에 사용되어 에러를 발생시킵니다.   값이 할당되지 않은 변수를 위해 undefined 타입을 명시적으로 추가해주었습니다.   let furtherLeft: \"Angelica\" | \"Chuckie\" | undefined; let furtherRight: \"Kimi\" | \"Timmy\" | \"Chuckie\" | undefined;   문제 출처      learning typescript  ","categories": ["TypeScript"],
        "tags": ["learning typescript","러닝 타입스크립트","Primitive Cooking","유니언 타입","리터럴 타입"],
        "url": "/typescript/typescript-learning-typescript-primitive-cooking/",
        "teaser": "/assets%5Cimage%5Clearning-typescript.PNG"
      },{
        "title": "같은 숫자는 싫어",
        "excerpt":"문제 📄   배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,      arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.   arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.   배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.   나의 풀이 #1 🙋‍♀️   function solution(arr) {   return arr.filter((value, index) =&gt; value !== arr[index + 1]); }   프로그래머스 문제를 풀어보기 시작하고 처음으로 정답다운 풀이가 나온 느낌입니다.   filter함수를 사용해서 배열을 순환하며 해당 값과 바로 오른쪽의 값을 비교하며 같지 않은 값만 모아놓은 배열을 새로 생성했습니다.   마지막 값은 undefined와 비교하기 때문에 새로운 배열에 무조건 들어가게 됩니다.   나의 풀이 #2 🙋‍♀️   문제를 보고 바로 filter함수를 사용하면 되겠다 싶었는데 문제 옆에 스택/큐라고 쓰여 있어 스택 큐를 떠올리며 다시 풀어봤습니다.   function solution(arr) {   let answer = []; // 1   for (let i = 0; i &lt; arr.length; i++) {     arr[i] === arr[i + 1] ? \"\" : answer.push(arr[i]); // 2   }   return answer; }      정답에 해당하는 값만 담을 새로운 배열 answer을 생성합니다.   반복문을 돌려 해당 값과 오른쪽의 값을 비교하여 값이 다른 경우에만 새로운 배열(answer)에 담아 반환해줍니다.   Best Practice 👍   function solution(arr) {   var answer = [arr[0]];    for (let i = 1; i &lt; arr.length; i++) {     if (answer[answer.length - 1] !== arr[i]) {       answer.push(arr[i]);     }   }    return answer; }   다른 분의 풀이를 보니 비교한 값이 다른 경우만 생각해도 된다는 것을 알았습니다.   굳이 제 풀이처럼 삼항연산자를 쓰지 않아도 되는 것이었습니다.   왠지 삼항연산자에 집착이 생겨버려 자꾸 쓰게 되네요.   불필요한 습관을 버려야겠습니다.   문제 출처  ","categories": ["programmers-lv1"],
        "tags": ["filter","스택","큐"],
        "url": "/programmers-lv1/programmers-I-don't-want-the-same-number/",
        "teaser": null
      },{
        "title": "가운데 글자 가져오기",
        "excerpt":"문제 📖   단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.      s는 길이가 1 이상, 100이하인 스트링입니다.   🙋‍♀️ 나의 풀이   function solution(s) {   const stringToArray = [...s]; // 1   const target = s.length / 2; // 2    if (s.length % 2 === 0) {     // 3     return stringToArray[target - 1] + stringToArray[target];   }    return stringToArray[Math.floor(target)]; // 4 }      문자열을 배열(stringToArray)로 바꾼다.   배열의 크기를 2로 나눈 수(target)를 구한다.   stringToArray가 짝수면 target과 직전의 값을 인덱스로 하는 값을 함께 반환한다.   아니면 target을 반내림해서 하나의 값만 반환한다.   이번 문제는 간단해서 1분도 안되어 풀었지만, 오히려 이런 문제에서 고수는 드러나기 마련입니다.   그리고 당연하게도 저는 아직 초보자임이 들통나버립니다.   🔨 Best Practice   function solution(s) {   return s.substr(Math.ceil(s.length / 2) - 1, s.length % 2 === 0 ? 2 : 1); }   왜 삼항연산자를 사용할 생각을 못했을까요.   새로운 subString()이라는 자바스크립트 문법을 하나 알아갑니다.   📌 substr이라는 자바스크립트 문법이 인상적이어서 가져왔는데 댓글을 보니 미래에 삭제되니 subString()으로 대체해서 사용하라고 알려주네요.   🔖 subString()   subString()은 문자열을 인덱스를 기준으로 자를 수 있는 메소드 입니다.   str.substring(시작 인덱스, 마지막 인덱스(옵션));   시작 인덱스는 해당 인덱스를 포함하지만, 마지막 인덱스를 해당 인덱스까지 포함하지 않고 직전까지 잘라내기 때문에 헷갈리지 말아야 합니다.   const str = \"Mozilla\";  console.log(str.substring(1, 3)); console.log(str.substring(3, 1)); // Expected output: \"oz\"  console.log(str.substring(2)); // Expected output: \"zilla\"  console.log(str.substring(2, 2)); // Expected output: \"\"   만약, 마지막 인덱스보다 시작 인덱스가 크다면 알아서 순서를 바꿔서 메소드가 동작합니다.   시작 인덱스와 마지막 인덱스가 같다면 빈 문자열을 반환합니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["filter","스택","큐"],
        "url": "/programmers-lv1/programmers-Import-Intermediate-Characters/",
        "teaser": null
      },{
        "title": "JadenCase 문자열 만들기",
        "excerpt":"📄 문제   JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고) 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.      s는 길이 1 이상 200 이하인 문자열입니다.   s는 알파벳과 숫자, 공백문자(“ “)로 이루어져 있습니다.            숫자는 단어의 첫 문자로만 나옵니다.       숫자로만 이루어진 단어는 없습니다.       공백문자가 연속해서 나올 수 있습니다.           🙋‍♀️ 나의 풀이   function solution(s) {   const arr = s.toLowerCase().split(\" \");    const answer = arr.map((value) =&gt;     value ? value[0].toUpperCase() + value.substring(1) : \"\"   );    return answer.join(\" \"); }   이 문제에는 함정이 있습니다.   공백문자가 연속해서 나올 수 있습니다.   문제를 제대로 읽지 않으면 무엇 때문에 통과할 수 없는지 알 수 없습니다.   제 경험담입니다 :)   제가 푼 순서는 다음과 같습니다.      주어진 문자열을 모두 소문자로 바꾸고 공백을 기준으로 배열(arr)을 생성한다.   생성된 배열을 순환해 첫 글자를 대문자로 바꿔줍니다.   첫 글자가 대문자로 바뀐 문자열들이 담긴 배열을 다시 문자열로 바꿔 반환합니다.   2번 과정에서 공백문자가 연속으로 나올 가능성도 생각해야 합니다.   빈 문자열에 인덱스로 접근할 경우 undefined를 반환하기 때문에 toUpperCase에서 런타임 오류를 발생시킵니다.   문자열을 배열로 바꾼 arr의 요소가 공백문자일 경우 바로 넘어가도록 삼항연산자를 사용했습니다.   🔨 Best Practice   function solution(s) {   return s     .split(\" \")     .map((v) =&gt; v.charAt(0).toUpperCase() + v.substring(1).toLowerCase())     .join(\" \"); }   공백 문자를 해결하는 방법에 charAt이 있었습니다.   charAt은 해당 인덱스에 위치한 문자열을 반환합니다.   따라서 빈 문자열에 charAt으로 접근할 경우 똑같이 빈 문자열을 반환하기 때문에 문제가 일어나지 않는 것입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["프로그래머스","JadenCase 문자열 만들기"],
        "url": "/programmers-lv2/programmers-jadencase/",
        "teaser": null
      },{
        "title": "👩‍💻 개발자의 글쓰기",
        "excerpt":"    ▪ 제목: 개발자의 글쓰기  ▪ 작가: 김철수  ▪ 출판사: 위키북스  ▪ 독서 기간: 2023/03/29 ~ ing  ▪ 읽은 방식: 종이책     원래 독서기록을 쓸 때는 자유형식으로 쓰지만, 이 책은 글 쓰는 스킬을 정리해두면 두고두고 볼 것 같아 정리합니다. 전체 내용을 정리한 것이 아니라 글 작성자에게 필요한 개념을 주로 정리했습니다.   📄 1장 개발자가 알아야 할 글쓰기 기본   문장을 구조화 하는 법   핵심을 말하고 부가 설명을 해라.   나는 김수진이다. 글쓰기를 좋아하는 웹 개발자 취준생이다.   서술식, 개조식, 도식의 차이      서술식            ~다.       소설, 신문, 개발 가이드문서           개조식            명사형 종결어미       릴리스 문서나 장애 보고서       글머리 기호를 활용           도식            중복이나 누락이 많은 경우       각 항목이나 사항의 관계를 명확히 규정하고 싶은 경우           변수나 함수 영어 단어 선택 팁      create: 정해진 틀이 없을 때 틀을 만들기 위해 사용        resister: 정해진 틀에 값을 넣을 때 사용.       change: 단순히 내용을 바꾸는 경우에 사용   modify: 잘못된 것을 바로잡을 때 사용   revise: 기존에 없던 새로운 정보나 아이디어를 덧붙일 때 사용   📄 2장 개발 시간을 줄여주는 이름 짓기와 주석 쓰기   책 읽는 중… 📖  ","categories": ["books"],
        "tags": ["개발자의 글쓰기","IT서적","김철수","위키북스"],
        "url": "/books/books-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "Sass (Syntactically Awesome StyleSheets)",
        "excerpt":"Sass의 수요가 높아지고, 많이들 사용하는 추세라 배워보고 싶었는데 생각보다 공부하고 프로젝트에 적용시키기가 어려웠습니다.   프로젝트를 진행하는 경우에 Sass를 사용해 보고 싶었지만, 빌드된 CSS파일 관리를 어떻게 해야할지 몰라 결국 익숙한 styled-components로 사용하기도 했습니다.   예전에 웹 공부를 시작할때 기초 강의로 도움을 받았던 유노코딩님의 Sass 강의가 열려 재밌게 공부하고 정리한 내용입니다.   📄 Sass란 무엇인가?   Sass는 css를 효율적으로 작성하기 위한 CSS 전처리기 언어입니다.  전처리기는 ‘전에 처리한다’라고 이해하면 쉽습니다.  css가 되기 전에 Sass구문으로 작성해 처리하기 때문입니다.  css는 코드가 커질수록 유지보수가 복잡해집니다.  Sass는 이를 보완하기 위해 등장하였으며, 코드를 수정하거나 재사용하기에도 굉장히 편리합니다.   정리하자면 CSS를 읽기도 좋고 쓰기에도 좋게 사용하기 위해 만들어진 CSS 전처리기 언어입니다.   ▪ Sass 동작 방식   Sass의 동작 방식은 다음과 같습니다.      Sass 구문에 맞게 코드를 작성한다.   Sass 전처리기에 의해 CSS 코드로 변환(컴파일)된다.   변환을 마치고, CSS 파일이 생성된다.(빌드)   ▪ SCSS 이란?   SCSS는 Sass의 하위 개념입니다.  Sass 구문과 동일한 기능을 제공하는데 사용하기 좋아 SCSS구문의 수요가 더 높은 편입니다.   👾 scss로 작성한 코드   $font-stack: Helvetica, sans-serif; $primary-color: #333;  body {   font: 100% $font-stack;   color: $primary-color; }   👾 sass로 작성한 코드   $font-stack: Helvetica, sans-serif; $primary-color: #333;  body   font: 100% $font-stack;   color: $primary-color;    Sass로 작성하나 SCSS로 작성하나 결과는 같지만 SCSS구문이 더 가독성있고 친숙한 느낌을 줍니다.   // 결과  body {   font: 100% $font-stack;   color: $primary-color; }   📄 Sass 준비하기   ▪ Live Sass Compiler 설치하기   scss 코드의 변경 사항을 자동으로 감지해 저장할 때마다 새롭게 빌드를 진행하게 해주는 vscode extension입니다.      SCSS파일을 생성 후 vscode 하단에 있는 Live Sass Compiler 버튼을 클릭하면 실행됩니다.      ▪ 명령행 인터페이스 사용하기   명령행은 명령 프롬프트나 터미널을 뜻합니다.  명령행에서 명령어를 입력해 Sass 컴파일을 진행할 수 있습니다.  node.js가 설치되어 있어야 합니다..    ✔ Sass 명령행 인터페이스 설치하기   npm install -g sass  // 설치 확인하기 sass --version       ✔ Sass파일을 css파일로 컴파일하기   아래와 같이 컴파일을 진행하면 style폴더에 main.css 파일이 생성되어 컴파일됩니다.   sass style/main.scss:style/main.css // style/main.scss를 style/main.css로 컴파일한다.  // live Sass Compiler처럼 자동으로 변경사항 감지하는 옵션 추가 sass --watch  style/main.scss:style/main.css   css에서 기존 중괄호와 들여쓰기가 포함된 css스타일을 extend 스타일이라고 부릅니다.  extend 스타일은 가독성엔 좋지만 직접 css를 다루지 않는 경우엔 가독성이 필요가 없으니 파일이 큰 경우 용량에 부담이 됩니다.  compressed옵션은 그러한 단점을 보완해 코드를 공백없이 압축해 줍니다.   sass --style compressed style/main.scss:style/main.css       ✔ extend 스타일   h1 {   color: black;   background-color: yellow; }   ✔ compressed 스타일   h1 {color: #fff;background-color: #ff0;}   📄 주석과 중첩(nestring)   ▪ 주석   주석 1: 여러 줄 짜리 주석   /* 여러 줄 짜리 주석*/   주석 2: 한 줄 짜리 주석   // 한 줄 짜리 주석   Scss에서 주석을 사용하는 방법은 두가지 입니다.  한 줄 짜리 주석은 컴파일된 css파일에 반영되지 않지만, 기존 css 주석은 최종 css 파일에도 반영된다는 차이점을 가지고 있습니다.   ▪ 중첩 규칙 (nesting)   css를 작성하는 경우 선택자를 서로 다른 선언문에서 반복해야 하는 경우가 있습니다.  Sass에서는 선택자를 반복하지 않고 중첩해 사용할 수 있습니다.   div {   width: 100px;   height: 100px;    p {     color: red;      span {       color: blue;     }   } }   컴파일 후 결과 파일에는 선택자가 따로 생성되어 반영된다.   div {   width: 100px;   height: 100px; } div p {   color: red; } div p span {   color: blue; }     ✔ 단축 속성 중첩   Sass의 단축 속성 중첩은 ‘네입스페이스 속성 중첩’이라고도 부릅니다.   아래 코드는 font의 속성들을 중첩으로 정의한 예시입니다.   p {   font: {     family: sans-serif;     size: 1rem;     style: normal;     weight: 900;   } }     ✔ 상위 선택자 참조 (&amp;)   기호 &amp;사용하면 중첩된 선언문안에서 상위 선택자를 참조할 수 있습니다.  의사클래스를 선택하고자 할 때 유용합니다.   .first-btn {   &amp;:hover {     background: {       color: red;     }   } }   📄 변수   Sass에서는 $를 사용해 변수를 만들어 데이터를 저장하고 사용할 수 있습니다.  생성된 변수는 최종 CSS파일에서 표시되지 않습니다.   $main-color: orange; $font-color: white;  button {   &amp;:nth-child(1) {     color: $font-color;     background-color: $main-color;     width: 100px;   }   &amp;:nth-child(2) {     color: $font-color;     background-color: $main-color;     width: 200px;   }   &amp;:nth-child(3) {     color: $font-color;     background-color: $main-color;     width: 300px;   } }   ▪ SCSS 변수 사용 규칙      개수 제한은 없지만, 가독성을 해치니 남용하지 않는다.   변수명에는 영문자, 숫자, -, _를 사용하며 가능한 직관적인 이름을 사용한다.   📄 믹스인 (mixin)   믹스인은 사이트 전체에서 재사용할 스타일 그룹을 정의하기 위해 사용하는 문법입니다.   ▪ 믹스인 정의하기   믹스인을 정의할 때 인자를 함께 정의하면, 믹스인 호출 시에 상황에 따라 값을 다르게 주어 사용할 수 있습니다.  인자를 정의할 때 기본값은 옵션으로 설정합니다.  정의된 믹스인은 최종 CSS파일에 포함되지 않습니다.   @mixin box-style($bg-color: yellow, $font-color: green) {   width: 100px;   height: 100px;   display: flex;   justify-content: center;   align-items: center;   background-color: $bg-color;   color: $font-color; }   ▪ 믹스인 사용하기   정의된 믹스인을 사용하고자 할땐 @include지시어를 사용합니다.   .one {   @include box-style(); }  .two {   @include box-style(purple, yellow); }   📄 @content   @content는 믹스인의 인자로 단순한 변수가 아닌 스타일 블록 전체를 넘길 때 사용하는 문법입니다.  인자와 스타일 블록을 모두 전달받는 형태의 믹스인을 정의할 수도 있습니다.   @mixin btn-style($hv-color) {   @content;   width: 100px;   height: 25px;    &amp;:hover {     background-color: $hv-color;   } }  .one {   @include btn-style(orange) {     color: white;     background-color: tomato;   } }  .two {   @include btn-style(green) {     color: red;     background-color: teal;   } }   📄 여러개의 .scss파일을 하나의 .css파일로 관리하기   여러개의 .scss파일이 우후죽순 생겨날 때 이를 관리하는 방법이 있습니다.  모든 scss파일을 하나의 css파일로 보내버리는 것이 아니라,   하나의 main.scss파일에서 각 기능을 담당하는 scss파일을 @import해서 사용하는 방법입니다.   이때 주의해야할 점은 mains.scss파일이 아닌 scss파일의 이름은 언더바로 시작해야 컴파일 대상에서 제외된다는 사실입니다.&lt;/br&gt; @import지시자를 사용할 때는 언더바를 제거하고 사용합니다.   //main.scss  @import \"variables.scss\"; @import \"mixins.scss\";  div {   @include box($main-color); }   이렇게 CSS파일을 하나로 만들게 된다면      HTML과 CSS 문서 간 연결 횟수가 줄어 웹사이트 성능 개선에 도움이 되고   scss파일을 기능별로 분리할 수 있어 보기도 좋고 재사용하기도 좋습니다.   📄 스타일 중복을 피하는 방법 @extend   @extend지시자는 기존의 스타일을 확장해서 다른 클래스에서 쓰고 싶을 때 사용합니다.   .message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   @extend .message;   background: #f05; }   mixin과 비슷하지만, 저는 mixin은 규격을 설정하는 것이고 extend는 확장을 위해 사용하는 것이라고 이해했습니다.   실제로 컴파일된 결과도 mixin과 다릅니다.   .message, .bad-message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   background: #f05; }   @exclue를 사용해 컴파일된 결과를 보면 속성들을 사용하고 있는 클래스 네임이 쉼표와 함께 열거되고 있는 것을 확인할 수 있습니다.   유령 클래스(공식 명칭은 아닙니다.)를 사용해 컴파일 되었을 때 기존 클래스는 노출되지 않으면서 재사용한 클래스만 보여주는 방법도 있습니다.  유령 클래스는 %기호를 사용합니다.   %message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   @extend %message;   background: #f05; }   컴파일 된 결과를 확인하면 유령클래스의 이름은 노출되지 않고 있는 것을 확인할 수 있습니다.   .bad-message {   padding: 8px;   text-transform: uppercase;   text-align: center;   color: #fff;   background: #5f0; }  .bad-message {   background: #f05; }   📄 조건문을 사용해 코드의 흐름 제어하기   Sass에서는 @if 지시자를 이용해 조건을 설정할 수 있습니다.&lt;/br&gt; 아래 예시는 mixin안에 조건문을 설정한 경우입니다.&lt;/br&gt; @else 지시자를 사용하면 @if문이 불만족할 경우의 속성을 설정할 수 있습니다.   @mixin select-color($color) {   @if $color == blue {     color: blue;   } @else {     color: tomato;   } }  h1 {   @include select-color((red)); }   Sass에서 조건문은 웹사이트를 개발하는 단계보다는 라이브러리를 만드는 경우에 더 자주 사용된다고 합니다.   📄 미디어 쿼리   미디어 쿼리는 반응형 웹을 만들 때 사용되는 필수 문법입니다.  Sass에서 미디어 쿼리를 사용할 때 문자열을 변수로 사용하는 경우가 있는데 이때 문자열 삽입용 기호인 #{}를 사용해야 합니다.   $width-small: \"all and (min-width: 300px)\"; $width-medium: \"all and (min-width: 600px)\"; $width-large: \"all and (min-width: 900px)\";  div {   width: 100px;   height: 100px;    @media #{$width-small} {     background-color: cadetblue;   }    @media #{$width-medium} {     background-color: orange;   }    @media #{$width-large} {     background-color: purple;   } }     출처           유노코딩            실습을 진행한 깃허브 레파지토리      ","categories": ["CSS"],
        "tags": ["Sass"],
        "url": "/css/css-Sass/",
        "teaser": null
      },{
        "title": "[Lv 2] 올바른 괄호",
        "excerpt":"📄 문제   괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어   ”()()” 또는 “(())()” 는 올바른 괄호입니다. “)()(“ 또는 “(()(“ 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.      문자열 s의 길이 : 100,000 이하의 자연수   문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   let sum = 0;   for (let i = 0; i &lt; s.length; i++) {     // 1     if (s[i] === \"(\") sum += 1; // 2     if (s[i] === \")\") sum -= 1; // 3      if (sum &lt; 0) return false; // 4   }   return sum === 0; // 5 }   제가 생각한 풀이는 이렇습니다.      주어진 문자열을 순환한다.   ( 은 +1을 sum에 누적한다.   (은 -1을 sum에 누적한다.   누적된 값이 음수인 경우는 올바르지 않은 괄호이므로 false를 반환한다.   최종 누적된 sum이 0인지 진위값을 반환한다.   이 문제를 처음 보고 어떻게 접근할지 감이 잘 안와서 시간이 약간 걸렸습니다.   자료구조 공부가 부족한 탓일까요.   꾸준히 문제를 풀어야 하는 필요를 다시 한번 생각하게 됩니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["올바른 괄호","스택/큐"],
        "url": "/programmers-lv2/programmer-%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8/",
        "teaser": null
      },{
        "title": "x만큼 간격이 있는 n개의 숫자",
        "excerpt":"📄 문제   함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.      x는 -10000000 이상, 10000000 이하인 정수입니다.   n은 1000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(x, n) {   let answer = []; // 1    for (let i = 1; i &lt; n + 1; i++) {     answer.push(x * i); // 2   }   return answer; }      정답으로 반환할 배열 answer을 생성합니다.   for문을 돌려 배열 내장함수인 push를 이용해 배열에 x만큼 더해준 값을 삽입합니다.   👍 Best Practice   function solution(x, n) {   return Array(n)     .fill(x)     .map((v, i) =&gt; (i + 1) * v); }   아예 미리 x로 채워진 배열을 생성후 map을 이용해 값을 변경해준 답안입니다.   한줄로 훨씬 깔끔하지만 성능은 for문으로 하는게 더 좋다고 합니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["x만큼 간격이 있는 n개의 숫자"],
        "url": "/programmers-lv1/programmers-x%EB%A7%8C%ED%81%BC-%EA%B0%84%EA%B2%A9%EC%9D%B4-%EC%9E%88%EB%8A%94-n%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Lv 1] 문자열 내 p와 y의 개수",
        "excerpt":"📄 문제   대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.   예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다.      문자열 s의 길이 : 50 이하의 자연수   문자열 s는 알파벳으로만 이루어져 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   return (     s.toLowerCase().split(\"p\").length - 1 ===     s.toLowerCase().split(\"y\").length - 1   ); }   문자열을 소문자로 바꾸고 p와 y를 기준으로 잘라 크기를 구한 후 1를 빼주면 각 문자가 몇개 들어있는지 알 수 있습니다.   pPoooyY의 경우 toLowerCase()를 통해 소문자로 바꾸면 ppoooyy가 됩니다.   이후 p를 기준을 문자열을 split()메소드를 이용해 잘라내면 [\"\", \"\", \"oooyy\"]가 됩니다.   이 배열의 크기는 3인데 여기서 1을 빼면 p의 개수를 알 수 있습니다.   👍 Best Practice   function numPY(s) {   return s.match(/p/gi).length == s.match(/y/gi).length; }   이 답안은 match()라는 메소드를 이용했네요.   이번에 처음으로 알아갑니다.   📌 match()는 특정 문자열를 추출하여 배열로 반환해주는 메소드입니다.   그런데 이 코드는 문제가 있습니다.   p와 y가 없을 때 match()가 null을 반환해서 length함수를 쓸 수 없기 때문에 다음과 같은 컴파일 에러가 납니다.    Cannot read properties of null (reading 'length')   이 부분을 해결해보기 위해 옵셔널 체이닝을 걸어주겠습니다.   function numPY(s) {   return s.match(/p/gi)?.length == s.match(/y/gi)?.length; }   이렇게 되면 undefined === undefined가 되어 true를 반환해 에러없이 통과할 수 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["문자열 내 p와 y의 개수","match"],
        "url": "/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-p%EC%99%80-y%EC%9D%98-%EA%B0%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "[Lv 2] 최솟값 만들기",
        "excerpt":"📄 문제   길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)   예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면      A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)   A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)   A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)   즉, 이 경우가 최소가 되므로 29를 return 합니다.   배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.      배열 A, B의 크기 : 1,000 이하의 자연수   배열 A, B의 원소의 크기 : 1,000 이하의 자연수   🙋‍♀️ 나의 풀이   function solution(A, B) {   const newA = A.sort((a, b) =&gt; a - b);   const newB = B.sort((a, b) =&gt; b - a);   let answer = 0;   for (let i = 0; i &lt; A.length; i++) {     answer += newA[i] * newB[i];   }   return answer; }   이번 문제를 통해 숫자를 오름차순, 내림차순 하는 법을 공부했습니다.   곱셈한 값의 누적결과가 최솟값이 되려면 가장 작은 수 x 가장 큰 수가 되어야 하기 때문입니다.   따라서 A는 오름차순으로 B는 내림차순으로 정렬해 인덱스가 일치하는 값끼리 곱셈해주었습니다.   👍 Best Practice   function solution(A, B) {   A.sort((a, b) =&gt; a - b);   B.sort((a, b) =&gt; b - a);   return A.reduce((total, val, idx) =&gt; total + val * B[idx], 0); }   reduce메소드를 사용한 풀이입니다.   reduce메소드를 배열 하나에만 적용할 수 있다는 생각에 시도하지 않았는데 이렇게도 접근이 가능하네요 👍   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["최솟값 만들기","reduce"],
        "url": "/programmers-lv2/programmers-%EC%B5%9C%EC%86%9F%EA%B0%92-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 1] 나머지가 1이 되는 수 찾기",
        "excerpt":"📄 문제   자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.      3 ≤ n ≤ 1,000,000   🙋‍♀️ 나의 풀이   function solution(n) {   for (let i = 0; i &lt; n; i++) {     if (n % i === 1) return i;   } }   for문으로 반복문을 돌려 나머지가 1이 되면 바로 값을 반환했습니다.   👍 Best Practice   function solution(n, x = 1) {   while (x++) {     if (n % x === 1) {       return x;     }   } }   증감연산자를 for문뿐만 아니라 while문에서 사용해 반복문을 돌릴 수 있다는 걸 배워갑니다.   문제 출처      프로그래머스 - 나머지가 1이 되는 수 찾기  ","categories": ["programmers-lv1"],
        "tags": ["나머지가 1이 되는 수 찾기"],
        "url": "/programmers-lv1/programmers-%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%80-1%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 2] 이진 변환 반복하기",
        "excerpt":"📄 문제   0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.   x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 “c를 2진법으로 표현한 문자열”로 바꿉니다. 예를 들어, x = “0111010”이라면, x에 이진 변환을 가하면 x = “0111010” -&gt; “1111” -&gt; “100” 이 됩니다.   0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 “1”이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.      s의 길이는 1 이상 150,000 이하입니다.   s에는 ‘1’이 최소 하나 이상 포함되어 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   let binaryTransforms = s;   let NumberOfZero = 0;   for (let i = 0; i &lt; s.length; i++) {     // NumberOfZero += binaryTransforms.match(/0/gi)?.length; 🚨 Error!     NumberOfZero += binaryTransforms.split(\"0\").length;     binaryTransforms = binaryTransforms?.match(/1/gi).length.toString(2);      if (binaryTransforms === \"1\") return [i + 1, NumberOfZero];   } }   저번에 공부한 match()라는 메소드를 야무지게 써먹어 보았습니다.   그런데 문자열에서 0만 뽑아오는 binaryTransform이 0이 없을 때 null을 뱉어 NumberOfZero이 Nan이라는 결과를 뱉습니다.   이를 해결하기 위해 split()메소드를 사용해 무조건 값이 나오게 만들어 length 속성을 사용할 수 있도록 작성했습니다.   👍 Best Practice   function solution(s) {   var answer = [0, 0];   while (s.length &gt; 1) {     answer[0]++;     answer[1] += (s.match(/0/g) || []).length;     s = s.replace(/0/g, \"\").length.toString(2);   }   return answer; }   제가 많은 것들을 놓치고 있었네요.      명확한 조건이 있음에도 의미 없이 for문을 사용   OR 연산자를 사용해 조건을 걸어 length 사용 가능   답을 무조건 변수에 넣는다고 좋은 것이 아님   저는 다른것보다 답을 배열에 넣어놓은 부분이 마음에 들었습니다.   반환되는 값이 어떤 역할을 하는지 명확히 하려고 변수에 담았는데 오히려 여기서 보여주는 답안이 answer이 하는 역할을 더 잘 보여주는 것 같습니다.   또하나 인상적인 점은 string 메소드인 replace()를 사용했다는 것입니다.   📌 String.prototype.replace(): 문자열을 치환할 수 있다. str.replace(해당 문자열 || 정규식, 치환할 문자열 || 함수)    이녀석도 기억해서 다음 문제에 사용하게 된다면 야무지게 써먹어보겠습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["이진수","replace"],
        "url": "/programmers-lv2/programmers-%EC%9D%B4%EC%A7%84-%EB%B3%80%ED%99%98-%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 2] 숫자의 표현",
        "excerpt":"📄 문제   Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.      1 + 2 + 3 + 4 + 5 = 15   4 + 5 + 6 = 15   7 + 8 = 15   15 = 15   자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.      n은 10,000 이하의 자연수 입니다.   🙋‍♀️ 나의 풀이 1   function solution(n) {   let answer = 1;   let acc = 0;   for (let i = 1; i &lt;= n / 2; i++) {     for (let j = i; j &lt;= n; j++) {       acc += j;       if (acc &gt; n) break;       if (acc == n) {         answer++;         acc = 0;         break;       }     }     acc = 0;   }   return answer; }   처음에 for문을 돌려 연속된 수의 합을 구했는데 정확성 테스트는 통과했지만 효율성 테스트에서 모두 막혔습니다.   어떻게든 넘어가려고 if문에 i 조건까지 수정했는데 통과할 수 없어 풀이 과정 자체에 대해 다시 생각했습니다.   🙋‍♀️ 나의 풀이 2   function solution(n) {   let answer = 0;   for (let i = 1; i &lt;= n; i++) {     if (n % i === 0 &amp;&amp; i % 2 === 1) answer++;   }   return answer; }   연속된 수의 합을 구하는 방법을 찾던 중 다음과 같은 방법을 찾았습니다.      자연수의 소수 중 홀수의 개수는 연속된 자연수의 합이 나올 수 있는 개수와 같다.    예를 들어,   15의 약수는 [1, 3, 5, 15]입니다.      1의 경우, 연속하는 1개의 자연수로 표현 가능 =&gt; 15   3의 경우, 연속하는 3개의 자연수로 표현 가능 =&gt; 3+4+5   5의 경우, 연속하는 5개의 자연수로 표현 가능 =&gt; 1+2+3+4+5   15의 경우, 모든 홀수는 n과 n+1로 표현가능 =&gt; 7+8   이 풀이에서는 공식을 사용했기 때문에 for문이 한번만 돌아가 효율성 테스트를 모두 통과할 수 있었습니다.   다른 문제보다 수학적 지식이 요구되었던 문제였던것 같은데 정답률(73%)이 높네요.   원래 수학은 졸업하면 까먹는건데…  ","categories": ["programmers-lv2"],
        "tags": ["숫자의 표현"],
        "url": "/programmers-lv2/programmers-%EC%88%AB%EC%9E%90%EC%9D%98-%ED%91%9C%ED%98%84/",
        "teaser": null
      },{
        "title": "[Lv 1] 정수 제곱근 판별",
        "excerpt":"📄 문제   임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.      n은 1이상, 50000000000000 이하인 양의 정수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   const sqrt = Math.sqrt(n); // 1   return Number.isInteger(sqrt) ? (sqrt + 1) * (sqrt + 1) : -1; // 2 }   제곱근을 반환해주는 메소드 Math.sqrt()를 이용해 문제를 풀었습니다.   for문이나 while문을 사용하면 너무 많은 경우의 수가 생겨 효율성이 좋지 않을 거라고 생각했기 때문입니다.      주어진 숫자 n의 제곱근(sqrt)을 구한다.   sqrt가 정수라면 1을 더한 제곱을 반환, 아니면 -1을 반환한다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["정수 제곱근 판별","sqrt","Number.isInteger","pow"],
        "url": "/programmers-lv2/programmers-%EC%A0%95%EC%88%98-%EC%A0%9C%EA%B3%B1%EA%B7%BC-%ED%8C%90%EB%B3%84/",
        "teaser": null
      },{
        "title": "[Leaning Typescript 🦜] various-lawyerings",
        "excerpt":"👩‍🎓 Various Lawyerings      Hello, fellow lawyer. I’m glad you’ve chosen to join me in preparing to engage in legal battle. As you can see, I require your assistance in developing TypeScript projects to manage my files for this most important case.    안녕, 동료 변호사야.  이번 법정 사건을 나와 함께 준비하기로 했다니 정말 기쁘다.  보다시피, 아주 중요한 케이스를 위한 파일을 관리하는 지금 개발중인 타입스크립트 프로젝트를 너가 도와줬음 좋겠다잉.      타입 인터페이스말고, 타입 객체를 사용하세요.   🎓 Step 1: Aviary Classification      As a world-renowned expert in bird law, it is my duty to properly educate the court on the characteristics of various birds and related bird information. I cannot uphold my critical task if my bird files are not in proper order.  I require you to write an object type describing a Bird type for my array of birds. Please be as specific as possible for types when possible. Any property other than name whose values are strings should be a union of unions of string literals.    ▪ 요약: 새 정보가 들어있는 객체 타입을 가능한 구체적으로 만들어줘. name말고도 값이 string인 프로퍼티는 string 리터럴 유니언 타입이 되어야해   📄 문제 코드   birds배열의 속성들이 객체로 이루어져 있습니다. 이 객체들의 타입을 지정해주어야 합니다.   // Write your Bird type here! ✨ export const birds = [   {     dangerous: true,     diet: \"omnivore\",     name: \"White-Throated Magpie-Jay\",     noisy: true,   },   {     diet: \"omnivore\",     intelligent: true,     name: \"Eurasian Magpie\",   },   {     diet: \"carnivore\",     name: \"Yellow-Billed Blue Magpie\",     noisy: true,   },   {     intelligent: true,     diet: \"omnivore\",     name: \"American Crow\",   }, ];   📄 풀이과정   공통된 속성들을 빼주고 서로 다른 경우의 속성들을 유니언 타입으로 생성해 교차 타입으로 묶어주었습니다.   error는 없어졌지만 이게 요구사항대로 한게 맞는지 모르겠습니다.   type Bird = { name: string; diet: string } &amp; (   | { dangerous: boolean; noisy: boolean }   | { diet: string }   | { noisy: boolean }   | { intelligent: boolean } );   ✔ 정답   export type Bird = {   dangerous?: boolean,   diet: \"carnivore\" | \"omnivore\",   intelligent?: boolean,   name: string,   noisy?: boolean, };   역시 틀렸습니다. 교차 타입말고 선택적 속성을 사용하니 훨씬 가독성있네요.   교차 타입을 알기 전에는 이렇게 코드를 작성했었는데 교차 타입을 공부하니 애먼곳에 얶매여 생각했습니다.   역시 코드는 사람이 눈으로 읽기 좋게 짜야합니다.   🎓 Step 2: Case Management      Very good, very good. My birds are classified correctly. I thank you.  Next, I have the opposite type of task for you to tackle. I have created a Case type for you and have a cases array. But, the elements in cases vary in format and do not always match up with the Case type. Please correct cases – without changing the Case type.    ▪ 요약: 아주 맘에 드는구만. 이번엔 반대로 내주지. 타입 Case를 바꾸지 말고 배열 cases를 바꿔서 문제를 해결해 봐라!   📄 문제 코드   이번에는 타입을 수정하지 않고 주어진 배열 데이터인 cases를 고쳐야 합니다.   export type Case = {   court: \"state\" | \"federal\";   decided: Date;   defendant: string;   id: string | string[];   plaintiff: string;   title: string; };  export const cases: Case[] = [   {     court: \"federal\",     decided: new Date(\"February 18, 1986\"),     defendant: [\"Glynn Batson\", \"and\", \"Southplains Land Corporation\"],     id: 841710,     plaintiff: \"United States of America\",     title: \"United States v. Batson\",   },   {     court: \"state\",     decided: \"April 17, 1992\",     defendant: \"Bradford Marine, Inc\",     id: [\"90-6372-CIV\", \"90-6599-CIV\"],     plaintiff: \"Lyn C. Noble\",     title: \"Noble v. Bradford Marine, Inc\",   },   {     amusing: true,     court: \"NY state\",     defendant: \"PepsiCo, Inc.\",     decided: {       on: new Date(\"August 5, 1999\"),     },     ids: [\"96-cv-5320\", \"96-cv-9069\"],     plaintiff: \"John Leonard\",     title: \"Leonard v. Pepsico, Inc.\",   }, ];   📄 해결 과정   주어진 타입 Case에 맞게 배열 cases를 바꾸어 주었습니다.   Case에 없는 속성은 아예 삭제했습니다.   export type Case = {   court: \"state\" | \"federal\";   decided: Date;   defendant: string;   id: string | string[];   plaintiff: string;   title: string; };  export const cases: Case[] = [   {     court: \"federal\",     decided: new Date(\"February 18, 1986\"),     defendant: \"Glynn Batson and Southplains Land Corporation\",     id: \"841710\",     plaintiff: \"United States of America\",     title: \"United States v. Batson\",   },   {     court: \"state\",     decided: new Date(\"1992-04-17\"),     defendant: \"Bradford Marine, Inc\",     id: [\"90-6372-CIV\", \"90-6599-CIV\"],     plaintiff: \"Lyn C. Noble\",     title: \"Noble v. Bradford Marine, Inc\",   },   {     court: \"state\",     defendant: \"PepsiCo, Inc.\",     decided: new Date(\"August 5, 1999\"),     id: [\"96-cv-5320\", \"96-cv-9069\"],     plaintiff: \"John Leonard\",     title: \"Leonard v. Pepsico, Inc.\",   }, ];   정답 코드와 일치합니다 :)   📄 Step 3: Making Arguments      Well done, dear chap! Well done indeed. I have but one more file for you. It contains the many motions I have seen in cases involving my clients. I must admit, I’d grown quite weary while jotting down those motions. It is missing TypeScript types, and many elements in the motions array have typos in their data. The tricky thing is, there are a few different types of motions that can be filed. There should be some kind of discriminating indicator property on the types to distinguish between:       Status: allowed, denied, and pending. Within those types:            Allowed: it may also indicate how many hours it spent in deliberation       Denied: it may also indicate how many hours it spent in deliberation, and whether it annoyed the justice       Pending: it may also indicate how many hours it’s estimated to spent in deliberation           Step: post-trial and pre-trial. Within those types:            Pre-trial: I only noted dismissals, suppressions, and venue changes       Post-trial: I only noted acquittals, corrections, and new trials           ▪ 아주 잘했군, 녀석. 나 정말 피곤하다… 내 클라이언트 사건들에서 사라진 타입을 찾고 오타 좀 고쳐주라.. 여기 구별하기 위한 프로퍼티들이 있어.(망해버린 번역입니다.)   📄 문제 코드   배열 motions 요소를 이루는 객체의 타입을 지정해주어야 하네요.   // Write your types here! ✨  export const motions: Motion[] = [   {     annoyedJustice: true,     classification: \"acquittal\",     deliberationHours: 1,     from: \"defendant\",     reason: \"The heretofore document had dried ink on it.\",     status: \"denied\",     step: \"post-trial\",   },   {     annoyedJustice: true,     classification: \"correction\",     deliberationHours: 2.5,     from: \"plaintiff\",     reason: \"The tenant has ninety days to vacate.\",     status: \"denied\",     step: \"post-trial\",   },   {     classification: \"suppress\",     deliberationHours: 4,     from: \"plaintiff\",     reason: \"Frank was never allowed in the house.\",     status: \"allowed\",     step: \"pre-trial\",   },   {     classification: \"new trial\",     estimatedDeliberationHours: 3,     from: \"defendant\",     reason: \"The duel's been accepted. There's no backing out. That's the law.\",     status: \"pending\",     step: \"post-trial\",   },   {     annoyedJustice: false,     classification: \"dismiss\",     deliberationHours: 0.5,     from: \"plaintiff\",     reason:       \"It seems like you have a tenuous grasp on the English language in general.\",     status: \"denied\",     step: \"pre-trial\",   },   {     annoyedJustice: true,     classification: \"correction\",     deliberationHours: 1.5,     from: \"defendant\",     reason: \"Fillibuster?\",     status: \"denied\",     step: \"post-trial\",   },   {     annoyedJustice: true,     classification: \"venue\",     deliberationHours: 0.25,     from: \"defendant\",     reason: \"A time was never specified for the duel.\",     status: \"denied\",     step: \"pre-trial\",   },   {     annoyedJustice: true,     classification: \"correction\",     deliberationHours: 5,     from: \"plaintiff\",     reason: \"He's making a few good points!\",     status: \"denied\",     step: \"post-trial\",   }, ];   📄 풀이 과정   이번 문제는 제 영어 실력에 한계가 느껴졌습니다.   주어진 지문을 보고 문제가 잘 이해가 가지 않았습니다.   처음으로 못풀었던 문제입니다..   우선 객체의 공통된 속성들을 가지고 베이스 타입을 만들어줍니다.   export type MotionBase = {   from: \"defendant\" | \"plaintiff\";   reason: string; };   이후, 지문에서 주어진 요구사항에 맞게 두가지 타입을 분류합니다.   export type PreTrialMotion = MotionBase &amp; {   classification: \"dismiss\" | \"suppress\" | \"venue\";   step: \"pre-trial\"; };  export type PostTrialMotion = MotionBase &amp; {   classification: \"acquittal\" | \"correction\" | \"new trial\";   step: \"post-trial\"; };   이렇게 재판 유형에 따른 타입 TrialMotion을 유니언 타입으로 만들어주었습니다.   export type TrialMotion = PostTrialMotion | PreTrialMotion;   이제 각 상태에 맞게 타입을 분류하고 유니언 타입으로 합쳐 최종 타입을 생성합니다.   export type AllowedMotion = TrialMotion &amp; {   deliberationHours: number;   status: \"allowed\"; };  export type DeniedMotion = TrialMotion &amp; {   annoyedJustice: boolean;   deliberationHours: number;   status: \"denied\"; };  export type PendingMotion = TrialMotion &amp; {   estimatedDeliberationHours: number;   status: \"pending\"; };  export type Motion = AllowedMotion | DeniedMotion | PendingMotion;   영어 공부를 좀 더 해야겠네요.   정답 코드를 보기 전까진 어떻게 해야할지 사실 감이 잘 잡히지 않았습니다.   역시 영어는 꼭 공부해야겠습니다.   문제 출처      learning typescript  ","categories": ["TypeScript"],
        "tags": ["learning typescript","러닝 타입스크립트","타입 객체","various-lawyerings"],
        "url": "/typescript/typescript-learning-typescript-various-lawyerings/",
        "teaser": "/assets%5Cimage%5Clearning-typescript.PNG"
      },{
        "title": "객체 타입",
        "excerpt":"📄 객체 타입   객체 타입이란 타입스크립트에서 {속성명: 타입 명}형식으로 이루어진 타입입니다.   type Poet = {   // 별칭 객체 타입   born: number;   name: string; };  let poetLater: Poet;  poetLater = {   born: 1935,   name: \"Mary Oliver\", };  poetLater = \"Sappho\"; // Error: Type 'string' is not assignable to type '{born: numner; name: string;}   📄 구조적 타이핑   구조적 타이핑은 실제 구조와 정의에 의해 결정되는 타입 시스템입니다.   런타임에 타입을 결정하는 자바스크립트의 덕 타이핑과 달리, 타입스크립트는 구조적으로 타입화합니다.      덕 타이핑이란? 동적 타이핑의 한 종류로 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것    ▪ 초과 속성 검사   초과 속성 검사는 객체 타입 속성을 검사하는 과정입니다.   초과 속성 검사에는 중요한 조건이 있습니다.   “객체 리터럴을 변수에 집적 할당하는 경우에만”초과 속성 검사가 진행된다는 것입니다.   다음과 같은 예시에서는 객체 리터럴 Poet을 변수 extraPerson에 직접 할당했기 때문에 초과 속성 검사가 진행되어 타입 에러를 뱉습니다.   type Person = {   name: string,   age: number, };  // ok. Person필드와 일치 const Sujin: Person = {   name: \"sujin\",   age: 28, };  const extraPerson: Person = {   name: \"sujin\",   age: 28,   nickName: \"masuri\", // Error! };   이번에는 중간에 변수를 거쳐서 객체리터럴를 대입해보겠습니다.   const exisitingObject = {   name: \"sujin\",   age: 28,   nickName: \"masuri\", };  const extraPerson: Person = existingObject; // ok   객체를 다른 변수에 할당했더니, 변수 existingObject는 초과 속성 검사를 받지 않았기 때문에 에러가 발생하지 않습니다.   ▪ 선택적 속성   선택적 속성은 에너테이션(:)앞에 ?를 추가해서 선택적으로 속성을 허용할 때 사용합니다.   타입을 undefined로 선언한경우, 그 값이 undefined일지라도 반드시 그 값이 존재해야합니다.   반면, 선택적으로 선언된 속성은 존재하지 않아도 됩니다.   type Writer = {   author: string | undefined;   editor?: string; };  const hasRequired: Writer = {   author: undefined; }  const missingRequired: Writer = {}; // Error: Property 'author' is missing in type '{}' but required in type 'Writers'.   📄 교차 타입   교차 타입은 합집합의 개념으로 이해할 수 있습니다.   유니언 타입이 이거 또는 저거의 개념으로 주어진 타입 중 하나의 타입만 선택하게 되는 반면에,   교차 타입은 서로 다른 타입이 하나의 타입으로 만들어져 여러 타입을 동시에 나타낼 수 있습니다.   교차 타입은 유니언 타입과 결합하여 사용할 수 있습니다.   type ShortPoem = {   author: string; } &amp; ({ kigo: string; type: \"haiku\" } | { meter: number; type: \"villanelle\" });  // type: // {author: string;  kigo: string; type: \"haiku\"} // 또는 // {author: string; meter: number; type: \"villanelle\" }   ▪ never   원시타입에 교차타입을 적용하는 것은 무의미한 일입니다.   원시타입에 교차타입을 적용하면 never라는 타입이 되는데, 이는 비어있는 타입을 뜻합니다.   let notNumber: number &amp; string = 0; // Error: Type 'number'is not assignable to type 'never'   참고      learning TypeScript   InPa-Dev - 타입스크립트 잉여 속성 검사 원리 이해하기  ","categories": ["TypeScript"],
        "tags": ["객체 타입","구조적 타이핑","선택적 속성","교차타입","never"],
        "url": "/typescript/typescript-%EA%B0%9D%EC%B2%B4-%ED%83%80%EC%9E%85/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 🚨 react-scripts: not found",
        "excerpt":"🚨 문제 발생   모코늪 프로젝트에서 github actions를 통해 프로젝트를 배포하는데 npm run build명령어가 되질 않습니다.      프로젝트에서 npm을 업데이트하고 설치해도 같은 문제가 발생해서 아예 package.lock파일과 node_modules폴더를 삭제하고 다시 npm을 설치해주었습니다.   실패했습니다.   🔨 문제 해결   구글링하면 왜 자꾸 사람들이 node_modules를 지워라, 다시 npm install을 해라 하는지 알았습니다.   그런 케이스들은 로컬 환경에서 일어났던 에러였으니 당연히 다시 npm을 설치해 초기화 시켜주면 해결이 되었던 것입니다.   저는 로컬 환경에서는 빌드가 되었지만 github actions에서 되지 않았던 것이었는데 말이죠.   저의 CICD.yml파일입니다.   jobs:   CICD:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@main       # - run: npm ci 이 부분을 실수로 삭제 해놓고 헤매고 있던 것이었습니다.       - run: npm run build       - name: deploy to s3         uses: jakejarvis/s3-sync-action@master         with:           args: --delete         env:           AWS_S3_BUCKET: $           AWS_ACCESS_KEY_ID: $           AWS_SECRET_ACCESS_KEY: $           AWS_REGION: \"ap-northeast-2\"           SOURCE_DIR: \"build\"   📌 npm ci 란?   npm ci는 package-lock.json에 있는 패키지 정보를 이용해 정확한 버전의 패키지들을 설치해서 node_modules에 적재합니다.   npm run build을 실행할 수 있는 파일은 node_modules에 있는데 node_modules를 설치하지 않았으니 에러가 발생할 수 밖에요.     그런데 사실 에러가 완전히 끝나지 않았습니다.      @toast ui 라이브러리가 현재 사용중인 react 18버전과 맞지 않습니다.   산넘어 산입니다.   이거 리액트 버전을 낮추는거 밖에 답이 안보이네요.   참고      https://github.com/facebook/create-react-app/discussions/10220  ","categories": ["coding-swamp"],
        "tags": ["모코늪","리액트","github actions","에러","npm ci"],
        "url": "/coding-swamp/coding-swamp-scripts-not-found/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 🚨 Could not resolve dependency + package maneger Error",
        "excerpt":"🚨 문제 발생   리액트 프로젝트를 github actions를 통해 배포하는데 문제가 발생했습니다.   리액트 버전이 현재 18.2.0인데 @toast-ui라이브러리와 맞지 않습니다.      아무래도 리액트를 17로 버전을 낮춰야겠습니다.   🔨 해결 과정   다음 명령어를 통해 리액트를 17.0.2버전으로 다운그레이드 합니다.   당연히 react-dom도 함께 다운그레이드 합니다.   npm install react@^17.0.2 react-dom@17.0.2    👍   이제 로컬에서 잘 돌아가는지 테스트해보겠습니다.   버전이 바뀌니 뭔가 문제가 발생하네요.   내 이럴 줄 알았습니다.   ▪ Can’t resolve ‘react-dom/client’      💾 [index.ts]   버전이 바뀌어 사용방법도 다릅니다.   아래 코드처럼 수정해줍니다.   // import ReactDOM from \"react-dom/client\"; import ReactDOM from \"react-dom\";   ▪ Property ‘createRoot’ does not exist on type   바뀐 버전은 렌더 방식도 다릅니다.   마찬가지로 index.ts파일에서 진행됩니다.   리액트 17버전은 ReactDOM이 직접 render하는 구조입니다.   // const root = ReactDOM.createRoot( //   document.getElementById(\"root\") as HTMLElement // );  // root.render( //   &lt;Provider store={store}&gt; //     &lt;PersistGate loading={null} persistor={persistor}&gt; //       &lt;ThemeProvider theme={theme}&gt; //         &lt;GlobalStyle /&gt; //         &lt;Page&gt; //           &lt;App /&gt; //         &lt;/Page&gt; //       &lt;/ThemeProvider&gt; //     &lt;/PersistGate&gt; //   &lt;/Provider&gt;, // );  ReactDOM.render(   &lt;Provider store={store}&gt;     &lt;PersistGate loading={null} persistor={persistor}&gt;       &lt;ThemeProvider theme={theme}&gt;         &lt;GlobalStyle /&gt;         &lt;Page&gt;           &lt;App /&gt;         &lt;/Page&gt;       &lt;/ThemeProvider&gt;     &lt;/PersistGate&gt;   &lt;/Provider&gt;,   document.getElementById(\"root\") );   이제 문제 없이 프로젝트가 잘 돌아갑니다.   과연 npm ci명령도 잘 통과할까요..   🚨 문제 발생 #2      이번엔 testing library가 문제네요.   현재 설치되어 있는 testing-library 버전 @13.4.0은 react 버전 @18.0.0이랑 맞는답니다.   라이브러리끼리 서로 합의 봐주면 안되는 것이었을까요.   찾아보니 react-testing-libray 12버전은 react 18버전 아래로는 다 지원이 가능하다고 합니다.   🔨 문제 해결   react-testing-library를 12.1.5버전으로 다운그레이드 하겠습니다.   npm install @testing-library/react@^12.1.5   🚨 문제 발생 #3   npm ci명령에서 다시 문제가 발생했습니다.      package-lock.json파일을 삭제 후 다시 npm install해도 안되네요.   npm install로 npm을 설치해서 package-lock.json파일도 생성되었는데 왜 안될까요.   🔨 문제 해결   그것은 바로 제가 yarn.lock파일을 가지고 있었기 때문입니다.   프로젝트를 계속 yarn으로 진행했는데 이게 문제가 될 줄 몰랐습니다.   CI를 진행하는데 필요한 정보가 package-lock.json이 아니라 yarn.lock에 있었나 봅니다.   그렇다면 이제부턴 정말 yarn뿐입니다.   npm을 쓰든 yarn을 쓰든 하나의 매니저와 갑시다…   npm은 보내주고 yarn을 사용해 CI를 진행하겠습니다.   yarn으로 ci를 실행시키는 커맨드는 다음과 같습니다.   yarn install --immutable --immutable-cache --check-cache   [💾 CICD.yml]   문제된 부분을 수정합니다.   jobs:   CICD:     runs-on: ubuntu-latest     steps:       - uses: actions/checkout@main       - run: yarn install --immutable --immutable-cache --check-cache // 🎉       - run: yarn build // 🎉       - name: deploy to s3         uses: jakejarvis/s3-sync-action@master         with:           args: --delete         env:           AWS_S3_BUCKET: $           AWS_ACCESS_KEY_ID: $           AWS_SECRET_ACCESS_KEY: $           AWS_REGION: \"ap-northeast-2\"           SOURCE_DIR: \"build\"      드디어…CICD 파이프라인이 완성되었습니다. 🎉     🥶 오늘의 회고   공부를 하면 할수록 꼼수를 부리면 나중에 탈이 나고, 귀찮아서 넘기면 눈덩이처럼 커져 돌아오는것을 알았습니다.  그냥 애초에 눈에 보일 때 해결해야 뒤탈이 없습니다.  사실 toast-ui에 뭔가 버전이 안맞는 다는 걸 알았는데 개발환경에선 문제가 없길래 넘겼거든요.  인터스텔라가 흥행한 이유는 과거를 후회하는 인간이 많기 때문일까요.  이상 독학러의 주저리였습니다.     참고           what-are-the-corresponding-testing-library-react-versions-for-react-16-8-6            npm-ci-can-only-install-packages-with-an-existing-package-lock-json-or-npm-shrin      ","categories": ["coding-swamp"],
        "tags": ["모코늪","리액트 버전","toast-ui","다운 그레이드","testing-library","에러","npm"],
        "url": "/coding-swamp/coding-swamp-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%B2%84%EC%A0%84-%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[Lv 1] 자연수 뒤집어 배열로 만들기 by JS",
        "excerpt":"📄 문제   자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.      n은 10,000,000,000이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   const numToArr = [...String(n)].reverse(); // 1   let answer = [];   for (let i = 0; i &lt; numToArr.length; i++) {     answer.push(Number(numToArr[i])); // 2   }   return answer; }      주어진 숫자를 문자열로 바꿔 하나하나 배열의 요소로 만들어준 후 순서를 바꾼다.   answer에 numToArr의 요소를 숫자로 바꿔 삽입해준다.   뭔가 한줄짜리 코드로 바꿀 수 있을 것 같은데 깔끔하게 답이 나오지 않아 이렇게 제출했습니다.   👍 Best Practice 1   function solution(n) {   return (n + \"\")     .split(\"\")     .reverse()     .map((n) =&gt; parseInt(n)); }   역시 한줄짜리 답안이 있네요.   아직 배열 내장 메소드를 쓰는 것이 그렇게 익숙하지 않은듯 합니다.   그런데 왜 숫자 뒤에 공백을 붙이고 split(““)을 하면 문자열로 하나하나 쪼개질까요.   열심히 이리저리 콘솔을 찍어본 결과 숫자 뒤에 공백(““)을 붙이면 문자열이 되기 때문이었습니다.   제가 했던 [...String(n)]과 같은 과정이네요.   👍 Best Practice 2   function solution(n) {   var arr = [];    do {     arr.push(n % 10); // 1     n = Math.floor(n / 10); // 2   } while (n &gt; 0); // 3    return arr; }      주어진 자연수를 10으로 나누어 소수점 한자리를 나오게해 그 값을 arr에 넣어준다.   뒤에 소수점을 하나 떨궈내고 자릿수를 하나 줄인다.   n이 0이 될때까지 반복한다.   세상은 이런 분들이 바꿔가는걸까요.   저는 어떻게든 배열 메소드를 쓰려고 했는데 이런 멋진 방법이 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["reverse","split","스택/큐"],
        "url": "/programmers-lv1/programmers-%EC%9E%90%EC%97%B0%EC%88%98-%EB%92%A4%EC%A7%91%EC%96%B4-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "타입스크립트에서 함수 다루기",
        "excerpt":"타입스크립트에서 함수를 사용할때 변수를 사용할때와 마찬가지로 타입을 지정해주어야 합니다.   함수에서는 크게 매개변수와 반환값에 타입을 지정합니다.   📄 함수 매개변수   함수의 매개변수에 타입을 지정하면 그 매개변수는 필수 매개변수가 됩니다.   그렇다면 반대로 선택적 매개변수는 어떻게 지정할까요?   타입 애너테이션(:)앞에 ?를 붙여주면 됩니다.   function announceSong(song: string, singer?: string) {   console.log(`Song: ${song}`); }   announceSong함수의 매개변수인 singer은 선택적 매개변수가 되었습니다.   singer의 구체적인 타입은 string | undefined입니다.   이렇게 생성된 선택적 매개변수는 호출될때 생략해도 에러가 발생하지 않습니다.   ▪ 나머지 매개변수   나머지 매개변수는 매개변수의 개수를 특정할 수 없을 때 사용합니다.   스프레드 연산자(...)를 사용해 배열로 나타납니다.   function singAllTheSongs(singer: string, ...song: string[]) {   for (const song of songs) {     console.log(`${song}, by ${singer}`);   } }  singAllTheSongs(\"Day6\"); // ok singAllTheSongs(\"Day6\", \"예뻤어\", \"한 페이지가 될 수 있게\", \"때려쳐\"); // ok   📄 반환 타입   타입스크립트는 함수의 반환 타입도 유추할 수 있습니다.   따라서 타입스크립트가 명확하게 타입을 유추할 수 있는 상황이라면, 타입을 명시적으로 지정하는 것은 중복된 타입 지정이므로 지양하는 것이 좋습니다.   function(): 반환 타입 {   ... }  const name = (): 반환 타입 =&gt; {   ... }   📄 함수 타입   함수 타입은 함수를 매개변수에 값으로 넘겨줘야 하는 상황에 지정해야 합니다.   마찬가지로 타입이 맞지 않으면 에러가 발생합니다.   functions runOnSongs(getSonAt: (index: number) =&gt; string){   console.log(getSongAt('hello')); // Error. }   📄 그 외 반환 타입   ▪ void   반환 타입이 void인 경우는 다음과 같습니다.      return문이 없는 함수인 경우   값을 반환하지 않는 return문인 경우   반환 타입이 void인 경우 undefined와 잘 구분해야 합니다.   반환 타입이 void인 경우는 반환 타입이 무시된다는 것을 의미하고 undefined는 반환되는 리터럴값이기 때문입니다.   function returnVoid(){   return; }  let lazyValue: string | undefined;  lazyValue = returnVoid()\\ // Error: Type 'void' is not assignable to type 'string | undefined'   ▪ never   never 반환 타입은 의도적으로 오류를 발생시킵니다.   따라서 에러를 제어하는 경우에 사용합니다.   function fail(message: string): never {   throw new Error(`Invariant failure: ${message}`); }  function workWithUnasafeParam(param: unknown) {   if (typeof param !== \"string\") {     fail(`param should be a string, not ${typeof param}`);   }    param.toUpperCase(); }   참고      learning typescript  ","categories": ["TypeScript"],
        "tags": ["함수"],
        "url": "/typescript/typescript-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98-%EB%8B%A4%EB%A3%A8%EA%B8%B0/",
        "teaser": "/assets%5Cimage%5CTS-logo.PNG"
      },{
        "title": "[Lv 2] 다음 큰 숫자",
        "excerpt":"📄 문제   자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.      조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.   조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.   조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.   자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.      n은 1,000,000 이하의 자연수 입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   let answer = n;   const numberOfOne = n.toString(2).split(1).length - 1;    while (answer++) {     if (answer.toString(2).split(1).length - 1 == numberOfOne) return answer;   } }   저는 주어진 숫자에서 1을 더해가며 이진수로 변환 후 1의 개수를 split()메소드로 계산해 조건을 걸었습니다.   항상 익숙한 for문만 쓰다가 처음으로 while문을 써보았습니다.   👍 Best Practice   function solution(n, a = n + 1) {   return n.toString(2).match(/1/g).length == a.toString(2).match(/1/g).length     ? a     : solution(n, a + 1); }   주어진 문제 함수가 재귀함수가 되었네요.   조건이 맞을 때까지 계속 자기 자신을 호출하는 형태입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["이진수","알고리즘"],
        "url": "/programmers-lv2/programmers-%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Lv 1] 정수 내림차순으로 배치하기 by JS",
        "excerpt":"📄 문제   함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.      n은 1이상 8000000000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   return Number([...String(n)].sort((a, b) =&gt; b - a).join(\"\")); }   저는 주어진 숫자를 문자열 배열로 만들어 내림차순 한 뒤, 다시 문자열로 바꾸고 숫자로 반환했습니다.   배열 요소를 다 합해 문자열로 바꾸는 방법이 생각이 안나서 조금 헤맸습니다.   📌 배열 요소를 이어서 문자열로 바꾸는 방법: arr.join(\"\")  문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["내림차순","배열","문자열"],
        "url": "/programmers-lv1/programmers-%EC%A0%95%EC%88%98-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Lv 2] 피보나치 수",
        "excerpt":"📄 문제   피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.   예를들어      F(2) = F(0) + F(1) = 0 + 1 = 1   F(3) = F(1) + F(2) = 1 + 1 = 2   F(4) = F(2) + F(3) = 1 + 2 = 3   F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다.   2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.      n은 2 이상 100,000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   아마 지금까지 풀었던 프로그래머스 문제 중 가장 오래걸렸던 문제였던 것 같습니다.   재귀로 접근하려고 했다가 실패하고 스택 개념을 적용했습니다.   function solution(n) {     let arr = [0, 1]     for(let i = 2; i &lt;= n; i++){         arr.push(arr[i-2] + arr[i-1])     }     return arr[n]%1234567 }   값이 하나씩 늘어갈 때마다 배열에 값을 넣어줬습니다.   하지만 모든 테스트 코드를 통과하지 못했습니다.   자바스크립트의 number의 범위는 2^53 -1이 최대이기 때문에 이 이상의 값이 나오면 에러가 발생하기 때문이었습니다.   여기서 시간이 오래걸려 주어진 힌트를 보고 문제를 다시 풀었습니다.   function solution(n) {     let arr = [0, 1]     for(let i = 2; i &lt;= n; i++){         arr.push((arr[i-2] + arr[i-1])%1234567)     }     return arr[n] }  매 연산에 %1234567을 해주어 너무 큰 값이 발생하지 않게 하는 것이었습니다.   이는 자바스크립트의 특징으로 파이썬의 경우에는 해당되지 않는다고 합니다.   ","categories": ["programmers-lv2"],
        "tags": ["피보나치 수","알고리즘","스택"],
        "url": "/programmers-lv2/programmers-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98/",
        "teaser": null
      },{
        "title": "[알고리즘] 시간 복잡도와  빅오(Big O) 계산법",
        "excerpt":"📄 시간 복잡도   프로그래머스 문제를 푸는데 이제 점점 성능을 고려해야할 필요성이 생겼습니다.  효율성 테스트를 넘어가야 하기 때문이죠. 🥶  똑같은 답일지라도 빨리 답이 나오는 코드가 더 좋은 성능을 가진 코드인데 이를 구별할 수 있게 하는 것이 시간 복잡도입니다.   시간 복잡도는   입력 값에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마나 걸리는 지 알려주는 지표입니다.   이 시간 복잡도를 나타내주는 방법 중 하나가 빅오(Big O) 표기법입니다.   📄 빅오(Big O) 표기법의 종류      ▪ O(1) | Constant Complexity   O(1)는 입력값에 상관없이 정해진 스텝의 계산을 실행합니다.   콘솔을 한번만 찍는 함수는 아무리 큰 입력값이 오더라도 계산에 영향을 끼치지 않습니다.   const constantComplexity = (arr) =&gt; {   console.log(\"hello\"); };  constantComplexity([1, 2, 3, 4, 5]);      스택의 push, pop   ▪ O(n) | linear complexity   O(n)는 입력값이 증가함에 따라 시간이 같은 비율로 증가합니다.   const linearComplexity = (n) =&gt; {   for(let i = 0; i &lt; n; i++&gt;){     ...   } }      for 문   ▪ O(n²) | Quadratic Complexity   O(n)는 입력값이 증가함에 따라 시간이 n²으로 증가합니다.   const quadraticComplexity = () =&gt; {   for (let i = 0; i &lt; n; i++) {     for (let j =0; j &lt; n; j++) {       ...   } }      이중 for문   삽입정렬(insertion sort)   선택정렬(selection sort)   거품정렬(bubble sort)   ▪ O(log N) | Logarithmic Complexity   O(n)는 입력값에 따라 처리 시간이 증가합니다.   O(n)은 입력 값이 1이 될 때까지 절반으로 나누는 작업을 반복합니다.  따라서 입력값에 따라 처리 시간이 증가하지만, 비례해서 증가하는 것이 아니므로 O(1)다음으로 빠른 계산법입니다.      이진 트리 탐색   퀵 정렬(quick sort)   병합정렬(merge sort)   힙 정렬(heap Sort)   출처      노마드 코더 - 개발자라면 이제는 알아야하는 Big O 설명해드림. 10분컷.   shitai.koto - [Algorithm] 시간 복잡도(Time complexity) 학습  ","categories": ["Algorithm"],
        "tags": ["시간 복잡도","빅오 계산법"],
        "url": "/algorithm/algorithm-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/",
        "teaser": null
      },{
        "title": "Math 메소드 정리",
        "excerpt":"📄 Math.abs(number)   ▪ 용도: 인수의 절댓값을 반환한다.   Math.abs(-1); // 1 Math.abs(\"\"); // 0 Math.abs([]); // 0 Math.abs(null); // 0 Math.abs(undefined); // NaN   📄 Math.round(number)   ▪ 용도: 소수점 이하를 반올림한 정수를 반환한다.   Math.round(1.2); // 1 Math.round(-1.6); // -2 Math.round(); // NaN   📄 Math.ceil(number)   ▪ 용도: 소수점 이하를 올림한 정수를 반환한다.   Math.ceil(1.4); // 2 Math.ceil(1); // 1 Math.ceil(); // NaN   📄 Math.floor(number)   ▪ 용도: 소수점 이하를 내림한 정수를 반환한다.   Math.floor(1.4); // 1 Math.floor(-1.8); // -2 Math.floor(); // NaN   📄 Math.sqrt(number)   ▪ 용도: 인수의 제곱근을 반환한다.   Math.sqrt(9); // 3 Math.sqrt(-9); // NaN Math.sqrt(); // NaN   📄 Math.random()   ▪ 용도: 0에서 1미만의 랜덤 숫자를 반환한다.   Math.random(); // 0.xxxxxxxx   📄 Math.pow(number, number)   ▪ 용도: 첫번째 인수를 밑, 두번째 인수를 지수로한 거듭제곱근을 반환한다.   Math.pow(2, 8); // 256  // ES7 거듭 제곱 연산자 2 ** 8; // 256   📄 Math.max(numbers)   ▪ 용도: 인수 중 최댓값을 반환한다.   Math.max(1, 2, 3); // 3   📄 Math.min(numbers)   ▪ 용도: 인수 중 최솟값을 반환한다.   Math.min(1, 2, 3); // 1  ","categories": ["JavaScript"],
        "tags": ["Math"],
        "url": "/javascript/javascript-Math-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 기능 개발 by JS",
        "excerpt":"📄 문제   프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.   또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.   먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.      작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.   작업 진도는 100 미만의 자연수입니다.   작업 속도는 100 이하의 자연수입니다.   배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.   🙋‍♀️ 나의 풀이   function solution(progresses, speeds) {   let answer = [];   let hundreds = 0;   while (progresses.length !== 0) {     // 1     for (let i = 0; i &lt; progresses.length; i++) {       progresses[i] += speeds[i];     } // 2     if (progresses[0] &gt;= 100) {       while (progresses[0] &gt;= 100) {         progresses.shift();         speeds.shift();         hundreds++;       } // 3       answer.push(hundreds); // 4       hundreds = 0;     }   }   return answer; }      시간 복잡도: O(n^2)      progresses의 길이가 0이 될 때까지 반복문을 실행합니다.   progresses에 인덱스를 맞춰 speeds를 더해줍니다.   만약 progresses의 첫번째 인덱스의 값이 100보다 큰 경우 shift메소드를 사용해 각 각 배열들의 첫번째 원소를 추출하고, 추출된 횟수를 나타내는 변수 hundreds에 1을 더합니다.   progresses의 첫번째 인덱스가 100보다 크지 않아 반복문을 나오면, 작업이 완료된 기능의 개수인 hundreds를 answer에 추가합니다.   문제를 풀 때 중첩 반복문이 나오면 답은 나와도 성능상 좋지 않게 느껴져 아쉽습니다.    👍 Best Practice   function solution(progresses, speeds) {   let answer = [0];   let days = progresses.map((progress, index) =&gt;     Math.ceil((100 - progress) / speeds[index])   );   let maxDay = days[0];    for (let i = 0, j = 0; i &lt; days.length; i++) {     if (days[i] &lt;= maxDay) {       answer[j] += 1;     } else {       maxDay = days[i];       answer[++j] = 1;     }   }    return answer; }   각 기능들이 배포에 걸리는 시간을 배열로 만들어(days) 조건에 따라 maxDay를 바꿔가며 days를 순환합니다.   아예 접근방식이 달라버리네요. 이럴수가 있다니..  속도나 성능을 떠나서 풀이 방식이 신기합니다.  처음에 눈으로 보고 이해가 안가서 종이에 하나하나 조건을 줘가면서 이해했습니다. 세상엔 똑똑한 사람이 많네요.  ","categories": ["programmers-lv2"],
        "tags": ["스택/큐","while"],
        "url": "/programmers-lv2/programmers-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C/",
        "teaser": null
      },{
        "title": "[알고리즘] 정렬 (sorting)",
        "excerpt":"📄 정렬 알고리즘   정렬 알고리즘은 물건을 정리하는 것 처럼 데이터를 정해진 순서대로 나열하는 알고리즘입니다.   정렬 알고리즘에는 대표적으로 버블 정렬, 선택 정렬, 삽입 정렬이 있습니다.   📄 버블 정렬 (Bubble Sort)   버블 정렬은 매 사이클마다 모든 배열 요소를 비교합니다.      0번째 원소와 1번째 원소를 비교 &amp; swap   1번째 원소와 2번째 원소를 비교 &amp; swap   n-1번째 원소와 n번째 원소를 비교 &amp; swap   버블 정렬은 중첩 반복이 발생하므로 O(N^2)의 시간복잡도를 가집니다.   function bubble(input) {   const len = input.length;   let tmp = null;   for (let i = 0; i &lt; len; i++) {     for (let j = 0; j &lt; len - i - 1; j++) {       if (input[j] &gt; input[j + 1]) {         // swap         tmp = input[j];         input[j] = input[j + 1];         input[j + 1] = tmp;         tmp = null;       }     }   } }   이때 최악의 경우 모든 요소를 swap해야 하기 때문에 직관적이지만 비효율적인 방식이라 자주 사용되진 않습니다.   📄 선택 정렬 (Selection Sort)   선택 정렬은 원소를 넣을 위치(인덱스)를 미리 정해놓고, 데이터셋을 순회하여 해당 원소를 찾습니다.   쉽게 얘기하자면, 오름차순으로 정리할 때 가장 작은 수를 찾아 맨 앞과 교환한다는 뜻입니다.      주어진 데이터셋에서 최소값을 찾는다.   해당 값을 맨 앞의 요소와 swap한다.   두번째 요소부터 위 과정을 반복한다.   function selectionSort (array){   for (let i = 0; i &lt; array.length; i++){     let minIndex = i;     for (let j = i + 1; j++){       if (array[minIndex] &gt; array[j]){         minIndex = j; // 1       }     }     if (minIndex !== i){ // 2       let swamp = array[minIndex];       array[minIndex] = array[i];       array[i] = swamp;     }   }   return array }   선택 정렬은 정렬이 되어 있는 경우, 되어 있지 않은 경우 모든 O(N^2)의 시간 복잡도를 가집니다.   📄 삽입 정렬   삽입 정렬은 한 사이클동안 모든 요소를 순환하지 않습니다.   사이클마다 해당 요소를 왼쪽에 있는 값들과 비교하고 알맞은 자리에 해당 요소를 삽입합니다.      두번째 요소를 왼쪽 요소와 비교하고 데이터셋을 정렬한다.   세번째 요소를 첫번째 요소와 두번째 요소와 비교하고 데이터셋을 정렬한다.   배열의 크기만큼 위 과정을 반복한다.   function insertionSort(array) {   for (let i = 1; i &lt; array.length; i++) {     let cur = array[i];     let left = i - 1;      while (left &gt;= 0 &amp;&amp; array[left] &gt; cur) {       array[left + 1] = array[left];       left--;     }     array[left + 1] = cur;   }   return array; }   삽입 정렬의 경우 정렬이 모두 되어 있는 최선의 경우에는 O(N)의 시간복잡도를 가지고,  정렬이 되어 있지 않은 최악의 경우에는 O(N^2)의 시간 복잡도를 가집니다.   참고      노마드 코더 - 어? 재밌네? 정렬 알고리즘, 한방에 이해하기!   Code Playground  ","categories": ["Algorithm"],
        "tags": ["버블 정렬","선택 정렬","삽입 정렬"],
        "url": "/algorithm/algorithm-%EC%A0%95%EB%A0%AC/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] k번째수",
        "excerpt":"📄 문제   배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.   예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면   array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.      array의 길이는 1 이상 100 이하입니다.   array의 각 원소는 1 이상 100 이하입니다.   commands의 길이는 1 이상 50 이하입니다.   commands의 각 원소는 길이가 3입니다.   🙋‍♀️ 나의 풀이 #1   function solution(array, commands) {   let answer = [];   for (let i = 0; i &lt; commands.length; i++) {     answer.push(       array.slice(commands[i][0] - 1, commands[i][1]).sort((a, b) =&gt; a - b)[         commands[i][2] - 1       ]     );   }   return answer; }      주어진 배열 array를 요구사항대로 자르고 sort() 메소드로 정렬했습니다.   그래도 정렬 알고리즘을 배웠으니 한번 메소드를 사용하지 않고 풀어보겠습니다.   🙋‍♀️ 나의 풀이 #2   삽입 정렬을 사용한 풀이입니다.   function solution(array, commands) {   let answer = [];   for (let i = 0; i &lt; commands.length; i++) {     const slicedArray = array.slice(commands[i][0] - 1, commands[i][1]);     // 삽입 정렬 시작     for (let j = 1; j &lt; slicedArray.length; j++) {       let cur = slicedArray[j];       let left = j - 1;        while (left &gt;= 0 &amp;&amp; slicedArray[left] &gt; cur) {         slicedArray[left + 1] = slicedArray[left];         left--;       }       slicedArray[left + 1] = cur;     }     answer.push(slicedArray[commands[i][2] - 1]);   }   return answer; }      속도면에서는 크게 다른 점이 없습니다.   👍 Best Practice   function solution(array, commands) {   return commands.map((command) =&gt; {     const [sPosition, ePosition, position] = command;     const newArray = array       .filter(         (value, fIndex) =&gt; fIndex &gt;= sPosition - 1 &amp;&amp; fIndex &lt;= ePosition - 1       )       .sort((a, b) =&gt; a - b);      return newArray[position - 1];   }); }   주어진 조건 commands를 구조 분해 할당을 사용해 가독성을 높인 풀이입니다.   slice 메소드가 아니라 filter 메소드를 사용해 배열을 자를 수도 있다는걸 하나 알아갑니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["정렬","k번째 수"],
        "url": "/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 하샤드 수",
        "excerpt":"📄 문제   양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.      x는 1 이상, 10000 이하인 정수입니다.   🙋‍♀️ 나의 풀이   function solution(x) {   let sum = [...x.toString()].reduce((acc, cur) =&gt; {     return (acc += Number(cur));   }, 0);   return x % sum === 0; }      주어진 숫자(x)를 문자열로 변환 후, 각 자릿값을 배열의 요소로 만든다.   배열의 요소를 reduce메소드를 사용해 더한 누적값을 변수 sum에 할당한다.   요구사항대로 주어진 숫자를 누적값으로 나누었을 때 0이 되는지에 대한 boolean값을 반환한다.   처음으로 프로그래머스에서 reduce함수를 사용했습니다.   점점 응용하는 메소드가 생길수록 뿌듯합니다.   👍 Best Practice   function Harshad(n) {   return !(n % (n + \"\").split(\"\").reduce((a, b) =&gt; +b + +a)); }   반환값을 true/false가 아닌 0과 1을 통해 표현할 수도 있다는 것을 적용한 식입니다. 👍   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["하샤드 수","reduce"],
        "url": "/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 가장 큰 수",
        "excerpt":"📄 문제   0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.   예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.   0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.      numbers의 길이는 1 이상 100,000 이하입니다.   numbers의 원소는 0 이상 1,000 이하입니다.   정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.   🙋‍♀️ 나의 풀이   function solution(numbers) {   let answer = numbers     .map((value) =&gt; value + \"\")     .sort((a, b) =&gt; b + a - (a + b))     .join(\"\");    return answer[0] === \"0\" ? \"0\" : answer; }      주어진 배열 numbers를 순회해 sort()메소드를 적용한다.’   인접한 두 수를 순서를 바꿔 비교하고 내림차순한다.   완성된 배열을 join(““)으로 문자열로 바꾼다.   만약 [0, 0, 0]인경우 답이 “000”이 되므로 삼항연산자를 이용해 첫번째 자릿수가 0인경우 0을 바로 반환한다.  ","categories": ["programmers-lv2"],
        "tags": ["가장 큰 수","정렬","sort"],
        "url": "/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 두 정수 사이의 합",
        "excerpt":"📄 문제   두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요. 예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.      a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.   a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.   a와 b의 대소관계는 정해져있지 않습니다.   🙋‍♀️ 나의 풀이   function solution(a, b) {   let [newA, newB] = [a, b].sort((a, b) =&gt; a - b); // 1   let sum = 0;   for (let i = newA; i &lt;= newB; i++) {     // 2     sum += i;   }   return sum; }      주어진 정수를 배열에 담아 정렬후 구조분해 할당을 사용해 새로운 값을 만들었다.   반복문으로 newA부터 newB까지의 합을 구해 답을 반환한다.   👍 Best Practice   function adder(a, b, s = 0) {   for (var i = Math.min(a, b); i &lt;= Math.max(a, b); i++) s += i;   return s; }   Math 메소드를 적절히 활용한 풀이입니다. 👍  ","categories": ["programmers-lv1"],
        "tags": ["sort"],
        "url": "/programmers-lv1/programmers-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4-%ED%95%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 위장",
        "excerpt":"📄 문제   스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.   예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.   스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.      clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.   스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.   같은 이름을 가진 의상은 존재하지 않습니다.   clothes의 모든 원소는 문자열로 이루어져 있습니다.   모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.   스파이는 하루에 최소 한 개의 의상은 입습니다.   🙋‍♀️ 나의 풀이   function solution(clothes) {   let answer = 1;   const clothesMap = new Map(); // 1   clothes.forEach((value) =&gt; {     clothesMap.set(value[1], (clothesMap.get(value[1]) || 0) + 1); // 2   });   for (let [cloth, num] of clothesMap) {     answer *= num + 1; // 3   }   return answer - 1; // 4 }   이번 문제는 해시 개념을 이용한 문제입니다.      각 (옷의 종류가 가진 옷의 개수 +1)를 곱해서 답을 구한다. +1은 해당 옷을 입지 않았을 때의 경우이다.   스파이는 하루 최소 한개의 의상을 입으므로 모든 옷을 입지 않았을 경우(-1)를 빼준다.   예전에 풀었던 [완주하지 못한 선수]를 풀 때 봤던 map()메소드를 사용해보았습니다.      주어진 의상을 의상별로 정리할 데이터를 담을 Map 객체(clothesMap)를 생성한다.   clothes를 순회하며 같은 의상의 이름에 값을 누적하며 더해준다.(+1)   완성된 clothesMap에 있는 의상의 개수끼리 곱한다.   옷을 아예 입지 않은 경우를 제외시키 위해 answer에 -1을 하고 답을 반환한다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["해시"],
        "url": "/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 콜라츠 추측",
        "excerpt":"📄 문제 출처   1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.   예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.      입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.   🙋‍♀️ 나의 풀이   function solution(num) {   let answer = 0;   while (num &gt; 1) {     num = num % 2 === 0 ? num / 2 : num * 3 + 1;     answer++;     if (answer === 500) return -1;   }   return answer; }   재귀함수를 사용해 볼까 하다가 성능상 반복문이 더 좋을 것 같아 while문에 조건을 걸어 num가 1이 될때 까지 반복했습니다.   👍 Best Practice   function collatz(num, count = 0) {   return num == 1     ? count &gt;= 500       ? -1       : count     : collatz(num % 2 == 0 ? num / 2 : num * 3 + 1, ++count); }   그래도 재귀함수를 사용한 풀이는 멋있네요.   삼항 연산자를 중첩으로 사용할 수 있다는 것도 처음 알아갑니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["콜라츠 추측"],
        "url": "/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 서울에서 김서방 찾기",
        "excerpt":"📄 문제   String형 배열 seoul의 element중 “Kim”의 위치 x를 찾아, “김서방은 x에 있다”는 String을 반환하는 함수, solution을 완성하세요. seoul에 “Kim”은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.      seoul은 길이 1 이상, 1000 이하인 배열입니다.   seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다.   “Kim”은 반드시 seoul 안에 포함되어 있습니다.   🙋‍♀️ 나의 풀이   function solution(seoul) {   return `김서방은 ${seoul.indexOf(\"Kim\")}에 있다`; }   배열 내장 메소드인 indexOf()를 사용했습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["indexOf"],
        "url": "/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 짝지어 제거하기 by JS",
        "excerpt":"📄 문제   짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.   예를 들어, 문자열 S = baabaa 라면   b aa baa → bb aa → aa →   의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.      문자열의 길이 : 1,000,000이하의 자연수   문자열은 모두 소문자로 이루어져 있습니다.   🙋‍♀️ 나의 풀이 1   function solution(s) {   let arr = [...s]; // 0   while (arr.length !== 0) {     // 1     arr = arr.filter(       // 2       (value, index) =&gt;         arr[index] !== arr[index + 1] &amp;&amp; arr[index] !== arr[index - 1]     );     if (arr.length == s.length) break; // 3   }   return arr[0] ? 0 : 1; // 4 }      주어진 문자열을 배열 arr로 바꾼다.   while문 배열의 길이가 0이될 때까지 반복한다.   배열 요소의 앞 뒤 인덱스가 모두 다른 것만 남도록 조건을 주어 arr를 바꿔준다.   만약 바꾼 arr의 길이와 처음 주어진 문자열 s의 길이가 같다면 반복문을 나온다.   arr의 값이 있으면 0 없으면 1을 반환한다.   이 코드는 문제가 있습니다.   O(N^2)의 시간복잡도를 가지고 있어 몇개의 테스트코드를 통과하지 못했습니다.   좀 더 나은 시간복잡도를 내기 위해 스택개념을 사용해보기로 했습니다.   🙋‍♀️ 나의 풀이 2   function solution(s) {   const stack = [];    for (let i = 0; i &lt; s.length; i++) {     stack.push(i);     if (stack[stack.length - 1] == stack[stack.length - 2]) {       stack.pop();       stack.pop();     }   }   return stack.length == 0 ? 1 : 0; }      문자열 s를 순서대로 stack에 넣는다.   만약 들어온 문자열이 중복으로 또 들어오면 내보낸다. pop() pop()!!!   다른 풀이를 보니 모두 스택 개념을 적용했네요.   스택을 이용해 푸니 시간복잡도가 O(N)이 되어 모든 테스트코드를 통과할 수 있었습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["스택"],
        "url": "/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 최소직사각형 by JS",
        "excerpt":"📄 문제   명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.   아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.   명함 번호 가로 길이 세로 길이      1 60 50   2 30 70   3 60 30   4 80 40   가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.   모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.      sizes의 길이는 1 이상 10,000 이하입니다.            sizes의 원소는 [w, h] 형식입니다.       w는 명함의 가로 길이를 나타냅니다.       h는 명함의 세로 길이를 나타냅니다.       w와 h는 1 이상 1,000 이하인 자연수입니다.           🙋‍♀️ 나의 풀이   function solution(sizes) {   let sortedSizes = sizes.map((arr) =&gt; arr.sort((a, b) =&gt; b - a)); // 1   let card = [0, 0];   for (let i = 0; i &lt; sizes.length; i++) {     // 2     card[0] = sortedSizes[i][0] &gt; card[0] ? sortedSizes[i][0] : card[0];     card[1] = sortedSizes[i][1] &gt; card[1] ? sortedSizes[i][1] : card[1];   }   return card[0] * card[1]; // 3 }      주어진 배열 sizes를 순회하여 가로길이에 더 큰 값이 가도록 정렬한다.   정렬한 배열 sortedSizes를 반복문을 돌려 가로, 세로 각 최댓값을 구한다.   구한 최댓값끼리 곱해 답을 반환한다.   👍 Best Practice   function solution(sizes) {   const rotated = sizes.map(([w, h]) =&gt; (w &lt; h ? [h, w] : [w, h]));    let maxSize = [0, 0];   rotated.forEach(([w, h]) =&gt; {     if (w &gt; maxSize[0]) maxSize[0] = w;     if (h &gt; maxSize[1]) maxSize[1] = h;   });   return maxSize[0] * maxSize[1]; }   비슷한 방식으로 풀었지만 개인적으로 삼항연산자보다 if문을 사용한게 더 깔끔하다고 느꼈습니다.  ","categories": ["programmers-lv1"],
        "tags": ["완전 탐색"],
        "url": "/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 나누어 떨어지는 숫자 배열 by JS",
        "excerpt":"📄 문제   array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요. divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.      arr은 자연수를 담은 배열입니다.   정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.   divisor는 자연수입니다.   array는 길이 1 이상인 배열입니다.   🙋‍♀️ 나의 풀이   function solution(arr, divisor) {   const answer = arr.filter((value) =&gt; value % divisor === 0);   return answer.length ? answer.sort((a, b) =&gt; a - b) : [-1]; }      filter 메소드로 divisor로 나누어 떨어지는 수를 배열 answer에 담는다.   answer의 길이가 0이면 [-1], 0이 아니면 true를 반환하므로 answer을 오름차순한 값을 반환한다.   👍 Best Practice   function solution(arr, divisor) {   var _ = arr.filter((e) =&gt; !(e % divisor));   return _[0] ? _.sort(($, _) =&gt; $ - _) : [-1]; }   filter연산을 좀더 간소화한 풀이입니다. 👍   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": [""],
        "url": "/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 영어 끝말잇기 by JS",
        "excerpt":"📄 문제   1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.   1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.   tank → kick → know → wheel → land → dream → mother → robot → tank   위 끝말잇기는 다음과 같이 진행됩니다.      1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.   2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.   3번 사람이 자신의 첫 번째 차례에 know를 말합니다.   1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.   (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.   사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.      끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.   words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.   단어의 길이는 2 이상 50 이하입니다.   모든 단어는 알파벳 소문자로만 이루어져 있습니다.   끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.   정답은 [ 번호, 차례 ] 형태로 return 해주세요.   만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.   🙋‍♀️ 나의 풀이   function solution(n, words) {   let answer = [0, 0];   let stack = [];   for (let i = 0; i &lt; words.length; i++) {     // 1     if (!stack[0]) {       // 2       stack.push(words[i]);       continue;     }     if (stack.indexOf(words[i]) !== -1 || stack.at(-1).at(-1) !== words[i][0]) {       // 3       answer = [(i + 1) % n ? (i + 1) % n : n, Math.ceil((i + 1) / n)]; // 4       break;     }     stack.push(words[i]); // 5   }   return answer; }      주어진 문자열 배열 words를 순환한다.   첫번째 반복의 경우 stack의 값이 비어있어 연산과정에서 에러가 발생하므로, words의 첫번째 값을 삽입 후 반복문을 이어간다.   만약 stack에 현재 순환되고 있는 순서의 word[i]값이 있거나 끝말잇기에 실패한다면,   가장 먼저탈락한 사람의 번호와 몇 번째 차례 탈락인지 구하고 반복문을 나온다.   위 조건문에 해당하지 않을 경우, stack에 값을 추가한다.   이 문제는 예전에 봤던 모 기업의 코딩테스트에서는 풀지 못했는데 이번에는 풀어서 뿌듯합니다.😤  시간이 좀 걸렸던 이유는 배열의 인덱스는 0부터 시작하고 문제기준 인덱스는 1부터 시작해 헷갈렸기 때문입니다. 대체 왜 배열을 만든 사람은 첫번째 숫자를 0으로 한걸까요.   👍 Best Practice   function solution(n, words) {   let answer = 0;   words.reduce((prev, now, idx) =&gt; {     answer =       answer ||       (words.slice(0, idx).indexOf(now) !== -1 || prev !== now[0]         ? idx         : answer);     return now[now.length - 1];   }, \"\");    return answer ? [(answer % n) + 1, Math.floor(answer / n) + 1] : [0, 0]; }      첫번째 인덱스에서는 answer값을 0인 그대로 넘기고 prev에 값의 마지막 문자열을 담는다.   요구사항 조건에 해당하는 경우 answer에 해당 인덱스를 담는다.   answer에 값이 0이 아닌 경우, 가장 먼저 탈락한 사람의 번호와 탈락 차례를 반환한다. (0의 경우 [0,0]을 반환)   이 풀이는 속도에선 크게 차이가 없었으나, reduce함수를 잘 사용해서 Best Practice로 선정했습니다.  이 풀이의 단점은 reduce함수를 사용했기 때문에 break문을 사용할 수 없어 모든 경우를 연산해야 한다는 점이 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["스택"],
        "url": "/programmers-lv2/programmers-%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React] 줄글 props로 넘겨 줄바꿈하기",
        "excerpt":"📄 줄글 props로 넘겨 줄바꿈하는 방법      줄바꿈하는 곳에 \\n을 입력한다.   const GetStart = () =&gt; {   const description = `메세지가 도착했습니다는 익명 렌덤 메신저 💌 입니다.\\n쉽게 뱉을 수 없었던 비밀 또는 모르는 누군가에게 보낼 응원의 메세지 \t\t\t\t\t모두 좋아요.\\n 💡 rule 1 메세지는 단 한명에게만 전달됩니다.\\n 💡 rule 2 먼저 메세지를 보내야 익명의 누군가에게 메세지를 받을 \t\t\t\t\t수 있습니다.\\n 💡 rule 3 메세지의 상대방은 매번 바뀝니다.`;   return (     &lt;div className=\"start__container\"&gt;       &lt;Logo /&gt;       &lt;SpeechBubble text={description} /&gt;     &lt;/div&gt;   ); };  export default GetStart;      텍스트가 들어가는 태그 css에 white-space: pre-line을 설정한다.   .start__description__content {   background-color: $back-ground-light;   white-space: pre-line; // 💡   padding: 1em;   border-top-right-radius: 30px;   border-top-left-radius: 30px;   border-bottom-right-radius: 30px;   color: black; }  ","categories": ["React"],
        "tags": ["props","줄바꿈"],
        "url": "/react/react-%EC%A4%84%EA%B8%80-props%EB%A1%9C-%EB%84%98%EA%B2%A8-%EC%A4%84%EB%B0%94%EA%BF%88%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 핸드폰 번호 가리기",
        "excerpt":"📄 문제   프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.      phone_number는 길이 4 이상, 20이하인 문자열입니다.   🙋‍♀️ 나의 풀이   function solution(phone_number) {   return \"*\".repeat(phone_number.length - 4) + phone_number.slice(-4); }      문자열 메소드인 repeat으로 보여질 숫자 4개를 제외한 개수로 “*“을 만든다.   주어진 phone_number를 뒤에서 4개로 잘라 붙여서 반환한다.   👍 Best Practice   function hide_numbers(s) {   return s.replace(/\\d(?=\\d{4})/g, \"*\"); }   정규식을 이용한 풀이입니다.  ?=가 숫자 앞에오면 그 뒤에있는 숫자가 일치하는지 확인하는 정규식 문법입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["repeat","정규식"],
        "url": "/programmers-lv1/programmers-%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8-%EA%B0%80%EB%A6%AC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[메세지가 도착했습니다] 둘다 사용해보고 작성하는 Styled-Components와 SCSS의 차이점",
        "excerpt":"📄 SCSS? SCSS!   처음으로 프로젝트에 SCSS를 사용했다.  두가지 사용경험에 우선 차이점이 있다면 styled-components는 일단 다른 코드를 보며 무작정 사용하고 SCSS는 인강을 보고 공부했다는 점이다.  styled-component를 계속 사용하다보니 CSS-in-CSS문법에 둔해져 그냥 구글링과 공식문서를 보고 사용하기엔 감이 잘 오지 않아 인강을 들을 수 밖에 없었다.  빨리 SCSS를 사용해 보고 싶어서 인강은 하루만에 다 들었다.    📄 SCSS 사용하니 좋았던 점   1. 좀 더 나은 스타일 구조화   아주 객관적이지만 SCSS를 사용했을 때 프로젝트 구조를 잡기가 더 쉬웠다.  styled-component의 경우 베이스 코드를 작성하기 위해 createGlobalStyle을 사용해 index파일에서 import하고 태그를 생성하는 과정이 있는 반면, SCSS에서는 베이스 코들르 작성하고 import하면 바로 사용할 수 있었다.  큰 차이는 아니지만 처음 styled-components를 사용했을 때 createGlobalStyle 태그를 생성해야하는 위치가 헷갈려 애먹었던 적이 있다.   💾 base.scss      프로젝트를 진행하며 점점 추가될 예정인 내 base 코드   * {   font-family: \"NanumBarunpen\";   box-sizing: border-box; } html {   height: 100%; } body {   height: 100%;   width: 100%;   margin: 0; } button {   font-weight: bold; }   좀더 시각적으로 나았던 부분이 하나 더 있다.  SCSS는 파일 아이콘이 있어 좀더 확실히 구분되는 느낌을 준다.      styled-components는 어떤게 스타일 파일인지 직관적으로 눈에 들어오지 않는다.      2. 매번 설치할 필요가 없다.   저번에 인강들으면서 전역으로 한번 설치해놓으니 매번 설치할 필요가 없다.  왠지 프로젝트가 가벼워진 기분이든다.   npm install -g sass // 요거 한번만 설치하면 끝   3. 코드 재사용 문법이 더 잘되어 있다.      변수            theme color를 지정할 때 유용       media-query에도 사용할 예정           중첩   mixin   extend   styled-component도 물론 중복 코드를 처리할 수 있지만, styled-component 고유 문법이 아니다.  styled-component를 사용했을 때는 그냥 이렇게 보통 객체를 생성해 key-value형태로 사용했다.   // styled-component  const theme = {   mainColor: `#CCD6A6`,   bgGroundColor1: \"#FFFFFF\",   bgGroundColor2: \"#F8F9FA\",   bgGroundColor3: \"#E9ECEF\",   bgGroundColor4: \"#F4EAD5\",   ... };   SCSS에서는 따로 스타일을 위한 변수 선언 및 사용이 가능하다.   // scss  $main-color: #39b5e0;  $back-ground-light: #ffffff; $back-ground-light2: #f6f1f1;   뿐만 아니라 mixin문법으로 자주 사용하는 스타일을 저장해 꺼내쓰고, extend문법으로 부모 스타일을 상속받아 사용할 수 있다.   .messageList__content {   padding: 1em;   background-color: wheat;   border-bottom: 1px solid $point-blue1; }  .messageList__header {   @extend .messageList__content ...; // 💡 }  .messageList_list {   @extend .messageList__content ...; // 💡 }   4. 코드가 색이 칠해져 있다 🤩   사실 이게 styled-componets의 가장 큰 단점이라고 생각한다.  코드가 한 색깔로 되어 있다는 것이다.   export const HeaderWrapper = styled.div`   display: flex;   justify-content: space-between;   align-items: center;   box-sizing: inherit;   height: 100%;    @media (max-width: 1920px) {     width: calc(100% - 20rem);   }    @media (max-width: 1080px) {     width: calc(100% - 8rem);   }    @media (max-width: 600px) {     width: calc(100% - 3rem);   } `;   혹시 바로 몰라 찾아 보니 vscode에 vscode-styled-components이라는 extension이 있다고 한다.  진작 찾아봤으면 좋았을껄…   📄 SCSS 사용하니 불편했던 점   1. 처치 곤란한 CSS파일들   작성은 SCSS로 하지만 컴파일되면 모두 CSS로 변환되어 새로운 CSS파일이 자동으로 생긴다.  나에게 가장 큰 진입장벽이 CSS파일을 관리하는 것이었다.       SCSS파일이 위치한 곳마다 CSS파일을 둔다.   CSS파일 경로를 설정해 한 폴더에 몰아버린다.   여기까지 알아 뒀는데 인강을 듣고 한가지 방법을 더 알게 되었고 프로젝트에 도입했다.      main.scss에 모든 scss파일을 import해 컴파일 되는 파일은 main.scss파일 하나만 되게 만든다.   3번의 방법을 사용하면 결국 나오는 .CSS확장자를 가진 파일은 main.css하나만 존재한다.  아마 프로젝트가 큰 경우에는 main.scss 파일이 너무 무거워져 사용하면 안될 것 같다.    이렇게 하면 또 번거로운 점이 생긴다.      Styled-Components의 경우: styled.js –(import)–&gt; index.tsx   SCSS의 경우: _index.scss –(import)–&gt; main.scss –(compile)–&gt; main.css –(import)–&gt; (root경로의)index.tsx   일단 인강에서 배운대로만 하면 이렇게 징검다리가 생기는데 분명 더 나은 방법이 있을 것이다.  요즘 프로젝트 구조를 참고하는 sendbird Github는 나처럼 한번에 모아서 컴파일 하지도 않고 CSS파일이 숨겨져 있는지 보이지도 않는다.  검색해도 방법 찾기가 쉽지 않다.   2. 컴파일로 인한 속도 저하   Scss파일을 컴파일하기 위해 터미널말고 Watch Sass extension을 사용하고 있다.  문제는 파일이 변경(저장)되면 즉시 컴파일 한다는 점이다.   ctrl + s가 습관인 나는 굉장히 여러번 컴파일을 하는데 OUTPUT창이 계속 움직인다…  만약 프로젝트 크기가 굉장히 큰 경우에는 적용한 스타일을 바로바로 빠르게 확인하기 어려울듯 싶다.   3. props 참조가 안된다.   이 부분은 styled-component의 가장 큰 장점인듯 싶다.  styled-component를 사용할 때 매우 유용하게 사용해 이 부분도 굉장히 불편하게 느껴졌다.    SCSS에서 props를 설정하는 방법은 여러가지가 있다.      className을 배열로 선언해 사용   import React from \"react\"; import \"./Button.scss\";  function Button({ children, size }) {   return &lt;button className={[\"Button\", size].join(\" \")}&gt;{children}&lt;/button&gt;; }  Button.defaultProps = {   size: \"medium\", };  export default Button;      className을 리터럴로 만들어 사용   import React from \"react\"; import \"./Button.scss\";  function Button({ children, size }) {   return &lt;button className={`Button ${size}`}&gt;{children}&lt;/button&gt;; }  Button.defaultProps = {   size: \"medium\", };  export default Button;   이를 보완하기 위해 classnames라는 라이브러리를 많이 사용한다고 한다.    classNames(\"foo\", \"bar\"); // =&gt; 'foo bar' classNames(\"foo\", { bar: true }); // =&gt; 'foo bar' classNames({ \"foo-bar\": true }); // =&gt; 'foo-bar' classNames({ \"foo-bar\": false }); // =&gt; '' classNames({ foo: true }, { bar: true }); // =&gt; 'foo bar' classNames({ foo: true, bar: true }); // =&gt; 'foo bar' classNames([\"foo\", \"bar\"]); // =&gt; 'foo bar'  // 동시에 여러개의 타입으로 받아올 수 도 있습니다. classNames(\"foo\", { bar: true, duck: false }, \"baz\", { quux: true }); // =&gt; 'foo bar baz quux'  // false, null, 0, undefined 는 무시됩니다. classNames(null, false, \"bar\", undefined, 0, 1, { baz: null }, \"\"); // =&gt; 'bar 1'     SCSS와 Styled-Component는 둘다 CSS 스타일링에 많이 사용되는 언어이고 장단점이 있어 사용자 특성에 따라 사용되는 것 같다.  SCSS를 꼭 사용해보고 싶었는데 하루 써보고 신나서 바로 블로그에 포스팅하러 달려왔다.  계속 사용해볼 예정인데 아마 오늘 알게 된 내용보다 더 많은 걸 알게 될 것 같다.   코드 참고      벨로퍼트와 함께하는 모던 리액트  ","categories": ["random-message"],
        "tags": ["Styled-Components","SCSS"],
        "url": "/random-message/random-message-styled-component%EC%99%80-scss%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 카펫",
        "excerpt":"📄 문제   Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.   Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.   Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.      갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.   노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.   카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.   🙋‍♀️ 나의 풀이   function solution(brown, yellow) {   let answer = [];   let sum = brown + yellow;    for (let height = 3; height &lt;= brown / 2; height++) {     if (sum % height === 0) {       let width = sum / height;        if ((height - 2) * (width - 2) === yellow) return [width, height];     }   } }      직사각형의 최소길이는 3이므로 3부터 brown/2까지 반복문을 돌린다.   sum을 height로 나누어 0이 떨어지는 경우는 직사각형의 가로, 세로 길이가 정수가 되는 경우이므로 width를 구해서 답을 반환한다.  ","categories": ["programmers-lv2"],
        "tags": ["완전탐색"],
        "url": "/programmers-lv2/programmers-%EC%B9%B4%ED%8E%AB/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 음양 더하기",
        "excerpt":"📄 문제   어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.      absolutes의 길이는 1 이상 1,000 이하입니다.            absolutes의 모든 수는 각각 1 이상 1,000 이하입니다.           signs의 길이는 absolutes의 길이와 같습니다.            signs[i] 가 참이면 absolutes[i] 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.           🙋‍♀️ 나의 풀이   function solution(absolutes, signs) {   const answer = absolutes.reduce((acc, cur, index) =&gt; {     return (acc += signs[index] ? cur : -cur);   }, 0);   return answer; }   이렇게 반복문을 사용하게 되는 문제에서는 항상 고민을 하게 됩니다.   언제 for문을 사용하고 언제 배열 메소드를 사용할까요?   속도는 for문이 빠르지만 가독성은 배열 메소드들이 좋기 때문입니다.      참고한 포스팅을 읽고 정리한 저의 생각은 다음과 같습니다.           성능이 중요한 경우에 for 문(명령형 프로그래밍)을 사용한다. 예를들어, 프로그래머스 효율성 테스트 혹은 계산이 너무 많아 느려지는 함수등이 그렇다.            병목 현상은 사실상 다른곳에서 일어나는 경우다. 따라서 성급한 최적화는 오히려 독이 되는 경우가 많다.            만약 배열 메소드를 사용해도 가독성이 좋지 않으면, 다시 고려해본다.          병목 현상이란? PC에서 병목 현상이라고 하면 두 구성 요소의 최대 성능의 차이로 인해 한 구성 요소가 다른 하드웨어의 잠재 성능을 제한하는 것을 말합니다. by. intel    항상 고민하던 문제였는데 이제 나름 기준이 생겨 가고 있습니다 :)   참고      프로그래머스        Leany Labs       intel - 구성 요소의 균형을 적절하게 조정하는 방법  ","categories": ["programmers-lv1"],
        "tags": ["reduce","for"],
        "url": "/programmers-lv1/programmers-%EC%9D%8C%EC%96%91-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 제일 작은 수 제거하기 by JS",
        "excerpt":"📄 문제   정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.      arr은 길이 1 이상인 배열입니다.   인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다.   🙋‍♀️ 나의 풀이   function solution(arr) {   let target = Math.min.apply(Math, arr);   return arr == target ? [-1] : arr.filter((value) =&gt; value !== target); }      Math 메소드를 사용해 주어진 배열에서 가장 작은 수를 구한다.   찾은 가장 작은수 (target)이 처음 값과 같다면 [-1]을, 아니라면 filter함수를 사용해 해당 값을 제거한 배열을 리턴한다.   👍 Best Practice   function solution(arr) {   arr.splice(arr.indexOf(Math.min(...arr)), 1);   if (arr.length &lt; 1) return [-1];   return arr; }   제가 푼 문제에서는 apply메소드를 사용해서 속도가 느렸는데 이 풀이는 스프레드 연산자를 사용해 이를 보완했습니다.   스프레드 연산자를 문자열을 배열로 만들때만 생각했는데 다양한 방법으로 활용해 문제에 접근해보는 시각을 넓혀야겠습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["Math"],
        "url": "/programmers-lv1/programmers-%EC%A0%9C%EC%9D%BC-%EC%9E%91%EC%9D%80-%EC%88%98-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 구명보트 by JS",
        "excerpt":"📄 문제   무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.   예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.   구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.   사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.      무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.   각 사람의 몸무게는 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.   🙋‍♀️ 나의 풀이   function solution(people, limit) {   let answer = 0;   let sortedPeople = people.sort((a, b) =&gt; a - b);   while (sortedPeople.length !== 0) {     if (sortedPeople[0] + sortedPeople[sortedPeople.length - 1] &lt;= limit) {       sortedPeople.pop();       sortedPeople.shift();     } else {       sortedPeople.pop();     }     answer++;   }   return answer; }                  🎲 key point       최선의 상황은 가장 몸무게가 많은 사람 + 가장 몸무게가 적은 사람           처음에 몸무게가 가장 적은 순서대로 배에 태웠더니 자꾸 테스트 에러가 발생해서 몸무게 조합을 바꾸어서 생각하니 통과할 수 있었습니다.      people을 내림차순으로 정렬한 배열 sortedPeople을 생성한다.   sortedPeople에 요소가 없을 때까지 반복문을 돌린다.   요소의 맨 앞(가장 가벼운 사람) + 요소의 맨 뒤(가장 무거운 사람)의 합이 제한 무게 보다 적으면 배열에서 제거하고 answer에 1을 추가한다.   요소의 맨 앞(가장 가벼운 사람) + 요소의 맨 뒤(가장 무거운 사람)의 합이 제한 무게 보다 많으면 맨 뒷사람만 배열에서 제거하고 answer에 1을 추가한다.   👍 Best Practice   function solution(people, limit) {   people.sort(function (a, b) {     return a - b;   });   for (var i = 0, j = people.length - 1; i &lt; j; j--) {     if (people[i] + people[j] &lt;= limit) i++;   }   return people.length - i; }   for문 조건으로 4개가 들어가는건 처음 봅니다. 신기하네요.   이 풀이에서는 i가 맨 앞사람, j가 맨 뒷사람이 됩니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["스택","큐","그리디"],
        "url": "/programmers-lv2/programmers-%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 없는 숫자 더하기 by JS",
        "excerpt":"📄 문제   0부터 9까지의 숫자 중 일부가 들어있는 정수 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.      1 ≤ numbers의 길이 ≤ 9            0 ≤ numbers의 모든 원소 ≤ 9       numbers의 모든 원소는 서로 다릅니다.           🙋‍♀️ 나의 풀이   function solution(numbers) {   let answer = 0;   for (let i = 0; i &lt;= 9; i++) {     numbers.find((value) =&gt; value === i) ? \"\" : (answer += i);   }   return answer; }      0부터 9까지 for문을 돌려 find메소드로 number에 해당하는 정수가 있는지 확인하고 answer에 더한다.   👍 Best Practice 1   function solution(numbers) {   return 45 - numbers.reduce((cur, acc) =&gt; cur + acc, 0); }      45에서 주어진 배열 요소를 합한 값을 뺀다.   👍 Best Practice   function solution(numbers) {   let answer = 0;    for (let i = 0; i &lt;= 9; i++) {     if (!numbers.includes(i)) answer += i;   }    return answer; }      0부터 9까지 for문을 돌려 include메소드로 number에 해당하는 정수가 있는지 확인하고 answer에 더한다.   콜백함수를 받는 find대신 include를 사용하는 것이 더 좋아보입니다 :)  ","categories": ["programmers-lv1"],
        "tags": ["find","include"],
        "url": "/programmers-lv1/programmers-%EC%97%86%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 수박수박수박수박수박수? by JS",
        "excerpt":"📄 문제   길이가 n이고, “수박수박수박수….”와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 “수박수박”을 리턴하고 3이라면 “수박수”를 리턴하면 됩니다.      n은 길이 10,000이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   let answer = [];   for (let i = 1; i &lt;= n; i++) {     i % 2 ? answer.push(\"수\") : answer.push(\"박\");   }   return answer.join(\"\"); }      빈배열을 생성해 홀수번째 인덱스에는 “수”, 짝수번째 인덱스에는 “박”을 push한다.   반환할때는 문자열로 바꾼다.   👍 Best Practice   var waterMelon = (n) =&gt; \"수박\".repeat(n / 2) + (n % 2 === 1 ? \"수\" : \"\");      repeat 메소드를 사용해 수박을 주어진 수를 글자 수로 나눈 값만큼 반복한다.   마지막에 자릿수가 하나 남으면 “수”를 채워준다.   아무래도 배열보다 문자열이 메모리 소비를 덜할 것 같아 좋은 풀이로 느껴집니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["수박","repeat"],
        "url": "/programmers-lv1/programmers-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 내적 by JS",
        "excerpt":"📄 문제   길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.   이때, a와 b의 내적은 a[0]b[0] + a[1]b[1] + … + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)      a, b의 길이는 1 이상 1,000 이하입니다.   a, b의 모든 수는 -1,000 이상 1,000 이하입니다.   🙋‍♀️ 나의 풀이   function solution(a, b) {   return a.reduce((acc, cur, index) =&gt; {     return (acc += cur * b[index]);   }, 0); }   reduce함수를 사용해 배열 a와 b의 같은 인덱스끼리의 합을 구해 반환했습니다.   👍 Best Practice   function solution(a, b) {   return a.reduce((acc, _, i) =&gt; (acc += a[i] * b[i]), 0); }   reduce 함수를 사용할때 사용하지 않는 인자일 경우 _를 사용해 표현해주는 방법도 있습니다 :)   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["reduce"],
        "url": "/programmers-lv1/programmers-%EB%82%B4%EC%A0%81/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 예상 대진표 by JS",
        "excerpt":"📄 문제   △△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, … , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다.   이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다.      N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.)   A, B : N 이하인 자연수 (단, A ≠ B 입니다.)   🙋‍♀️ 나의 풀이   function solution(n, a, b) {   let answer = 1;   while (Math.min(a, b) % 2 === 0 || Math.abs(b - a) !== 1) {     a = Math.ceil(a / 2);     b = Math.ceil(b / 2);     answer++;   }   return answer; }      while문 조건: a와 b중 작은 수가 짝수인 경우 또는 a와 b의 차의 절댓값이 1이 아닌 경우   위 조건에서 a와 b의 차의 절댓값이 1이 될 때까지 a와 b를 절반으로 나눈다.   👍 Best Practice   function solution(n, a, b) {   let answer = 0;   while (a !== b) {     a = Math.ceil(a / 2);     b = Math.ceil(b / 2);     answer++;   }    return answer; }   a와 b의 차가 1이 될떄까지가 아니라 a와 b가 같을때까지를 조건으로 하면 조건이 하나가 되어도 답을 반환할 수 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["ceil"],
        "url": "/programmers-lv2/programmes-%EC%98%88%EC%83%81-%EB%8C%80%EC%A7%84%ED%91%9C/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 문자열 내림차순으로 배치하기 by JS",
        "excerpt":"📄 문제   문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.      str은 길이 1 이상인 문자열입니다.   🙋‍♀️ 나의 풀이   function solution(s) {   return [...s].sort().reverse().join(\"\"); }   구조분해 + 메소드 체이닝을 통해 풀었습니다.      문자열을 배열로 바꾼다. [...s]   정렬한다. sort()   역순으로 배치한다. reverse()   다시 문자열로 바꿔 리턴한다. join()   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["ceil"],
        "url": "/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 점프와 순간 이동 by JS",
        "excerpt":"📄 문제   OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.   예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다. 아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.      처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.   처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.   처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.   위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.      숫자 N: 1 이상 10억 이하의 자연수   숫자 K: 1 이상의 자연수   🙋‍♀️ 나의 풀이   function solution(n) {   let answer = 0;   while (n !== 0) {     if (n % 2 === 0) {       n = n / 2;     } else {       n = Math.floor(n / 2);       answer++;     }   }   return answer; }   시각을 시작점이 아닌 도착점으로 돌려 시작했습니다.      순간이동 =&gt; 2로 나눌 수 있음   점프 &gt; 순간이동으로 안되는 거리 = 2로 나누어 나머지가 나오는 경우 =&gt; 다시 남은 거리에 +1을 해준다.   남은 거리가 0이 될때까지 반복   👍 Best Practice   function solution(n) {   return n.toString(2).match(/1/g).length; }   어떤 값을 2로 계속 나누었을 때 나오는 나머지의 모든 합 = 어떤 값을 이진수로 변환한 수의 1의 개수   위 공식을 이용하면 더 간단히 풀 수 있는 문제였습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["이진수"],
        "url": "/programmers-lv2/programmers-%EC%A0%90%ED%94%84%EC%99%80-%EC%88%9C%EA%B0%84-%EC%9D%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "[알고리즘] DFS/BPS 깊이/너비 우선 탐색 알고리즘",
        "excerpt":"📄 그래프 탐색 알고리즘   여러개체들이 연결되어 있는 자료구조에서 특정 개체를 찾는 알고리즘을 그래프 탐색 알고리즘이라고 합니다.   ✔ 대표 문제      경로탐색 유형 (최단거리, 시간)   네트워크 유형 (연결)   조합 유형 (모든 조합 만들기)   이 알고리즘들의 대표 유형이 DFS(깊이 우선 탐색)/BFS(너비 우선 탐색)입니다.   📄 DFS | 깊이 우선 탐색 알고리즘      DFS는 임이의 노드에서 시작해서 그 경로를 완벽히 탐색해야 다음 분기로 넘어가는 특징이 있습니다.      장점: 운이 좋으면 처음부터 최적의 탐색 경로를 알 수 있다   단점: 처음 경로가 복잡하고 아주 길면 시간이 오래걸릴 수 있다.   예시 코드입니다.   // 그래프 정의 (인접 리스트 형태) const graph = {   A: [\"B\", \"C\"],   B: [\"A\", \"D\", \"E\"],   C: [\"A\", \"F\", \"G\"],   D: [\"B\"],   E: [\"B\", \"H\"],   F: [\"C\"],   G: [\"C\"],   H: [\"E\"], };  // DFS 알고리즘 function dfs(graph, start) {   const visited = new Set(); // 방문한 노드를 저장하는 Set   const stack = [start]; // 스택을 사용하여 탐색할 노드를 저장   const result = []; // 탐색 결과를 저장할 배열    while (stack.length &gt; 0) {     const node = stack.pop(); // 스택에서 하나의 노드를 꺼냄      if (!visited.has(node)) {       // 해당 노드를 방문하지 않았다면       visited.add(node); // 노드를 방문 처리       result.push(node); // 결과 배열에 노드를 추가        const neighbors = graph[node]; // 현재 노드의 인접 노드들       for (const neighbor of neighbors) {         if (!visited.has(neighbor)) {           // 방문하지 않은 인접 노드들을 스택에 추가           stack.push(neighbor);         }       }     }   }    return result; }  // DFS 실행 const startNode = \"A\"; // 시작 노드 설정 const result = dfs(graph, startNode); // DFS 실행 console.log(result); // DFS 결과 출력   위 코드는 인접 리스트 형태로 그래프를 정의하고, DFS알고리즘을 사용하여 시작 노드에서 출발해 깊이 우선 탐색을 수행합니다.   방문한 노드는 visited Set에 저장되고, 탐색 결과는 result배열에 추가됩니다.   작성한 함수를 재귀함수로 만들면 다음과 같습니다.   // 그래프 정의 (인접 리스트 형태) const graph = {   A: [\"B\", \"C\"],   B: [\"A\", \"D\", \"E\"],   C: [\"A\", \"F\", \"G\"],   D: [\"B\"],   E: [\"B\", \"H\"],   F: [\"C\"],   G: [\"C\"],   H: [\"E\"], };  // DFS 알고리즘 (재귀 함수) function dfs(graph, node, visited, result) {   visited.add(node); // 현재 노드를 방문 처리   result.push(node); // 결과 배열에 노드를 추가    const neighbors = graph[node]; // 현재 노드의 인접 노드들   for (const neighbor of neighbors) {     if (!visited.has(neighbor)) {       // 방문하지 않은 인접 노드들에 대해 재귀 호출       dfs(graph, neighbor, visited, result);     }   } }  // DFS 실행 const startNode = \"A\"; // 시작 노드 설정 const visited = new Set(); // 방문한 노드를 저장하는 Set const result = []; // 탐색 결과를 저장할 배열  dfs(graph, startNode, visited, result); // DFS 실행 console.log(result); // DFS 결과 출력   ✔ 재귀함수를 사용했을 때 장점      더 간결하고 직관적이다   스택의 개념을 명시적으로 사용하지 않아도 된다   ✔ 재귀함수를 사용했을 때 단점      스택의 크기가 커질 수 있고 스택 오버플로우가 발생할 수 있다   깊이 가 매우 깊은 트리 구조의 경우 재귀 함수를 사용하면 성능이 저하될 수 있다.   따라서 더 간단하고 직관적인 구현이 필요하거나 스택 오버플로우 등의 문제가 발생할 가능성이 낮은 경우에는 재귀 함수를 사용하는 것이 좋습니다.   하지만 성능이 중요하거나 스택의 크기가 커질 수 있는 경우에는 반복문 기반의 구현이 우선적으로 고려되어야 합니다.   📄 BFS | 너비 우선 탐색 알고리즘      DFS는 깊게 탐색하기 전에 먼저 넓게 탐색해보는 알고리즘입니다.   ✔ BFS 알고리즘의 장점      시작 노드에서 레벨별로 탐색을 진행하기 때문에 최단 경로 탐색에 유용하다.   각 레벨별로 탐색을 진행하기 때문에 같은 노드를 중복 방문하지 않아 무한 루프 회피가 가능하다.   레벨 기반으로 탐색을 진행하기 때문에 그래프의 균형을 잡아주는 특징이 있어 균형 잡힌 탐색이 가능해 노드가 균등하게 분포된 경우 유용하다.   ✔ BFS 알고리즘의 단점      BPS는 큐를 사용해 탐색을 진행하는데, 현재 레벨의 모든 노드를 큐에 저장해야 하므로 그래프의 너비가 큰 경우 메모리에 부담이 커질 수 있다.   무방향 그래프일 경우 같은 노드를 중복 방문할 수 있다.   그래프가 복잡할 경우 경로의 복잡성이 커진다.   // 그래프의 인접 리스트를 표현한 예시 const graph = {   1: [2, 3],   2: [4, 5],   3: [],   4: [],   5: [6],   6: [], };  // BFS 알고리즘 함수 function bfs(graph, start) {   const queue = []; // 큐   const visited = new Set(); // 방문한 노드를 저장할 Set   queue.push(start); // 시작 노드를 큐에 넣음   visited.add(start); // 시작 노드를 방문 처리    while (queue.length &gt; 0) {     // 큐가 빌 때까지 반복     const currentNode = queue.shift(); // 큐에서 노드를 꺼냄     console.log(currentNode); // 현재 노드를 출력 또는 원하는 작업 수행      const neighbors = graph[currentNode]; // 현재 노드의 인접 노드들     for (const neighbor of neighbors) {       if (!visited.has(neighbor)) {         // 방문하지 않은 노드라면         queue.push(neighbor); // 큐에 넣음         visited.add(neighbor); // 방문 처리       }     }   } }  // BFS 실행 예시 bfs(graph, 1); // 1 2 3 4 5 6 순서로 출력 또는 원하는 작업 수행  ","categories": ["Algorithm"],
        "tags": ["DFS","BPS"],
        "url": "/algorithm/algorithm-DFS&BFS/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 약수의 개수와 덧셈 by JS",
        "excerpt":"📄 문제   두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.      1 ≤ left ≤ right ≤ 1,000   🙋‍♀️ 나의 풀이   function solution(left, right) {   let answer = 0;   for (let i = left; i &lt;= right; i++) {     let count = 0;     for (let j = 1; j &lt;= i; j++) {       if (i % j === 0) count++;     }     answer = count % 2 === 0 ? answer + i : answer - i;   }   return answer; }   중첩 반복문을 생성해 모든 경우를 계산하고,   약수의 개수가 짝수일 경우에는 합, 홀수인 경우에는 차를 계산해 answer를 반환했습니다.   👍 Best Practice   function solution(left, right) {   var answer = 0;   for (let i = left; i &lt;= right; i++) {     if (Number.isInteger(Math.sqrt(i))) {       answer -= i;     } else {       answer += i;     }   }   return answer; }   이 풀이는 제곱근이 정수이면, 약수의 개수는 홀수이다라는 공식을 이용한 풀이입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["약수"],
        "url": "/programmers-lv1/programmers-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 타겟 넘버 by JS",
        "excerpt":"📄 문제   n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3   사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.      주어지는 숫자의 개수는 2개 이상 20개 이하입니다.   각 숫자는 1 이상 50 이하인 자연수입니다.   타겟 넘버는 1 이상 1000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(numbers, target) {   let answer = 0;    dfs(0, 0);    function dfs(depth, sum) {     if (depth === numbers.length) {       if (sum === target) answer += 1;       return;     }      dfs(depth + 1, sum + numbers[depth]);     dfs(depth + 1, sum - numbers[depth]);   }   return answer; }   이번 문제는 dfs알고리즘을 이용해서 재귀함수를 만들어 풀었습니다.      함수 dfs는 주어진 숫자의 개수만큼 깊이가 길어지면 리턴한다. 이때 노드의 충합이 target과 같다면 answer에 1을 더한다.   1번의 조건과 만족하지 않는다면 depth에 1을 더하고 number의 요소가 음수인 경우를 포함해 구하기 때문에 재귀함수를 두번 호출한다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["DFS"],
        "url": "/programmers-lv2/programmers-%ED%83%80%EA%B2%9F-%EB%84%98%EB%B2%84/",
        "teaser": null
      },{
        "title": "[메세지가 도착했습니다] 컴포넌트 겹침 현상 해결하기",
        "excerpt":"🚨 CSS 레이아웃 문제 발생   데스크탑 환경에서는 몰랐지만 배포하고 모바일에서 테스트해보니 Footer가 되는 컴포넌트가 다른 컴포넌트와 겹치는 현상이 발생했습니다.      아무래도 Footer컴포넌트가 항상 밑에만 있으면 된다는 생각에 position설정을 absolute로 줘서 그런것 같습니다.   뷰포트 높이의 길이는 한정되어 있는데 모바일 화면은 데스크탑보다 작으니 자리가 고정되어 있는 Footer컴포넌트가 밀리지 않고 겹쳐지게 됩니다.   🔨 문제를 해결해보자   우선 Footer CSS를 변경하겠습니다.   .footer {   width: 100%;   max-width: 650px;   // position: absolute; 🔨   // bottom: 0; 🔨   padding: 1rem;   text-align: left;    .github__link {     display: flex;     align-items: center;     text-decoration-line: none;     color: $text-dark1;     &amp;:hover {       cursor: pointer;     }   } }   해당 부분을 주석으로 없앴더니 다른 문제가 발생합니다.   아예 페이지 바깥으로 컨텐츠가 탈출해버렸습니다.      이렇게 컨텐츠가 넘치는 현상을 막기 위해 페이지 컴포넌트에 overflow: auto를 추가합니다.   .start__container {   @include set-box-size();   @include set-center-aligned;   flex-direction: column;   background-color: $main-color;    overflow: auto; // 🎉 }      이제 더이상 컴포넌트끼리 겹치지도, 컨텐츠가 페이지 밖으로 튀어나오지도 않습니다 :)  ","categories": ["random-message"],
        "tags": ["CSS","레이아웃"],
        "url": "/random-message/random-message-CSS-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] N개의 최소공배수 by JS",
        "excerpt":"📄 문제   두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.      arr은 길이 1이상, 15이하인 배열입니다.   arr의 원소는 100 이하인 자연수입니다.   📄 나의 풀이   function solution(arr) {   const gcd = (a, b) =&gt; (a % b === 0 ? b : gcd(b, a % b));   const lcm = (a, b) =&gt; (a * b) / gcd(a, b);    let answer = 1;   const sortedArr = arr.sort((a, b) =&gt; a - b);   for (let i = 0; i &lt; arr.length; i++) {     answer = lcm(answer, sortedArr[i]);   }   return answer; }      📌 유클리드 호제법이란? 유클리드 호제법은 나눗셈을 반복해서 두 수의 최대공약수를 구하는 알고리즘입니다. 두 수 A와 B의 나머지가 r일때, gcd(A, B) = gcd(B, r)입니다. r이 0이라면 최대공약수는 B가 되고, 아니라면 gcd(B, r)을 계산합니다.       최대공배수는 두수를 곱한 값 / 최대 공약수이다.   주어진 배열을 오름차순으로 정렬한다.(sortedArr)   초기값이 1인 answer와 sortedArr의 요소의 최대공배수를 구해 answer의 값을 변경해준다.   👍 Best Practice   function nlcm(num) {   return num.reduce((a, b) =&gt; (a * b) / gcd(a, b)); }  function gcd(a, b) {   return a % b ? gcd(b, a % b) : b; }   for문 대신 reduce 메소드를 사용해 가독성을 높인 풀이입니다.   이 풀이에서는 누적값 a가 answer이 되었습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": ["유클리드 호제법","최소공배수"],
        "url": "/programmers-lv2/programmers-N%EA%B0%9C%EC%9D%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 부족한 금액 계산하기 by JS",
        "excerpt":"📄 문제   새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다. 놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요.      놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수   처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수   놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수   🙋‍♀️ 나의 풀이   function solution(price, money, count) {   let total = price * ((count * (count + 1)) / 2);   return total - money &gt; 0 ? total - money : 0; }   📌 정수 1부터 N까지 합: (N(N+1))/2      등차수열 공식을 이용해 요금 합계(total)를 구한다.   요금 합계(total)에서 돈이 모자라면 부족한 금액을 아니라면 0을 반환한다.  ","categories": ["programmers-lv1"],
        "tags": ["등차수열"],
        "url": "/programmers-lv1/programmers-%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[메세지가 도착했습니다] Firestore를 사용해 원격으로 DB관리하기",
        "excerpt":"📄 사용 계기   혼자 간단한 토이프로젝트를 만들게 되었는데, 이때 사용할 REST API를 만들기에는 시간이 부족했습니다.   Firestore를 사용하면 어렵지 않고 빠르게 DB를 만들어 통신할 수 있어 사용하게 되었습니다.   📄 Firestore DB 구조   Firebase 페이지에서 Firestore를 생성하면 다음과 같은 DB를 만들 수 있습니다.      제가 사용하고 싶던 기능은 다음과 같습니다.      메세지 가져오기 (GET)   메세지 생성하기 (CREATE)   메세지 삭제하기 (DELETE)   📄 VSCode에서 Firestore와 통신하기   프로젝트 설정탭에서 SDK 설정 및 구성을 확인하면 제품의 SDK를 확인할 수 있습니다.      0. npm install firebase   1. src폴더 내에 firebase.js 파일 생성   firestore를 사용해주기 위해 firebase를 초기화 합니다.   저는 SDK를 환경변수로 설정해 가려줬습니다.   import { initializeApp } from \"firebase/app\"; import { getFirestore } from \"firebase/firestore\"; const firebaseConfig = {   apiKey: process.env.REACT_APP_FB_API_KEY,   authDomain: process.env.REACT_APP_FB_AUTH_DOMAIN,   projectId: process.env.REACT_APP_FB_PROJECT_ID,   storageBucket: process.env.REACT_APP_FB_STORAGE_BUCKET,   messagingSenderId: process.env.REACT_APP_FB_MESSAGING_SENDER_ID,   appId: process.env.REACT_APP_FB_API_ID,   measurementId: process.env.REACT_APP_FB_MEASUREMENT_ID, };  const firebaseApp = initializeApp(firebaseConfig);  const firebaseDB = getFirestore(firebaseApp);  export { firebaseDB };   2. baseDB 설정하기   DB를 사용하는 작업에서 공통으로 사용되는 부분을 따로 만들었습니다.   💾 lib/db/baseDB.ts   import { firebaseDB } from \"../../firebase\"; import { collection } from \"firebase/firestore\";  const baseDB = () =&gt; {   const db = collection(firebaseDB, \"Messages\");   return db; };  export default baseDB;   collection은 Firestore에서 생성했던 컬렉션 이름을 기준으로 데이터를 관리합니다.   3. 데이터 가져오기 + 삭제하기   저는 가져오자마자 삭제하는 작업을 해야했기 때문에 함수 하나에 동시에 작업했습니다.   💾 lib/db/getMessages.ts   const getMessage = async () =&gt; {   try {     const response = await getDocs(baseDB()); // Get 🎉     const data = response.docs.map((doc) =&gt; ({       ...(doc.data() as docInterface),       id: doc.id,     }));     const selectedData = data[getRandomNum(data.length - 1)];     await deleteDoc(doc(firebaseDB, \"Messages\", selectedData.id)); // Delete 🎉     return selectedData;   } catch (error) {     console.error(\"Error in getMessage:\", error);     return undefined;   } };   baseDB에서 Docs를 가져와서 데이터를 가져왔습니다.   단점은 Get을 사용하면 모든 데이터를 가져옵니다.   그래서 데이터가 큰 경우에는 성능이 저하 될 수 있습니다.   Firestore은 데이터가 크지 않은 경우에만 사용하는 것이 좋은 것 같습니다.   delete명령을 사용할 때는 인수가 추가 됩니다.   deleteDoc(doc(db, 컬렉션 이름, 해당 id))   가져온 데이터의 아이디를 통해 해당 데이터를 삭제할 수 있습니다.   데이터 생성(추가)하기   export const createMessage = (message: MessageFormInterface) =&gt; {   addDoc(baseDB(), message); };   데이터 생성은 addDoc라는 명령을 통해 이루어집니다.     느낀점   생각보다 사용법이 간편해서 수월했습니다.   다만, 언급했던 것처럼 데이터를 한번에 가져와야하니 비효율적으로 느껴졌지만 해당 프로젝트는 많은 데이터 를 요구하는게 아니니 쓸만했습니다.   다음엔 Firebase로 REST API를 만들거나 mongoDB를 배워 직접 API를 만들어 보고 싶습니다:)  ","categories": ["random-message"],
        "tags": ["Firestore","DB"],
        "url": "/random-message/random-message-FireStore%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9B%90%EA%B2%A9%EC%9C%BC%EB%A1%9C-DB%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 멀리 뛰기 by JS",
        "excerpt":"📄 문제   효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는 (1칸, 1칸, 1칸, 1칸) (1칸, 2칸, 1칸) (1칸, 1칸, 2칸) (2칸, 1칸, 1칸) (2칸, 2칸) 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.      n은 1 이상, 2000 이하인 정수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   if (n === 1 || n === 2) return n;   const dp = Array(n).fill(0);   dp[0] = 1;   dp[1] = 2;   for (let i = 2; i &lt; n; i++) {     dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567;   }   return dp[n - 1]; }   처음 문제를 보고 DFS로 접근했더니 시간 초과가 되어 동적 계산법(DP)로 다시 생각했습니다.   n이 1일 경우 -&gt; 1  n이 2일 경우 -&gt; 2  n이 3일 경우 -&gt; 3  n이 4일 경우 -&gt; 5  n이 5일 경우 -&gt; 8  n이 6일 경우 -&gt; 13    문제의 답이 피보나치 수열로 이루어져 있습니다.   따라서 배열 (dp)의 맨 앞과 두번째 수를 1과 2로 만들고 그 뒤의 값들을 구하면 답을 알 수 있습니다.   % 1234567연산을 for문 안에서 한 이유는 dp[n - 1]의 크기가 커져 오버 플로우가 발생하기 때문입니다.   👍 Best Practice   function jumpCase(num) {   if (num &lt;= 2) return num;    return jumpCase(num - 1) + jumpCase(num - 2); }   같은 방식을 재귀함수로 풀어낸 풀이입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv2"],
        "tags": [""],
        "url": "/programmers-lv2/programmers-%EB%A9%80%EB%A6%AC-%EB%9B%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 문자열 다루기 기본 by JS",
        "excerpt":"📄 문제   문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다.      s는 길이 1 이상, 길이 8 이하인 문자열입니다.   s는 영문 알파벳 대소문자 또는 0부터 9까지 숫자로 이루어져 있습니다.   🙋‍♀️ 나의 풀이   function solution(s) {   if (s.length !== 4 || s.length !== 6) return false;   console.log(Number(s));   return !isNaN(Number(s)); }   처음에 주어진 문자열 전체를 숫자로 바꿨는데 테스트 케이스 오류가 발생했습니다.   알고보니 문자 e가 포함되면 Number()가 지수로 인식해 e를 숫자로 판별했던 것이었습니다.   따라서 for문을 돌려 문자 하나하나에 Number()를 적용해주어야 했습니다.   function solution(s) {   if (s.length !== 4 &amp;&amp; s.length !== 6) return false;    for (let i = 0; i &lt; s.length; i++) {     if (isNaN(Number(s[i]))) return false;   }   return true; }   문자열에 Number() 메소드를 적용하면 NAN이 되니, isNaN()을 사용해 이를 판별했습니다.   isNaN을 !!isNaN으로 사용하면 더 간결하겠지만, 주어진 문자열이 “0000”인 경우에는 0도 false로 인식하므로 사용할 수 없었습니다.   👍 Best Practice   function alpha_string46(s) {   var regex = /^\\d{6}$|^\\d{4}$/;    return regex.test(s); }   정규식을 이용한 풀이입니다.   주어진 문자열이 6개 혹은 4개의 숫자(d)로 이루어져 있는지 바로 확인할 수 있습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["문자열"],
        "url": "/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 행렬의 덧셈 by JS",
        "excerpt":"📄 문제   행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.      행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다.   🙋‍♀️ 나의 풀이   function solution(arr1, arr2) {   let answer = [];    for (let i = 0; i &lt; arr1.length; i++) {     answer.push(arr1[i].map((value, index) =&gt; arr1[i][index] + arr2[i][index]));   }    return answer; }      for문으로 주어진 배열의 인덱스만큼 반복문을 돌린다.   배열의 요소가 배열이니 다시한번 map을 사용해 값을 더해준 후 answer에 값을 삽입한다.   👍 Best Practice   function sumMatrix(A, B) {   return A.map((arr1, idx1) =&gt; arr1.map((val, idx2) =&gt; val + B[idx1][idx2])); }   map을 두번 사용해 배열의 값을 더한 풀이입니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["배열"],
        "url": "/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 2] 멀리 뛰기 by JS",
        "excerpt":"📄 문제   경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 ‘k’개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.   예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.   경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.      1 ≤ k ≤ tangerine의 길이 ≤ 100,000   1 ≤ tangerine의 원소 ≤ 10,000,000   🙋‍♀️ 나의 풀이   function solution(k, tangerine) {   let answer = 0;   let acc = 0;   const tangerineObject = {};   tangerine.forEach((value) =&gt; {     tangerineObject[value] = (tangerineObject[value] || 0) + 1;   });   const tangerineNum = Object.values(tangerineObject).sort((a, b) =&gt; b - a);   for (let i = 0; acc &lt; k; i++) {     answer++;     acc += tangerineNum[i];   }   return answer; }      tangerine배열에서 과일이름이 중복된 횟수를 계산해 새로운 객체 tangerineObject에 이름과 과일의 개수를 매칭해 저장한다.   과일 개수를 내림차순으로 정렬해 배열에 저장한다.(tangerineNum)   정렬된 배열에서 앞에서부터 k개의 요소를 더하여, 그 합이 k이상이되는 최소값을 구한다.   👍 Best Practice   function solution(k, tangerine) {   let answer = 0;   const tDict = {};   tangerine.forEach((t) =&gt; (tDict[t] = (tDict[t] || 0) + 1));   const tArr = Object.values(tDict).sort((a, b) =&gt; b - a);   for (const t of tArr) {     answer++;     if (k &gt; t) k -= t;     else break;   }   return answer; }   최솟값을 구할때 저는 변수(acc)를 선언해 누적값을 구했는데, 이 풀이에서는 따로 변수를 선언하지 않고 주어진 k에서 값을 빼주며 0이 되었을 때 반복문을 나오게 했습니다 👍  ","categories": ["programmers-lv2"],
        "tags": [""],
        "url": "/programmers-lv2/programmers-%EA%B7%A4-%EA%B3%A0%EB%A5%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 최대공약수와 최소공배수 by JS",
        "excerpt":"📄 문제   두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.      두 수는 1이상 1000000이하의 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n, m) {   const gcd = (a, b) =&gt; (a % b === 0 ? b : gcd(b, a % b));   const lcm = (a, b) =&gt; (a * b) / gcd(a, b);    return [gcd(n, m), lcm(n, m)]; }   저번 문제에서 공부한 유클리드호제법으로 최대공약수(gcd)와 최소공배수(lcm)을 계산해 풀었습니다.   👍 Best Practice   function gcdlcm(a, b) {   var r;   for (var ab = a * b; (r = a % b); a = b, b = r) {}   return [b, ab / b]; }   재귀함수가 아닌 for문을 사용해 최대공약수를 찾는 풀이입니다.   a % b가 0이 될 때까지 반복문을 실행합니다.   재귀함수로만 풀릴 줄 알았는데 for문으로 풀려서 신기하네요:)   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["최대공약수","최소공배수"],
        "url": "/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 3진법 뒤집기 by JS",
        "excerpt":"📄 문제   자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.      n은 1 이상 100,000,000 이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(n) {   return parseInt([...n.toString(3)].reverse().join(\"\"), 3); }   toString에 들어가는 인자는 적용한 숫자를 n진법으로 나타낼 때 사용합니다.   n.toString(3)은 숫자 n을 3진법으로 변환한다는 뜻입니다.   3진법으로 변환한 숫자 n을 spread연산자로 배열에 담아 뒤집은뒤 다시 문자열로 변환했습니다.   parseInt의 두번째 인자에는 해당 값이 몇진법인지 나타내는 숫자를 입력합니다.   parseInt([...n.toString(3)].reverse().join(\"\"), 3)는 앞뒤 반전한 3진법을 다시 10진법으로 변환해주는 역할을 합니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["toString","parseInt"],
        "url": "/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 모코숲 뜯어고치기 시작",
        "excerpt":"📄 나는 왜 이 프로젝트를 처음부터 뜯어고치는 재공사를 시작하는가   모코숲은 나의 애증의 프로젝트..   백엔드를 담당하시는 분과 todolist이후 처음으로 진행하는 프로젝트이다.   처음으로 여러가지 기능을 만들다보니 제대로 꼬여버렸다.   신나서 막 짓고 쌓다보니 새로운 기능을 추가하기도 참 어렵게 되었다.         굉장히 많은 오류들이 있었다.   cors 에러 + 레이아웃 우장창 + 알 수 없는 렌더링 등등…   할 건 많은데 다른 일까지 겹쳐서 다시 손대기가 굉장히 두려운 프로젝트다.   일단 프로젝트를 다시 시작해야하는 이유는 다음과 같다   1. 꼬여버린 레이아웃   사실 레이아웃 같은걸 투두리스트말고 만들어봤어야지 아무것도 모르는 상태에서 제대로 된 틀을 설정하지 않고 시작해 페이지를 받쳐주는 틀이 엉망이 되었다. 사실 그래서 모 인강사이트에서 개발자도구를 켜서 참고하면서 했는데 하다보니 내 코드가 아니게 되어 스타일이 이상해졌을 때 어떻게 손대야 할지 감이 안잡혔다.   2. 사용자 접근성 고려   현재 진행되어 있는 프로젝트는 로그인/회원가입이 안되어 있으면 메인페이지에 접근하지 못한다. URL로 접근하더라도 라우터가 튕겨보낸다.   백엔드 개발자 분에게 웹 성격 특성상 서비스를 먼저 둘러보는 것이 사용자 접근에 더 좋을 것이라는 피드백을 들었다. 맨 처음 접속한 페이지를 로그인페이지가 아니라 메인 페이지로 변경하고 public/private 라우터도 싹다 바꿔줄 예정이다.   3. 꼬여버린 전역 상태 관리   전역 상태 관리가 제대로 꼬였다. 각 state의 성격대로 잘 구분한줄 알았는데 그렇지 않더랬다… 서버에서 받아온 하나의 데이터를 여러 slice에서 관리하게 되고 이걸 고치자니 아예 로직이 엉켜버렸다.   4. 디자인이 마음에 아주 안든다   왜 디자인을 이렇게 한건지 모르겠다. 처음 만들때 simple is the best 인것을… 욕심이 과했는지 아니면 너무 많이 봐서 그러는지 모르겠고 프로젝트한테 미안하지만 살짝 어디 내놓기 창피하다.   5. 전혀 재사용되고 있지 않는 컴포넌트들   컴포넌트를 재사용하지 않으면 리액트를 왜 사용할까…🥶 props나 state다루는 것이 익숙하지 않으니 컴포넌트를 재사용하는 것이 거의 없다. 지금은 이걸 좀 공부하기 위해 다른 사람이 만든 프로젝트(예. sendbird)를 열어보며 어렵지만 감을 잡아가고 있는 중이다. 이것을 토대로 프로젝트 설계를 다시 할 예정이다.   🏃‍♀️ 결론!   조급하지 말자.   할게 쌓여 있으면 불안한 내 성격이 프로젝트를 망쳤다.   하나의 기능을 만들더라도 차분하게 설계하고 시작하자.   🍀 목표      피그마로 스타일 설계 진행하기   디자인은 심플하게. 난 디자인 전공이 아니다. 슬프다.   버그를 미루지 말자. 미루면 눈덩이처럼 증가해서 굉장히 힘들다.   구글링하고 남의 코드를 참고하되 된다고 끝내지말고 공부해서 내것으로 만들어 나중에 오류가 발생해도 당황하지 말자.   힘내자…  ","categories": ["coding-swamp"],
        "tags": ["모코늪","재시작"],
        "url": "/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2-%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0-%EC%8B%9C%EC%9E%91/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 이상한 문자 만들기 by JS",
        "excerpt":"📄 문제   문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.      문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.   첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.   🙋‍♀️ 나의 풀이   function solution(s) {   const newS = s.split(\" \").map((value, index) =&gt; {     return [...value]       .map((char, index) =&gt; {         return (index + 1) % 2 === 0 ? char.toLowerCase() : char.toUpperCase();       })       .join(\"\");   });   return newS.join(\" \"); }      단어 s를 공백을 기준으로 잘라 배열을 생성한다.(newS)   주어진 조건에 맞게 단어를 배열로 만든 후 각 글자를 대문자 또는 소문자로 변환하고 다시 문자열로 만든다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["toUpperCase()","toLowerCase()"],
        "url": "/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 예산 by JS",
        "excerpt":"📄 문제   S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.   물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.   부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.      d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.   d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.   budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(d, budget) {   let answer = 0;   d = d.sort((a, b) =&gt; a - b);   for (let i = 0; budget &gt; 0; i++) {     if (budget - d[i] &lt; 0) break;     if (d[i] === undefined) break;     budget = budget - d[i];     answer++;   }   return answer; }      배열을 오름차순으로 정리한다.   budget이 0이 될 때까지 배열 d의 값을 하나씩 뺀다.   예산을 뺀 값이 마이너스가 되면 for문을 종료한다.   부서가 한개인 경우 조건(budget - d[i] &lt; 0)을 걸어 for문을 종료한다.   👍 Best Practice   function solution(d, budget) {   return d     .sort((a, b) =&gt; a - b)     .reduce((count, price) =&gt; {       return count + ((budget -= price) &gt;= 0);     }, 0); }   sort와 reduce 메소드를 연달아 사용한 풀이입니다.   ((budget -= price) &gt;= 0)결과에 따라 0 또는 1이 되네요.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": [""],
        "url": "/programmers-lv1/programmers-%EC%98%88%EC%82%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 시저 암호 by JS",
        "excerpt":"📄 문제   어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.      공백은 아무리 밀어도 공백입니다.   s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.   s의 길이는 8000이하입니다.   n은 1 이상, 25이하인 자연수입니다.   🙋‍♀️ 나의 풀이   function solution(s, n) {   const MINCODE = 97;   const MAXCODE = 122;   let answer = [];    let store;   for (let i = 0; i &lt; s.length; i++) {     if (s[i] === \" \") {       answer.push(\" \");       continue;     }     store = s.toLowerCase()[i].charCodeAt() + n;     if (store &gt; 122) store = store - MAXCODE + MINCODE - 1;     store = String.fromCharCode(store);     if (s[i] === s[i].toUpperCase()) store = store.toUpperCase();     answer.push(store);     store = \"\";   }   return answer.join(\"\"); }      문자열의 아스키 코드를 구하고 n만큼 더한다.   만약 더한 값이 122보다 크다면 더한 값 - 122 + 97 - 1 을 해준다.   해당 문자열이 대문자인지 확인 후 값을 변환한다.   👍 Best Practice   function solution(s, n) {   var upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";   var lower = \"abcdefghijklmnopqrstuvwxyz\";   var answer = \"\";    for (var i = 0; i &lt; s.length; i++) {     var text = s[i];     if (text == \" \") {       answer += \" \";       continue;     }     var textArr = upper.includes(text) ? upper : lower;     var index = textArr.indexOf(text) + n;     if (index &gt;= textArr.length) index -= textArr.length;     answer += textArr[index];   }   return answer; }   아스키코드가 아닌 배열로 작성한 풀이입니다.      우선, 주어진 문자열을 순환할때 해당 문자열이 소문자인지 대문자인지 확인합니다. (textArr)   textArr에 해당 문자열의 인덱스를 구한 후 n만큼 더합니다.   만약 textArr의 길이보다 길어질 경우 그만큼 값을 빼서 정확한 위치를 구합니다.   아스키코드를 사용한 풀이보다 오히려 가독성이 좋은 것 같습니다.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["아스키 코드","배열"],
        "url": "/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/",
        "teaser": null
      },{
        "title": "[React-Query 01] 쿼리 생성 및 로딩/에러 상태 관리하기",
        "excerpt":"   📄 리액트 쿼리 공부를 시작한 이유   프로젝트를 진행할 때, 상태관리를 위해 redux를 사용하는데 서버 데이터를 위한 로직이 과도하게 커져 상태를 관리하기가 어려웠습니다.   Redux-thunk를 사용하긴 했지만 이또한 store가 비대해져 한번에 관리하는게 맞는지 의문이 들었습니다.   그래서 리액트 쿼리를 이용해 서버에서 오는 데이터는 따로 관리해보고자 공부를 시작하게 되었습니다.   📄 리액트 쿼리란?           역할: 서버의 상태를 관리하는 리액트 라이브러리            특징             서버에서 오는 데이터 전송 결과에 따라 비동기 처리 로직이 가능하다.       서버의 데이터에 변경이 생기면 클라이언트가 다시 데이터를 가져오지 않아도 알아서 업데이트 된다.       데이터를 캐시해서 전달할 수 있다.       데이터에 만료시간을 정할 수 있다. -&gt; 만료되지 않은 데이터는 refetching해도 변경이 적용되지 않을 수 있게 설정할 수 있다.           📄 리액트 쿼리 개발자 도구 사용하기      방법: QueryClientProvider태그 안에 ReactQueryDevtools를 작성한다.   function App() {   return (     // provide React Query client to App     &lt;QueryClientProvider client={qeuryClient}&gt;       &lt;div className=\"App\"&gt;         &lt;h1&gt;Blog Posts&lt;/h1&gt;         &lt;Posts /&gt;       &lt;/div&gt;       &lt;ReactQueryDevtools /&gt; // 🎉     &lt;/QueryClientProvider&gt;   ); }   ReactQueryDevtools를 추가하면 해당 태그가 있는 페이지의 위치에 리액트 쿼리 개발자 도구가 생성됩니다.      개발자 도구를 통해 데이터가 서버로부터 로딩중인지, 만료된 데이터인지 등등 다양한 정보를 제공받고, Actions 탭에서는 데이터관련 작업을 실행할 수 있습니다.   📄 리액트 쿼리 시작하기   리액트 쿼리를 사용하기 위해서는 여느 상태관리 라이브러리처럼 최상단 컴포넌트인 App.jsx에서 Provider 컴포넌트를 설정해야 합니다.      QueryClient: 캐싱기능과 기본 옵션을 자녀 컴포넌트에서도 사용할 수 있게 해준다.   const qeuryClient = new QueryClient();  function App() {   return (     // provide React Query client to App     &lt;QueryClientProvider client={qeuryClient}&gt;       &lt;div className=\"App\"&gt;         &lt;h1&gt;Blog Posts&lt;/h1&gt;         &lt;Posts /&gt;       &lt;/div&gt;       &lt;ReactQueryDevtools /&gt;     &lt;/QueryClientProvider&gt;   ); }   📄 stale Time?      뜻: 리액트 쿼리가 가져오는 데이터의 만료 시간 (기본 값: 0)                  🎲 key point       데이터는 만료되었을 때만 리페칭이 가능하다.           리액트 쿼리는 만료 시간을 기본 값으로 0을 설정해 클라이언트가 만료된 데이터를 제공받을 가능성을 낮추어 줍니다.   만약 데이터의 만료시간을 5초로 설정했을 경우, 처음 데이터를 fetching 한 후 5초안에 데이터를 refetching했을 때 만료시간이 다 되지 않았으므로 데이터는 update되지 않습니다.   📄 로딩 상태와 에러상태 처리하기   리액트 쿼리로 서버의 데이터를 가져오기 위해 useQeury라는 키워드를 사용합니다.      인자 1: 쿼리 키 (post): 서버에서 가져오는 데이터에 이름을 부여   인자 2: 쿼리 함수 (fetchPosts): 서버에서 데이터를 가져오는 로직을 작성 (비동기)   인자 3: 옵션 ({ staleTime: 2000}): 만료시간을 2초로 설정   const { data, isError, error, isLoading } = useQuery(\"posts\", fetchPosts, {   staleTime: 2000, });   ▪ 로딩 상태 처리하기   useQuery로 가져온 쿼리 데이터 posts를 구조분해해서 나온 isLoading을 활용하여 로딩이 되는 중이라면, Loading...을 화면에 보여줍니다.   if (isLoading) return &lt;h3&gt;Loading...&lt;/h3&gt;;   📌 isLoading과 isFetching의 차이점      isFetching: 비동기 쿼리 함수가 해결되지 않았을 때 (데이터를 가져오는 중일 때)   isLoading: 비동기 쿼리 함수가 해결되지 않았을 때 (데이터를 가져오는 중일 때) + 쿼리에 대해 캐시된 데이터가 없을 때 (isFetching의 하위 집합)   ▪ 에러 상태 처리하기   리액트 쿼리는 데이터를 가져올 때 fetching이 성공될 때까지 세번의 로딩 시도후 안되면 에러라고 판단합니다.   if (isError)   return (     &lt;&gt;       &lt;h3&gt;Oops, something went wrong&lt;/h3&gt;       &lt;p&gt;{error.toString()}&lt;/p&gt;     &lt;/&gt;   );   참고      udemy - React Query: React로 서버 상태 관리하기  ","categories": ["React"],
        "tags": ["react-query"],
        "url": "/react/react-reactquery/",
        "teaser": null
      },{
        "title": "[React-Query 02] 리액트 쿼리로 페이지네이션 작업하기",
        "excerpt":"📄 페이지네이션 작업에 리액트 쿼리가 하는 일   페이지네이션 작업에서 다음 페이지 버튼을 눌렀을 경우에 리액트는 새로운 데이터를 불러오기 위해 api를 호출합니다.   이때 사용자는 데이터를 불러오는 시간만큼 기다려야 하기 때문에 사용자 경험이 안좋아지는 결과를 초래합니다.   리액트 쿼리를 사용해 호출 가능성이 있는 데이터를 미리 불러오는 작업, 즉 프리페칭(Prefetching)을 사용해 미리 다음 페이지의 데이터를 불러온다면 사용자는 페이지에 나타날 정보를 위해 기다릴 필요성이 사라지게 됩니다.      📌 프리페칭(Prefetching)이란? 호출 가능성이 있는 데이터를 미리 불러오는 작업. 데이터를 미리 불러와 캐시에 데이터를 저장한다.    📄 리액트 쿼리로 페이지네이션 구현하기   1. 쿼리 설정하기   페이지네이션을 위해 쿼리를 설정합니다.   페이지 별 게시글을 불러오는 함수를 쿼리함수로 설정했는데 이때 쿼리키를 동일하게 한다면 모든 페이지가 같은 정보를 표시하게 됩니다.   쿼리키를 동일하게 했을 경우 어떤 트리거가 있어야만 데이터를 리페칭할 수 있는데 다음 페이지 버튼을 클릭한다고 트리거가 발생하지 않습니다.   트리거가 발생하는 기준은 다음과 같습니다.      컴포넌트 리마운트   윈도우 리포커징   리페칭함수 실행   자동 리페칭   mutation 이후 쿼리 무효화   이전/다음 버튼을 클릭했을 때 트리거가 발생하도록 쿼리키를 배열로작성했습니다.   const { data, isError, error, isLoading } = useQuery(   [\"posts\", currentPage], // 🎉   () =&gt; fetchPosts(currentPage),   {     staleTime: 2000,     keepPreviousData: true,   } ); if (isLoading) return &lt;h3&gt;Loading...&lt;/h3&gt;; if (isError)   return (     &lt;&gt;       &lt;h3&gt;Oops, something went wrong&lt;/h3&gt;       &lt;p&gt;{error.toString()}&lt;/p&gt;     &lt;/&gt;   );      📌 keepPreviousData: 새 데이터가 요청되는 동안 마지막으로 성공한 fetch Data로 유지해 사용자 경험을 향상시킬 수 있다.    2. 프리페칭 함수 설정하기   현재 페이지가 변경될 때마다 프리페칭 함수를 실행시키기 위해 useEffect함수를 사용합니다.   useEffect(() =&gt; {   if (currentPage &lt; maxPostPage) {     const nextPage = currentPage + 1;     queryClient.prefetchQuery([\"posts\", nextPage], () =&gt; fetchPosts(nextPage));   } }, [currentPage, queryClient]);   최대 페이지 (maxPostPage)에서는 실행되지 않도록 if 조건문을 사용했습니다.   쿼리를 설정했을 때와 마찬가지로 쿼리키를 배열로 설정합니다.   3. return 함수 작성하기   각 버튼의 disabled 속성을 이용해 페이지가 1일 경우, 최대 페이지일 경우에 버튼이 비활성화 되도록 설정합니다.   &lt;div className=\"pages\"&gt;   &lt;button     disabled={currentPage &lt;= 1}     onClick={() =&gt; {       setCurrentPage((previosValue) =&gt; previosValue - 1);     }}   &gt;     Previous page   &lt;/button&gt;   &lt;span&gt;Page {currentPage}&lt;/span&gt;   &lt;button     disabled={currentPage &gt;= maxPostPage}     // onClick함수에 프리페칭 작업을 하지 않는 이유: setState함수는 비동기로 실행되기 때문에 현재 페이지가 무엇인지 정확히 알 방법이 없다.     onClick={() =&gt; {       setCurrentPage((previousValue) =&gt; previousValue + 1);     }}   &gt;     Next page   &lt;/button&gt; &lt;/div&gt;   프리페칭 함수를 onClick함수에 바로 작성하지 않은 이유가 있습니다.   setState함수는 비동기로 실행되기 때문에 프리페칭이 진행될 시점에는 현재 페이지가 무엇인지 정확히 알 방법이 없기 때문입니다.   따라서 useEffect의 의존성 배열에 조건을 걸어 프리페칭이 실행되도록 하는 것이 적합합니다.   참고      udemy - React Query: React로 서버 상태 관리하기  ","categories": ["React"],
        "tags": ["prefetching","keepPreviousData"],
        "url": "/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BF%BC%EB%A6%AC%EB%A1%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스 / Lv 1] 삼총사 by JS",
        "excerpt":"📄 문제   한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.   한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요.      3 ≤ number의 길이 ≤ 13   -1,000 ≤ number의 각 원소 ≤ 1,000   서로 다른 학생의 정수 번호가 같을 수 있습니다.   🙋‍♀️ 나의 풀이   function solution(number) {   let answer = 0;   for (let i = 0; i &lt; number.length; i++) {     for (let j = i + 1; j &lt; number.length - 1; j++) {       for (let l = j + 1; l &lt; number.length; l++) {         if (number[i] + number[j] + number[l] === 0) answer++;       }     }   }   return answer; }   자바스크립트를 공부하면서 삼중 for문은 처음 사용해보았습니다.   이중 for문도 불안한데 삼중으로 중첩되니 달달 떨리네요.   문제 출처      프로그래머스  ","categories": ["programmers-lv1"],
        "tags": ["for문"],
        "url": "/programmers-lv1/programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/",
        "teaser": null
      },{
        "title": "[Next.js] Next.js란?",
        "excerpt":"📄 Next.js는 무엇일까?      리액트 프레임 워크   리액트JS의 풀스택 프레임 워크   🎲 리액트를 더 잘 사용하기 위해 만들어진 리액트 프레임워크   📄 주요 기능      서버 사이드 렌더링 (사전 렌더링)            풀스택 프레임워크라 불리는 이유       리액트 페이지, 컴포넌트를 서버 측에서 미리 렌더링       SEO에 유리 + 로딩 경험 유리 -&gt; 서버로부터 받은 모든 정보가 html에 포함되어 있기 때문           파일 기반 라우팅            기존 리액트는 라우터가 아예 없음. 리액트 라우터 사용했음.       페이지 폴더의 이름으로 url을 결정한다.           ⭐ 풀스택 쌉가능            백엔드 API를 리액트 프로젝트에 추가할 수 있다.       독립적인 REST API 프로젝트를 구축하지 않아도 된다.           참고           유데미 Nextjs.&amp;React - 완전 정복 가이드            Next.js 공식 문서      ","categories": ["Nextjs"],
        "tags": ["Next.js"],
        "url": "/nextjs/nextjs-Nextjs%EB%9E%80/",
        "teaser": null
      },{
        "title": "[Next.js] Next.js의 페이지 사전렌더링",
        "excerpt":"📄 Next.js가 페이지를 준비하고 사전 렌더링을 하는 방법      💡 Hydration이란? HTML을 미리 렌더링하고, 그 뒤에 요청이 오면 chunk단위로 js를 보내주어 이벤트가 작동하는 것    Next.js의 사전렌더링은 기존 리액트의 CRA와 다르게 완성된 HTML을 브라우저에 보내주는 방법이다.   사전 렌더링은 첫번째 페이지에만 적용되며, 첫번째 페이지 렌더링이 끝아면 다시 SPA로 돌아간다.   이렇게 미리 완성된 HTML 페이지를 가져오면 두가지 이점이 생긴다.      사용자는 데이터가 실질적으로 로딩될때까지 기다리지 않아도 된다. =&gt; 사용자 경험 최적화   구글 검색엔진이 실질적 데이터가 들어있는 HTML코드를 읽고 해석한다. =&gt; SEO 최적화   Next.js 가 사전렌더링을 구현하는 방법은 SSG, SSR이 있다.   ⭐ 중요한 사실은 Next.js는 어떤 작업을 하지 않아도 기본적으로 사전렌더링을 한다는 점이다. SSG, SSR은 사전렌더링을 하는 방식을 정하기 위한 요소라는 점을 이해해야한다.   🔴 SSG(Server-Side-Generation, Static-Site-Generation)      사용 방법: 페이지에 getStaticProps함수를 추가한다.   사용 목적            페이지가 사전 생성되어야 하는 것을 Next.js에게 알려준다.       만약 Next.js가 사전렌더링을 하지 않도록 설정되었을 때, getStaticProps함수로 특정 페이지를 사전렌더링 하도록 지정할 수 있다.           페이지 생성 시기: 프로젝트 빌드시   function HomePage(props) {   const { products } = props;   return (     &lt;ul&gt;       {products.map((product) =&gt; (         &lt;li key={product.id}&gt;{product.title}&lt;/li&gt;       ))}     &lt;/ul&gt;   ); }  export async function getStaticProps() {   return {     // 항상 객체를 반환한다.     props: {       products: [{ id: \"p1\", title: \"Product 1\" }],     },   }; }  export default HomePage;   getStaticProp가 포함된 페이지 파일이 실행되면 발생하는 순서를 다음과 같다.      getStaticProps함수를 먼저 호출한다. 함수안에 컴포넌트에서 사용될 데이터를 페칭해오는 작업을 한다.   컴포넌트 함수를 실행한다.   🗨 SSG를 통해 JSON데이터 가져오기      SSG를 하면서 모든 데이터를 파일 내에 저장하지 않고, JSON파일을 불러와 사용하는 방법      data 폴더를 생성해 json 파일을 만들어 데이터를 저장한다.   { \"products\": [   { \"id\": \"p1\", \"title\": \"Product 1\", \"description\": \"This is product 1\" },   { \"id\": \"p2\", \"title\": \"Product 2\", \"description\": \"This is product 2\" },   { \"id\": \"p3\", \"title\": \"Product 3\", \"description\": \"This is product 3\" } ] }      데이터를 사용할 페이지의 getStaticProps함수에서 데이터를 가져와 return한다.   import path from \"path\"; import fs from \"fs/promises\"; // Node.js 로 부터 파일 시스템 모듈을 임포트  function HomePage(props) {   //getStaticProps를 통해 가져온 json데이터를 props를 통해 전달   const { products } = props;   return (     &lt;ul&gt;       {products.map((product) =&gt; (         &lt;li key={product.id}&gt;{product.title}&lt;/li&gt;       ))}     &lt;/ul&gt;   ); }  export async function getStaticProps() {   const filePath = path.join(process.cwd(), \"data\", \"dummy-backend.json\");   const jsonData = await fs.readFile(filePath);   const data = JSON.parse(jsonData);    return {     props: {       products: data.products,     },   }; }   🗨 ISR (증분 정적 생성) 활용하기           사용 목적: 사전 생성하는 페이지에서 데이터가 계속 업데이트 되는 경우에 사용            장점: 페이지를 빌드할 때 한 번만 생성하는 것이 아닌 재배포 없이 업데이트 할 수 있다.       export async function getStaticProps() {   console.log(\"(RE-)Generating...\");   const filePath = path.join(process.cwd(), \"data\", \"dummy-backend.json\");   const jsonData = await fs.readFile(filePath);   const data = JSON.parse(jsonData);    return {     props: {       products: data.products,     },     revalidate: 10, // 🎉 ISR: 10초마다 주어진 페이지를 Next.js가 재생성한다.   }; }      🗨 getStaticProps 구성 옵션 활용하기      notFound: 페이지가 일반 페이지 대신 404 오류 페이지를 렌더링   if (data.products.length === 0) {   return { notFound: true }; }      redirect: 데이터베이스에 엑세스할 수 없을 경우 주로 사용 (데이터 자체가 없을 때)   if (!data) {   return {     redirect: {       destination: \"/no-data\",     },   }; }   참고           유데미 Nextjs.&amp;React - 완전 정복 가이드            Next.js 공식 문서      ","categories": ["Nextjs"],
        "tags": ["SSG","SSR"],
        "url": "/nextjs/nextjs-next.js%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%A0%84%EB%A0%8C%EB%8D%94%EB%A7%81/",
        "teaser": null
      },{
        "title": "[React] forwardRef로 부모컴포넌트에서 자식컴포넌트 DOM에 접근하기",
        "excerpt":"📄 리액트 폼 관리하기   하나의 폼을 관리할 때 input이 각각 파일로 나뉘어져 있다면 관리할 수 있는 방법은 여러가지가 있다.      부모-자식 컴포넌트간 통신   상태 관리 라이브러리 사용   Context API 사용   폼 라이브러리 사용   원래는 상태 관리 라이브러리로 form을 관리했지만 해당 state를 구독하는 컴포넌트가 타이핑마다 리렌더링되어 비효율적이라는 생각이 들었다.   그래서 다른 방법이 있나 찾아보던 중 forwardRef라는 react 훅을 알게 되었다.   📄 forwardRef를 써보자           역할: 부모컴포넌트가 자녀 컴포넌트에 ref를 전달할 수 있다.            사용법: 자식 컴포넌트를 forwardRef로 감싸준다.       const inputRef = useRef();  const focus = () =&gt; {   inputRef.current.focus(); };  return (   &lt;div&gt;     &lt;MyInput ref={inputRef} /&gt;     &lt;button onClick={focus}&gt;포커스&lt;/button&gt;   &lt;/div&gt; );   const Input = (ref) =&gt; {   return &lt;input ref={ref} /&gt;; };  export default forwardRef(MyInput);   📄 주의할 점   자녀 컴포넌트가 가진 DOM노드를 외부로 노출시키는 일이므로 캡슐화를 방해할 수 있다.   필요하다면 사용하지만 굳이 필요없다면 최선책으로 사용할만한 방법은 아니다.   출처      별코딩 Youtube - React의 ForwardRef란?  ","categories": ["React"],
        "tags": ["forwardRef"],
        "url": "/react/react-fowardRef%EB%A1%9C-%EB%B6%80%EB%AA%A8%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-DOM%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React] React Portal",
        "excerpt":"🗒️ React Potal 이란?      다른 곳에 있는 element를 렌더링할 수 있다.   컴포넌트가 종속되어 있는 돔 트리를 벗어나 외부의 다른 돔으로 렌더한다. (어플리케이션은 하나지만 부분적으로 다른 돔에 마운트)   🗒️ useModal hook   import { useEffect, useRef, useState } from \"react\"; import { createPortal } from \"react-dom\"; import { styled } from \"styled-components\";  const useModal = () =&gt; {   const [modalOpened, setModalOpened] = useState(false);    const openModal = () =&gt; {     setModalOpened(true);   };    const closeModal = () =&gt; {     setModalOpened(false);   };    interface IProps {     children: React.ReactNode;   }    const ModalPortal: React.FC&lt;IProps&gt; = ({ children }) =&gt; {     const ref = useRef&lt;Element | null&gt;();     const [mounted, setMounted] = useState(false);      useEffect(() =&gt; {       setMounted(true);       if (document) {         // dom에 root-modal이 있으면 가져오기         const dom = document.querySelector(\"#root-modal\");         ref.current = dom;       }     }, []); // mount      if (ref.current &amp;&amp; mounted &amp;&amp; modalOpened) {       return createPortal(         &lt;Container&gt;           &lt;div             className=\"modal-background\"             role=\"presentation\"             onClick={closeModal}           /&gt;           {children}         &lt;/Container&gt;,         ref.current       );     }     return null;   };    return {     openModal,     closeModal,     ModalPortal,   }; };  export default useModal;  const Container = styled.div`   width: 100%;   height: 100%;   display: flex;   justify-content: center;   align-items: center;   position: fixed;   top: 0;   left: 0;   z-index: 11;   .modal-background {     position: absolute;     width: 100%;     height: 100%;     background-color: rgba(0, 0, 0, 0.75);   } `;   🗒️ useModal hook 사용하기   import { styled } from \"styled-components\"; import AirbnbLogoIcon from \"../public/static/svg/logo/logo.svg\"; import AirbnbLogoTextIcon from \"../public/static/svg/logo/logo_text.svg\"; import Link from \"next/link\"; import palette from \"../styles/palette\"; import { useState } from \"react\"; import useModal from \"../hooks/useModal\"; import SignUpModal from \"./auth/SignUpModal\";  const Header: React.FC = () =&gt; {   const { openModal, ModalPortal } = useModal();   return (     &lt;Container&gt;       &lt;Link href={\"/\"}&gt;         &lt;div className=\"header-logo-wrapper\"&gt;           &lt;AirbnbLogoIcon className=\"header-logo\" /&gt;           &lt;AirbnbLogoTextIcon /&gt;         &lt;/div&gt;       &lt;/Link&gt;       &lt;div className=\"header-auth-buttons\"&gt;         &lt;button           type=\"button\"           className=\"header-sign-up-button\"           onClick={openModal}         &gt;           회원가입         &lt;/button&gt;         &lt;button type=\"button\" className=\"header-login-button\"&gt;           로그인         &lt;/button&gt;       &lt;/div&gt;       &lt;ModalPortal&gt;         &lt;SignUpModal /&gt;       &lt;/ModalPortal&gt;     &lt;/Container&gt;   ); };  export default Header;  const Container = styled.div`   position: sticky;   top: 0;   width: 100%;   height: 80px;   display: flex;   justify-content: space-between;   align-items: center;   padding: 0 80px;   background-color: white;   box-shadow: rgba(0, 0, 0, 0.08) 0px 1px 12px;   z-index: 10;   .header-logo-wrapper {     display: flex;     align-items: center;     .header-logo {       margin-right: 6px;     }   }    .header-auth-buttons {     .header-sign-up-button {       height: 42px;       margin-right: 8px;       padding: 0 16px;       border: 0;       border-radius: 21px;       background-color: white;       cursor: pointer;       outline: none;       &amp;:hover {         background-color: ${palette.gray_f7};       }     }     .header-login-button {       height: 42px;       padding: 0 16px;       border: 0;       box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.18);       border-radius: 21px;       background-color: white;       cursor: pointer;       outline: none;       :hover {         box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.12);       }     }   } `;   참고      클론 코딩으로 시작하는 Next.js  ","categories": ["React"],
        "tags": ["portal","modal"],
        "url": "/react/react-react-portal/",
        "teaser": null
      },{
        "title": "[JavaScript] 내쓰내정 카카오톡 api 사용 후기 및 정리",
        "excerpt":"📄 사용한 카카오톡 api   프로젝트를 진행하며 카카오톡 api를 사용했다. 주 기능은 공유하기 기능과 카카오 싱크. 깃허브 로그인은 구현한적이 있는데 기록을 안해서 기억이 하나도 안나더랬다. 그래서 이번엔 또 같은 어려움을 겪기 전에 그리고 또 까먹기 전에 기록한다.   📄 카카오톡 api를 사용하며 내가 겪었던 삽질들   1. 환경별로 .env파일을 따로 관리하자   이번 프로젝트를 진행한 브랜치는 세가지였다.      main   dev   test   각 브랜치에서 사용한 환경변수는 다음과 같다.   NEXT_PUBLIC_KAKAO_REST_API_KEY = \"비밀이지롱\"; NEXT_PUBLIC_KAKAO_REDIRECT_URL =   \"http://localhost:3000/카카오 로그인성공하면 이동할 리다이렉트 페이지\"; NEXT_PUBLIC_API_BASE_URL = \"비밀이지롱\"; NEXT_PUBLIC_JS_API_KEY = \"비밀이지롱\";   ⭐️ 브랜치별로 사용하는 uri가 다르기 때문에 리다이렉트 uri를 다르게 관리해야한다.           카카오톡에 등록한 uri 주소로 리다이렉트 해야하기 때문에 배포되는 브랜치 작업의 주소를 기준으로 환경변수를 설정한다.            카카오톡 로그인 페이지에서 로그인에 성공하면 등록한 리다이렉트 페이지로 이동하는데 이때 쿼리로 auth code를 받는다.            프론트는 이 auth code를 백엔드에게 보내고 나머지 로직 (home으로 이동 등)을 리다이렉트 페이지에 작성해서 로그인 과정을 진행한다.            백엔드는 받은 auth code로 token을 요청하는데 이때 로그인페이지로 라우팅될 때 사용한 리다이렉트 uri가 같아야 한다.       2. authorization code not found for code (500 Error)   카카오톡에서 날려주는 500 error.   ⭐️ 이 에러가 발생한 이유는 동일한 인증코드를 여러번 사용했기 때문이다.   앞서 사용한 auth code를 두번이상 사용하면 카카오는 500에러를 전송한다.   이때 아마 로그인 요청이 두번 가게되어 에러가 발생했는데 꽤나 고생했던 것 같다.   📄 마무리   처음 사용하면서 봤을 때는 꽤 어려웠는데 정리하다보니 생각보다 별거 아닌 것 같아서 괜히 허무한 것 같다.   카카오 공식문서 짱~  ","categories": ["JavaScript"],
        "tags": ["카카오톡","API"],
        "url": "/javascript/nextjs-%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-api-%EC%82%AC%EC%9A%A9-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[React] return null vs return false",
        "excerpt":"📄 return null vs return false   지금까지 진행했던 프로젝트에서 자바스크립트는 null을 false로 인식해 boolean 체킹을 하기 때문에, boolean타입으로 형변환을 거치지 않고 그대로 null를 반환해서 사용했다.   하지만 리액트의 성능 최적화를 고려한다면, 이 둘을 명확히 구분해서 사용할 필요가 있다.   ✅ null 보다는 false를 사용하자!   null과 false를 반환하는 것에 대한 차이점을 바로 말하자면, 리렌더링의 유무이다.   리액트는 null를 유효한 값으로 취급한다.   이말인 즉슨 리액트의 가상 돔이 null을 인식하여 null을 반환하는 하위 컴포넌트를 가진 컴포넌트들이 강제로 리렌더링 된다는 뜻이다.   function Parent() {   return (     &lt;div&gt;       &lt;Child /&gt;     &lt;/div&gt;   ); }  function Child() {   const [count, setCount] = useState(0);    useEffect(() =&gt; {     console.log(\"Child rendered\");   });    if (count === 0) {     return null;   }    return (     &lt;div&gt;       &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;       {count}       &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;     &lt;/div&gt;   ); }      하위 컴포넌트인 Children이 null을 반환할 때, 상위 컴포넌트인 Parent가 강제로 리렌더링 된다.   이 현상을 방지하기 위한 방법이 false를 반환하는 것이다.   function Parent() {   return (     &lt;div&gt;       &lt;Child /&gt;     &lt;/div&gt;   ); }  function Child() {   const [count, setCount] = useState(0);    useEffect(() =&gt; {     console.log(\"Child rendered\");   });    if (count === 0) {     return false;   }    return (     &lt;div&gt;       &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;/button&gt;       {count}       &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;     &lt;/div&gt;   ); }      하위 컴포넌트인 Children이 false를 반환할 때, 상위 컴포넌트인 Parent가 리렌더링 되지 않는다.   리액트의 가상돔이 false를 인식하지 않기 떄문에, 상위 컴포넌트에서 리렌더링이 발생하지 않는다는 것을 알 수 있다.   📄 정리                  return       null       false                       차이점       상위 컴포넌트 리렌더링 O       상위 컴포넌트 리렌더링 X           비지니스로직이 아닌 뷰로직으로서 아무것도 반환하지 않겠다는 뜻으로 사용할 때는 false를 사용해 리렌더링을 방지할 수 있다.   참고      stop using “return null” in React  ","categories": ["React"],
        "tags": ["null","false","return"],
        "url": "/react/react-return-null-%EA%B3%BC-false%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/",
        "teaser": null
      },{
        "title": "[Next.js] Next.js 13.5 update!",
        "excerpt":"📄 Next.js 13.5 realize!   Next.js 13.5 버전이 릴리즈 되었다.   어떤 기능이 향상되었는지 확인 겸 정리한다.   1. 시작 및 새로고침 시간 단축      로컬 서버 시작 시간 22% 단축   HMR 시간 29% 단축   메모리 사용량 40% 감소      💡 HMR(Hot Module Replacement)? 브라우저를 새로고침하지 않아도 Webpack으로 빌드한 결과물이 웹 애플리케이션에 실시간으로 반영    2. next/image 기능 향상      unstable_getImgProps 함수 추가   기존에 next/image 를 사용하려면 &lt;Image&gt; 컴포넌트를 사용해야했다. 이번 업데이트 버전에 따르면 &lt;Image&gt; 컴포넌트를 사용하지 않아도, 이미지를 렌더링 할 수 있다.   import { unstable_getImgProps as getImgProps } from \"next/image\";  export default function Page() {   const common = { alt: \"Hero\", width: 800, height: 400 };   const {     props: { srcSet: dark },   } = getImgProps({ ...common, src: \"/dark.png\" });   const {     props: { srcSet: light, ...rest },   } = getImgProps({ ...common, src: \"/light.png\" });    return (     &lt;picture&gt;       &lt;source media=\"(prefers-color-scheme: dark)\" srcSet={dark} /&gt;       &lt;source media=\"(prefers-color-scheme: light)\" srcSet={light} /&gt;       &lt;img {...rest} /&gt;     &lt;/picture&gt;   ); }     이 외에도 Import 최적화 등 자잘한 업데이트 사항이 있지만, 이 두가지가 가장 크게 눈에 들어왔다.   더 확실한건 vercel이 page 라우팅 보다 app 라우팅에 중점을 두고 업데이트를 진행했다는 느낌을 받았다.   app 라우팅의 사용량도 점점 늘고 있는만큼 app 라우팅 기능을 잘 활용할 수 있도록 꾸준히 사용해 보아야겠다.   참고      Next.js란?  ","categories": ["Nextjs"],
        "tags": ["nextjs","업데이트"],
        "url": "/nextjs/nextjs-nextjs-13.5-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[React] react hook, 언제 사용해야 할까?",
        "excerpt":"📄 react hook?   리액트 훅 (React hook)은 함수형 컴포넌트에서도 클래스형 컴포넌트의 기능을 사용할 수 있게 해주는 기능이다.   자주 사용되는 리액트 훅의 종류는 다음과 같다.           useCallback              의존성 배열안의 인자가 변경될 때까지 함수를 저장       하위 컴포넌트의 무의미한 렌더링을 방지할 수 있어 유용                useMemo              의존성 배열안의 인자가 변경될 때까지 계산된 값(value) 저장       매 렌더링마다 복잡한 계산을 해야하는 상황을 피할 수 있다.                useEffect             모든 컴포넌트가 렌더링 (처음 렌더링) 된 후, 실행       의존성 배열안의 인자가 변경될 때마다, 첫번째 인자로 등록된 함수가 실행           리액트 훅은 매우 유용하지만 데이터를 메모리에 저장하는 메모이제이션 기능을 담당하기 때문에, 무분별하게 사용한다면 의미없는 메모리 낭비가 발생하게 된다.   리액트 훅을 어느 상황에서 사용하는 것이 적절한 것인지 정리해보았다.   📄 useCallback | 리렌더링될 때마다 함수 호출하기 싫어요      목적: 함수 생성 최적화   useCallback은 함수를 저장하는 리액트 훅이다.   이때 함수를 저장하다는 것은 함수의 실행 여부를 정한다는 뜻이다.   컴포넌트가 리렌더링된다면 그 안에 종속되어 있는 함수는 매번 호출된다. 간단한 함수라면 문제없지만 api를 통해 데이터를 fetching하는 함수라면 의미없는 api 호출이 계속 발생하게 될 수 있다.   💾 App.js      getItem(): 데이터 fetching 함수. List에 props로 전달한다.   import React, { useState } from \"react\"; import List from \"./List\";  function App() {   const [input, setInput] = useState(1);   const [light, setLight] = useState(true);    const getItems = () =&gt; {     return [input + 10, input + 100];   };    const theme = {     backgroundColor: light ? \"White\" : \"grey\",     color: light ? \"grey\" : \"white\",   };   return (     &lt;&gt;       &lt;div style={theme}&gt;         &lt;input           type=\"number\"           value={input}           onChange={(event) =&gt; setInput(parseInt(event.target.value))}         /&gt;         &lt;button onClick={() =&gt; setLight((prevLight) =&gt; !prevLight)}&gt;           {light ? \"dark mode\" : \"light mode\"}         &lt;/button&gt;         &lt;List getItems={getItems} /&gt;       &lt;/div&gt;     &lt;/&gt;   ); }  export default App;   💾 List.js   import React, { useEffect, useState } from \"react\";  function List({ getItems }) {   const [items, setItems] = useState([]);    useEffect(() =&gt; {     console.log(\"Fetching items\");     setItems(getItems());   }, [getItems]);    return (     &lt;div&gt;       {items.map((item) =&gt; (         &lt;div key={item}&gt;{item}&lt;/div&gt;       ))}     &lt;/div&gt;   ); } export default List;   🔍 문제 상황: theme을 바꾸는 버튼을 눌렀을 때 컴포넌트 리렌더링 -&gt; 매 렌더링마다 getItem()호출되어 계속되는 무의미한 api 호출     🔦 해결 방법: useCallback 함수로 getItem()을 저장해 의존성 배열안의 값이 바뀔 때만 함수가 실행되도록 하자!   const getItems = useCallback(() =&gt; {   return [input + 10, input + 100]; }, [input]);   useCallback함수로 getItem()는 input값이 변경될 때만 호출되어 무의미한 data fetching을 없애 주었다.   📄 useMemo | stateful한 값이 변경될 때마다 발생하는 리렌더링을 막고 싶어요      목적: 값 계산 최적화   💾 MyComponent.js   function MyComponent() {     const [data, setData] = useState(0);     const number = verySlowFunction(data);     return &lt;div&gt;{number}&lt;/div&gt;; }  function verySlowFunction(input) {     ...heavy work done here     return value; }   🔍 문제 상황: MyComponent가 호출될 때마다, verySlowFunction()가 호출   🔦 해결 방법: useState 값을 저장해 무의미한 컴포넌트 호출을 막을 수 있다.   function MyComponent() { \tconst [data, setData] = useState(0); \tconst number = useMemo(() =&gt; { \t\treturn verySlowFunction(data) \t}, [data]);  \treturn &lt;div&gt;{number}&lt;/div&gt;; }  function verySlowFunction(input) { \t...heavy work done here \treturn value; }      useCallback 과 useMemo는 리액트 컴포넌트 내에서 렌더링과 관련된 함수와 값의 최적화를 달성하기 위해 사용된다. 이로써 불필요한 렌더링을 방지하고 애플리케이션의 성능을 향상 시킬 수 있다. 목적은 의존성 배열을 올바르게 설정하여 효율적인 최적화를 도출하는 것이다. 하지만 무작정 사용하는 것보다 “왜” 사용하는지를 중요시하며, 무의미한 메모리 낭비를 줄이기 위해 신중하게 확인해야 한다.   참고      When to use useCallback, useMemo and useEffect?  ","categories": ["React"],
        "tags": ["useEffect","useCallback","useMemo"],
        "url": "/react/react-react-hook-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C/",
        "teaser": null
      },{
        "title": "tailwind를 사용해보자",
        "excerpt":"📝 Tailwind란?      CSS 프레임워크   미리 세팅된 유틸리티 클래스 활용   📝 tailwind 사용하기   1. 설치 및 환경 세팅      tailwind를 설치한다.   npm install -D tailwindcss npx tailwindcss init      tailwind.config.js파일에서 경로를 설정한다.   /** @type {import('tailwindcss').Config} */ module.exports = {   content: [\"./src/**/*.{html,js}\"],   theme: {     extend: {},   },   plugins: [], };      메인 CSS파일에서 tailwind 지시자를 설정한다.   @tailwind base; @tailwind components; @tailwind utilities;      CLI도구를 설치해 메인 CSS 파일을 빌드시켜준다.   npx tailwindcss -i ./src/input.css -o ./dist/output.css --watch      HTML파일에 빌드된 css파일을 연결한다.   &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt;   &lt;meta charset=\"UTF-8\"&gt;   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;   &lt;link href=\"/dist/output.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt;   &lt;h1 class=\"text-3xl font-bold underline\"&gt;     Hello world!   &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;   2. vsCode에 맞는 에디터 설치하기      Tailwind CSS IntelliSense            클래스 이름, css 함수, 지시자 이름 자동 완성       린팅기능       호버시 미리보기 기능           Prettier            prettier는 공식적으로 tailwind css 코드 sorting기능을 제공           3. element className에 스타일 설정하기      리액트에서 사용할 경우, class가 아닌 className을 사용한다.   function App() {   return &lt;h1 className=\"text-3xl font-bold underline\"&gt;Hello world!&lt;/h1&gt;; }        다음에 또 보기 위해 tailwind 사용법을 간단하게 정리했다. 짧게 써보고 남기는 후기는 다음과 같다.      장) 컴포넌트 이름을 신경쓰지 않아도 괜찮다.   장) 이미 구현된 유틸리티 클래스 덕에 빠른 구현이 가능하다   단) 아무래도 클래스 이름이 스타일 코드로 인해 길어져 코드가 혼잡해 보인다.   사용하며 더 알게 되는 점이나 기록할 부분이 생기면 추가할 예정이다.   부트스트랩도 사용해본 경험이 없어 css framework는 꽤 생소했다. 잘 쓰면 약, 못쓰면 독일테니 적절하게 잘 사용해 퀄리티를 높이는 연습을 해야겠다.   참고      tailwind 공식문서  ","categories": ["CSS"],
        "tags": ["tailwind"],
        "url": "/css/css-tailwind-%EC%82%AC%EC%9A%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[JavaScript] 모듈 번들러, 웹팩(Webpack)",
        "excerpt":"Webpack - JS 모듈 번들링 도구   보통 CRA 또는 CNA로만 프로젝트를 빌드해왔기 때문에 “번들링”이라는 개념을 몰라도 프로젝트를 진행하는데 문제가 없었다. 최근 최적화에 관심을 가지게 되면서 평소에 그냥 지나쳤던 웹팩에 대해 관심을 가지게 되었고, 역시 공식문서가 제일 정리가 잘 되어 있다는 것을 알고 전체적으로 읽어 보았다.   🟣 웹팩이란?   웹팩은 자바스크립트 모듈 번들러이다.그렇다면 모듈과 번들링의 의미는 무엇일까.      모듈: 프로그래밍 관점에서 특정 기능을 갖는 가장 작은 단위.   번들링: 웹 애플리케이션을 구성하는 자원을 하나의 파일로 병합, 압축하는 과정   즉, 웹팩이 하는 일은 특정 기능을 가지는 작은 코드 뭉치를 하나의 파일로 병합하는 것이다.   웹팩 사용 이유      파일 단위로 변수를 관리할 수 있다.   웹팩은 자바스크립트 파일을 모듈로 관리한다. 모듈로 관리하지 않으면 두개의 파일에서 전역으로 선언된 변수 example이 중복선언되는 일이 생긴다. 웹팩을 사용하면 같은 이름으로 선언된 전역 변수를 다른 취급으로 관리할 수 있다.   모듈 번들링을 통해 브라우저에서 서버로 요청하는 파일 숫자를 줄일 수 있다.  브라우저에서 서버로 보낼 수 있는 HTTP요청 수는 정해져있다. 모듈 번들링을 통해 HTTP요청을 줄임으로써 사용자 경험을 높일 수 있다.   웹팩의 code splitting 기능을 통해 동적으로 모듈을 로딩할 수 있다.   자바스크립트 코드가 모듈로 관리되어 있어 필요한 부분만 동적으로 로딩한다.   🟣 웹팩 설치하기   기본 프로젝트에 웹팩을 설치하는 방법이다.      webpack 설치   npm init -y npm install webpack webpack-cli --save-dev      index.html 분리 배포코드(/dist)와 개발자가 작성하는 소스코드(/src)를 분리하는 작업이다.   webpack-demo   |- package.json   |- package-lock.json  |- /dist    |- index.html   |- /src     |- index.js      webpack.config.js 설정      번들링된 코드를 /dist 경로의 main.js에서 관리   const path = require(\"path\");  module.exports = {   entry: \"./src/index.js\",   output: {     filename: \"main.js\",     path: path.resolve(__dirname, \"dist\"),   }, };      번들링 실행 명령어   npx webpack --config webpack.config.js      package.json 에서 script 명령어 설정   {   \"name\": \"webpack-test\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",     \"build\": \"webpack\" // 👀   },   \"keywords\": [],   \"author\": \"\",   \"license\": \"ISC\",   \"devDependencies\": {     \"webpack\": \"^5.89.0\",     \"webpack-cli\": \"^5.1.4\"   },   \"dependencies\": {     \"lodash\": \"^4.17.21\"   } }   🟣 웹팩으로 Asset 관련 코드 관리하기   참고      웹팩 공식문서  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Webpack","번들링","웹팩"],
        "url": "/javascript/javascript-webpack/",
        "teaser": null
      },{
        "title": "[Next.js] 🚨 이벤트가 함수가 prop로 전달되지 않는 이유",
        "excerpt":"🚨 문제 발생   Next.js를 사용해 프로젝트를 진행하는데 에러가 발생했다.      프로젝트 환경은 다음과 같다.      Next.js (app routing)   TS   이벤트 함수를 컴포넌트 간 props로 전달하는 과정에서 발생했다.   ❔문제 원인      Server Component에서 Client Component로 함수를 전달 할 수 없다.   각 컴포넌트 간 props로 전달되는 함수는 직렬화 할 수 없기 때문이다.   이 때 궁금한점.      난 Client Component로 컴포넌트를 변환한 적이 없는데?   함수 직렬화가 무엇이지?   1. 난 Client Component로 컴포넌트를 변환한 적이 없는데? | Client Component로 실행되는 조건   next.js는 따로 설정하지 않으면 기본적으로 서버 컴포넌트로 실행된다. 하지만 위와 같은 에러가 발생했고 이유를 찾아보았다.   하위 컴포넌트인 Modal.tsx는 onClick 이벤트를 발생시키는 컴포넌트를 포함하고 있다. onClick 이벤트는 자바스크립트 이벤트 핸들러로 웹 브라우저 상에서 사용자에 의해 컨트롤된다.   사용자와 상호작용하는 이벤트 핸들러는 브라우저 환경에서 실행되는 클라이언트 측 코드에서 사용되어야 한다   ⭐️ 이벤트 핸들러가 실행되는 함수는 자동으로 클라이언트 컴포넌트로 변환된다!   const MyModal = (props: IModal) =&gt; {   const { isOpen, onRequestClose, contentLabel } = props; // 👀    return (     &lt;div&gt;       &lt;h2&gt;{contentLabel}&lt;/h2&gt;       &lt;p&gt;...모달내용...&lt;/p&gt;       &lt;button onClick={onRequestClose}&gt;닫기&lt;/button&gt; // 👀     &lt;/div&gt;   ); };   에러가 발생한 포인트는 props전달 과정에 있다. props전달 과정에서 어떤 일이 발생하길래 서버 ↔️ 클라이언트 컴포넌트 간 props를 전달 할 수 없는 것일까?   2. 함수 직렬화가 무엇이지? | 서버 ↔️ 클라이언트 컴포넌트 간 props를 전달할 때 발생하는 일      If you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server to Client Components need to be serializable by React. by. NEXT JS 공식문서    공식문서에서도 서버 컴포넌트가 클라이언트 컴포넌트로 데이터를 props형태로 전달할때 리액트에 의해 직렬화(serializable)되어야 한다고 말한다.   💡 함수 직렬화란?  함수를 문자열로 변환하여 데이터를 직렬화하는 과정을 뜻한다. 자바스크립트에서는 데이터를 JSON형태로 변환하는 것을 직렬화한다고 한다.   하지만 NEXT JS에서 서버 컴포넌트에서 클라이언트 컴포넌트로 데이터를 전달할 때 JSON으로 직렬화되지 않고 React.Element로 전달한다.   전달된 React.Elements는 리액트 컴포넌트를 표현하는 객체로, JS 기본 데이터 형식 이외에도 React에 특화된 데이터를 포함하고 있다.   다시 한번 문제를 정리하자면 다음과 같다.      하위 컴포넌트가 이벤트 함수를 props로 전달받아 클라이언트 컴포넌트로 자동 전환되었다.   컴포넌트간 데이터를 전달할 때는 직렬화 과정이 필요한데, 이때 서버 컴포넌트에서 클라이언트 컴포넌트로 props로 전달된 데이터는 직렬화 과정을 거치지 않는다.   이 데이터는 JSON으로 직렬화 되지 않고, React.Elements로 전달되기 때문이다.   이 문제를 해결하는 데에 여러 방법이 있다.   🔨 문제 해결   1. 클라이언트 ↔️ 클라이언트 구조 만들기   서버 컴포넌트 ↔️ 클라이언트 컴포넌트 구조가 문제라면, ㅊ 구조로 바꾸는 것은 어떨까?   이 때 사용되는 명령어는 다음과 같다.   \"use client\";   상위 컴포넌트 파일 상단에 이 명령어를 추가하면 클라이언트 컴포넌트로 선언된다. 여기서 구분을 명확하게 하기 위해 파일 이름도 바꾸어 주면 좋다.   MyModal.tsx -&gt; MyModal.client.tsx   여기서 또 궁금점이 생겼다.   NEXT JS에서 상위 컴포넌트가 클라이언트 컴포넌트라면 하위 컴포넌트는 모두 클라이언트로 설정된다. 이 프로젝트의 가장 상위 컴포넌트인 Page.tsx에 use client를 추가했는데, 이러면 NEXT JS 프레임워크를 사용하는 것이 의미가 있을까?   공식문서에 따르면 이를 해결하기 위해 react-query 같은 third-party 라이브러리 사용을 권장한다. 하지만 프로젝트가 작고 상태관리 라이브러리가 굳이 필요하지 않다면 라이브러리를 추가하지 않고 이벤트 핸들러를 props로 전달하는 경우를 최대한 지양하는 편이 좋다는 생각이 들었다.   참고           Passing props to onClick from server to client component in Next13            Next.js 공식문서 - composition-patterns      ","categories": ["Nextjs"],
        "tags": ["nextjs","props","error","함수의 직렬화","서버 컴포넌트","클라이언트 컴포넌트"],
        "url": "/nextjs/nextjs-event%ED%95%A8%EC%88%98%EB%8A%94-%EC%99%9C-props%EB%A1%9C-%EC%A0%84%EB%8B%AC%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[React] 리액트팀은 왜 가상 돔을 만들었을까?",
        "excerpt":"사용자가 브라우저 주소창에 주소를 입력하면 어떤 일이 발생할까?         브라우저가 사용자가 요청한 주소를 방문해 html을 다운받는다.   브라우저의 렌더링 엔진이 html 을 파싱해 DOM 트리를 만든다.   2 과정에서 CSS 파일을 만나면 CSS 파일을 다운받는다.   브라우저의 렌더링 엔진이 CSS 트리인 CSSOM을 만든다.   브라우저는 만들어진 DOM트리를 순회한다. 이 과정에서 사용자의 눈에 보여지는 부분만 순회한다. 이를 통해 트리를 분석하는 과정을 빠르게 할 수 있다.   DOM 트리에서 눈에 보이는 노드에 대한 CSSOM 정보를 찾아 노드에 적용해 렌더트리를 만든다.            레이아웃(Reflow): 노드가 브라우저 화면에 어느 좌표에 위치해야하는지 계산하는 과정       페인팅(Repaint): 레이아웃단계를 거친 노드에 색, 이미지 같은 유효한 모습을 그리는 과정           사용자 인터렉션에 의해 DOM이 변경되었을 때는 어떻게 동작할까?      어떠한 인터렉션에 의해 DOM에 변화가 생길 때, 브라우저는 위 과정을 반복하며 렌더 트리를 다시 만든다.      Layout부터 발생하는 경우 (Reflow): 레이아웃의 높이, 너비 등 변화   Paint부터 발생하는 경우 (Refaint): 이미지, 색상 등 변화   레이어의 합성만 다시 발생하는 경우 (Composite): transform, opacity 속성 등   composite(합성) 단계는 여러 레이어로 나누어진 픽셀값들을 우리가 실제로 보는 화면처럼 합성해주는 단계이다. paint단계에서 만들어진 레이어들을 순서대로 합성해 유저에게 보여준다.   이 과정을 이해하고 있다면 렌더링 최적화 과정을 진행할 수 있다.   예시로 애니메이션을 구현할 때, position과 transform을 선택할 수 있는데 position의 경우는 layout이 변경되어 reflow단계부터 트리가 재구조화된다면, transform은 coposite단계부터 변화가 적용되어 레이아웃과 페인트 과정을 감소시킬 수 있기 때문이다.   왜 리액트팀은 가상 DOM을 만들게 되었을까?      과거 전통적인 웹사이트는 하나의 문서에 전달되는 정보의 양이 적었다. 그렇기 때문에 DOM이 변경되어도 서버에서 완전히 새로운 페이지를 내려주는 방법이 가능했지만, 현대 웹 사이트는 유저 인터렉션이 빈번하게 발생할 뿐더러 다뤄지는 데이터 양도 많다.   이러한 문제를 해결하기 위해 SPA가 등장했다. SPA는 ‘단일 페이지 어플리케이션’으로 웹 사이트에서 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 변경하는 기술이다. 이러한 SPA 방식은 하나의 페이지에서 모든게 이루어지기 때문에 자바스크립트에 의한 DOM 조작이 빈번하게 발생해 브라우저의 성능을 저하시킨다.   이러한 단점을 극복하기 위해, 리액트 팀은 가상(Virtual) DOM을 만들었다. 가상 DOM의 장점은 변경된 부분만 실제 브라우저 DOM에 적용할 수 있다는 것이다. 또한, 가상 DOM은 실제 브라우저 DOM에 직접 접근하는 것이 아니라 메모리에 저장되는 객체이므로, 가상 DOM에 접근하고 수정하는 과정은 매우 빠르게 이루어진다.   리액트는 두개의 가상 DOM을 가지고 있다.         렌더링 이전 화면 구조를 나타내는 가상 DOM (Virtual DOM)   렌더링 이후 화면 구조를 나타내는 가상 DOM (New Virtual DOM)   Reconciliation: 재조정   리액트는 상태가 변경되어 리렌더링이 일어날 때 마다 실제 브라우저가 그려지기 전에 두개의 가상 DOM을 생성한다. 이후 diffing알고리즘을 통해 변화가 발생한 노드만 실제 브라우저 DOM에 적용한다.   Batch Update   10개의 노드가 변경 되었다고 가정했을 때, 하나씩 순서대로 적용되는 것이 아니라 변경 사항을 한번에 모아서 실제 DOM에 적용한다.   정리   리액트 가상 DOM은 자바스크립트 객체이기 때문에 접근하고 수정하는 속도가 빨라 실제 변경된 부분을 빠르게 파악할 수 있다. 이 변경된 부분만 한번에 모아서 실제 DOM에 적용시키기 때문에 브라우저 성능도 개선할 수 있다. 다만 UI 변경이 적고 브라우저에서 보여주는 데이터가 적을 경우에는 SPA 프레임워크없이 기존 웹 사이트 개발 방식을 선택해 개발하는 것도 좋은 방법이다.  ","categories": ["React"],
        "tags": ["브라우저","virtual dom","가상돔"],
        "url": "/react/react-react-virtual-dom/",
        "teaser": null
      },{
        "title": "[Next.js] 서버 컴포넌트에서 Redirect 구현하기 with middleware",
        "excerpt":"🚨 문제 발생   페이지 인증 로직을 구현하면서 권한이 없는 사용자를 로그인 페이지로 리다이렉트하는 기능이 필요했습니다.   클라이언트 컴포넌트에서는 useRouter를 사용하여 리다이렉트할 수 있었지만, 서버 컴포넌트에서는 useRouter를 사용할 수 없었습니다. 따라서 서버에서 인증을 처리하는 적절한 방법을 찾아야 했습니다.      시도 1 | redirect   가장 간단하게 사용할 수 있어보이는 redirect를 사용해 보았습니다.   await reissueTokenAPI(REFRESH_TOKEN).then((res) =&gt; {       if (res.accessToken) {         cookieStore.set(REFRESH_TOKEN, res.refreshToken);       } else {         redirect(Url.SignIn);       } })      문제가 없을 줄 알았지만 콘솔에서 에러가 발생했습니다.         Invoking the redirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which it was thrown. by Next.js    왜 redirect api 표에서는 severcomponet가 포함되어있는지 잘 모르겠지만 아무래도 서버 컴포넌트에서는 redirect()를 사용할 수 없는 것 같습니다.   (2025.03.07 수정)  서버 컴포넌트임에도 redirect()를 사용할 수 없었던 이유는 await을 사용하는 비동기 코드 내부에서 redirect()를 호출했기 때문입니다.  redirect() 함수는 페이지가 서버에서 렌더링되는 도중에 실행되어야합니다.   시도 2 | NextResponse.redirect in Middleware   미들웨어는 페이지 요청이 완료되기 전에 실행되므로, 페이지가 서버에서 렌더링되기 전에 필요한 로직을 처리할 수 있습니다.   그러나 미들웨어에서는 axios의 기본 설정으로 AJAX 요청을 보낼 수 없었으며, 이를 사용하려고 하면 다음과 같은 에러가 발생했습니다.   [TypeError] adapter is not a function   따라서 fetch 함수를 사용하여 API 요청을 처리하는 방식으로 해결했습니다. 저의 경우에는 미들웨어에서 사용하는 인증관련 로직을 분리했습니다.     💾 withAuth.ts  import { NextRequest, NextResponse } from 'next/server';  export async function withAuth(request: NextRequest) {   try {     const redirectUrl = request.nextUrl.clone(); // 1     redirectUrl.pathname = `${리다이렉트 경로}`      const refreshToken = request.cookies.get('refreshToken'); // 2     if (!refreshToken) return NextResponse.redirect(redirectUrl);      const url = `${refreshToken 갱신 api}`; // 3     const data = {       refreshToken: refreshToken.value,     };     const requestOptions = {       method: 'POST',       headers: {         'Content-Type': 'application/json',       },       body: JSON.stringify(data),     };      const apiResponse = await fetch(url, requestOptions);     const responseData: any = await apiResponse.json();      if (responseData.resultCode == 200) { // 4 \t\t\tconsole.log('succeed')        const response = NextResponse.next();        response.cookies?.set(         'refreshToken',         responseData.data.refreshToken       );       response.cookies?.set(         'accessToken',         responseData.data.accessToken       );        return response;     } else {       console.log('failed');        return NextResponse.redirect(redirectUrl); // 5     }   } catch (error) {     console.log('err: ' + error);   } }     객체의 참조를 공유하지 않고 안전하게 nextUrl를 사용하고자 clone 메서드를 사용해 값을 복사한다.   서버에 요청 (request)할때 브라우저 쿠키에 저장된 refreshToken을 가져온다.   서버에서 api요청을 처리해 refreshToken을 갱신한다.   refreshToken 갱신 성공시, 쿠키에 새로운 토큰을 저장해 클라이언트에 응답 (response)을 내려보낸다.   refreshToken 갱신 실패시, 설정한 경로로 리다이렉트 한다.   이전에는 서버에서 쿠키를 다루기 위해 별도의 라이브러리를 설치하거나, 각 페이지 컴포넌트에서 getServerSideProps의 request를 통해 관리해야 했습니다.   그러나 이번에 미들웨어를 사용하면서, 원하는 페이지를 요청할 때 공통된 비즈니스 로직을 처리할 수 있게 되었고, 쿠키를 다루는 과정이 번거롭지 않아 작업이 훨씬 간편해졌습니다.   또한, 서버에서 인증을 처리할 수 있기 때문에, 브라우저에서 추가적인 화면을 렌더링하지 않고 즉시 로그인 페이지로 리다이렉트할 수 있어, 사용자는 바로 로그인을 진행할 수 있습니다.   만약 리다이렉트 후 사용자에게 추가적인 메시지를 전달하고 싶다면, 응답(Response)을 커스텀하여 메시지를 포함할 수도 있습니다.   💾 middleware.ts  import { NextRequest } from 'next/server' import { isAuthenticated } from '@lib/auth'   // Limit the middleware to paths starting with `/api/` export const config = {   matcher: '/api/:function*', }   export function middleware(request: NextRequest) {   // Call our authentication function to check the request   if (!isAuthenticated(request)) {     // Respond with JSON indicating an error message     return Response.json(       { success: false, message: 'authentication failed' },       { status: 401 }     )   } }   공식 문서를 참고하며 작업을 진행하는 과정에서, 현재까지 Next.js의 기능을 절반 정도만 활용하고 있었다는 것을 깨달았습니다.   미들웨어는 단순히 리다이렉트를 처리하는 용도뿐만 아니라, 다양한 기능을 제공하고 있습니다. 이를 적극적으로 활용하여 프로젝트를 더욱 효율적으로 진행하고 싶습니다.   참고     Next.js 공식 문서 - middleware   reddit - using_axios_in_middleware_not_working  ","categories": ["Nextjs"],
        "tags": ["middleware","서버 컴포넌트"],
        "url": "/nextjs/nextjs-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-Redirect-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-with-middleware/",
        "teaser": null
      },{
        "title": "[JS] 프로미스(Promise)는 어떻게 동작할까?",
        "excerpt":"📄 Promise란?   자바스크립트를 사용한 프로젝트에서 데이터를 페칭한다면 데이터를 받아오기도 전에 마치 데이터를 받아온 것처럼 화면에 데이터가 표시되고 에러가 발생합니다.   이는 자바스크립트의 이벤트루프가 동작하여 동기적으로 코드가 실행되기 때문입니다.   필요한 데이터를 모두 받아온 후 나머지 로직이 실행되게 만들고 싶을 때, 즉 로직을 비동기로 동작하게 할 때 Promise를 사용합니다.   Promise는 자바스크립트 ES6부터 추가된 내장 객체로 비교적 최근에 생성되었습니다.   📄 promise 처리 흐름   1. 프로미스가 생성자를 통해 Pending(대기) 상태로 생성된다.   const myPromise = new Promise((resolve, reject) =&gt; {}); //pending   2. Promise의 executor(resolve, reject)함수의 인자를 통해 순서를 제어한다.   resolve()가 실행되는 경우 → 프로미스가 fulfilled(이행) 상태가 됩니다.   const myPromise = new Promise((resolve, reject) =&gt; {   // pending상태   // ... 비동기적인 상황이 되는 처리가 벌어짐.   resolve(); // fulfilled });   reject()가 실행되는 경우 → 프로미스가 rejected(거부) 상태가 됩니다.   const myPromise = new Promise((resolve, reject) =&gt; {   // pending상태   reject(); //rejected });      프로미스가 실행되는 조건에 따라 이후 실행되는 로직을 결정할 수 있습니다.      resolve()가 실행되는 경우 → fulfilled 상태가 되어 .then 콜백 함수 실행   reject()가 실행되는 경우 → rejected 상태가 되어 .catch 콜백 함수 실행   myPromise     .then((result) =&gt; {       console.log(\"성공:\", result);     })     .catch((error) =&gt; {       console.error(\"실패:\", error);     });      reject() 함수를 이용해 구체적인 에러핸들링도 가능합니다. 보통 reject 함수를 실행하여 rejected 되는 이유를 넘기는데, 표준 내장 객체인 Error의 생성자를 이용해 Error 객체를 만들 수 있습니다.   reject(new Error('bad')); catch((error) =&gt; {...});    3. 최종으로 실행되는 로직의 경우 finally를 설정해 실행한다.   프로미스 객체가 fulfilled(이행)되거나 rejected 되고 나서 가장 마지막으로 실행되어야 하는 작업이 있다면 finally 콜백함수를 설정합니다.   myPromise     .then((result) =&gt; {       console.log(\"성공:\", result);     })     .catch((error) =&gt; {       console.error(\"실패:\", error);     })     .finally(() =&gt; {       console.log(\"finally 블록 실행: 작업 종료 후 항상 실행됩니다.\");     });      📄 Callback vs Promise  콜백함수도 비동기 작업을 할 수 있습니다.   콜백 함수를 사용할 때 함수가 많아질 경우 유명한 콜백 지옥에 빠지게 되어 한눈에 봐도 불안한 모습이 됩니다.   function c(callback) {   setTimeout(() =&gt; {     callback();   }, 1000); }  c(() =&gt; {   console.log(\"1000ms 후에 callback 함수가 실행됩니다.\"); });  c(() =&gt; {   c(() =&gt; {     c(() =&gt; {       console.log(\"3000ms 후에 callback 함수가 실행됩니다\");     });   }); }); //callback hell (콜백 지옥)       이런 경우 프로미스 체이닝 (Promise Chaning)을 통해 콜백 지옥을 해결 할 수 있습니다. 콜백 함수보다 가독성이 좋습니다.  function p() {   return new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {       resolve();     }, 1000);   }); }  p()   .then(() =&gt; {     return p(); // 다시 새로운 프로미스 객체를 만들어서 리턴한다.   })   .then(() =&gt; p())   .then(p)   .then(() =&gt; {     console.log(\"4000ms 후에 fulfilled 됩니다.\");   });       📄 여러개의 Promise(프로미스) 객체를 다루는 경우   여러개의 프로미스를 다룰 때는 배열을 통해 다룰 수 있습니다.   1. Promise.all   프로미스 객체들을 배열에 저장해 순차적으로 실행하는 경우에 Promise.all을 사용합니다.   Promise.all은 모든 프로미스가 fulfilled 되었을 경우, 각 프로미스의 결과를 배열에 담아 리턴합니다.  Promise.all에 전달되는 프로미스 중 하나라도 거부되면, Promise.all이 반환하는 프로미스는 에러와 함께 바로 거부됩니다.   function fetchData(url) {     return new Promise((resolve, reject) =&gt; {       setTimeout(() =&gt; {         const data = `${url}에서 가져온 데이터`;         resolve(data);       }, Math.random() * 2000); // 랜덤한 시간 후에 데이터를 반환     });   }  // 프로미스 객체들을 배열로 저장 const promises = [   fetchData('https://example.com/data1'),   fetchData('https://example.com/data2'),   fetchData('https://example.com/data3') ];  try { \tconst results = await Promise.all(promises);   console.log(\"모든 데이터를 성공적으로 가져왔습니다:\", results); } catch (error) {   console.error(\"데이터를 가져오는 도중 오류가 발생했습니다:\", error); }       2. Promise.allSettled   Promise.all의 프로미스 객체들이 하나라도 실패했을 경우 바로 프로미스 체인을 중단한다면, Promise.allSettled 는 이행/실패 여부와 상관없이 모든 프로미스 객체를 실행합니다.  이후 각 프로미스의 결과에 대한 정보를 담은 배열을 리턴합니다. 여러개의 작업을 병렬로 실행하고 각 작업의 성공 또는 실패 여부를 알아야 할 때 유용합니다.      응답이 성공할 경우     {status:\"fulfilled\", value:result}           에러가 발생한 경우     {status:\"rejected\", reason:error}                  promise.allSettled 는 다음과 같이 활용할 수 있습니다.   let urls = [   \"https://api.github.com/users/iliakan\",   \"https://api.github.com/users/Violet-Bora-Lee\",   \"https://no-such-url\", ];  Promise.allSettled(urls.map((url) =&gt; fetch(url))).then((results) =&gt; {   results.forEach((result, num) =&gt; {     if (result.status == \"fulfilled\") {       alert(`${urls[num]}: ${result.value.status}`);     }     if (result.status == \"rejected\") {       alert(`${urls[num]}: ${result.reason}`);     }   }); });       3. Promise.race   Promise.race 는 가장 먼저 종료(fullfilled 또는 rejected)된 프로미스 객체의 결과 또는 에러를 반환합니다.   Promise.race([promise1, promise2, promise3])   .then(result =&gt; {     console.log('가장 빠른 프로미스 결과:', result);   })   .catch(error =&gt; {     console.error('가장 빠른 프로미스 에러:', error);   });      📝 정리      동기적으로 실행되는 작업을 비동기적으로 만들 때 Promise를 사용해 제어할 수 있다.        순서 뿐만 아니라 fullfilled / rejected 콜백 함수를 통해 조건 제어도 가능하다       성공시) pending → fullfilled → then → finally       실패시) pending → rejected → catch → finally       프로미스를 사용하면 콜백 지옥을 해결 할 수 있다.   여러개의 프로미스를 다루는 것도 가능하다            Promise.all ⇒ 하나의 프로미스라도 실패할 경우 프로미스 체이닝 중단       Promise.allSettled ⇒ 프로미스 개별의 성공/실패 여부와 상관없이, 모든 프로미스를 실행시키고 결과를 반환       Promise.race ⇒ 프로미스 개별의 성공/실패 여부와 상관없이, 가장 먼저 실행되는 프로미스 순으로 결과를 반환           출처      패스트캠퍼스 강의   캡틴판교  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Promise","비동기"],
        "url": "/javascript/javascript-%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4(Promise)%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[JS] JavaScript의 다양한 함수 형태",
        "excerpt":"📄 자바스크립의 함수   함수는 특정한 작업을 수행하는 과정을 표현하고, 하나의 블록으로 감싸 실행단위로 만들어 놓은 것입니다.   다음은 함수의 기본적 형태입니다. 함수의 결과 값을 나타낼 때는 return이라는 키워드를 사용합니다. return되는 순간 함수는 종료됩니다.   function sum(a, b) { \treturn a + b; };  sum(5, 10);   📄 선언방법   함수를 선언할 때는 function이라는 키워드를 사용합니다. 함수의 결과 값을 나타낼 때는 return이라는 키워드를 사용합니다. return되는 순간 함수는 종료됩니다.   💡  매개변수와 인수       공통점: 함수에 넘겨주는 값   차이점:            매개변수: 함수를 선언할 때 받는 입력값       인수: 함수를 호출할 때 받는 입력값           📄 함수를 정의하는 방법   1. 함수 선언문   함수 선언문을 사용할 때는 function이라는 키워드를 사용해 이름을 붙여서 선언합니다.  가장 기본적인 함수를 사용하는 방법입니다.   function add(a,b) { // add라는 이름의 함수에 파라미터값으로 a와 b를 받아서, a + b의 결과값을 return시키는 함수.     return a + b; }      2. 함수 표현식 (익명함수)   함수 표현식은 함수의 이름을 만들어주지 않고 특정 변수에 함수를 할당하는 방식입니다.   const hello1 = function () {   console.log(\"hello1\"); };       자바스크립트에서 함수는 일급 객체입니다. 따라서 함수를 변수에 할당하는 것이 가능합니다.   💡 [일급 객체란?]     변수에 할당할 수 있어야 합니다.   인자로 전달할 수 있어야 합니다.   다른 함수의 반환값으로 사용할 수 있어야 합니다.       2-1. 함수 선언문과 함수 표현식의 차이점   함수 선언문은 호출문이 먼저 나와있어도 문제없이 실행되지만, 함수 표현식은 호출문이 먼저 나오면 에러가 발생합니다.   hello1(); // 함수 선언문은 호출이 먼저 나와있어도 문제없이 실행. hello2(); // 함수 표현식은 호출이 먼저나오면 문제 발생 function hello1() {   //선언적 함수   console.log(\"hello1\"); }  var hello2 = function () {   console.log(\"hello2\"); };    ⬇️ 결과  TypeError: hello2 is not a function   이는 호이스팅으로 발생하는 이슈입니다.  호이스팅은 함수에 대한 선언을 실행하기 이전에 미리 메모리에 등록하는 작업입니다. 함수 선언문은 호이스팅으로 인해 실행 이전 메모리에 저장되어 코드 순서에 영향을 받지 않고 실행됩니다.  위 코드에서 hello2는 var에 할당되었는데, var는 호이스팅이 되는 시점에 undefined로 초기화되어 타입에러가 발생한 것입니다.       3. Function 생성자   Function 생성자는 new 키워드를 통해 함수를 생성합니다.  함수의 블록을 모두 문자열로 작성해야 하기 때문에 현재는 잘 사용하지 않는 방법입니다.   var myFunction = new Function('a', 'b', 'return a + b;');       4. 화살표 함수 (Arrow Function)   화살표 함수는 ES6문법에서 소개되었습니다.   const add = (a, b) =&gt; {   return a + b; };   화살표 함수의 특징은 다음과 같습니다.      contructor를 사용할 수 없다.   arguments가 존재하지 않는다.   함수 자체에 this를 바인딩하지 않고 상위 스코프의 this를 따르게 된다.       📄 다양한 함수의 형태   1. 즉시 실행 함수   즉시 실행함수는 함수를 정의할 때 바로 실행되는 함수입니다.  컴포넌트에 처음 렌더링될때 이외에 실행될 필요가 없는 함수를 useEffect대신 사용하기 좋을 것 같다는 생각이 들었습니다.   // 기본적인 즉시 실행 함수의 형태 (function () {   console.log(\"이 함수는 즉시 실행됩니다!\"); })();  // 매개변수 전달 가능한 즉시 실행 함수 (function (name) {   console.log(\"안녕하세요, \" + name + \"님!\"); })(\"John\");  // 반환값을 활용한 즉시 실행 함수 const result = (function (a, b) {   return a + b; })(3, 4);  console.log(result); // 출력: 7      2. 고차 함수   자바스크립트의 함수는 일급함수라는 특징을 통해 고차 함수로 사용할 수 있습니다.  따라서 고차함수는 함수를 인자로 받고 함수를 반환할 수 있다는 특징을 가지고 있습니다. 보통 배열 내장함수를 통해 고차 함수를 사용합니다.   const newArr = arr.map(function(item) {   return item * 2; }); // [2, 4, 6] 출력       📝 정리      함수: 특정한 작업을 수행하는 하나의 블록   정의 방법            함수 선언문                    가장 기본적인 방법                       함수 표현식                    var을 사용할 경우 호이스팅 이슈가 있다. const, let을 사용할 경우 호이스팅은 발생하지만 TDZ(Temporal Dead Zone)에 빠져 변수에 접근할 때 에러가 발생한다.                       Funtion 생성자       화살표 함수 (ES6)                    ES6에서 새로 추가된 문법           함수 자체가 아닌 상위 스코프의 this를 바인딩한다.                           다양한 함수 사용방법으로 즉시 실행함수, 고차함수가 있다.   출처      패스트캠퍼스 프론트엔드 강의   모던 리액트 Deep Dive  ","categories": ["JavaScript"],
        "tags": ["JavaScript","함수","호이스팅"],
        "url": "/javascript/js-function/",
        "teaser": null
      },{
        "title": "[Next.js] 클라이언트 컴포넌트에서 서버 컴포넌트 유지하는 방법",
        "excerpt":"📄 클라이언트 컴포넌트 내에서 서버 컴포넌트 다루기   컴포넌트를 구현할 때마다 여러 난관에 부딪힌 경험이 있습니다.   서버 컴포넌트를 작성한 후에도 이벤트 리스너를 추가하거나 훅을 적용해야 하는 경우, 결국 클라이언트 컴포넌트로 전환해야 했습니다.   여러가지 방법을 찾아보다가 클라이언트 컴포넌트 내부에서도 서버 컴포넌트를 충분히 활용할 수 있다는 점을 발견했습니다.   ◾ 서버 컴포넌트를 children으로 받아오기   단순한 방법이지만 큰 차이였습니다.  import문으로 컴포넌트를 서버 컴포넌트를 가져오면 클라이언트 컴포넌트로 자동 변환됩니다.   서버 컴포넌트를 children으로 받아오면 클라이언트 컴포넌트를 유지하면서 서버컴포넌트를 사용할 수 있습니다.   'use client'   import { useState } from 'react'   export default function ClientComponent({   children, }: {   children: React.ReactNode }) {   const [count, setCount] = useState(0)     return (     &lt;&gt;       &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;       {children}     &lt;/&gt;   ) }  import ClientComponent from './client-component' import ServerComponent from './server-component'   export default function Page() {   return (     &lt;ClientComponent&gt;       &lt;ServerComponent /&gt;     &lt;/ClientComponent&gt;   ) }   이렇게 하면 굳이 전체 컴포넌트를 클라이언트 컴포넌트로 전환할 필요 없이 서버 컴포넌트를 children으로 전달하여 활용할 수 있습니다.   참고     Next.js 공식 문서 - Server and Client Composition Patterns   Next.js + ReactQuery로 SNS 서비스 만들기 (인프런)  ","categories": ["Nextjs"],
        "tags": ["middleware","서버 컴포넌트"],
        "url": "/nextjs/nextjs-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[JS] MSW(Mock Service Worker, v 2.0) - API Mocking 하기 ",
        "excerpt":"📄 MSW란?   MSW는 Mock Service Worker의 약자로 API 모킹을 위한 자바스크립트 라이브러리 입니다.   다음과 같은 상황에서 사용할 수 있습니다.      백엔드 API가 미완성일 경우 미리 로직을 구성해야할 때   특정 에러를 발생시켜 에러 핸들링 테스트 할 때   MSW는 Service Worker API를 사용하여 브라우저에서 발생하는 네트워크 요청을 가로챕니다. 실제 서버 대신 가짜 응답을 만들어 프론트엔드 개발자가 API 테스트를 할 수 있는 환경을 만들어줍니다.   사내 프로젝트에서 API 전달이 늦어지며 프론트엔드에서 API 요청 로직을 미리 구현하고 테스트하기 위해 MSW를 도입했습니다. 미리 DTO를 전달받으면 추후 실제 API를 전달받았을 때 큰 공수없이 바로 API를 연결 할 수 있었습니다. 다만, 리액트 쿼리처럼 전역으로 설정을 해 예상치 못한 네트워크를 가로채는 상황을 피하기 위해 개발 환경에서만 사용하고 실제 릴리즈되는 브랜치에서는 사용하지 않았습니다.       📄MSW 설치 (Next.js App Router 환경 기준)   Next.js에서 MSW를 사용할 경우 클라이언트/서버 환경 모두 요구되는데, 글 작성 시점 기준 서버 사이드에서 msw과 매끄럽게 호환하는 방법이 없어 node 서버와 함께 사용합니다.    ℹ️ Notice: Next.js에서 MSW를 사용할 경우 클라이언트/서버 환경 모두 요구되는데, 글 작성 시점 기준 서버 사이드에서 msw과 매끄럽게 호환하는 방법이 없어 node 서버와 함께 사용합니다.   1. 설치하기  $ npm install msw@latest --save-dev   2. public 폴더에 초기화  $ npx msw init public/ --save     public 폴더에 설치   mockServiceWorker.js 가 자동으로 생성            http 요청을 가로채 서버와의 통신을 모방한다.           --save : package.json 에 등록되어 msw를 업데이트 할 때마다 자동으로 업데이트       📄 MSW 세팅   💾 src/mocks/browser.ts  import { setupWorker } from \"msw/browser\"; import { handlers } from \"./handlers\";  // This configures a Service Worker with the given request handlers. const worker = setupWorker(...handlers);  export default worker;     CSR 네트워크 요청용   serviceWorker가 가로챈 브라우저 요청을 전달받는다.   💾 src/mocks/http.ts  import { createMiddleware } from '@mswjs/http-middleware'; import express from 'express'; import cors from 'cors'; import { handlers } from './handlers';  const app = express(); const port = 9090; // 서버 포트  app.use(cors({ origin: 'http://localhost:3000', optionsSuccessStatus: 200, credentials: true })); app.use(express.json()); app.use(createMiddleware(...handlers)); app.listen(port, () =&gt; console.log(`Mock server is running on port: ${port}`));     SSR 네트워크 요청용 =  서버 컴포넌트에서 사용   CSR만 사용할 경우 필수는 아님   💾 src/mocks/handler.ts  import {http, HttpResponse, StrictResponse} from 'msw' import {faker} from \"@faker-js/faker\";  function generateDate() {   const lastWeek = new Date(Date.now());   lastWeek.setDate(lastWeek.getDate() - 7);   return faker.date.between({     from: lastWeek,     to: Date.now(),   }); } const User = [   {id: 'elonmusk', nickname: 'Elon Musk', image: '/yRsRRjGO.jpg'},   {id: 'zerohch0', nickname: '제로초', image: '/5Udwvqim.jpg'},   {id: 'leoturtle', nickname: '레오', image: faker.image.avatar()}, ] const Posts = [];  export const handlers = [   http.post('/api/login', () =&gt; {     console.log('로그인');     return HttpResponse.json(User[1], {       headers: {         'Set-Cookie': 'connect.sid=msw-cookie;HttpOnly;Path=/'       }     })   }),   http.post('/api/logout', () =&gt; {     console.log('로그아웃');     return new HttpResponse(null, {       headers: {         'Set-Cookie': 'connect.sid=;HttpOnly;Path=/;Max-Age=0'       }     })   }), // ... ];     API 요청과 응답 정의   쿼리 파라미터 처리하기   http.get('/test/search', async ({ request, params }) =&gt; {         const url = new URL(request.url);         const keword = url.searchParams.get('keyword');         const page = Number(url.searchParams.get('page'));         const size = Number(url.searchParams.get('size'));         const totalCount = searchParams.length;         const totalPages = Math.round(totalCount / size);           return HttpResponse.json({             result: 'SUCCESS',             resultCode: 200,             message: '성공',             contents: test.slice(page * size, (page + 1) * size),             pageNumber: page,             pageSize: size,             totalPages,             totalCount,             isLastPage: totalPages &lt;= page,             isFirstPage: page === 0,         });      })     url 객체 생성 후 searchParams을 통해 처리합니다.       📄 MSW 서버 실행   1. package.json 스크립트 추가  \"scripts\": {   \"dev\": \"next dev\",   \"build\": \"next build\",   \"start\": \"next start\",   \"lint\": \"next lint\",   \"mock\": \"npx tsx watch ./src/mocks/http.ts\" },     watch : 서버 코드가 수정되면 자동으로 재시작   2. 실행  $ npm run mock      📄 MSW 사용 분기처리   💾 src\\app_component\\MSWCoponent.tsx  \"use client\"; import { useEffect } from \"react\";  export const MSWComponent = () =&gt; {   useEffect(() =&gt; {     if (typeof window !== \"undefined\") {       if (process.env.NEXT_PUBLIC_API_MOCKING === \"enabled\") { \t\t\t worker.start({ onUnhandledRequest: \"bypass\" }); // msw 핸들러로 요청하지 않은 request는 무시. console 경고를 없앨 수 있다       }     }   }, []);    return null; };     MSW는 개발환경에서만 사용한다   💾 env.local  NEXT_PUBLIC_API_MOCKING=enabled      로컬 환경에서만 돌아가는 환경변수 파일   개발 환경에서만 읽어올 수 있는 브라우저 환경 변수를 설정하여 배포환경일때는 MSW를 사용하지 않는다.   💾 src\\app\\layout.tsx   export default function RootLayout({ children }: Props) {   return (     &lt;html lang=\"en\"&gt;       &lt;body className={inter.className}&gt;         &lt;div className={styles.container}&gt;           &lt;MSWComponent /&gt; // ✅           {children}         &lt;/div&gt;       &lt;/body&gt;     &lt;/html&gt;   ); }   출처      Next.js + ReactQuery로 SNS 서비스 만들기 (인프런)  ","categories": ["JavaScript"],
        "tags": ["MSW","Mock"],
        "url": "/javascript/javascript-MSW(Mock-Service-Worker,-v-2.0)/",
        "teaser": null
      },{
        "title": "[JS] 이벤트 루프와 비동기 통신",
        "excerpt":"📝 싱글 스레드 자바스크립트   자바스크립트는 싱글 스레드 언어다.   하나의 프로세스안에 여러개의 스레드가 있을 수 있다. 하지만 자바스크립트는 싱글 스레드 언어이므로 하나의 스레드만 존재한다.   여러개의 스레드가 있다면 메모리를 공유해 동시에 여러작업이 가능하지만 하나의 스레드만 가지고 있는 자바스크립트 엔진은 작업을 병렬로 처리할 수 없다.   자바스크립트 코드는 한줄한줄 순서대로 처리되며 하나의 작업이 끝나기전까지 다음 작업이 실행되지 않는다.   만약 하나의 작업이 너무 오래걸리면 뒤에 있는 작업이 실행되지 않는데, 이는 Run-to-Completion이라고 불리는 자바스크립트의 특징이다.      프로세스            메모리를 사용하는 독립적인 실행 단위       다른 프로세스와 자원을 공유하지 않는다.           스레드            하나의 프로세스 안에 존재하는 작은 실행 단위       스레드끼리 자원을 공유할 수 있다.       하나의 프로세스가 병렬로 작업을 처리할 수 있게 한다.               ◆ 메모리 힙과 콜 스택  | 자바스크립트가 작업을 수행하는 방법   ■ 메모리 힙 (Memory Heap)     선언된 변수들의 메모리 할당이 이루어진다.   비구조적으로 데이터가 저장된다.   ■ 콜 스택 (Call Stack)     함수들이 실행 순서에 따라 쌓인다.   LIFO(선입후출)의 구조로 진행된다.          📝 이벤트 루프 | 자바스크립트가 비동기 통신을 하는 방법   function bar(){     console.log('bar') }  function baz(){     console.log('baz') }  function foo(){     console.log('foo')     setTimeout(bar(), 0)     baz() }  foo()      출력 순서: foo → baz → bar   bar의 실행을 기다리지 않고 다음줄인 baz가 실행된 이유는 setTimeout 함수는 바로 콜스택에 들어가는 것이아니라 태스크큐에 들어가기 때문이다.     태스크큐에 저장되는 작업들: setTimeout, setInterval, setImmediate       ◆ 브라우저 이벤트 동작 순서        콜스택 실행   콜스택이 비어있으면 마이크로 태스크 큐 확인. 큐가 빌 때까지 모든 마이크로 태스크 실행            프로미스의 then이나 catch, MutationObserver 등           태스크 큐 확인. 큐가 빌 때까지 모든 태스크 실행            setTimeout, setInterval, I/O 작업, DOM 이벤트 등           Request Animation Frame에서 대기중인 콜백 실행            Request Animation Frame: 애니메이션을 효율적으로 실행하기 위해 제공하는 함수로 브라우저가 다음 리페인트(Repaint) 전에 지정된 콜백 함수를 실행하도록 예약           모든 작업이 완료되면 브라우저는 렌더링을 수행해 화면을 업데이트한다.       ◆ 함수가 마이크로 태스크 큐에 저장될 경우      콜 스택에서 프로미스를 만들고 프로미스에 등록된 콜백, 즉 프로미스가 다 수행이 되고나면 실행되는 then과 mutation observer라는 웹 API에 등록된 콜백이 마이크로 큐에 들어온다.   이벤트루프는 마이크로 태스크 큐에 있는 프로미스 then 콜백을 비어있는 콜스택으로 가져간다.   프로미스 then이 끝나면 mutation obsever를 콜 스택으로 가져간다.   ⭐️ 포인트 1 이 과정에서 마이크로 태스크 큐에 새로운 함수가 들어온다면, 나중에 들어온 함수도 모두 끝날때까지 계속 콜스택으로 가지고 와서 수행한다.   ⭐️ 포인트 2 마이크로 태스크 큐가 텅텅비면 테스크 큐로 넘어간다.(태스크 큐와의 차이점: 태스크 큐에서는 아이템 하나만 콜스택으로 보내고 기다린다.)   function handleClick() {   console.log(\"handleClick\");   Promise.resolve(0) // promise 의 콜백은 Microtask que를 이용한다.     .then(() =&gt; {       console.log(\"then\");       handleClick();     }); }  const button = document.querySelector(\"button\"); button.addEventListener(\"click\", () =&gt; {   handleClick(); });   이벤트루프는 마이크로태스크 큐에 등록된 콜백이 모두 빌때까지 기다리기때문에 이벤트루프가 멈춰 브라우저가 반응하지 않는다.       ◆ 함수가 태스크 큐에 저장될 경우      브라우저에서 지정된 이벤트가 발생한다.   웹 API는 콜백함수를 태스크 큐에 넣어준다.   이벤트 루프는 계속 관찰을 하다가 콜 스택에 할일이 남아 있으면 콜스택이 비워질 떄까지 기다린다.   콜스택이 비어서 자바스크립트 엔진이 더이상 일을 하지 않을 때 태스크 큐에 있는 함수를 콜 스택으로 가져온다.   자바스크립트 엔진이 콜 스택에 들어온 콜백함수를 실행한다.   ⭐️ 포인트 1 이벤트 루프는 콜스택에 있는 함수를 하나씩만 가져온다.   function handleClick() {   console.log(\"handleClick\");   setTimeout(() =&gt; {     console.log(\"setTimeout\");     handleClick(); // 콜스택에 무한으로 추가되어 동일한 내용의 이벤트루프가 반복된다.   }, 0); }  const button = document.querySelector(\"button\"); button.addEventListener(\"click\", () =&gt; {   handleClick(); });  콜백함수 내에서 다시 콜백함수를 호출하기 때문에 Task Queue에 무한으로 함수가 추가된다.       ◆ 함수가 Request Animation Frame Queue에 저장될 경우   브라우저를 다시 업데이트 할 때는 render안의 request Animation Frame 에 등록된 콜백들을 거친 후 렌더 트리를 만들고 그 트리를 이용해서 레이아웃을 계산한 뒤에 페인트를 통해서 브라우저에 업데이트를 한 다음에 이벤트루프가 재개된다.   const button = document.querySelector(\"button\");  button.addEventListener(\"click\", () =&gt; {   requestAnimationFrame(() =&gt; {     // 렌더링이 되기 전 브라우저가 콜백함수를 실행하는 것을 보장해준다.     document.body.style.backgroundColor = \"beige\";   });   requestAnimationFrame(() =&gt; {     document.body.style.backgroundColor = \"orange\";   });   requestAnimationFrame(() =&gt; {     document.body.style.backgroundColor = \"red\";   }); });   큐는 FIFO의 구조를 가지고 있기 때문에 마지막에 들어온 코드가 가장 먼저 적용되기 때문에 최종적으로 빨간색이 적용된 상태에서 렌더트리가 만들어지고 브라우저에 표기가 완료된다.   출처      드림코딩   모던 리액트 딥다이브   모던 자바스크립트 딥다이브  ","categories": ["JavaScript"],
        "tags": ["비동기","이벤트루프"],
        "url": "/javascript/javascript-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%86%B5%EC%8B%A0/",
        "teaser": null
      },{
        "title": "[JS] CJS와 ESM | 자바스크립트의 모듈화",
        "excerpt":"📝 자바스크립트의 모듈화   모듈화는 코드를 작은 조각 또는 파일로 나누어 관리하는 방법입니다.   초기 자바스크립트는 하나의 자바스크립트 파일에 모든 기능을 담아야 했습니다. 이로인해 가독성이 떨어지고 복잡성이 증가되는 등 문제가 발생하였습니다.   자바스크립트의 역할이 커지며 모듈화의 필요성이 증가했고 CJS, ESM 등의 방법이 등장했습니다.   📝 CJS와 ESM | 자바스크립트를 모듈화 하는 방식   ■ CJS (CommonJS) 방식      require과 module.exports를 사용   Node.js 환경에서 사용 (오직 서버사이드에서만 활용)   동기적으로 로드            모듈이 완전히 로드되어 실행될 때까지 코드 차단       실행전 모든 종속성이 로드되었는지 확인하고싶은 서버 측 애플리케이션에 적합           확장자: .cjs   // moduleA.js const message = \"Hello, from Module A!\"; module.exports = message;  // moduleB.js const messageA = require(\"./moduleA\");       ■ ESM (ECMAScript Modules) 방식      import와 export를 사용   Node.js 환경에서 사용하며 최신 브라우저에서도 사용 가능 (서버사이드와 브라우저 환경 모두 활용)   동기적으로 로드 되나 비동기 가능            ESM은 Top-level await를 지원하기 때문에 가능           three shaking 가능            정적 분석을 통해 빌드 단계에서(= 번들링된 코드에서) 사용하지 않는 코드를 제거       웹페이지 로딩속도를 개선할 수 있어 프론트엔드 개발에 적합           확장자: .mjs   // moduleA.mjs const message = \"Hello, from Module A!\"; export default message;  // moduleB.mjs import messageA from \"./moduleA\";  ■ CJS와 ESM 비교                          CJS       ESM                       문법       require, export.module       import, export                 적합도       서버측 개발에 적합       모던 웹 애플리케이션 개발에 적합                 동적 가져오기       가능하나 일반적이지 않음       o                 비동기       x       o                 정적 분석       x       o                 three shaking       x       o                 브라우저 지원       x       o               출처     .js, .cjs and .mjs defference   https://tech.kakao.com/posts/605  ","categories": ["JavaScript"],
        "tags": ["JavaScript","CJS","ESM"],
        "url": "/javascript/js-function/",
        "teaser": null
      },{
        "title": "[Next.js 13] 클라이언트 컴포넌트가 정말 클라이언트 사이드에서만 렌더링 될까 ?",
        "excerpt":"◾️문제 발생   react-draft-wysiwyg 를 사용한 컴포넌트를 페이지 컴포넌트에 import했습니다. 페이지는 성공적으로 렌더링 되었지만 터미널에서 에러를 확인할 수 있었습니다. 빌드시에도 동일한 에러가 발생합니다.      use client를 최상단에 선언했었기에, 클리이언트 컴포넌라고 생각했고 서버 컴포넌트에서 날 법한 프리렌더링 에러가 발생하는 것이 이해가 가지 않았습니다.   ◾️ 문제 원인   문제가 발생한 이유는 다음과 같습니다.      Next.js 13 컴포넌트는 서버에서 사전 렌더링되고 클라이언트에서 하이드레이션된다.   따라서 use client 를 선언한다고해서 클라이언트에서만 렌더링 되는 것은 아니다.   컴포넌트에서 window객체에 접근하는데, 서버에서 사전 렌더링되는 과정에서 window객체를 찾지 못해 에러가 발생한 것이었습니다. 클라이언트 단에서만 실행되어야하는 코드는 서버에서 실행되지 않도록 설정이 필요합니다.   ◾️ 문제 해결   ✔️ 방법 1. dynamic import (동적 임포트)로 SSR 옵션 끄기   const NoticeForm = dynamic(() =&gt; import('@/components/notice/NoticeForm'), {   ssr: false, });   Next.js 의 dynamic import 기능을 활용해 서버 측 렌더링을 비활성화했습니다. dynamic import는 컴포넌트 외부에서 선언해야합니다.   다만 이 방법은 해당 에러가 발생하는 모든 컴포넌트를 동적으로 import해야하는 번거로움이 있었고, 에러 원인을 찾던 중 전역으로 설정해주는 방법이 있었습니다.   ✔️ 방법 2. 컨텍스트를 사용한 custom hook 만들기   동적 임포트 매커니즘을 컴포넌트마다 반복적으로 구현하는 대신, 컨텍스트를 사용해 전역에서 관리하는 방법도 있습니다.   useEffect와 useState 훅을 사용한 커스텀 훅을 통해 클라이언트 환경을 실행조건으로 설정할 수 있었습니다.   이렇게하면 서버에서의 사전렌더링과 클라이언트의 첫번째 렌더링이 일치해 하이드레이션 오류도 방지할 수 있습니다.   💾 useIsClient.tsx  'use client';  import { createContext, useContext, useEffect, useState } from 'react';  const IsClientCtx = createContext(false);  export const IsClientCtxProvider = ({   children, }: {   children: React.ReactNode; }) =&gt; {   const [isClient, setIsClient] = useState(false);   useEffect(() =&gt; setIsClient(true), []);   return (     &lt;IsClientCtx.Provider value={isClient}&gt;{children}&lt;/IsClientCtx.Provider&gt;   ); };  export function useIsClient() {   return useContext(IsClientCtx); }   💾 app/layout.tsx  import type { Metadata } from 'next'; import './globals.css'; import { IsClientCtxProvider } from '@/hooks/useIsClient';  export const metadata: Metadata = {   title: 'Project',   description: 'Generated by create next app', };   export default function RootLayout({   children, }: Readonly&lt;{   children: React.ReactNode; }&gt;) {   return (     &lt;html lang=\"en\"&gt;       &lt;body&gt;         &lt;IsClientCtxProvider&gt; \t\t\t\t\t{children}         &lt;/IsClientCtxProvider&gt;       &lt;/body&gt;     &lt;/html&gt;   ); }   💾 사용예시  import { useIsClient } from './is-client-ctx';  function MyComponent() {   const isClient = useIsClient();   const scrollPosition = useScrollPosition(); // 예시를 위한 가상 훅    return (     &lt;&gt;       {scrollPosition &gt;= 0 &amp;&amp; &lt;FirstModule /&gt;}       {isClient &amp;&amp; scrollPosition &gt;= window.innerHeight * 2 &amp;&amp; &lt;SecondModule /&gt;}     &lt;/&gt;   ); }    useIsClient.tsx 훅을 통해 서버에서 렌더링할 수 있는 부분을 먼저 렌더링 후, 클라이언트 조건에 따라 업데이트 (두번째 렌더링)을 실행합니다. 이 방식을 통해 하이드레이션 오류를 피하면서 필요한 경우 클라이언트 측 업데이트를 수행할 수 있었습니다.   참고     stackoverflow - next-js-13-window-is-not-defined  ","categories": ["Nextjs"],
        "tags": ["prerendering","서버 컴포넌트","use client","에러"],
        "url": "/nextjs/nextjs-Error-occured-prerendering-page/",
        "teaser": null
      },{
        "title": "[Next.js 14] npm 패키지 배포 가이드",
        "excerpt":"■ 목적     어드민 디자인 시스템 컴포넌트와 에셋을 패키지로 배포해 관리   아토믹 디자인 패턴을 사용해 컴포넌트를 체계적으로 설계 및 개발   컴포넌트 유지보수성을 높이고, 일관된 UI/UX를 제공하며, 개발 속도를 향상   ■ 프로젝트 환경     next.js 14   react 18   tailwindcss 3.4.1   ■ 배포 순서   1. src/export.ts 를 생성합니다   패키지로 배포할 컴포넌트를 export.ts 파일에 선언합니다. (파일 경로와 이름은 변경가능합니다)   💾 src/export.ts  export {default as SujinButton} from './app/components/common/Button';   2. tsconfig.build.json 을 생성합니다.      (기존) tsconfig.json: Next.js 어플리케이션 코드 빌드용   (생성) tsconfig.build.json: 패키지 배포 코드 빌드용   💾 tsconfig.build.json   {   \"compilerOptions\": {     \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"], // 프로젝트에서 사용할 JavaScript 표준 라이브러리     \"target\": \"ESNext\",  // 컴파일 대상 ECMAScript 버전     \"allowJs\": true, // JavaScript 파일을 TypeScript 코드로 포함할 수 있도록 허용     \"skipLibCheck\": true, // 외부 라이브러리 타입 검사 건너뛰기     \"strict\": true,  // 엄격 모드 활성화     \"noEmit\": false, // 컴파일된 출력 파일 생성 여부     \"allowSyntheticDefaultImports\": true, // 기본(default) 내보내기를 허용할지 여부     \"esModuleInterop\": true, // CommonJS(require)와 ES Module(import) 간의 호환성 설정     \"forceConsistentCasingInFileNames\": true, // 파일 이름 대소문자 불일치를 방지     \"noFallthroughCasesInSwitch\": true, // switch 문에서 case가 누락되지 않도록 방지     \"module\": \"esnext\", // 사용할 모듈 시스템     \"moduleResolution\": \"node\", // 모듈 해석 방식을 정의     \"resolveJsonModule\": true, // JSON 파일을 모듈로 가져오기 허용     \"isolatedModules\": true, // 개별 파일을 독립적으로 컴파일     \"jsx\": \"react-jsx\", // React JSX 구문 설정 - React 17+의 새로운 JSX 변환 방식 사용     \"incremental\": true, // TypeScript 이전 빌드 결과를 재사용하여 빌드 속도 향상(증분 빌드)     \"outDir\": \"dist\", // 컴파일된 파일의 출력 디렉토리     \"declaration\": true, // 타입 정의 파일 생성 여부 (.d.ts)     \"plugins\": [       {         \"name\": \"next\"       }     ],     \"paths\": {       \"@/*\": [\"./src/*\"]     }   },   \"include\": [ \"**/tailwind.config.ts\",  \"src/export.ts\"],   \"exclude\": [\"node_modules\"] }      include            **/tailwind.config.ts : tailwind 설정 (asset, font) 공유       src/export.ts : 컴포넌트 공유           3. package.json을 수정합니다.   💾 package.json  {   \"name\": \"sujin-design-system\",   \"version\": \"0.1.5\", // 패키지를 새로 배포할 때마다 버전을 업그레이드 해야합니다.   \"main\": \"dist/src/export.js\",    \"types\": \"dist/src/export.d.ts\",   \"files\": [     \"dist\"   ],   \"scripts\": {     \"dev\": \"next dev\",     \"next:build\": \"next build\",     \"start\": \"next start\",     \"lint\": \"next lint\",     \"build\": \"rm -rf dist &amp;&amp; tsc -p tsconfig.build.json\",     \"prepublishOnly\": \"npm run build\"   },   \"dependencies\": {     \"react\": \"^18\",     \"react-dom\": \"^18\",     \"next\": \"14.2.18\"   },   \"devDependencies\": {     \"typescript\": \"^5\",     \"@types/node\": \"^20\",     \"@types/react\": \"^18\",     \"@types/react-dom\": \"^18\",     \"postcss\": \"^8\",     \"tailwindcss\": \"^3.4.1\",     \"eslint\": \"^8\",     \"eslint-config-next\": \"14.2.18\"   } }     main: 패키지를 설치한 후 패키지를 사용할 때 진입점. 가장 먼저 로드되는 파일을 지정.   types : 타입스크립트 타입 정의 파일   package.json을 수정하고 npm run build 스크립트를 실행하면 dist폴더가 생성됩니다.      4. npm에 패키지 배포하기      npm login : 스크립트를 실행하고 브라우저에서 로그인합니다.   npm build : 패키지에 필요한 빌드파일을 생성합니다.   npm publish : 생성한 빌드 파일을 npm에 배포합니다.   배포에 성공하면 npm에서 배포한 패키지를 확인 할 수 있습니다.      5. 배포한 패키지 사용하기   먼저 배포한 패키지를 사용할 프로젝트에서 패키지를 다운받습니다.  npm i sujin-design-system   tailwind.config.ts 파일에서 패키지를 presets에 적용합니다.   💾 tailwind.config.ts   import sujin from 'sujin-design-system/dist/tailwind.config';  module.exports = {   presets: [sujin], // ✅ preset으로 패키지의 tailwind 설정 적용   content: ['./src/**/*.{js,jsx,ts,tsx}'],    설정을 완료하면 패키지의 에셋과 컴포넌트를 사용할 수 있습니다.   import { SujinButton } from 'sujin-design-system'; // 👍  참고     blacksheepcode - publish_a_react_package_using_nextjs_as_a_base  ","categories": ["Nextjs"],
        "tags": ["npm","배포"],
        "url": "/nextjs/nextjs-npm-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%B0%B0%ED%8F%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/",
        "teaser": null
      },{
        "title": "[NestJS] NestJS가 env 파일을 읽어오지 못했을 때",
        "excerpt":"🪹 문제상황: 프로젝트가 env 파일에 접근을 하지 못한다.   🐞 error message   ERROR [ExceptionHandler] Error: Config validation error: \"EMAIL_SERVICE\" is required. \"EMAIL_AUTH_USER\" is required. \"EMAIL_AUTH_PASSWORD\" is required. \"EMAIL_BASE_URL\" is required      💾 app.module.ts  @Module({   imports: [     UsersModule,     EmailModule,     ConfigModule.forRoot({       envFilePath: [`${__dirname}/config/env/.${process.env.NODE_ENV}.env`],        load: [emailConfig],       isGlobal: true, // 전역모듈로 설정       validationSchema, // joi를 이용해 유효성검사     }),     TypeOrmModule.forRoot({       type: 'mysql',       host: process.env.DATABASE_HOST,       port: 3306,       username: process.env.DATABASE_USERNAME,       password: process.env.DATABASE_PASSWORD,       database: 'test',       entities: [__dirname + '/**/*.entity{.ts,.js}'], // TypeORM이 구동될 때 인식하도록 할 엔티티 클래스 경로       synchronize: process.env.DATABASE_SYNCHRONIZE === 'true', // dev | 서비스가 실행될 때 DB가 초기화된다.     }),   ],   controllers: [],   providers: [], }) export class AppModule {}   nest-auth 프로젝트 실행 도중 프로젝트가 env파일을 읽어오지 못했습니다.   cat src/config/env/.development.env ⇒ 성공   echo $NODE_ENV ⇒ 성공 (development)   터미널을 통해 env파일을 읽는 것은 성공했지만 ConfigModule에서 env파일에 접근을 하지 못해 경로문제일 것이라 판단했습니다.       🪹 문제 이유: .env 파일 경로 문제  envFilePath: [`${__dirname}/config/env/.${process.env.NODE_ENV}.env`]  ts-node를 사용할 경우 __dirname은 각각 다음과 같은 위치를 가리킵니다.      빌드 전: src 폴더   빌드 후: dist 폴더   빌드 후 src폴더일 것이라는 예상과 달리  __dirname가 dist 폴더를 가리키게 되어 env파일을 찾지 못하고 에러가 발생한 것입니다.       🪺 문제 해결: envFilePath 경로 재설정  envFilePath 경로를 재설정해 현재 작업 디렉토리(process.cwd())를 기준으로 경로를 지정하겠습니다.   envFilePath: [path.resolve(process.cwd(), `src/config/env/.${process.env.NODE_ENV}.env`)]   문제없이 프로젝트가 실행되었습니다.     ","categories": ["NestJS"],
        "tags": ["NestJS","env","error"],
        "url": "/nestjs/nestjs-NestJS%EA%B0%80-env-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%9D%BD%EC%96%B4%EC%98%A4%EC%A7%80-%EB%AA%BB%ED%96%88%EC%9D%84-%EB%95%8C/",
        "teaser": null
      },{
        "title": "[NestJS] NestJS로 배우는 백엔드 프로그래밍 완독 후기",
        "excerpt":"   ◾️ 책을 완독하고 나서  📒노션 스터디 노트   🐱 실습 프로젝트 Github   😀 추천 대상     공식문서읽는게 힘들다.   Nestjs의 기본 핵심개념을 한권으로 정리하고 싶다.   Typescript 문법에 익숙하다.   🤨 비추천 대상     개발이 아예 처음이다.   Typescript를 전혀 모른다.   Nestjs의 심화 개념을 공부하고 싶다.   NestJS는 먼저 공식문서로 접했습니다.  공식문서가 워낙 잘되어있는터라 기본개념을 쌓기에는 문제가 없지만 한글로 정리된 문서로 개념을 읽고싶어 책을 찾아보게 되었습니다.  책의 구조는 개념 -&gt; 프로젝트 적용 -&gt; 심화 개념 순서로 이루어져 있습니다.  가장 좋았던 점은 책을 완독하면 유저 (인증) 프로젝트를 완성할 수 있어 성취감을 느낄 수 있다는 것이었습니다.  다만 타입스크립트를 다루는 책이 아니기에 어느정도 개발경험이 있어야 속도감있게 책을 읽을 수 있어 개발 입문자에게는 다소 버거울 수 있을 것 같습니다.  ","categories": ["NestJS"],
        "tags": ["NestJS","공부"],
        "url": "/nestjs/nestjs-NestJS%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%B0%B1%EC%97%94%EB%93%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8A%A4%ED%84%B0%EB%94%94-%EB%85%B8%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[네트워크] RefreshToken을 왜 쿠키에 저장해야할까?",
        "excerpt":"🍪 accessToken은 메모리에, refreshToken은 쿠키에 저장하게 된 이유  여러 프로젝트를 진행하면서 항상 JWT 토큰을 다뤄왔습니다. 그 과정에서 토큰 관리 방법이 궁금해 여러 자료를 찾아봤고, 가장 많이 추천되는 방식은 다음과 같았습니다.   ✅ Access Token → 프론트엔드의 메모리에 저장  ✅ Refresh Token → 백엔드 서버에서 HttpOnly 쿠키로 관리   이번 Rebook 프로젝트에서는 프론트엔드와 백엔드 개발을 모두 맡고 있기 때문에, 그동안 궁금했던 이 토큰 관리 방식을 직접 실험해볼 좋은 기회가 되었습니다.   🍪 리프레시 토큰을 왜 쿠키에 저장해야할까?   리프레시 토큰을 쿠키에 저장한다는 것은 정확히 HttpOnly Secure 쿠키에 저장한다는 뜻입니다.   const setCookieOptions = {   httpOnly: true, // ✅ JavaScript에서 접근 불가능 → XSS 방어   secure: process.env.NODE_ENV === 'production', // ✅ HTTPS에서만 전송   sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax', // ✅ CORS와 일치해야 함   maxAge: 7 * 24 * 60 * 60 * 1000, // ✅ 7일 (밀리초)   path: '/', };       1. XSS 공격 방어   ◾️ XSS(Cross-Site Scripting-크로스 사이트 스크립팅)란 ?     공격자가 웹사이트에 악성 자바스크립트 코드를 삽입   자바스크립트 코드를 통해 사용자의 쿠키나 개인정보를 탈취하거나 악성 스크립트 실행   자바스크립트에서 쿠키에 접근하려면 보통 아래와 같은 코드를 실행합니다.   document.cookie;    httpOnly 설정은 자바스크립트 코드가 쿠키에 접근하는 것을 방지합니다.   리프레시 토큰은 사용기간도 길고, 계속해서 엑세스 토큰을 발급할 수 있습니다. 따라서 보안 중요성을 높게 가져가기 위해 쿠키에 저장하는 방식을 많이 사용합니다.       2. CSRF 공격 방어  ◾️CSRF(Cross-Site Request Forgery) 란?     공격자가 사용자의 세션을 이용해 악의적인 요청을 자동으로 보내는 공격   공격자가 사용자의 세션을 탈취해 임의의 기기에서 원치않은 요청(구매, 비밀번호 변경 등)을 수행할 수 있다.   이러한 경우는 직접 리프레시토큰을 보지 않고도 악의적 요청을 보내는 공격 방식입니다.   CSRF 공격 시나리오는 다음과 같습니다.      피해자가 중고책 거래 사이트 Rebook에 로그인한다.   브라우저는 리프레시토큰을 HttpOnly Secure 쿠키로 저장한다.   피해자는 공격자가 만든 악성 사이트에 방문한다.   악성사이트가 백그라운드에서 Rebook 서버로 강제 요청 🧨을 보낸다.   피해자의 브라우저는 자동으로 로그인된 세션 (쿠키 포함)과 함께 요청을 보낸다.   결과적으로 사용자의 의도와 관련없는 요청 (구매, 비밀번호 변경 등)을 보낸다.   위 시나리오에서 공격자는 직접 리프레시토큰을 탈취하지 않았지만, 피해자의 세션을 악용합니다.   이러한 경우를 막으려면, 다른 사이트에서 요청할 때 쿠키를 자동으로 전송하지 않도록 해야합니다.   res.cookie('refreshToken', refreshToken, {   httpOnly: true,    secure: process.env.NODE_ENV === 'production',    sameSite: 'strict', // ✅ CSRF 공격 방어 (다른 사이트에서 자동 요청 차단)   maxAge: 7 * 24 * 60 * 60 * 1000,    path: '/', });       3. 프론트엔드의 개발적인 편리함 - 쿠키 저장, 삭제에 관여하지 않는다.   로컬스토리지나 세션스토리지의 경우에는, 프론트엔드가 직접 정보를 저장하고 삭제하는 코드가 필요합니다.   localStorage.setItem('refreshToken', response.refreshToken);   쿠키에 저장된 값을 관리하는 주체는 백엔드입니다.  백엔드 서버에서 쿠키에 리프레시토큰을 설정하면, 프론트엔드 개발자가 리프레시 토큰을 저장하는 코드를 직접 작성할 필요가 없습니다.   const apiClient = axios.create({   baseURL: 'http://localhost:3000',   withCredentials: true, // ✅ 쿠키 자동 포함 });   withCredentials을 true로 설정하면, Authorization 헤더를 수동으로 설정할 필요없이 자동으로 쿠키가 포함됩니다.   하지만 HttpOnly 쿠키는 자바스크립트에서 접근할 수 없기 때문에, 프론트엔드에서 로그인 상태를 직접 확인할 수 없어 추가적인 상태관리가 필요합니다.   특히 엑세스토큰을 메모리에 저장하는 방식은 새로고침시 토큰이 유실되는 문제가 발생합니다. 로그인 상태를 유지하려면 LoggedIn 상태를 로컬스토리지에 저장해서 관리해야합니다.       🍪️느낀점  리프레시토큰을 쿠키로 관리하면서, 보안적으로 고려해야 할 다양한 이슈를 공부할 수 있었습니다. 이전에는 쿠키를 이론으로만 공부하여 이해가 되지 않았던 부분들이, 백엔드 서버에서 직접 쿠키를 설정하고 관리하면서 더욱 명확해졌습니다.     이 방법은 편리함보다는 보안성을 우선하는 방식이라고 생각합니다. 프론트엔드과 백엔드 모두 추가적인 작업이 필요했으며, 특히 NextJS에서 엑세스토큰을 전역 상태(Zustand)로 관리하며 로그인 상태 유지가 중요한 과제가 되었습니다.     구현과정이 다소 복잡해졌지만, 프로젝트가 추구하는 우선 방향이 보안성 강화라면 저는 이 방법을 앞으로도 사용할 예정입니다.   ","categories": ["network"],
        "tags": ["쿠키","HTTP","accessToken","refreshToken","JWT","NextJS","NestJS"],
        "url": "/network/network-RefreshToken%EC%9D%84-%EC%99%9C-%EC%BF%A0%ED%82%A4%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[NestJS] NestJS에서 Socket.IO 연결 시 404 에러가 발생하는 이유",
        "excerpt":"◾️문제 상황   rebook 프로젝트에서 NestJS + Socket.IO로 실시간 채팅을 구현하려던 도중,  클라이언트에서 WebSocket 연결이 안되고 다음과 같은 에러가 발생했습니다.   GET {SERVER_URL}/socket.io/?EIO=4&amp;transport=polling 404 (Not Found)    WebSocket 연결 전 polling 요청이 404로 실패하면서 웹소켓 연결 자체가 이루어지지 않았습니다.   ◾ 문제 원인   404에러 이길래 처음에는 네임스페이스 및 경로 설정 문제인 줄 알았습니다.   Socket.IO는 내부적으로 HTTP 핸드셰이크를 위해 /socket.io 경로에 polling 요청을 먼저 보냅니다.   하지만 NestJS는 기본적으로 이 경로를 인식하지 않으며 IoAdapter을 통해 Socket.IO를 Express 서버에 붙여줘야 정상적으로 작동합니다.   💾 ws.adapter.ts    export class SocketIoAdapter extends IoAdapter {   constructor(     private readonly app: INestApplication, // NestApplication 객체     private readonly config: ConfigService, // ConfigService   ) {     super(); // ⚠️ HTTP 서버 인스턴스를 super에 전달하지 않았음   }    createIOServer(portOrServer: any, options?: ServerOptions) {     const serverArg =       typeof portOrServer === 'number' ? undefined : portOrServer;      const partialOpts: Partial&lt;ServerOptions&gt; = {       cors: {         origin: this.config.get('CLIENT_URL') || 'http://localhost:3000',         credentials: true,       },     };      return serverArg       ? super.createIOServer(serverArg, partialOpts as ServerOptions)       : super.createIOServer(portOrServer, partialOpts as ServerOptions);   } }      문제: SocketIoAdapter에서 super()만 호출하고 httpServer를 넘기지 않음   결과: /socket.io 핸들러가 Express에 등록되지 않아 polling 요청시 404에러가 발생함       ◾️ 해결 방법   1. 어댑터에 httpServer 전달    export class SocketIoAdapter extends IoAdapter {   constructor(     private readonly app: INestApplication, // NestApplication 객체     private readonly config: ConfigService, // ConfigService   ) {     super(app.getHttpServer()); // ✅️ HTTP 서버 인스턴스를 super에 전달   }    createIOServer(portOrServer: any, options?: ServerOptions) {     const serverArg =       typeof portOrServer === 'number' ? undefined : portOrServer;      const partialOpts: Partial&lt;ServerOptions&gt; = {       cors: {         origin: this.config.get('CLIENT_URL') || 'http://localhost:3000',         credentials: true,       },     };      return serverArg       ? super.createIOServer(serverArg, partialOpts as ServerOptions)       : super.createIOServer(portOrServer, partialOpts as ServerOptions);   } }    2. main.ts에 어댑터 등록   async function bootstrap() {   const app = await NestFactory.create(AppModule);   const config = app.get(ConfigService);    app.enableCors({     origin: config.get('CLIENT_URL'),     credentials: true,   });    app.useWebSocketAdapter(new SocketIoAdapter(app, configService));    await app.listen(4000); }   httpServer을 제대로 전달해주고나자 polling -&gt; WebSocket 순으로 요청이 성공했습니다.       📖️ polling -&gt; WebSocket 핸드 셰이크 구조   ↔️ polling -&gt; WebSocket 핸드 셰이크란 ?     Socket.IO 연결 구조의 핵심 개념   WebSocket 연결전 서버와 먼저 HTTP로 연결하고, 그 다음 Websocket으로 업그레이드 하는 과정   📌 Socket.IO의 연결 과정     클라이언트가 먼저 polling 방식으로 서버에 연결 시도   서버가 응답하고, 클라이언트와 서버가 서로 연결 확인   연결이 확인되면, HTTP연결을 Websocket으로 업그레이드   📌 Socket.IO가 핸드셰이크를 사용하는 이유     Websocket을 지원하지 않는 네트워크/브라우저 환경이 아직 존재   최초연결은 HTTP로 시작해서 WebSocket 연결 가능성을 판단   ◾️전체 코드  ☑️ 서버측 코드 (NestJS)   💾 chat.gateway.ts  @WebSocketGateway({   cors: {     origin: '{CLIENT_URL}',     methods: ['GET', 'POST'],     allowedHeaders: ['Content-Type', 'Authorization'],     credentials: true,   },   credentials: true, })      💾 ws.adapter.ts  import { IoAdapter } from '@nestjs/platform-socket.io'; import { INestApplication, Injectable } from '@nestjs/common'; import { ServerOptions } from 'socket.io'; import { ConfigService } from '@nestjs/config';  // ws 연결 프론트 서버 주소를 동적으로 연결해준다.(dev/prod 구분) @Injectable() export class SocketIoAdapter extends IoAdapter {   constructor(     private readonly app: INestApplication, // NestApplication 객체     private readonly config: ConfigService, // ConfigService   ) {     super(app.getHttpServer()); // ⚠️ HTTP 서버 인스턴스를 super에 전달   }    createIOServer(portOrServer: any, options?: ServerOptions) {     const serverArg =       typeof portOrServer === 'number' ? undefined : portOrServer;      const partialOpts: Partial&lt;ServerOptions&gt; = {       cors: {         origin: this.config.get('CLIENT_URL') || 'http://localhost:3000',         credentials: true,       },     };      return serverArg       ? super.createIOServer(serverArg, partialOpts as ServerOptions)       : super.createIOServer(portOrServer, partialOpts as ServerOptions);   } }       💾 main.ts  async function bootstrap() {   const app = await NestFactory.create(AppModule);   const config = app.get(ConfigService);    app.enableCors({     origin: config.get('CLIENT_URL'),     credentials: true,   });    app.useWebSocketAdapter(new SocketIoAdapter(app, config));    await app.listen(4000); }      ☑️ 클라이언트측 코드 (NextJS)   💾 useChat.ts   import { useEffect, useRef } from 'react'; import { io, Socket } from 'socket.io-client'; import { ChatMessage } from '@/types/chat'; import { getChatMessages } from '@/lib/api/chat'; import { useAuth } from '@/hooks/useAuth';  export function useChat(   chatRoomId: number | null,   onMessagesLoaded: React.Dispatch&lt;React.SetStateAction&lt;ChatMessage[]&gt;&gt; ) {   const { accessToken } = useAuth();   const socketRef = useRef&lt;Socket&gt;(null);    useEffect(() =&gt; {     if (!chatRoomId) return;     // 1. 기존 메세지 조회     const loadMessages = async () =&gt; {       try {         const res = await getChatMessages(chatRoomId);         onMessagesLoaded(res.data);       } catch (error) {         console.log('메세지 조회 실패', error);       }     };      // 2. 소켓 연결 및 방 입장     const connectSocket = () =&gt; {       console.log('🔄 소켓 연결 시도:', { chatRoomId, token: !!accessToken });        socketRef.current = io('http://localhost:4000', {         transports: ['websocket'],         withCredentials: true,         auth: { token: accessToken },       });        socketRef.current.on('connect', () =&gt; {         console.log('✅ 소켓 연결 성공!');         socketRef.current?.emit('joinRoom', { chatRoomId });       });        socketRef.current.on('connect_error', (error) =&gt; {         console.error('❌ 소켓 연결 오류:', error);       });        // 메세지 수신       socketRef.current.on('newMessage', (message: ChatMessage) =&gt; {         console.log('📩 새 메시지 수신:', message);         onMessagesLoaded((prev) =&gt; [...prev, message]);       });     };      loadMessages();     connectSocket();      // cleanup     return () =&gt; {       socketRef.current?.disconnect();     };   }, [chatRoomId, onMessagesLoaded]); }   ","categories": ["NestJS"],
        "tags": ["NestJS","Socket.io","adapter","rebook"],
        "url": "/nestjs/nestjs-NestJS%EC%97%90%EC%84%9C-Socket.IO-%EC%97%B0%EA%B2%B0-%EC%8B%9C-404-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0/",
        "teaser": null
      },{
        "title": "[NestJS] 내가 EC2서버에서 CORS 에러지옥에 갇혔던 이유(는 NGINX) + EC2/NextJS/PM2 배포 가이드",
        "excerpt":"   ◾ 배경  이전에 회사에서 NextJS 프로젝트를 EC2 서버에 배포하며 고생했던 경험이 있습니다.  이번에는 NestJS 라고 별거 있겠냐며 겁나는 마음을 속이며 배포를 진행하게 되었고, 그때 나를 힘들게 했던 NGINX라는 친구와 다시 만나게 되었습니다.   그렇게 다시 혼쭐이나면서 겪었던 과정을 남겨봅니다.   ◾ 내가 NGINX를 선택한 이유 - HTTPS 통신을 하기 위해서  Rebook 프로젝트의 프론트엔드 서버는 AWS Amplify를 통해 간편하게 배포했습니다. Amplify는 모든 배포 도메인에 HTTPS가 적용된 보안 인증서를 기본 제공합니다.   반면, 백엔드 서버는 EC2를 사용했으며, 별도의 설정 없이 기본적으로 HTTP 도메인만 제공합니다.   이 때, 프론트엔드 서버와 백엔드 서버 사이에는 Mixed Content 에러가 발생합니다.   📚Mixed Content 에러란?      HTTPS 페이지에서 HTTP 리소스를 요청할 때 발생하는 보안 에러   암호화되지 않은 데이터 전송으로 보안 위협이 발생할 수 있어, 브라우저가 요청 자체를 차단함   해결 방법            도메인을 발급하고, SSL 인증서를 적용해 백엔드 서버도 HTTPS로 통신하도록 설정하자!           NestJS에서도 SSL 인증서를 다룰 수 있지만, 역할을 구분하고 서버에 가해지는 부담을 감소하기 위해 NGINX를 도입했습니다.   📚 NGINX의 역할     SSL 인증서 관리            Let’s Encrypt 같은 무료 인증서를 자동으로 갱신       인증서의 암호화/복호화           인프라 관리 표준 패턴 사용 (TLS Termination)   간편한 포트 관리 및 리버스 프록시            NGINX가 80/443 포트에서 요청을 받고, 내부적으로 NestJS 서버로 프록시 요청을 전달함.       NestJS 서버 포트 노출 없이 보안성과 유연성 확보           그렇게 NGINX의 설정까지 마친 저는 두가지 CORS에러를 마주하게 됩니다.   ◾ 프리플라이트(OPTIONS) 요청 실패   📝문제 상황      본 요청 성공적으로 도달하기 전에, 프리플라이트 요청이 404응답으로 돌아옵니다.      📝문제 원인   문제의 원인을 찾고자 NGINX 테스트를 진행합니다.   ubuntu@ip-[\"be 서버 도메인\"]:~/rebook-api$ sudo nginx -t 2025/05/17 09:43:14 [warn] 75575#75575: conflicting server name \"be 서버 도메인\" on 0.0.0.0:80, ignored // ✅ 2025/05/17 09:43:14 [warn] 75575#75575: conflicting server name \"be 서버 도메인\" on 0.0.0.0:443, ignored // ✅ nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful      80 포트와 443 포트에서 충돌이 나서 요청이 무시되었다는 메세지를 확인했습니다. 이 설정을 작성한 NGINX 설정파일을 확인합니다.   ubuntu@ip-172-31-13-63:~/rebook-api$ sudo ls -l /etc/nginx/sites-enabled/ total 0 lrwxrwxrwx 1 root root 34 May 15 09:46 default -&gt; /etc/nginx/sites-available/default lrwxrwxrwx 1 root root 33 May 17 07:35 rebook -&gt; /etc/nginx/sites-available/rebook   기본(default)설정 파일에 80/443 포트용 server 블록이 중복 선언되어, HTTPS 요청은 수신되지만 실제 처리를 못했습니다.   즉, 백엔드 도메인을 처리하는 server 블록이 동일 포트(80/443)에서 두 개 이상 선언되어 충돌이 발생했던 것입니다.   📝문제 해결   /etc/nginx/sites-available/default을 디렉터리 내에서 제거하고, 오직 하나의 서버 블록에서만 80/443 요청을 처리하도록 했습니다.   ubuntu@ip-[\"be 서버 도메인\"]:~/rebook-api$ sudo nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful   ","categories": ["NestJS"],
        "tags": ["NestJS","NGINX","PM2","EC2","AWS"],
        "url": "/nestjs/nestjs-%EB%82%B4%EA%B0%80-EC2%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-CORS-%EC%97%90%EB%9F%AC%EC%A7%80%EC%98%A5%EC%97%90-%EA%B0%87%ED%98%94%EB%8D%98-%EC%9D%B4%EC%9C%A0(%EB%8A%94-NginX)/",
        "teaser": null
      }]
