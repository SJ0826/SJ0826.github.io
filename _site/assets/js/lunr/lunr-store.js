var store = [{
        "title": "[TodoList-Project] 클래스로 작성하는 로그인/회원가입 axios통신",
        "excerpt":"📑 axios통신 로직을 클래스로 작성한 이유   꽤 여러번 투두리스트를 만들어봤지지만 axios 통신 로직은 항상 함수로만 작성했다. 원티드에서 강의를 듣고 클래스에 대해 고민하게 되었다. 클래스는 객체 형태로 state를 저장할 수 있기 때문에 state를 가진 모듈이라면 클래스로 작성하는 것이 좋다고 한다. 로그인/회원가입을 구현하는 로직은 url과 token을 가지고 있기 때문에 클래스로 작성을 하기로 결정했다. 이번에 본격적으로 구글링을 하는 연습을 하기 위해서 영어로 된 문서도 적극적으로 참고했다.   📑 httpClient.ts | axios Client를 담당   import axios, { AxiosInstance, AxiosRequestConfig } from \"axios\"; import { getLocalStorageToken } from \"../store/localStorage\";  declare module \"axios\" {   type AxiosRequest&lt;T = unknown&gt; = Promise&lt;T&gt;; } // 0  abstract class HttpClient {   // 1   protected readonly instance: AxiosInstance;    public constructor(baseURL: string) {     // 2     this.instance = axios.create({       baseURL: BASE_URL,     });      this._initializeRequestInterceptor(); // 3   }    private _initializeRequestInterceptor = () =&gt; {     // 4     this.instance.interceptors.request.use(this._handleRequest);   };    private _handleRequest = (config: InternalAxiosRequestConfig) =&gt; {     const accessToken = getLocalStorageToken();     if (accessToken &amp;&amp; config.headers) {       config.headers.Authorization = `Bearer ${accessToken}`;     }     return config;   }; }  export default HttpClient;           타입스크립트를 사용하고 있기 때문에 AxiosRequest가 무슨일을 하는지 알려줘야 한다. 이렇게 하면 response를 순수 data로 사용할때 타입스크립트가 에러를 내지 않는다고 한다.            우선, HttpClient라는 추상 클래스를 만들어 instance를 생성할 수 없게 만들어주었다. instance를 생성할 클래스는 기능별로 따로 만들었기 때문이다.            axios-instance를 생성하는 constructor이다. constructor로부터 base URL을 얻을 수 있다. axios.create는 protected 멤버로 설정된 instance에 저장되어 외부 클래스에서 사용할 수 없게 했다. 하지만 상속받은 클래스에서는 접근할 수 있다.            데이터를 요청하기 전 토큰이 있는지 확인해야 하기 때문에 axios의 interceptor메소드를 활용할 것이다. _는 private 메소드라고 암시하는 뜻이다.            interceptor메소드는 _handleRequest라는 콜백함수를 가진다. axios 요청시 로컬스토리지에 있는 값을 꺼내서 헤더에 Authorization 키를 설정할 수 있다.         📑 authAPI.ts | 로그인/회원가입 axios 통신을 담당   import { AxiosResponse } from \"axios\"; import { SIGNIN_URL, SIGNUP_URL } from \"../../constants/constants\"; import HttpClient from \"../httpClient\"; import { UserParam } from \"../../types/auth/UserInterface\";  class AuthAPI extends HttpClient {   public constructor() {     super();      this._initializeResponseInterceptor();   }    private _initializeResponseInterceptor = () =&gt; {     this.instance.interceptors.response.use(       this._handleResponse,       this._handleError     );   };    private _handleResponse = (response: AxiosResponse) =&gt; {     const responseCode = response.status;      switch (responseCode) {       case 200:         alert(\"로그인되었습니다.\");         break;       case 201:         alert(\"회원가입에 성공했습니다. 로그인해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }     return response;   };    protected _handleError = (error: AxiosError) =&gt; {     const { response: errorResponse } = error;     const errorCode = errorResponse.status;      switch (errorCode) {       case 400:         alert(\"동일한 이메일이 이미 존재합니다.\");         break;       case 401:         alert(\"아이디와 비밀번호를 확인해주세요.\");         break;       case 404:         alert(\"해당 사용자가 존재하지 않습니다. 회원가입을 진행해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }   };    public SignIn = (data: UserParam) =&gt; this.instance.post(SIGNIN_URL, data);    public SignUp = (data: UserParam) =&gt; this.instance.post(SIGNUP_URL, data); }  const authApi = new AuthAPI(); export { authApi };     참고      Enhance Your HTTP  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","axios","클래스"],
        "url": "/todolist-project/projects-todolist-axios/",
        "teaser": null
      },{
        "title": "최댓값과 최솟값",
        "excerpt":"문제 📖   문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.   예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다.      s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.   function solution(s) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(s) {   const stringToArray = s.split(\" \");   const stringToNumber = stringToArray.map((element) =&gt; parseInt(element));   const maxValue = Math.max(...stringToNumber);   const minValue = Math.min(...stringToNumber);   const answer = `${minValue} ${maxValue}`;   return answer; }   먼저 split 배열 내장 함수를 통해 공백을 기준으로 문자열을 구분했다.   이후 최댓값과 최솟값을 구하기 위해 구분된 배열의 문자들을 숫자로 바꾸어 주고,   spread연산자로 배열을 분해해서 최댓값과 최솟값을 구했다.   문자열을 반환해야 한다고해서 백틱으로 maxValue minValue을 감싸 return시켰다.   Best Practice 👍   # 1   function solution(s) {   const arr = s.split(\" \");    return Math.min(...arr) + \" \" + Math.max(...arr); }   우선, 내가 작성한 코드보다 훨씬 간결한 것을 확인했다.   내가 몰랐던 점은 다음과 같다.      Math가 문자열도 취급한다는 것   굳이 따로 변수나 상수에 값을 할당하는 것보다 바로 return을 시키는게 더 나을 때도 있다는 것   # 2   function solution(s) {   let min = Math.min.apply(null, s.split(\" \").map(Number));   let max = Math.max.apply(null, s.split(\" \").map(Number));   var answer = min + \" \" + max;   return answer; }   이 코드가 인상적이었던 점은 map함수를 사용하는 방식 때문이었다.   내 풀이를 보면 map을 사용할때 각각 요소에 parseInt를 적용해서 숫자로 변환하는 방식이었는데, 그냥 Number라고 적기만 해도 식이 진행된다는 것을 알게 되었다.  ","categories": ["programmers-lv2"],
        "tags": ["프로그래머스","최댓값과 최솟값"],
        "url": "/programmers-lv2/programmers-maxandmin/",
        "teaser": null
      },{
        "title": "2016년",
        "excerpt":"문제 📖   2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT   입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.      2016년은 윤년입니다.   2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   나의 풀이 🙋‍♀️   function solution(a, b) {   const dayOfTheWeek = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];   const daysOfMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   let sum = 0;    if (a === 1) {     sum = b;   } else {     for (let i = 0; i &lt;= a - 2; i++) {       // 1       sum += daysOfMonth[i];       if (i == a - 2) {         sum += b; //2       }     }   }    const index = sum - Math.floor(sum / 7) * 7; // 3    return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1]; }   내가 생각한 풀이의 순서는 다음과 같다.      주어진 월(a)전의 총 날짜를 더한 값을 구한다.. = sum   sum에 b를 더해 필요한 날짜를 모두 더한 값을 구한다.   sum에 7의 배수를 뺐을 때 나올 수 있는 한자리 수를 구해 dayOfTheWeek의 인덱스로 활용한다.   trouble shooting 1 💥   처음 코드   for (let i = 0; i &lt;= a - 2; i++) {   sum += daysOfMonth[i];   if (i == a - 2) {     sum += b;   } }   수정한 코드   if (a === 1) {   sum = b; } else {   for (let i = 0; i &lt;= a - 2; i++) {     sum += daysOfMonth[i];     if (i == a - 2) {       sum += b; //2     }   } }   이 부분은 왜 통과하지 못했는지 머리를 굴리다 1월인 경우, 2월인 경우 값을 대입해서 생각해보니 문제점을 찾을 수 있었다.   만약 1월이라면 a는 1이되는데 for문의 조건에 처음부터 충족되지 못해서 sum에 값이 들어가지 않았던 것이다.   if문으로 조건을 달아주긴 했지만 조건문속 반복문속 조건문.. 정말 맘에 들지 않는다..   trouble shooting 2 💥   처음 코드   return dayOfTheWeek[index - 1];   수정한 코드   return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1];   계산대로 하면 모든 케이스가 통과해야하는데 13개의 케이스 중 2개가 통과하지 못하고 계속 실패로 걸렸다.   테스트 케이스에 날짜를 하나 하나 추가해서 결과를 확인하던 중 이유를 알 수 있었다.   index가 0이 될 수도 있었던것이었다.   예를 들어 5월 5일인 경우, index가 126 - (18*7) = 0이 되는데 나는 결과값을 dayOfTheWeek[index-1]로만 리턴해서 결과가 undefined가 나왔던 것이다.   return할 때 삼항연산자를 이용해 index가 0이 될 경우의 케이스도 처리해주었다.   Best Practice #1 👍   function getDayName(a, b) {   var tempDate = new Date(2016, a - 1, b);    return tempDate.toString().slice(0, 3).toUpperCase(); }  //아래 코드는 테스트를 위한 코드입니다. console.log(getDayName(5, 24));   Date가 있는 걸 알긴 했지만 그러면 너무 단순해질것같아서 사용하지 않았다.   그래도 메소드를 사용한걸 보니 훨씬 보기 편하다.   Best Practice #2 👍   function solution(a, b) {   const monthDay = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   const weekDay = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\"];    let days = b;   for (let i = 0; i &lt; a - 1; i++) days += monthDay[i];    return weekDay[days % 7]; }   코드가 흘러가는 구성이 내가 작성한 코드와 크게 다르지 않다.   하지만 간결함과 가독성이 크게 다르다.   for문의 조건식에서 &lt;=을 &lt;로 고쳤을뿐인데 if문이 하나 줄었다.   굳이 sum이라는 변수를 새로 만들지 않고 b에 값을 더해주었다.   굳이… Math.floor()를 사용하지 않고도 그냥 %연산자로 나머지값 계산해서 index로 처리해주었다…   만약 다른 사람이 푼 답에 Best Practice가 있다면 배열 내장 함수를 사용했을 것이라고 생각했는데 아니었다.   물론 배열 내장 함수를 사용할 수도 있지만 이 코드가 가독성도 좋고 제일 좋아보였다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","2016년"],
        "url": "/programmers-lv1/2016/",
        "teaser": null
      },{
        "title": "🚨 Cannot find module",
        "excerpt":"🚨 Cannot find module   자바스크립트 강의를 들으며 실습 도중 파일이 실행이 안됐다.      경로 설정 문제 인줄 알았는데 파일 설정을 잘못했다.   🔨 해결           확장자 명이 js로 되어 있는지 확인하고 고친다.            끝^^       느낀점   항상 오류가 발생하면 사실 대부분 이런 사소한 문제들인것 같다.   모든 과정을 꼼꼼히 살피자.   참고      [stackoverflow]https://stackoverflow.com/questions/9023672/how-do-i-resolve-cannot-find-module-error-using-node-js  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/cannot-find-module/",
        "teaser": null
      },{
        "title": "🚨 Cannot use import statement outside a module",
        "excerpt":"🐞 에러 발생   공연 검색기 프로젝트 중 에러가 발생했다.    ❔ 원인   해당 스크립트를 모듈로 인식하지 못해 import문을 쓸 수 없다는 뜻이다.   직접 스크립트의 타입을 지정해주어야 한다.   ❕ 해결   [index.html]   &lt;script src=\"main.js\" type=\"module\"&gt;&lt;/script&gt;   이렇게 해당 스크립트 태그에서 타입을 모듈로 지정해주면 에러가 해결된다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","import"],
        "url": "/javascript/javascript-cannot-use-import-statement-outside-a-module/",
        "teaser": null
      },{
        "title": "해시(Hash)",
        "excerpt":"📄 해시(Hash)      해시는 (Key, Value)로 데이터를 저장하는 자료구조입니다.   해시 함수는 임이의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환시켜주는 함수를 뜻합니다.   해시 함수를 사용하면 한 배열의 키에 해시함수를 적용해 고유한 인덱스를 생성할 수 있습니다.   참고      업비트 투자자보호센터  ","categories": ["structure"],
        "tags": ["자료구조","해시"],
        "url": "/structure/structure-hash/",
        "teaser": null
      },{
        "title": "논리 연산자를 이용한 조건문",
        "excerpt":"📄 논리 연산자를 이용한 조건문   조건문은 계산식뿐만 아니라 논리연산자를 이용해 완성할 수 있습니다.   📄 표현식 &amp;&amp; 표현식   &amp;&amp;는 and연산자로 불리며 조건 중 하나라도 거짓일 경우 거짓이 됩니다.   if (true &amp;&amp; true) {   console.log(\"두개 모두 참이면 참\"); }  if (true &amp;&amp; false) {   console.log(\"한개만 참이면 거짓\"); }  if (false &amp;&amp; false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 표현식 || 표현식   ||는 &amp;&amp;OR연산자**로 둘중 하나만 참이면 참이 됩니다.   if (true || true) {   console.log(\"두개 모두 참이면 참\"); }  if (true || false) {   console.log(\"한개만 참이면 참\"); }  if (false || false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 !표현식   !는 NOT연산자로 반대의 결과값을 출력합니다.   if (!true) {   console.log(\"참이면 거짓\"); // 거짓이므로 출력되지 않음. }  if (!false) {   console.log(\"거짓이면 참\"); }   결과      📄 논리연산자를 이용한 조건부 실행   표현식은 앞을 먼저 평가하고 뒤를 평가합니다.   앞 표현식을 평가를 해서 참 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤의 표현식이 실행됩니다.   n % 5;  // 앞이 참이기 때문에 뒤가 실행이 되지 않음. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");  n = 6;  // 앞이 거짓이기 때문에 뒤가 실행됨. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");   결과    📄 논리연산자 우선순위   논리연산자에는 우선순위가 있습니다.   NOT(!) &gt; AND(&amp;&amp;) &gt; OR(||) 순으로 NOT연산자가 제일 먼저 실행됩니다.   const value = !((true &amp;&amp; false) || (true &amp;&amp; false) || !false);   세가지 논리연산자가 동시에 쓰였지만,   우선순위가 적용되어 value는 false라는 값을 가지게 됩니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","논리연산자"],
        "url": "/javascript/javascript-logical-operator/",
        "teaser": null
      },{
        "title": "컨테이너와 전역 속성",
        "excerpt":"📄 컨테이너 태그   콘텐츠에 아무런 영향을 주지 않고, 여러 요소를 묶어 관리하기 편하게 만드는 역할을 하는 태그입니다.   div: 블록 레벨 컨테이너      페이지 전체 면적을 차지합니다.   span: 인라인 컨테이너   지정한 부분의 면적만 차지합니다.   📄 전역 속성   전역속성(Global attributes)은 모든 HTML 태그에서 공통으로 사용할 수 있는 속성입니다.   &lt;태그명 속성명=**속성값** 속성명=**속성값**&gt;콘텐츠&lt;/태그명&gt;   대표적인 전역 속성들      id: 요소에 고유한 이름을 부여하는 식별자 역할 속성입니다. id는 태그당 하나씩만 지정합니다.   class: 요소를 그룹 별로 묶을 수 있는 식별자 역할 속성입니다. class는 다중 지정 및 중복이 가능합니다.   style: 요소에 적용할 CSS스타일을 선언하는 속성입니다.   title: 요소의 추가 정보를 제공하는 텍스트 속성입니다. 사용자에게 툴팁을 제공합니다.  ","categories": ["HTML"],
        "tags": ["HTML","컨테이너","전역속성"],
        "url": "/html/html-container/",
        "teaser": null
      },{
        "title": "HTML 문서 기본 구조",
        "excerpt":"📄 HTML이란?      HyperText: 하이퍼링크를 통해 어떤 문서에서 다른 문서로 접근할 수 있는 텍스트   MarkUp: (콘텐츠를) 표시하다   Language: 언어   즉, HTML은 웹브라우저를 통해 표시되는 웹페이지의 콘텐츠를 정의하기 위해 사용하는 언어입니다.   📄 HTML 문서 기본 구조   ▪ &lt;!DOCTYPE html&gt;   문서의 첫 부분에서 문서 유형을 지정하는 단일 태그입니다.   &lt;!DOCTYPE html&gt;   ▪ &lt;html&gt; ~ &lt;/html&gt;   문서 유형을 지정한 후 실제 문서가 시작되고 끝나는 것을 나타내는 태그입니다.   &lt;html&gt;   ... &lt;/html&gt;   ▪ &lt;head&gt; ~ &lt;/head&gt;   웹 브라우저 화면에는 보이지 않지만 웹 브라우저가 알아야 할 정보들입니다.   ▪ &lt;meta charset=\"utf-8\"&gt;   문자 인코딩 및 문서 키워드 등에 대한 요약 정보를 기입하는 단일 태그입니다.  영문과 한글을 모두 사용하기 위해 utf-8 방식을 사용하는 것이 좋습니다.    ▪ &lt;title&gt; ~ &lt;/title&gt;   문서의 제목을 나타냅니다. 콘텐츠는 브라우저 탭에 표시됩니다.       ▪ &lt;body&gt; ~ &lt;/body&gt;   실제 브라우저 화면에 표시될 내용을 입력하는 태그입니다.     들여쓰기를 깔끔하게 해서 가독성을 높이자   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그"],
        "url": "/html/html-html-docs-structure/",
        "teaser": null
      },{
        "title": "이미지 표시하기",
        "excerpt":"📄 이미지를 보여주는 img 태그   html에서는 이미지를 보여줄 때 img라는 단일 태그를 사용합니다.   &lt;img src=\"표시할 이미지 파일\" alt=\"이미지설명\" /&gt;   이때 alt는 대체 택스트 역할을 합니다.   이미지가 로딩되기 전이나 이미지 로딩에 실패한 경우   이미지 대신에 대체 텍스트가 표시됩니다.   이미지 유실 상황에 대비하거나 시각 장애인을 위한 콘텐츠에 유용합니다.(음성인식기 활용)   📄 이미지 크기 조절하기   width와 height로 크기를 지정합니다.   이때 너비와 높이는 각각 픽셀(px)단위로 적용됩니다.   &lt;img   src=\"표시할 이미지 파일\"   alt=\"이미지 설명\"   width=\"너비 값\"   height=\"높이 값\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","img"],
        "url": "/html/html-image/",
        "teaser": null
      },{
        "title": "입력 요소 만들기(input)",
        "excerpt":"📄 input 태그   입력요소는 &lt;input&gt; 태그를 이용해 만들어 줍니다.   &lt;input&gt;태그는 인라인 요소이며, 단일 태그입니다.   &lt;input&gt;태그에는 name식별자를 추가하여 각각 어떤 특징을 가지는지 설명하는 것이 좋습니다.   📄 input 태그의 type 속성   type값에 따라 입력 요소의 형태나 입력 데이터 유형 등이 달라집니다.   1. text: 텍스트 메세지를 입력합니다.   &lt;input name=\"text\" type=\"text\" maxlength=\"5\" placeholder=\"메세지입력\" /&gt;      maxlength: 텍스트 최대 크기를 지정합니다.   place holder: 텍스트 입력 전 창에 띄워지는 텍스트를 지정합니다.   2. button: 버튼이 생성됩니다.   &lt;input name=\"button\" type=\"button\" value=\"PUSH\" /&gt;   3. color: 색을 지정할 수 있는 팔레트가 띄워 집니다.   &lt;input name=\"color\" type=\"color\" /&gt;   4. rage: 숫자로 된 값을 입력 할 수 있는 바를 만들어 줍니다.   &lt;input name=\"score\" type=\"range\" max=\"100\" min=\"0\" step=\"10\" /&gt;   5. date: 날짜를 입력할 수 있는 달력이 생성됩니다.   &lt;input name=\"birthdaty\" type=\"date\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","input"],
        "url": "/html/html-input/",
        "teaser": null
      },{
        "title": "링크 만들기",
        "excerpt":"📄 링크(Link)   링크는 현재 문서에서 다른 문서로 이동할 수 있는 수단입니다.   링크는 a 태그를 사용합니다.   a 태그에 사용하는 속성      href: 링크가 참조하고자 하는 url을 입력합니다.   target: 링크 클릭 시 현재 탭에서 열지 새로운 탭에서 열지 결정합니다   &lt;a href=\"www.naver.com\" target=\"_self\"&gt; 현재 탭에서 열기(기본값) &lt;/a&gt;  &lt;a href=\"www.naver.com\" target=\"_blank\"&gt; 새로운 탭에서 열기 &lt;/a&gt;   이 외에도 href에 전화번호나 메일 주소 등을 지정 할 수 있습니다.   &lt;a href=\"tel:010-1234-5678\"&gt;   전화 걸기   &lt;!-- 데스크탑일 경우 전화기능이 없다면 사용 불가--&gt; &lt;/a&gt;  &lt;a href=\"mailto:ikosdu60@gmail.com\"&gt; 메일 쓰기 &lt;/a&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","link"],
        "url": "/html/html-link/",
        "teaser": null
      },{
        "title": "HTML코드 기초 문법",
        "excerpt":"📄 태그(tag)   HTML 코드에서 정보(콘텐츠)를 정의하는 형식입니다.   &lt;태그명&gt; 여기에 콘텐츠를 기입합니다.&lt;/태그명&gt; &lt;/태그명&gt; // 단일 태그 사용 형태   📄 속성   태그의 부가적인 기능을 정의합니다.   &lt;태그명 속성명=\"속성값\"&gt;내용이 들어감&lt;/태그명&gt; &lt;태그 속성명=\"속성값\"/&gt; //단일 태그 사용 형태   📄 주석   사람에게는 보이지만, 웹브라우저에게는 보이지 않는 코드입니다.   주로 메모를 남기기 위해 사용됩니다.   &lt;!--** 이 사이에 작성한 내용은 주석으로 처리된다. **--&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그","속성","주석"],
        "url": "/html/html-html-grammner/",
        "teaser": null
      },{
        "title": "목록 표시하기",
        "excerpt":"📄 ul   순서 있는 항목은 &lt;ul&gt;태그로 작성합니다.   &lt;ul&gt;   &lt;li&gt;토끼&lt;/li&gt;   &lt;li&gt;다람쥐&lt;/li&gt;   &lt;li&gt;청설모&lt;/li&gt;   &lt;li&gt;호랑이&lt;/li&gt; &lt;/ul&gt;   이와 같이 항목 하나하나는 &lt;li&gt;로 표시합니다.   ul태그로 작성하면 앞에 숫자가 붙습니다.   📄 ol   순서 없는 항목은 &lt;ol&gt;태그로 작성합니다.   &lt;ol&gt;   &lt;li&gt;HTML&lt;/li&gt;   &lt;li&gt;CSS&lt;/li&gt;   &lt;li&gt;JAVAScript&lt;/li&gt;   &lt;ol&gt;&lt;/ol&gt; &lt;/ol&gt;   &lt;ul&gt;태그와 &lt;ol&gt;태그와 &lt;li&gt;태그는 모두 블록 레벨 요소를 만드는 태그입니다.  ","categories": ["HTML"],
        "tags": ["HTML","ul","ol","li"],
        "url": "/html/html-list/",
        "teaser": null
      },{
        "title": "메타(meta) 태그",
        "excerpt":"📄 메타(meta) 태그   meta 태그는 HTML 문서의 정보를 표시하는 태그입니다.   검색엔진 최적화에 기여하며, 검색 결과에도 영향을 끼칩니다.   개발자가 페이지를 참고할 때 도움이 되기도 합니다.   📄 메타 태그의 다양한 속성들   1. charset   문자 인코딩에 대한 요약 정보를 기입하는 속성입니다.   주로 영문과 한글을 모두 사용하기 위해 utf-8방식을 사용합니다.   &lt;meta charset=\"uth-8\" /&gt;   2. http-eqiv   콘텐츠 속성의 정보/값에 대한 HTTP 헤더를 제공합니다.   &lt;!-- IE 브라우저의 최신 버전의 엔진을 사용하라는 뜻--&gt; &lt;meta http-equiv=\"x-ua-compatible\" content=\"IE-edge\" /&gt; &lt;!-- 10초마다 페이지 새로고침하라는 뜻--&gt; &lt;meta http-equiv=\"refresh\" content=\"10\" /&gt;   3.name name 속성을 이름으로, content 속성을 값으로 하여 문서 정보를 제공합니다.   &lt;!--문서 제작자--&gt; &lt;meta name=\"author\" content=\"유노코딩\" /&gt; &lt;!-- 페이지에 대한 요약--&gt; &lt;meta name=\"desciption\" content=\"페이지에 대한 짧고 명확한 요약\" /&gt; &lt;!-- 페이지의 콘텐츠와 관련된, 쉼표로 구분한 키워드 목록--&gt; &lt;meta   name=\"keywords\"   content=\"예를 들면, 강아지, 고양이, 정보, 반려동물, 등등\" /&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","메타 태그","charset","http-eqiv","name"],
        "url": "/html/html-metatag/",
        "teaser": null
      },{
        "title": "select & textarea",
        "excerpt":"📄 select   select는 다수의 옵션(선택지)를 포함할 수 있는 선택 메뉴입니다.   메뉴 안에 포함되는 옵션은 option 태그를 사용하여 표시합니다.   &lt;select&gt;     &lt;option value=\"starbucks\"&gt;스타벅스&lt;/option&gt;     &lt;optio nvalue=\"coffeebean\"&gt;커피빈&lt;/option&gt;     &lt;option value=\"ediya\"&gt;이디야&lt;/option&gt;     &lt;option value=\"pascucci\"&gt;파스쿠찌&lt;/option&gt; &lt;/select&gt;      선택지에서 커피빈을 고른다 = cafe의 입력 값은 coffebean이다    📄 textarea   textarea는 여러 줄의 일반 텍스트를 입력할 수 있는 입력 요소입니다.   &lt;textarea name=\"letter\" rows=\"10\" cols=:10\"&gt;기본적으로 쓰여 있는 텍스트&lt;/textarea&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","select","textarea"],
        "url": "/html/html-select&textarea/",
        "teaser": null
      },{
        "title": "뷰포트(viewport)",
        "excerpt":"📄 뷰포트(viewport)   현재 화면에 보여지고 있는 영역을 의미합니다.   기기별로 뷰포트가 다르기때문에 보여지는 화면의 배율에 따라 화면이 다르게 보입니다.   html문서에서 이름이 뷰포트인 메타태그 설정을 확인할 수 있습니다.   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;      width=device-width : 너비를 기기의 너비 기준으로 초기화 한다. initial-scale=1.0 : 기기의 너비에 맞게 초기 scale를 지정한다.    이 메타태그 설정은 기기에 맞게 화면 배율을 조정해주기 때문에, 모바일 화면에서도 pc화면과 동일하게 콘텐츠의 크기가 유지되는 것을 확인할 수 있습니다.   📄 뷰포트 단위   뷰포트 크기를 기반으로 값을 계산하여 크기를 결정하는 가변단위들이 있습니다.   이는 반응형 웹을 만들 때 매우 유용하게 사용되는 단위들입니다.   ▪ font-size: 1vw;      화면 사이즈에서 너비의 100분의 1    화면 너비의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vh;      화면 사이즈에서 높이의 100분의 1    화면 높이의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vmin;      화면 사이즈에서 너비와 높이 중 작은것의 100분의 1 너비와 높이 중 작은 것에 백분율을 맞춘다    ▪ font-size: 1vmax;      화면 사이즈에서 너비와 높이 중 큰것의 100분의 1 너비와 높이 중 큰 것에 백분율을 맞춘다.   ","categories": ["HTML"],
        "tags": ["HTML","뷰포트"],
        "url": "/html/html-viewport/",
        "teaser": null
      },{
        "title": "식별자(Identifier)",
        "excerpt":"📄 식별자(Identifier)   코드 내의 변수, 함수 혹은 속성을 식별하는 문자열을 식별자라고 합니다.   식별자를 통해서 이름을 지어주게 됩니다.   📄 식별자를 만들 때 규칙           식별자는 대소문자를 구분합니다.            유니코드 문자, $, 숫자를 사용할 수는 있지만, 숫자로 시작할 수는 없습니다.            예약어는 사용할 수 없고, 공백 문자도 사용할 수 없습니다.            한글도 가능은 하지만, 보통 영문을 사용합니다.       📄 주의할 점      식별자를 만들 때는 의미없는 이름보다는, 역할에 맞는 적절한 이름을 짓도록 해야합니다.   📄 식별자 가능 유무 확인하기   [식별자]https://mothereff.in/js-variables       사용가능한 식별자를 확인하는 페이지 입니다.    출처      패스트 캠퍼스 프론트엔드 올인원 패키지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","식별자"],
        "url": "/javascript/js-identifier/",
        "teaser": null
      },{
        "title": "조건문",
        "excerpt":"📄 조건문   조건문은 표현식이 참으로 평가될 때, 실행되는 블럭입니다.   if (true) {   console.log(\"항상 실행\"); // 출력됨. }  if (false) {   console.log(\"항상 실행되지 않음\"); // 출력되지 않음. }   조건이 참인 경우는 출력이 되고 거짓인 경우는 출력되지 않습니다.                  TIP       블록에 코드가 한줄이면, 중괄호는 생략 가능합니다.           if (true) console.log(\"항상 실행\");  if (false) console.log(\"항상 실행되지 않음\");   📄 표현식이 거짓으로 평가될 때   표현식이 거짓으로 평가될 때는 false만 있는 것이 아닙니다.   if (false) console.log(false); if (0) console.log(0); if (\"\") console.log(\"\"); if (null) console.log(null); if (undefined) console.log(undefined); if (NaN) console.log(NaN);   위의 경우 모두 거짓으로 평가되어 출력되지 않습니다.   📄 표현식이 참으로 평가될 때   마찬가지로 참인 경우도 여러가지 경우가 있습니다.   if (true) console.log(true); if (37) console.log(37); if (-37) console.log(-37); if (\"Mark\") console.log(\"Mark\"); if ({}) console.log({}); if ([]) console.log([]);   📄 if에 해당하지 않을 때 | else   if문으로 조건식을 작성하고 반대의 경우에는 간단하게 else로 작성할 수 있습니다.   const n = 15;  if (n % 3 === 0) {   console.log(\"n은 3의 배수 입니다.\"); } else if (n % 5 === 0) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   마찬가지로 한줄로 작성할 경우 중괄호 생략이 가능합니다.   if (n &gt; 0) console.log(\"n이 0보다 큰 경우\"); else console.log(\"n이 0보다 크지 않은 경우\");   📄 조건이 여러번 반복되는 경우   조건이 여러번 반복되는 경우에는, 조건을 변수나 상수에 넣어 작성할 수 있습니다.    const multipleOfThree = n % 3 === 0; const multipleOfFive = n % 5 === 0;  if (multipleOfThree &amp;&amp; multipleOfFive) {   console.log(\"n은 15의 배수입니다.\"); } else if (multipleOfThree) {   console.log(\"n은 3의 배수입니다.\"); } else if (multipleOfFive) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   📄 삼항 연산자를 이용한 조건부 실행   조건 ? 조건이 참이면 실행되는 표현식 : 조건이 거짓이면 실행되는 표현식   삼항 연산자를 이용한 조건부 실행은 위의 형식으로 나타납니다.   중괄호 {}를 사용할 수 없는 문법이기 때문에 하나의 표현식으로 작성합니다.   let n = 5;  const message = n % 5 === 0 ? \"5의 배수 입니다.\" : \"5의 배수가 아닙니다.\"; console.log(message);   주의할 점   삼항연산자를 남발하면 오히려 보기 헷갈릴 수 있으니 가급적 여러번 사용하는 것은 지양합니다.    📄 switch를 이용한 조건문   switch뒤 괄호 안에 있는 값이 무엇인지 중괄호 안에 있는 코드들을 비교해서 실행합니다.   복수의 if문을 switch문으로 정리할 수 있습니다.      5의 배수 일 경우 case0으로 출력하는 조건문   switch (n % 5) {   case 0: {     console.log(\"5의 배수입니다.\");     break;   }   case 1:   case 2:   case 3:   case 4:     console.log(\"5의 배수가 아닙니다.\");    default:     console.log(n); }   만약에 해당 블럭이 실행된 후 다음 블럭을 거치지 않고 switch문을 나가고 싶다면, case문 안에서 break;를 실행합니다.   break와 case 문의 순서를 잘 조정하여, 원하는 코드를 만들어 낼 수 있도록 제대로 이해해야 합니다.   출처      패스트캠퍼스 프론트엔드 강의   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","조건문"],
        "url": "/javascript/js-conditional/",
        "teaser": null
      },{
        "title": "객체(Object)",
        "excerpt":"📄 객체란 무엇인가?   객체는 이름과 값으로 구성된 프로퍼티의 정렬되지 않은 집합체입니다.   객체를 생성할 때는 함수나 클래스를 이용할 수 있습니다.   쉽게 말해 함수나 클래스를 큰 틀로 생각하고 하나하나 찍어내는 것을 각각 객체라고 생각하면 됩니다.   이 객체는 인스턴스라고 부르기도 합니다.   new라는 키워드를 통해 객체를 생성합니다.   function A() {}  const a = new A(); // new를 통해서 함수 A의 객체가 만들어져 변수 a에 할당된다. console.log(a, typeof a); console.log(A());   📄 객체에 속성(프로퍼티)추가하기   함수에서 프로퍼티를 만들어 객체에 할당할 수 있습니다.   프로퍼티를 설정하면 각각의 성질을 가지는 속성을 만들게 됩니다.   function A(name) {   this.name = name; }  const a = new A(\"Mark\"); console.log(a);   함수를 속성으로 넣기   함수를 프로퍼티로 넣는 것또한 가능합니다.   function B() {   this.hello = function () {     console.log(\"hello\");   }; }  new B().hello();      함수B의 프로퍼티 hello에 ‘hello’를 출력하는 함수를 설정함.    📄 객체 리터럴   객체 리터럴은 중괄호 안에 프로퍼티를 정의하여 객체를 생성하는 방식입니다.   프로퍼티는 쉼표(,)로 구분합니다.   const b = {   name: \"Mark\", // name이라는 프로퍼티에 'Mark'라는 값 할당 };  console.log(b, typeof b);   결과   {   name: \"Mark\"; } object;   프로퍼티에 함수도 할당할 수 있습니다.   const c = {   name: \"Mark\",   hello1() {     console.log(\"hello1\", this.name);   },   hello2: function () {     console.log(\"hello2\", this.name);   },   hello3: () =&gt; {     console.log(\"hello3\", this);   }, };  c.hello1(); c.hello2(); c.hello3();   결과   hello1 Mark hello2 Mark hello3 {}  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체"],
        "url": "/javascript/javascript-object/",
        "teaser": null
      },{
        "title": "[클래스] 상속",
        "excerpt":"📄 클래스 상속   extends라는 키워들를 통해서 자식클래스가 부모클래스를 상속받습니다.   class Parent {}  class Child extends Parent {}   오버라이딩(override)   오버라이딩은 부모클래스에서 구현한 함수나 변수를 자식클래스에서 다시 구현하는 것입니다. 즉, 자식이 만든 함수가 부모가 만든 함수를 덮어씌우는 것을 오버라이딩이라고 합니다.   class Parent {   name = \"Lee\";    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age = 37;    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }      자식 클래스에서 부모클래스의 hello 함수를 오버라이딩 함.   📄 super (새로운 속성 추가하기)   자식클래스가 부모클래스로부터 상속을 받을 때, 새로운 속성을 추가하려면 super()로 부모클래스로부터 생성자를 호출해 초기값을 세팅합니다.   super은 생성자안에서 사용합니다.    class Parent {   name;    constructor(name) {     // name값을 받는 생성자     this.name = name;   }    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age;    constructor(name, age) {     super(name); //부모클래스의 생성자를 호출해 초기값 세팅     this.age = age;   }    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }   출처      패스트클래스  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스","상속"],
        "url": "/javascript/js-class2/",
        "teaser": null
      },{
        "title": "데이터 타입(Data type)",
        "excerpt":"📄 데이터 타입(Data type)   프로그램에서 다뤄지는 모든 데이터에는 다양한 종류가 있습니다.   그 종류들을 데이터 타입이라고 부릅니다.   📄 String   String은 데이터를 문자열로 표현합니다.   데이터를 문자열로 지정하는 경우 따옴표 혹은 쌍따옴표를 이용합니다.   let text = \"hello\"; let name = \"하이요\";   📄 boolean   boolean은 데이터의 참과 거짓을 지정하는 타입입니다.   let good = true; let loading = false;   📄 null과 undefined   null과 undifined는 둘다 의미가 없음을 뜻합니다.   하지만 분명한 차이점이 존재합니다.   null은 의미가 진짜 없다는 뜻을 가지고 있고,   undefined는 의미가 아직 정해지지 않았다는 뜻입니다.   let friend = null; let criminal;   위 코드를 출력하면   friend는 null을 그대로 출력하지만,   아무것도 값이 지정되지 않은 criminal은 undefined를 출력합니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","데이터타입"],
        "url": "/javascript/javascript-datatype/",
        "teaser": null
      },{
        "title": "배열(Array)",
        "excerpt":"📄 배열(Array)   배열은 여러개의 항목이 들어있는 리스트를 뜻합니다.   배열은 대괄호([])를 사용하여 선언합니다.   대괄호 안에 들어가는 항목들은 숫자, 문자열 배열, 객체 등 이 있습니다.   const array = [1, 2, 3, 4, 5];      이름이 array인 배열을 선언함.    📄 배열에 새로운 항목 추가   배열에 새로운 항목을 추가할 때는 push라는 키워드를 사용합니다.   array.push(6);      배열에 6이라는 값을 추가함    이렇게 배열에 값을 추가하면 배열의 마지막에 추가 됩니다.    📄 배열의 크기 조회   배열의 크기를 조회 한다는 것은 배열에 몇개의 항목이 있는지 계산한다는 뜻입니다.   배열의 크기를 조회할 때는 length라는 키워드를 사용합니다.   console.log(array.length);      배열 array의 크기를 조회해서 출력한다.    출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","배열"],
        "url": "/javascript/javascript-array/",
        "teaser": null
      },{
        "title": "get & set 함수",
        "excerpt":"📄 get &amp; set 함수   클래스 내부에서 get과 set 함수를 이용해 값을 저장하고 불러올 수 있습니다.      get: 값을 조회한다.   set: 값을 저장한다.   📄 Getter함수   Getter함수는 특정 값을 실행이 아닌 조회하려고 할 때 사용됩니다.   조회하려는 값을 return키워드를 사용해 조회합니다.   const numbers = {   a: 1,   b: 2,   get sum() {     console.log(\"sum함수가 실행됩니다.\");     return this.a + this.b;   }, };      const numbers라는 객체의 a와 b를 합한 값을 조회하는 Getter함수 sum.    📄 Setter함수   Setter함수는 객체나 함수 밖에서 값을 설정하려고 할 때 사용됩니다.   그렇기 때문에 Getter함수와는 다르게 파라미터 값 설정은 필수입니다.   const dog = {   _a: 1,    set name(value) {     this._a = value;   }, };   출처      패스트캠퍼스 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","get","set"],
        "url": "/javascript/javascript-get&set/",
        "teaser": null
      },{
        "title": "함수",
        "excerpt":"📄 함수   함수는 특정코드를 하나의 명령으로 실행할 수 있게 해주는 기능입니다.   함수는 파라미터가 주어졌을 때 파라미터를 처리해서 결과를 만듭니다.   📄 선언방법   함수를 선언할 때는 functions이라는 키워드를 사용합니다.   함수의 결과 값을 나타낼 때는 return이라는 키워드를 사용합니다.   return되는 순간 함수는 종료됩니다.   functions add(a,b) { // add라는 이름의 함수에 파라미터값으로 a와 b를 받아서, a + b의 결과값을 return시키는 함수.     return a + b; }   📄 선언적 함수   선언적 함수는 함수에 이름을 붙여서 선언합니다.    function hello1() {   // 함수 선언   console.log(\"hello1\"); }  hello1(); //함수 호출   결과     📄 익명함수   함수의 이름을 만들어주지 않고 특정 변수에 함수를 할당하는 방식입니다.   const hello1 = function () {   console.log(\"hello1\"); };   결과     📄 선언적 함수와 익명함수의 차이점   선언적 함수는 호출이 먼저 나와있어도 문제없이 실행되지만,  익명함수는 호출이 먼저 나오면 에러가 발생합니다.   hello1(); // 선언적 함수는 호출이 먼저 나와있어도 문제없이 실행. hello2(); // 익명함수는 호출이 먼저나오면 문제 발생 function hello1() {   //선언적 함수   console.log(\"hello1\"); }  var hello2 = function () {   console.log(\"hello2\"); };   결과     📄 리턴   리턴은 함수를 실행하면 얻는 값입니다.   const hello3 = function (name) {   return `hello ${name}`; };   작은따옴표(‘)가 아닌 백틱(`)를 써야 합니다.   함수 안에서 함수를 만들어 리턴   리턴값으로 함수를 지정하여 리턴할 수 있습니다.    function plus(base) {   return function (num) {     return base + num;   }; }  const plus5 = plus(5); console.log(plus5(10));   📄 인자로 함수를 사용   함수를 호출하는 경우 인자로 함수를 사용할 수 있습니다.    function hello(c) {   console.log(\"hello\");   c(); }  hello(function () {   console.log(\"콜백\"); });   결과   hello; 콜백;   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","함수"],
        "url": "/javascript/js-function/",
        "teaser": null
      },{
        "title": "비구조화 할당",
        "excerpt":"📄 비구조화 할당   비구조화 할당을 다른 말로 표현하면 객체 구조 분해라고 할 수 있습니다. 말 그대로 객체의 구조를 분해해서 특정값을 추출하는 과정을 비구조화 할당이라고 합니다.   const ironMan = {   name: \"토니 스타크\",   actor: \"로버트 다우니 주니어\",   alias: \"아이언맨\", };  const { name } = ironMan; //객체 ironMan에서 name이란 값을 추출함. console.log(name);   결과   토니 스타크   중괄호({})를 사용해서 선언한 객체의 원하는 키를 뽑아냅니다.   객체뿐만아니라 배열에서도 비구조화 할당을 할수 있습니다.   const array = [1, 2];  const [one, two = 2] = array;  console.log(one); console.log(two);   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체","비구조화 할당"],
        "url": "/javascript/javascript-destructuringAssignment/",
        "teaser": null
      },{
        "title": "spread & rest",
        "excerpt":"📄 spread 연산자   spread연산자는 ES6문법에서 처음으로 등장했습니다.   spread연산자는 객체나 배열의 엘리먼트를 요소 하나하나로 펼쳐서 사용할 수 있게 합니다.   ...라는 키워드를 사용합니다.   기존 객체나 배열을 복사하고 추가적인 값을 넣어줄 때 주로 사용합니다.   const first = {   one: 1, };  const second = {   ...first, //first의 엘리먼트를 가져옴.   two: 2, };  consol.log(first); consol.log(second);   ✔ 결과   { one: 1} { one: 1, two: 2}   장점           spread연산자는 기존객체를 변경시키지 않고 복사해옵니다.            코드의 재사용성이 높아집니다.       📄 rest 연산자   rest연산자도 마찬가지로 ...키워드를 사용합니다.   차이점은 ‘나머지’라는 뜻을 가진것처럼 정해준 값 이외의 값을 복사해온다는 것입니다.   const numbers = [0, 1, 2, 3, 4, 5, 6];  const [one, ...rest] = numbers; //첫번째 값을 제외한 값을 rest로 가져온다. console.log(one); console.log(rest);   ✔ 결과   0; [(1, 2, 3, 4, 5, 6)];   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","spread","rest"],
        "url": "/javascript/javascript-spread&rest/",
        "teaser": null
      },{
        "title": "불변객체(Immutable Object )",
        "excerpt":"📄 불변 객체란?   변수에 새로운 객체를 할당하더라도, 객체의 주소가 변하지 않는 객체   불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역메모리입니다.   불변 객체는 언제 필요할까?   모든 참조형 데이터가 가변성을 띠는 것은 아닙니다.   참조형 데이터가 가변성을 가질 때는 데이터 자체가 아닌 내부 프로퍼티를 변경하는 경우입니다.   내부 프로퍼티를 변경하면 변수가 가르키고 있는 데이터의 주소가 변경되기 때문입니다.   이러한 상황에서 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 불변객체가 필요합니다.   var user = {   name: \"Jaenam\",   gender: \"male\", };  var chanegeName = function (user, newName) {   var newUser = user;   newUser.name = newName;   return newUser; };  var user2 = chanegeName(user, \"Jung\");  if (user !== user2) {   console.log(\"유저 정보가 변경되었습니다.\"); // 실행되지 않음 } console.log(user.name, user2.name); console.log(user === user2);   결과    Jung Jung true   user과 newUser이 같은 데이터 주소를 참조하게 되어 newUser의 데이터가 변경될때 마다 user의 데이터도 변경됩니다.   따라서 user를 불변 객체로 만들어 줄 필요성이 보입니다.   📄 얕은 복사와 깊은 복사   1. 얕은 복사   중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.   얕은 복사를 하면 해당 프로퍼티에 대한 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키고, 사본을 바꾸면 원본이 바뀌고 원본을 바꾸면 사본이 바뀌는 현상이 일어납니다.   var copyObject = function (target) {   var result = {};   for (var prop in target) {     result[prop] = target[prop];   }   return result; };  var user = {   name: \"Jaenam\",   urls: {     portfolio: \"http://github.com/abc\",     blog: \"http://blog.com\",     facebood: \"http://facebook.com/abc\",   }, }; var user2 = copyObject(user);  user.name = \"Jung\"; console.log(user.name === user2.name); //false  user.urls.portfolio = \"http://portfolio.com\"; console.log(user.urls.portfolio === user2.urls.portfolio); // true  user2.urls.blog = \"\"; console.log(user.urls.blog === user2.urls.blog); //true   결과    false true true   user객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것을 확인할 수 있습니다..   user.urls의 프로퍼티에 대해서도 불변 객체로 만들 필요성이 생겼습니다.   깊은 복사   깊은 복사는 얕은 복사에서 한 단계 더 복사를 하는 것입니다.   객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하고, 참조형 데이터에는 다시 그 내부의 프로퍼티를 복사합니다.   var copyObjectDeep = function (target) {   var result = {};   if (typeof target === \"object\" &amp;&amp; target !== null) {     for (var prop in target) {       result[prop] = copyObjectDeep(target[prop]);     }   } else {     result = target;   }   return result; };   target이 객체인 경우 내부 프로퍼티를 순회하여 copyObjectDeep함수를 재귀적으로 호출하고, 원본과 사본이 서로 다른 객체를 참조하게 됩니다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","불변객체"],
        "url": "/javascript/javascript-immutableObject/",
        "teaser": null
      },{
        "title": "호이스팅(hoisting)",
        "excerpt":"📄 호이스팅(hoisting)   아래에 있는 선언을 먼저 끌어올리는 것을 호이스팅이라고 합니다.   변수나 함수를 먼저 호출하고 다음에 변수나 함수를 선언하게 되면 문제없이 함수의 결과값이 출력됩니다.    hello2(); // 함수 호출  function hello2() {   //함수 선언   console.log(\"hello2\"); }   함수뿐만 아니라 var키워드를 통한 호이스팅도 가능합니다.   age = 6; age++; console.log(age);  var age;   주의할 점   var로 변수를 선언함과 동시에 값을 지정했다면, 값을 제외한 선언만 호이스팅 됩니다.   console.log(name);  name = \"Mark\";  console.log(name);  var name = \"Sujin\";   결과      이렇게 호이스팅되어 먼저 출력된 name은 값을 제외한 선언만 끌어올리기 때문에 undifined라고 출력됩니다.   함수를 선언했을 때는 함수 전체를 끌어올립니다.   function a() {   var b; // 수집 대상 1. 변수는 선언부만 끌어올립니다.   function b() {} // 수집 대상 2. 함수 선언은 전체를 끌어올립니다.    console.log(b);   b = \"bbb\";   console.log(b);   console.log(b); } a();   결과   [Function: b] bbb bbb   📄 let을 이용한 호이스팅은 불가능!   let을 이용한 호이스팅은 불가능 합니다.   let은 무조건 선언이 우선시 되어야 합니다.   console.log(name);  name = \"MARK\";  console.log(name);  let name;   결과      출처      패스트캠퍼스 프론트엔드 강의   코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","호이스팅"],
        "url": "/javascript/javascript-hoisting/",
        "teaser": null
      },{
        "title": "명시적으로 this를 바인딩 하는 방법",
        "excerpt":"📄 명시적으로 this를 바인딩 하는 방법   this는 함수를 호출할 때 결정됩니다.   하지만 this가 가리키는 대상을 명시적으로 바인딩할 수 있습니다.   📄 call 메서드   call메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.   Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])      첫 번째 인자를 this로 바인딩한다.   이후 인자들은 호출할 함수의 매개변수이다.   var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, };  obj.method(2, 3); obj.method.call({ a: 4 }, 5, 6);   call메서드의 첫번째 인자로 this가 가리키는 a값을 4로 변경합니다.   ✔ 결과   1 2 3 4 5 6   📄 apply 메서드   Function.prototype.apply(thisArg[, argsArray])      첫 번째 인자를 this로 바인딩한다.   두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다.   var func = function (a, b, c) {   console.log(this, a, b, c); }; func.apply({ x: 1 }, [4, 5, 6]);  var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, }; obj.method.apply({ a: 4 }, [5, 6]);   ✔ 결과   { x: 1 } 4 5 6 4 5 6   call/apply 메서드는 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있지만, 그럼에도 불구하고 ES5이하의 환경에서는 마땅한 대안이 없어 실무에서 광범위하게 활용됩니다.   📄 bind 메서드   Function.prototype.bind(thisArg[, arg1, arg2, ...])   bind메서드는 call과 비슷하지만,  즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 함수이다.      함수에 this를 미리 적용한다.   부분 적용 함수를 구현한다.   var func = function (a, b, c, d) {   console.log(this, a, b, c, d); }; func(1, 2, 3, 4); // Window{...} 1 2 3 4  var bindFunc1 = func.bind({ x: 1 }); bindFunc1(5, 6, 7, 8); // (1) {x: 1} 5 6 7 8  var bindFunc2 = func.bind({ x: 1 }, 4, 5); bindFunc2(6, 7); // (2) {x: 1} 4 5 6 7 bindFunc2(8, 9); // {x: 1} 4 5 8 9      this를 { x: 1}로 지정했다.    매개변수로 6, 7을 넘기면 this값이 바뀐 겂을 제외하고는 최초 func함수에 4, 5, 6, 7을 넘긴 것과 같은 동작을 한다. this의 지정과 함께 부분 적용 함수를 구현한 것이다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","this"],
        "url": "/javascript/javascript-thisbinding/",
        "teaser": null
      },{
        "title": "클로저(Closer)",
        "excerpt":"📄 클로저란   클로저란   어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상이다.   📄 클로저의 동작 원리   var outer = function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; }; var outer2 = outer(); console.log(outer2()); console.log(outer2());     ```js 2; 3; ```  `inner`함수의 실행 시점에는 `outer`함수가 이미 종료 되었는데 `outer`함수의 **LexicalEnvitonment**에 접근했다.  바로 가비지 컬렉터의 동작 방식 때문이다.  **가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함하지 않는다.**  외부함수인 `outer`의 실행이 종료 되더라도  내부함수인 `inner`함수는 언젠가 `outer2`를 실행함으로써 호출될 가능성이 열렸기 때문에   가비지 컬렉터의 수집대상에 포함되지 않는다.  ## 클로저와 메모리 관리  클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수의 메모리를 소모하도록 함으로써 발생한다.  하지만 클로저의 필요성이 사라진 시점에는 더이상 메모리를 소모하지 않게 해주어야 한다.  방법은 **참조 카운터를 0으로 만들어 주는 것**이다.  식별자에 참조형이 아닌 기본형 데이터(보통`null` 또는 `undefined`)를 할당해주면 가비지 컬렉터가 값을 수거해 갈 것이다.  ```js var outer = (function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; })(); console.log(outer()); console.log(outer()); outer = null; // outer 식별자의 inner 함수 참조를 끊음 ```  ```js (function () {   var a = 0;   var intervalId = null;   var inner = function () {     if (++a &gt;= 10) {       clearInterval(intervalId);       inner = null; // inner 식별자의 함수 참조를 끊음     }     console.log(a);   };   intervalId = setInterval(inner, 1000); })(); ```  이렇게 식별자에 기본형 데이터 값을 대입해서 함수 참조를 끊으면 메모리를 효율적으로 관리할 수 있다.  ## 출처  - 코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클로저"],
        "url": "/javascript/js-closer/",
        "teaser": null
      },{
        "title": "옵셔널 체이닝",
        "excerpt":"📄 옵셔널 체이닝   옵셔널 체이닝(optional chaining) ?.을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.     ?.은 ?.‘앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.   let user = null;  alert( user?.address ); // undefined alert( user?.address.street ); // undefined   user?.address로 주소를 읽으면 아래와 같이 user 객체가 존재하지 않더라도 에러가 발생하지 않습니다.   📄 주의할 점      ?.는 존재하지 않아도 되는 괜찮은 대상에만 사용해아 합니다.   ?.앞의 변수는 꼭 선언되어 있어야 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","옵셔널체이닝"],
        "url": "/javascript/js-optionalchaning/",
        "teaser": null
      },{
        "title": "원시값의 메서드",
        "excerpt":"📄 원시값이란?   원시값은 객체가 아니면서 메서드도 가지지 않는 데이터를 뜻한다.   자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다.   원시값에서도 객체에서처럼 메서드를 호출할 수 있다는 뜻이다.   📄 원시값을 객체처럼 사용하는 과정   let str = \"Hello\";  alert(str.toUpperCase()); // HELLO      문자열 str은 원시값이므로 프로퍼티 toUpperCase에 접근하는 순간 특별한 객체가 만들어진다.   메서드가 실행되고, 새로운 문자열이 반환된다.   특별한 객체는 파괴되고 원시값 str만 남는다.   📄 왜 이런 내부 프로세스가 생겨난 것일까?   자바스크립트는 다양한 고유한 프로퍼티와 메서드를 가지는 내장 객체를 제공한다.  하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다.  객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.  따라서 원시값에 메서드를 호출해 임시객체를 만들고 작업이 완료되면 임시객체를 파괴한다.   📄 주의할 점   원시값은 추가 데이터를 저장할 수 없다.   let str = \"Hello\";  str.test = 5;  alert(str.test);   엄격모드에서는 래퍼 객체를 수정하려 할 때 에러가 발생하고,  비 엄격 모드에서는 에러가 발생하진 않고 래퍼 객체에 프로퍼티 test가 추가되지만 래퍼 객체는 바로 삭제되기 때문에 마지막 줄이 실행될 땐 프로퍼티 test를 찾을 수 없다.   출처      모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","원시값"],
        "url": "/javascript/js-primitive/",
        "teaser": null
      },{
        "title": "반복문(Iteration)",
        "excerpt":"📄 반복문 for   for문은 어떤 유한한 횟수만큼 반복할 때 사용합니다.   for(초기화; 반복 조건; 반복이 된 후 실행되는 코드) {     반복이 되는 코드 블럭  }   초기화 하면서 선언된 변수를 중괄호 안 반복 블럭에서 사용할 수 있습니다.   반복문 종료하기 | break   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &gt; 2) {     break;   }   console.log(\"안녕하세요\", i); }      i가 0부터 4까지 1씩 증가하면서 출력하는데, 만약 i가 2보타 큰 경우는 반복을 종료한다.    결과     반복문 넘기기 | continue   반복되는 블럭 안에서 continue를 만나면 거기서 바로 해당 블럭은 종료됩니다.   그리고 이와 같이 다음 반복이 있으면 다음 반복으로 넘어갑니다.   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &lt; 2) {     continue;   }   console.log(\"안녕하세요\", i); }   결과    for 무한 루프   소괄호 ()안에 아무것도 적지 않고 세미콜론 ;만 작성하면 조건이 생성되지 않아 무한으로 출력합니다.   이런 경우 보통 for문 안에서 if문으로 조건을 생성하기도 합니다.   for (;;) {   console.log(\"안녕하세요\");   if (Math.random * 100 &gt; 90) {     break;   } }      랜덤숫자*100 이 90보다 크면 반복문 종료    📄 for in   for in반복문은 객체의 속성들을 반복하여 작업을 수행합니다.   객체의 key값에는 접근할 수 있지만 value에는 접근할 수 없습니다.   for(let(또는 const) in 객체이름) {}  console.log(Object.keys(객체이름)); // 객체의 키 받아오기 console.log(Object.values(객체이름)); //키의 값 받아오기 console.log(Object.entries(객체이름)); //배열 형태로 키와 값을 반환   📄 for of   ES6에 추가된 for...of반복문은 배열안의 것들을 반복할 때 사용합니다.   for of 구문을 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.   var iterable = [10, 20, 30];  for (let value of iterable) {   console.log(value); // 10, 20, 30 }   주의할 점   for..in은 배열에 사용할 순 있지만 되도록 쓰지 않는 편이 좋습니다.  for..in반복문은 모든 프로퍼티를 대상으로 순회하기 때문에 키가 숫자가 아닌 프로퍼티도 순회 대상이 되어 필요 없는 프로퍼티들이 문제를 일으킬 가능성이 생깁니다.  또한 for..in반복문은 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다.    📌 객체에는 for...in, 배열에는 for...of를 사용하자   📄 while   무한 반복 루프를 작성할 때 for문 뿐만 아니라 while문으로도 작성할 수 있습니다.   while (true) {   console.log(\"안녕하세요\");   if (Math.random() * 100 &gt; 90) {     break;   } }      Math.random() * 100이 90보다 크면 반복문 종료    do while   while문이 최초로 한번은 무조건 실행하도록 합니다.   do {   // 최초 한번은 무조건 실행   console.log(\"안녕하세요\"); } while (Math.random() * 100 &gt; 90);   출처      패스트캠퍼스   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","반복문"],
        "url": "/javascript/javascript-iteration/",
        "teaser": null
      },{
        "title": "[클래스] 클래스(Class)",
        "excerpt":"📄 클래스(Class)란   자바스크립트는 기본적으로 객체지향언어를 지원합니다.   es6문법에 class가 추가되어 좀더 강력한 객체지향언어를 지향하게 되었습니다.   Class는 객체를 생성하기 위한 템플릿이자 함수의 한 종류입니다.   클래스는 데이터와 이를 조작하는 코드를 하나로 추상화합니다.   📄 선언적 방식   class A {     constructor() {...}     method1() {...}     method2() {...} } //class A 생성  console.log(new A()); // class A의 세로운 객체를 출력   결과   A {}   클래스를 만들고 new A()를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성됩니다.  클래스 내부에서 정의한 메서드는 A.prototype에 저장됩니다.  객체의 기본 상태를 설정해주는 생성자 메서드 constructor()는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화할 수 있습니다.   주의할 점      메서드 사이에는 쉼표가 없습니다.        클래스의 선언적 방식에서 호이스팅은 일어나지 않습니다.       new키워들를 통해 호출하지 않으면 에러가 발생합니다.   클래스에 정의된 메서드는 열거할 수 없습니다. 클래스의 prototype프로퍼티에 추가된 메서드의 enumerable플래그는 false입니다.   클래스는 항상 엄격모드로 실행됩니다.(use strict)   📄 클래스 표현식   클래스의 표현식을 변수에 할당하는 방식으로 사용됩니다.   const B = class {};  console.log(new B());   결과   B {}   📄 클래스 필드로 바인딩 된 메서드   자바스크립트에서 this는 동적으로 결정됩니다.   따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출하게 되면 this는 메서드가 정의된 객체를 참조하지 않습니다.   class Button {   constructor(value) {     this.value = value;   }    click() {     cosole.log(this.value);   } }  let button = new Button(\"안녕하세요\");  setTimeout(button.click, 1000);   결과   undefined;   this의 컨텍스트를 알 수 없게 된 현상을 ‘잃어버린 this‘라고 합니다.  이러한 현상을 해결하기 위해 클래스 필드를 사용할 수 있습니다.    class Button {   constructor(value) {     this.value = value;   }    click = () =&gt; {     // 수정한 부분     alert(this.value);   }; }  let button = new Button(\"안녕하세요.\");  setTimeout(button.click, 1000);   결과   안녕하세요.   클래스 필스 click = () =&gt; {...}는 각 Button객체마다 독립적인 함수를 만들어주고 이 함수의 this를 해당 객체에 바인딩시켜줍니다.  클래스의 이러한 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야할 때 특히 유용합니다.   📄 멤버변수   멤버 변수는 메소드 밖에서 선언된 변수를 뜻합니다. 클래스의 멤버변수는 this라는 키워드를 사용하여 반드시 생성자에 만들어야 합니다.   class C {   name = \"no name\"; // 초기값 설정   age = 0;    constructor(name, age) {     // 생성자를 통해서 새로 할당.     this.name = name; // 멤버변수     this.age = age; // 멤버변수   } }  console.log(new C(\"Mark\", 37));   결과   C { name: 'Mark', age: 37 }   📄 멤버 함수   클래스에는 멤버변수 뿐만 아니라 멤버 함수도 생성할 수 있습니다.   class A {   // 방법1: 함수의 이름과 중괄호를 이용해 설정   hello1() {     console.log(\"hello1\", this);   }   // 방법2: 멤버변수 이름에 함수를 할당하는 방법   hello2 = () =&gt; {     console.log(\"hello2\", this);   }; }  new A().hello1(); new A().hello2();   결과   hello1 A { hello2: [Function: hello2] } hello2 A { hello2: [Function: hello2] }   출처           패스트캠퍼스              MDN web docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스"],
        "url": "/javascript/js-class/",
        "teaser": null
      },{
        "title": "프로토타입(prototype)",
        "excerpt":"📄 프로토타입이란?   프로토타입의 한국어 뜻은 원형입니다.   프로토타입은 말 그대로 객체의 원형이라고 할 수 있는 것입니다.   Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용합니다.           생성자 함수에 기본으로 세팅되는 프로퍼티(F.prototype)는 [[Prototype]]과 다릅니다. F.prototype은 new F()를 호출할 때 만들어지는 새로운 객체의 [[Prototype]]을 설정합니다.       F.prototype의 값은 객체나 null만 가능합니다. 다른 값은 무시됩니다.   굳이 this라는 자기참조변수를 사용하지 않고 prototype으로 변수 p에 hello라는 함수를 할당했다.   function Person(name, age) {   this.name = name;   this.age = age;   //this.hello = function() {   //    console.log('hello', this.name, this.age);   //} }  Person.prototype.hello = function () {   console.log(\"hello\", this.name, this.age); };  const p = new Person(\"Mark\", 37);  p.hello();   결과   hello Mark 37   function Person() {} //Person함수 생성  Person.prototype.hello = function () {   //Person의 프로토타입으로 hello 함수 생성   console.log(\"hello\"); };  function Korean(region) {   //Korean 함수 생성   this.region = region;   this.where = function () {     console.log(\"where\", this.region);   }; }  Korean.prototype = Person.prototype; // 프로토타입을 이용해 부모의 프로퍼티를 자식의 프로퍼티에 할당  const k = new Korean(\"Seoul\"); // 변수 k에 객체 할당  k.hello(); k.where();   결과   hello1 where Seoul   📄 프로토타입 장점   프로토타입의 장점은 함수의 재사용성을 높인다는 것입니다.   프로토 타입을 사용해서 함수 밖에서 새로운 함수나 값을 선언한다면,   새로운 함수나 값을 기존 함수에 할당할 필요없이 prototype이라는 키워드 하나로 바로 사용가능하기 때문에 코드가 훨씬 간결해집니다.   📄 프로토타입 체인   프로토타입을 이용해 서로 이어져 있는 집합을 프로토타입 체인이라고 합니다.   위의 코드에 다음과 같은 코드를 이어서 작성합니다.   console.log(k instanceof Korean); console.log(k instanceof Person); console.log(k instanceof Object);   true; true; true;      Korean이 Person을 상속하고, Person이 Object를 상속하므로 true값이 나왔다.   느낀 점   자바스크립트 공부하면서 제일 난관에 봉착했다.  뭔가 알듯 말듯 헷갈리는 개념이다.  강의를 끝나면 모던자바스크립트튜토리얼도 보고 책도 보고 할텐데 그 과정에서 익숙해지며 습득될 수 있도록 꼼꼼히 학습해야겠다.     출처           패스트캠퍼스 프론트엔드 강의              생활코딩              MDN Web Docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","프로토타입"],
        "url": "/javascript/js-prototype/",
        "teaser": null
      },{
        "title": "[클래스] 정적 메서드와 정적 프로퍼티",
        "excerpt":"📄 정적 메서드(static method)   정적 메서드는 프로토타입이 아닌 클래스 함수 자체에 설정되어 있는 메서드이다.  클래스 안에서 static이라는 키워드를 사용해서 설정한다.   class User {   static staticMethod() {...} }   정적 메서드의 this는 무엇을 가리킬까?   클래스의 메서드가 호출될 때  this의 값은 클래스 생성자 그자체가 된다.    정적 메서드는 언제 사용할까?   정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 사용한다.  데이터베이스 관련 클래스에도 사용되곤한다.    📄 정적 프로퍼티(static property)   정적 프로퍼티또한 static이라는 키워드를 사용한다.   class User {   static staticProperty = \"John\"; }   정적 프로퍼티는 언제 사용할까?   정적 프로퍼티는 데이터를 클래스 수순에 저장하고 싶을 때 사용한다.  정적 프로퍼티 역시 개별 인스턴스에 묶이지 않는다.   정적 프로퍼티와 메서드의 상속   정적 프로퍼티와 정적 메서드는 상속이 가능하다.    class Animal {} class Rabbit extends Animal {}  // 정적 메서드 consol.log(Rabbit.__proto__ === Animal); // true  // 일반 메서드 consol.log(Rabbit.prototype.__proto__ === Animal.prototype); // true   클래스 Rabbit의 프로토타입이 클래스 Animal을 가리키게 한다.  따라서 Rabbit에서 원하는 프로퍼티나 메서드를 찾지 못하면 Animal로 검색이 이어진다.   출처   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","정적메서드","정적프로퍼티"],
        "url": "/javascript/js-static-method/",
        "teaser": null
      },{
        "title": "Promise",
        "excerpt":"📄 promise   프로미스는 주로 서버에서 데이터를 받아올 때 사용합니다.   서버에 요청을 보내고 데이터를 받아올 때, 아직 데이터를 다 받아오기도 전에 데이터를 다 받아온것 처럼 화면에 데이터를 표시하고 오류가 발생합니다.   이런 문제점을 해결하는 방법이 프로미스 입니다     프로미스는 ES6부터 JavaScript의 표준 내장 객체로 추가되었습니다.   📄 promise 처리 흐름   1. 프로미스가 생성자를 통해서 생성되면 pending(대기)상태가 됩니다.   new Promise((resolve, reject) =&gt; {}); //pending   2-1. pending상태로 돌입한 후 excutor 함수 인자 중 하나인 resolve 함수를 실행하면, fulfilled(이행)상태가 됩니다.   new Promise((resolve, reject) =&gt; {   // pending상태   // ... 비동기적인 상황이 되는 처리가 벌어짐.   resolve(); // fulfilled });   2-2. excutor 함수 인자 중 하나인 reject 함수를 실행하면, rejected (거부) 상태가 됩니다.   new Promise((resolve, reject) =&gt; {   reject(); //rejected });   3-1. 프로미스 객체가 fulfilled 되는 시점에 .then 안에 설정한 callback 함수가 실행됩니다.   p.then(/*callback*/);      p라는 프로미스 객체의 callback이 실행됨.    excutor의 resolve함수를 실행할 때 인자를 넣어 실행하면, then의 callback 함수의 인자로 받을 수 있습니다.   resolve('hello'); then((message) =&gt; {...})   3-2. 마찬가지로 프로미스 객체가 rejected되는 시점에 .catch안에 설정한 callback함수가 실행됩니다.   catch(() =&gt; {     console.log('/*callback*/'); });   executor의 reject 함수를 실행할 때 인자를 넣어 실행하면, catch의 callback함수의 인자로 받을 수 있습니다.   reject('error'); catch((reason) =&gt; {...})   보통 reject 함수를 실행하며 rejected 되는 이유를 넘기는데, 표준 내장 객체인 Error의 생성자를 이용하여 Error 객체를 만들 수 있습니다.   reject(new Error('bad')); catch((error) =&gt; {...});   4. fulfilled 되거나 rejected 된 후에 최종적으로 실행할 것이 있다면, .finally()를 설정하고, 함수를 인자로 넣습니다.   finally(() =&gt; {...});   📄 callback vs promise   비동기 작업을 하는 방법은 주로 callback과 promise가 있습니다.   1. callback   보통 비동기 작업을 할 때, callback함수를 인자로 넣어 로직이 끝나면 callback함수를 호출합니다.   이런 경우 함수가 아래로 진행되지 않고, callback 함수 안으로 진행됩니다.   function c(callback) {   setTimeout(() =&gt; {     callback();   }, 1000); }  c(() =&gt; {   console.log(\"1000ms 후에 callback 함수가 실행됩니다.\"); });  c(() =&gt; {   c(() =&gt; {     c(() =&gt; {       console.log(\"3000ms 후에 callback 함수가 실행됩니다\");     });   }); }); //callback hell (콜백 지옥)   2. promise 체이닝   promise방식에서는 then 함수에서 다시 프로미스 객체를 리턴하는 방법을 통해 체이닝하면, 비동기 적업을 순차적으로 아래로 표현할 수 있습니다.   function p() {   return new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {       resolve();     }, 1000);   }); }  p()   .then(() =&gt; {     return p(); // 다시 새로운 프로미스 객체를 만들어서 리턴한다.   })   .then(() =&gt; p())   .then(p)   .then(() =&gt; {     console.log(\"4000ms 후에 fulfilled 됩니다.\");   });   📄 value가 프로미스 객체인지 알 수 없는 경우   연결된 then 메서드를 실행합니다.   value가 프로미스 객체면, resolve 된 then 메서드를 실행합니다.   value가 프로미스 객체가 아니면, value를 인자로 보내면서 then메서드를 실행합니다.   Promise.resolve(/* value */); //프로미스라는 전역객체의 resolve함수를 실행하면서 동시에 promise를 만들어낸다.  Promise.resolve(   new Promise((resolve, reject) =&gt; {     // 비동기 프로미스 객체를 생성해서 resolve의 인자인 value값으로 설정.     setTimeout(() =&gt; {       resolve();     }, 1000);   }) ).then((data) =&gt; {   console.log(     \"프로미스 객체인 경우, resolve 된 결과를 받아 then이 실행됩니다.\",     data   ); });  Promise.resolve(\"bar\").then((data) =&gt; {   console.log(\"then 메서드가 없는 경우, fulfilled됩니다.\", data); });   promise.reject를 사용하면, catch로 연결된 rejected 상태로 변경됩니다.   Promise.reject(/* */);  Promise.reject(new Error(\"reason\"))   .then((error) =&gt; {})   .catch((error) =&gt; {     console.log(error);   });   📄 promise 객체를 배열로 생성하기   promise.all   프로미스 객체를 여러개를 생성하여,   배열로 만들어 인자로 넣고 Promise.all을 실행하면,   배열의 모든 프로미스 객체들이 fulfilled 되었을 때, then의 함수가 실행됩니다.   then의 함수의 인자로 프로미스 객체들의 resolve 인자값을 배열로 돌려줍니다.   Promise.all([프로미스 객체들]);   promise.all에 전달되는 프라미스 중 하나라도 거부되면, Promise.all이 반환하는 프라미스는 에러와 함께 바로 거부됩니다.   promise.allSettled   Promise.allSettled는 모든 프라미스가 처리될 때까지 기다립니다.   반환되는 배열은 다음과 같은 요소를 갖습니다.      응답이 성공할 경우 – {status:”fulfilled”, value:result}   에러가 발생한 경우 – {status:”rejected”, reason:error}   let urls = [   \"https://api.github.com/users/iliakan\",   \"https://api.github.com/users/Violet-Bora-Lee\",   \"https://no-such-url\", ];  Promise.allSettled(urls.map((url) =&gt; fetch(url))).then((results) =&gt; {   results.forEach((result, num) =&gt; {     if (result.status == \"fulfilled\") {       alert(`${urls[num]}: ${result.value.status}`);     }     if (result.status == \"rejected\") {       alert(`${urls[num]}: ${result.reason}`);     }   }); });   결과   [   {status: 'fulfilled', value: ...응답...},   {status: 'fulfilled', value: ...응답...},   {status: 'rejected', reason: ...에러 객체...} ]   promise.race   프로미스 객체 여러개를 생성하여,   배열로 만들어 인자로 넣고 Promise.race를 실행하면,   배열의 모든 프로미스 객체들 중 가장 먼저 fulfiiled된 것으로, then의 함수가 실행됩니다.   then의 함수의 인자로 가장 먼저 fulfilled 된 프로미스 개체의 resolve 인자값을 돌려줍니다.   Promise.race([프로미스 객체들]);   출처           패스트캠퍼스 강의              캡틴판교      ","categories": ["JavaScript"],
        "tags": ["JavaScript","Promise"],
        "url": "/javascript/javascript-promise/",
        "teaser": null
      },{
        "title": "콜백(Callback)",
        "excerpt":"📄 콜백   콜백 함수는 다른 코드를 인자로 넘겨주는 함수이다.  다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한다. 자바스크립트는 호스트 환경이 제공하는 여러 함수를 사용하면 비동기 동작을 수행할 수 있다.   📄 콜백은 어떤 경우에 사용될까?   function loadScript(src) {   // &lt;script&gt; 태그를 만들고 페이지에 태그를 추가합니다.   // 태그가 페이지에 추가되면 src에 있는 스크립트를 로딩하고 실행합니다.   let script = document.createElement(\"script\");   script.src = src;   document.head.append(script); }  loadScript(\"/my/script.js\"); // script.js엔 \"function newFunction() {…}\"이 있습니다.  newFunction(); // 함수가 존재하지 않는다는 에러가 발생합니다!   new Function()에서 에러가 발생하는 이유는 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문이다.    function loadScript(src, callback) {   let script = document.createElement('script');   script.src = src;    script.onload = () =&gt; callback(script);    document.head.append(script); }  loadScript('/my/script.js', function() {   // 콜백 함수는 스크립트 로드가 끝나면 실행됩니다.   newFunction(); // 이제 함수 호출이 제대로 동작합니다.   ... });   loadScript의 두 번째 인수에 스크립트 로딩이 끝난 후 실행될 함수인 콜백 함수를 추가했다.  두 번째 인수로 전달되 함수는 원하는 동작이 완료되었을 떄 실행된다.     이것을 콜백 기반 비동기 프로그래밍이라고 부른다.  비동기적으로 수행되어야할 필요성을 가진 코드에 콜백을 기반으로 접근할 수 있다.   📄 오류 우선 콜백   콜백함수를 이용해서 에러를 핸들링할 수 있다.   function loadScript(src, callback) {   let script = document.createElement(\"script\");   script.src = src;    script.onload = () =&gt; callback(null, script);   script.onerror = () =&gt;     callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));    document.head.append(script); }  loadScript(\"/my/script.js\", function (error, script) {   if (error) {     // 에러 처리   } else {     // 스크립트 로딩이 성공적으로 끝남   } });   오류 우선 콜백의 관례      callback의 첫 번째 인수는 에러를 위해 남겨둔다. 에러가 발생하면 이 인수를 이용해 callback(err)이 호출된다.   두 번째 인수는 에러가 발생하지 않았을 때를 위해 남겨둔다. 원하는 동작이 성공한 경우엔 callback(null, result1, result2)가 호출된다.   오류 우선 콜백의 장점   오류 우선 콜백을 사용하면, 단일 콜백 함수에서 에러 케이스와 성공 케이스 모두를 처리할 수 있다.   출처      코어 자바스크립트   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","콜백"],
        "url": "/javascript/js-callback/",
        "teaser": null
      },{
        "title": "JS 문자열을 HTML 개체로 변환",
        "excerpt":"📄 JS 문자열을 HTML 개체로 변환   자바스크립트에서 작성한 문자열을 innerHTML 속성을 이용해 HTML로 변환시켜 주는 방법입니다.   const stringToHTML = function (str) {   const dom = document.createElement(\"div\");   dom.innerHTML = str;   return dom; }; console.log(stringToHTML(`&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;p&gt;How are you today?&lt;/p&gt;`));   결과   &lt;div&gt;   &lt;h1&gt;Hello world&lt;/h1&gt;   &lt;p&gt;How are you today?&lt;/p&gt; &lt;/div&gt;      domcument에 div 엘리먼트를 추가한다.   새로 생성된 div 인스턴스는 dom과 연결된다.   dom의 경우 innerHTML 속성을 설정해서 HTML 개체로 변환한다.   return은 strinToHTML 함수에 대한 dom 인스턴스가 된다.   출처      DelftStack-JavaScript에서 문자열을 HTML로 변환  ","categories": ["JavaScript"],
        "tags": ["JavaScript","문자열","HTML"],
        "url": "/javascript/javascript-stringtohtaml/",
        "teaser": null
      },{
        "title": "배열 내장 함수",
        "excerpt":"📄 배열 내장함수   자바스크립트 배열에는 자체적으로 내장되어 있는 함수들이 있습니다.   이 함수들을 잘 활용한다면 코드가 더욱 간결해지고 가독성이 높아질 수 있습니다.   📄 forEach   forEach함수는 기존의 for문을 대체할 수 있습니다.   const array = [a, b, c, d];  superheroes.forEach((item) =&gt; {   console.log(item); });   forEach의 파라미터로 각 원소에 대하여 처리하고 싶은 코드를 함수로 넣어줍니다.   이렇게 주어진 함수를 배열 요소 각각에 대해 실행합니다.   📄 map   map은 배열 안의 각 원소를 변환할 때 사용하며,   결과 값이 담긴 새로운 배열을 생성합니다.     map 함수의 파라미터로는 변화를 주는 함수를 전달해줍니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((n) =&gt; n * n);   map을 사용하면서 index값을 얻고 싶다면 함수의 두번째 파라미터를 이용하면 됩니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((currentElement, index) =&gt; {   console.log(\"The current iteration is: \" + index); // 배열의 인덱스 값   console.log(\"The current element is: \" + currElement); // 배열의 현재 값 });   📄 IndexOf   IndexOf는 배열에서 원하는 항목이 몇번째 원소인지 찾아주는 함수입니다.   const superheroes = [\"아이언맨\", \"캡틴 아메리카\", \"토르\", \"닥터 스트레인지\"];  const index = superheroes.indexOf(\"토르\");   함수의 파라미터로 원하는 값을 넣어주면 몇번째 함수인지 반환합니다.   📄 findIndex &amp; find   만약 찾고자 하는 배열안의 값이 숫자나 문자열이라면 indexOf를 사용하지만   배열안의 값이 객체이거나 배열인 경우에는 사용할 수 없습니다.   그럴경우 사용하는 함수가 findIndex와 find입니다.   findIndex함수를 사용하고자 하면 함수에 검사하고자 하는 조건을 반환하는 함수를 넣습니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   }, ];  const index = todos.findIndex((todo) =&gt; todo.id === 3);      배열 todos에서 id가 3인 값의 index를 반환한다.    결과   `2`;   만약 Index아닌 객체나 배열의 값 전체를 반환하고자 하면 find함수를 사용합니다.   const index2 = todos.find((todo) =&gt; todo.id === 3);   결과   { id: 3, text: '객체와 배열 배우기', done: true }   📄 filter   filter함수는 특정조건을 만족하는 원소를 찾아서 그 원소들을 새로운 배열로 만듭니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   },   {     id: 4,     text: \"배열 내장함수 배우기\",     done: false,   }, ];  const tasksNotDone = todos.filter((todo) =&gt; todo.done === false); console.log(tasksNotDone);   결과   [{ id: 4, text: \"배열 내장함수 배우기\", done: false }];   📄 splice &amp; slice   splice함수 사용법   const spliced = 배열.splice(index number, n);      index number인 원소부터 n개를 지우겠다.    slice함수 사용법   const sliced = 배열.slice(index number, n);      index number인 원소부터 n개를 잘라내 새로운 배열을 생성한다.    공통점   두 함수 모두 배열을 잘라낼 때 사용합니다.   차이점   splice로 배열을 잘라내면 기존배열이 그대로 잘리지만, slice로 배열을 잘라내면 기존배열이 유지됩니다.   📄 shift &amp; unshift      shift: 배열의 첫번째 원소를 추출합니다.   unshift: 배열의 맨 앞에 원소를 추가합니다.   const value = numbers.shift(); // value라는 값에 배열 numbers의 첫번째 원소 할당. numbers.unshift(5); // 배열 numbers의 마지막 자리에 원소 5 추가.   📄 push &amp; pop      push: 배열의 마지막 원소를 추가합니다.   pop: 배열의 마지막 자리에 있는 원소를 추출합니다.   numbers.push(50); // numbers라는 배열에 값 50 추가 const value = numbers.pop(); // value에 numbers의 마지막 원소 할당   📄 reduce   reduce함수는 배열의 각 요소에 대해 주어진 리듀서 함수를 실행합니다.   배열안의 각 요소를 순회하며 callback함수의 실행 값을 누적하여 하나의 결과값을 반환합니다.   arr.reduce(callback, initialValue);   callback함수는 4개의 파라미터 값을 받습니다.      누산기 (acc): 콜백의 반환값을 누적합니다.   현재 값(cur): 처리할 현재 요소   현재 인덱스(idx): 처리할 현재 요소의 인덱스   원본 배열(src): reduce()를 호출한 배열   const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((acc, cur, idx) =&gt; {   return (acc += cur); }, 0); // 0은 초기값 console.log(result); // 15   출처           패스트캠퍼스 프론트엔드 강의            MDN      ","categories": ["JavaScript"],
        "tags": ["JavaScript","forEach","map","IndexOf","findIndex","filter","splice","slice","shift","push","pop","reduce"],
        "url": "/javascript/javascript-arrayfunction/",
        "teaser": null
      },{
        "title": "Fetch",
        "excerpt":"📄 Fetch   : 원격 API를 호출할 수 있는 자바스크립트 내장 함수   📄 Fetch 사용법   Fetch함수는 두가지의 인자를 받습니다.      URL   옵션객체   인자를 받아 Promise객체를 반환합니다.   반환된 객체는 API호출이 성공했을 때 응답(response) 객체를 resolve하고 실패했을 때는 예외(error)객체를 reject합니다.   fetch(url, options)   .then((response) =&gt; response.json())   .catch((error) =&gt; console.log(\"error:\", error));      Response: HTTP 응답 전체를 나타내는 객체. JSON 본문 콘텐츠를 추출하기 위해서는 json()메서드를 호출해야 합니다.   📄 GET 호출: 데이터 불러오기   fetch함수의 기본적인 동작은 GET입니다.   fetch(\"https://jsonplaceholder.typicode.com/posts/1\").then((response) =&gt;   console.log(response) );   ✔ 결과   Response {status: 200, ok: true, redirected: false, type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts/1\", …}   응답(response) 객체는 json메서드를 제공합니다.   json()을 호출하면 응답 객체로부터 JSON 포멧의 응답을 자바스크립트 객체로 변환해서 얻을 수 있습니다.   // json()을 활용하여 응답객체를 자바스크립트 객체로 변환 fetch(\"https://jsonplaceholder.typicode.com/posts/1\")   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   {   \"userId\": 1,   \"id\": 1,   \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",   \"body\": \"quia et suscipit↵suscipit recusandae consequuntur …strum rerum est autem sunt rem eveniet architecto\" }   📄 POST 호출: 데이터 생성하기   POST는 원격 API에서 관리하고 있는 데이터를 생성할 때 사용합니다.      method 옵션을 POST로 지정한다.   headers옵션을 통해 JSON포멧을 사용한다고 알려준다.   요청 전문을 JSON 포멧으로 직렬화하여 body옵션에 설정해준다.   fetch(\"https://jsonplaceholder.typicode.com/posts\", {   method: \"POST\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), }).then((response) =&gt; console.log(response));   ✔ 결과: 응답코드가 201 Created   Response {type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts\", redirected: false, status: 201, ok: true, …}  // json메서드로 응답객체를 호출했을 때(response.json()) {title: \"Test\", body: \"I am testing!\", userId: 1, id: 101}   📄 PUT, DELETE: 데이터 수정, 삭제하기   PUT과 DELETE는 데이터를 수정하거나 데이터를 삭제할 때 사용됩니다.   // PUT fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"PUT\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과     {title: \"Test\", body: \"I am testing!\", userId: 1, id: 1}   DELETE는 보낼 데이터가 없어 header와 body옵션이 필요하지 않습니다.   // DELETE fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"DELETE\", })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   { }   📄 fetch 함수 커스텀화 하기   async function post(host, path, body, headers = {}) {   const url = `https://${host}/${path}`;   const options = {     method: \"POST\",     headers: {       \"Content-Type\": \"application/json\",       ...headers,     },     body: JSON.stringify(body),   };   const res = await fetch(url, options);   const data = await res.json();   if (res.ok) {     return data;   } else {     throw Error(data);   } }  post(\"jsonplaceholder.typicode.com\", \"posts\", {   title: \"Test\",   body: \"I am testing!\",   userId: 1, })   .then((data) =&gt; console.log(data))   .catch((error) =&gt; console.log(error));   출처      MDN-Fetch 사용하기   DaleSeo-fetch()함수로 원격 API호출하기  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Fetch"],
        "url": "/javascript/javascript-fetch/",
        "teaser": null
      },{
        "title": "getElementById 와 querySelector 비교",
        "excerpt":"📄 getElementById 와 querySelector 비교   getElementById와 querySelector의 공통점은 엘리먼트를 검색해서 반환한다는 것입니다.   하지만 둘의 사용법은 다르며 사용하는 상황에서 차이점을 드러냅니다.   📄 getElementById와 querySelector의 차이점   getElementById      id를 통해 엘리먼트를 반환한다.   만약 document에 해당 id가 없다면 null을 반환한다.   querySelector      selector의 구체적인 그룹과 일치하는 document의 첫번째 엘리먼트를 반환한다.   일치하는 요소가 없다면 null을 반환한다.   ✔ 예시   &lt;form id=\"userForm\"&gt;   &lt;input id=\"username\" type=\"text\" value=\"Guilherme\"&gt; &lt;/form&gt;   getElementById로 username을 가져올 때:   var username = document.getElementById(\"username\");   querySelector로 username을 가져올 때:   var username = document.querySelector(\"#userForm #username\");   =&gt; 결과는 같지만 querySelector로 가져올 때 더 구체적이고 한정적이다.   📄 querySelectorAll vs selectElementByClassName   하나가 아니라 여러개의 요소를 하나의 이름으로 한번에 얻고 싶을 때 사용하는 방법이다.   ✔ 예시   &lt;form id=\"productForm\"&gt;   &lt;input id=\"productOne\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productTwo\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productThree\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt; &lt;/form&gt;   getElementByClassName으로 가져올 때: HTMLCollection에 리턴   var products = document.getElementByClassName(\"product\");   querySelectorAll로 가져올 때: NodeList에 리턴   var products = document.querySelectorAll(\"#productForm .product\");   둘다 인덱스를 제공해 인덱스 번호로 접근이 가능하지만, HTMLCollection항목은 name과 id속성으로도 접근할 수 있다.     엘리먼트에 접근할 때 방법이 두가지가 있어 어떤 상황에 어느 것을 사용하는지 궁금해서 정리를 시작했다.   구체적으로 엘리먼트를 선택하고 싶다면 querySelector를,   좀더 빠른 성능으로 접근하고 싶다면 getElementById를 사용하는 것이 좋다.   출처   *guinatal.github - qeurySelector vs getElementById  ","categories": ["JavaScript"],
        "tags": ["JavaScript","getElementById","querySelector"],
        "url": "/javascript/javascript-getElementById&querySelector/",
        "teaser": null
      },{
        "title": "JSON (JavaScript Object Notation)",
        "excerpt":"📄 JSON (JavaScript Object Notation)   : 데이터를 쉽게 교환하고 저장하기 위한 텍스트기반의 데이터 교환 표준   텍스트 기반이다 ❔   어떤 프로그래밍 언어에서도 JSON 데이터를 읽고 사용할 수 있다 ❕   즉, 데이터를 교환할때 어떤 프로그래밍언어도 쓸 수 있는 방법이다.   📄 JSON과 XML   XML(EXtensible Markup Language)은 문자기반의 마크업 언어로 데이터를 보여주는 것이 아닌 저장하고 전달하는 것 만을 목적으로 만들어졌다.   공통점      둘다 데이터를 저장하고 전달하기 위해 만들어졌다.   사람도 읽을 수 있다.   계층적인 데이터구조를 가진다.   다양한 프로그래밍 언어에 의해 파싱될 수 있다.   XMLHttpRequest 객체를 이용하여 서버로부터 데이터를 전송받을 수 있다.   차이점      JSON은 종료 태그를 사용하지 않는다.   JSON의 구문이 XML의 구문보다 짧다.   JSON 데이터가 XML 데이터보다 더 빨리 읽고 쓸 수 있다.   XML은 배열을 사용할 수 없지만, JSON은 배열을 사용할 수 있다.   XML은 XML 파서로 파싱되고, JSON은 자바스크립트 표준함수인 eval()함수로 파싱된다.   // XML 예제 &lt;dog&gt;     &lt;name&gt;식빵&lt;/name&gt;     &lt;family&gt;웰시코기&lt;family&gt;     &lt;age&gt;1&lt;/age&gt;     &lt;weight&gt;2.14&lt;/weight&gt; &lt;/dog&gt;  // JSON 예제 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }   JSON은 XML보다 더 빠른 처리속도를 가지고 있지만 전송받은 데이터의 무결성을 직접 인증해야하는 특징을 가지고 있다.   📄 JSON 문법   JSON은 객체 표기법 중 리터럴(literal)과 프로퍼티(property)를 표현하는 방법을 쓴다.      리터럴: 변수가 아닌 해석되는 값 자체 ex) 12(숫자 리터럴), “JSON”(문자열 리터럴), true(불리언 리터럴)   객체: 이름(name)과 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합   // 네쌍의 프로퍼티로 구성된 객체 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }      JSON에서 주석을 사용하는것은 권장하지 않는다.   undefined 와 null   JSON에서는 undefined타입을 제공하지 않는다. 자바스크립트와 다르게 JSON에서 null은 값을 가지고 있지 않다는 의미를 가지는 하나의 데이터값을 가지고 있기 때문에 유의해서 사용해야 한다.   📄 자바스크립트와 JSON   자바스크립트에서 JSON을 사용하기 위해 3가지의 메소드를 제공한다.      JSON.stringify(): 인수로 전달받은 자바스크립트 객체를 문자열로 변환   JSON.parse(text): 인수로 받은 문자열을 자바스크립트 객체로 변환   toJSON: 자바스크립트의 Date 객체의 데이터를 JSON 형식의 문자열로 변환. Date.prototype 객체에서만 사용할 수 있다.   // toJSON 예제 var date = new Date(); // 자바스크립트 Date 객체  var str = date.toJSON(); // Date 객체를 JSON 형식의 문자열로 변환함.  document.getElementById(\"json\").innerHTML = date + \"&lt;br&gt;\";  document.getElementById(\"json\").innerHTML += str;   출처      TCP SCHOOL.com-JSON  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Json"],
        "url": "/javascript/javascript-json/",
        "teaser": null
      },{
        "title": "디바운싱(Debouncing)",
        "excerpt":"📄 디바운싱(debouncing)      이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술   연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것   디바운싱 기술는 검색 기능을 구현하는 경우에 가장 많이 사용됩니다.   이런 경우에는   j ja jav java   처럼 키워드 하나하나 인식해서 키워드 하나에 매번 이벤트가 발생하게 됩니다.   이렇게 처리해야하는 일이 여러번의 요청이 있을때 최종(혹은 처음) 요청의 처리결과만 내놓게 하는게 디바운싱입니다.   var timer; document.querySelector(\"#input\").addEventListener(\"input\", function (e) {   if (timer) {     clearTimeout(timer);   }   timer = setTimeout(function () {     console.log(\"여기에 ajax 요청\", e.target.value);   }, 200); });      타자를 칠 때(input 이벤트 발생)마다 타이머를 설정한다.   200ms동안 입력이 없으면 입력이 끝난 것으로 한다. (시간 자유 설정 가능)   200ms 이전에 타자 입력이 발생하면 이전 타이머는 취소하고 새로운 타이머를 다시 설정한다.   출처      제로초-쓰로틀링과 디바운싱  ","categories": ["JavaScript"],
        "tags": ["JavaScript","디바운싱"],
        "url": "/javascript/javascript-debouncing/",
        "teaser": null
      },{
        "title": "배열 중복 요소 없애기 (Set)",
        "excerpt":"📄 Set   배열을 다룰때 Set함수를 사용하면 중복된 요소를 없애고 값을 한번만 보여줍니다.   Set은 객체로 다루어지지만 배열의 타입이 Object이기 때문에 사용할 수 있습니다.   📄 Set 사용하기   var mySet = new Set();   mySet은 중복된 요소가 있으면 하나만 남기고 사라집니다.   mySet.add(1); // Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add(\"some text\"); // Set { 1, 5, 'some text' }   5를 두번 추가했지만 한개만 남습니다.   this.setHistoryData = (histData) =&gt; {   const avoidDulpli = [...new Set([histData, ...this.state.historyList])];   if (avoidDulpli.length &gt; 5) {     avoidDulpli.pop();   }   this.setState({     ...this.state,     historyList: avoidDulpli,   }); };   구현하던 프로젝트에서 검색기록을 내는 코드입니다.   검색한 데이터(histData)를 받아서 새로운 배열 avoidDulpli를 만들고,   new Set을 이용해 중복된 값은 제거되는 새로운 배열을 만들어 받아온 데이터(histData)가 앞에 추가됩니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Set"],
        "url": "/javascript/javasrcipt-arraySet/",
        "teaser": null
      },{
        "title": "이미지 랜덤 배치",
        "excerpt":"📄 이미지 랜덤 배치하기   목표: Vanila JavaScript로 새로고침 될 때마다 이미지가 특정 범위에 랜덤으로 배치된다.   원하는 범위의 위치를 받아와서 이미지의 left와 right 값을 지정해주자!    📄 1. 원하는 feild의 위치를 파악한다.   const fieldRect = field.getBoundingClientRect(); function initGame() {   console.log(fieldRect); }   getBoundingClientRect를 이용해 출력하면 지정한 요소의 위치를 콘솔창에서 확인할 수 있다.   📄 2. feild에 추가하기 전에 이미지를 생성하는 함수를 만들어준다.   // 랜덤으로 숫자를 생성하는 함수 function randomNumber(min, max) {   return Math.random() * (max - min) + min; }  // 아이템을 생성하는 함수 function addItem(className, count, imgPath) {   const x1 = 0;   const y1 = 0;   // 이미지가 feild에서 벗어나는 것을 막기 위해 최댓값을 조정한다.   const x2 = fieldRect.width - CARROT_SIZE;   const y2 = fieldRect.height - CARROT_SIZE;    for (let i = 0; i &lt; count; i++) {     const item = document.createElement(\"img\"); // 이미지 추가!     item.setAttribute(\"class\", className); // 이미지에 클래스 속성추가!     item.setAttribute(\"src\", imgPath); // 이미지 경로 추가!     item.style.position = \"absolute\"; // feild에 상대적으로 오프셋 적용     const x = randomNumber(x1, x2); // 최솟값 x1와 최댓값 x2 사이에서 랜덤으로 숫자를 받아 상수 x에 할당!     const y = randomNumber(y1, y2); // 최솟값 y1와 최댓값 y2 사이에서 랜덤으로 숫자를 받아 상수 y에 할당!     item.style.left = `${x}px`; // 추가한 이미지의 left값에 x값 할당!     item.style.top = `${y}px`; // 추가한 이미지의 top에 y값 할당!     field.appendChild(item); // field에 해당 이미지를 추가   } }   📄 3. addItem함수에 값을 지정한다.   function initGame() {   addItem(\"carrot\", 5, \"carrot.png\"); // 당근 이미지 5개!   addItem(\"bug\", 5, \"bug.png\"); // 벌레 이미지 5개! }   결과      새로고침할 때 마다 당근 5개와 벌레 5개가 배치된다.   느낀점   강의 전혀 안보고 하려고 했는데 실패했다~   이미지를 랜덤으로 배치하는 함수가 따로 있는 줄 알았다.  모든게 함수나 API로 있진 않나보다.  구글링할때 많은 사람들이 제이쿼리를 쓰는 것을 보았다.  생각보다 바닐라로 구현하는 내용은 보지 못했다.  코드를 혼자서 완성시키는 것은 지금 당장 해내지 못할지라도 강의에서 보여주는 코드를 완벽하게 이해하고 넘어가서 다음에 사용하는 경우가 생긴다면 그때는 꼭 적용시켜서 스스로 해낼 것이다.    출처      드림코딩  ","categories": ["JavaScript"],
        "tags": ["JavaScript"],
        "url": "/javascript/js-image-random/",
        "teaser": null
      },{
        "title": "async 함수로 데이터 fetch하기",
        "excerpt":"📄 async 함수로 데이터 fetch하기   서버로부터 데이터를 fetch해오는 방법은 여러가지가 있다. 보통 promise를 사용하거나 async await문을 사용한다.   📄 Promise를 통한 비동기 코딩의 문제점   1. 디버깅   function fetchAuthorName(postId) {   return fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)     .then((response) =&gt; response.json())     .then((post) =&gt; post.userId)     .then((userId) =&gt; {       return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)         .then((response) =&gt; response.json())         .then((user) =&gt; user1.name); // 의도한 Error     }); }  fetchAuthorName(1).then((name) =&gt; console.log(\"name:\", name));   ✔ 결과   ReferenceError: user1 is not defined     at fetch.then.then.then.then.then (&lt;anonymous&gt;:7:29)   동일한 이름의 메소드인 여러개의 then()중에서 정확히 어디서 에러가 발생했는지 에러 메세지만 보고는 알 수 없다.   2. 예외처리   Promise를 사용하면 try/catch대신 catch()메서드만 사용하여 예외처리를 해야한다. 비동기, 동기 코드가 섞인 경우에는 예외 처리를 하는 과정이 복잡해질 수 있다.   3. 들여쓰기   실제 프로젝트에서 비동기 처리 코드는 길고 복잡하기 마련인데, 무한 then() 메서드에 빠지게 되면 코드의 가독성이 매우 떨어진다.   📄 aync/await를 통해 데이터 fetch해오기   async/await를 사용하면 Promise가 가진 문제점들을 해결해 줄 수 있다.   Promise 사용했을 때:   fetch(`https://api.idiots.band/api/search?keyword=${e.target.value}`)   .then((x) =&gt; x.json())   .then((data) =&gt; {     console.log(JSON.stringify(data, null, 2));   });   async-await 사용했을 때:   onSearchBand: async (inputValue) =&gt; {   const postResponse = await fetch(     `https://api.idiots.band/api/search?keyword=${inputValue}`   );   const post = await postResponse.json();   this.setState(post); };      fetch함수를 사용하는 함수를 aysnc 함수로 만들어준다.   fetch함수에 await를 걸어준다.   await로 가져온 데이터는 .json()을 호출해서 한번 더 await를 걸어준다.   예외처리 하기 주의사항   export const getSearchData = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const postResponse = await fetch(url);   if (postResponse.ok) {     const data = await postResponse.json();     return data;   } else {     throw new Error(data);   } };   이 코드는 에러는 나지 않지만 성능이 떨어진다.      async 함수는 모두 Promise를 리턴한다.   reponse.ok인 경우도 Promise가 리턴된다.   하지만 throw new Error(data)를 선언한다면 async 함수는 Promise&lt;Response&gt; | Promise&lt;void&gt;로 타입이 잡히게 된다.   따라서 reponse.ok를 선언했다면 예외처리를 할 경우도 Promise를 반환하게 하는 것이 바람직하다.   // 바람직한 코드  export const getSearchBand = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const response = await fetch(url);   if (response.ok) {     return response.json();   }   return Promise.reject(new Error(\"API 요청에 실패 했습니다.\")); };   출처      DaleSeo - 비동기 처리 3부 async/await  ","categories": ["JavaScript"],
        "tags": ["JavaScript","async"],
        "url": "/javascript/javascript-datafetchByAsync/",
        "teaser": null
      },{
        "title": "변수(variable)와 상수(constant)",
        "excerpt":"📄 선언이란?   특정 이름에 특정 값을 담는 것을 선언이라고 합니다.   선언을 하는 방식에는 두가지가 있습니다.   하나는 변수이고 다른 하나는 상수입니다.   📄 변수   변수에는 고정된 값이 아닌 바뀔 수 있는 값을 담습니다.   let이라는 키워드를 사용하여 변수를 선언합니다.   let value = 1;      value라는 변수를 선언하고, 1이라는 값을 담았다.    📄 상수   상수는 변수와 다르게 고정된 값을 가집니다.   상수를 선언할 때는 const라는 키워드를 사용합니다.   const a = 1; a = 2;   상수는 고정된 값을 담기 때문에 위와 같은 코드에는 오류가 발생합니다.   한번 선언되어 1이라는 값을 가지고 있는 상수 a에 다른 값을 다시 넣었기 때문입니다.    주의할 점   상수 객체는 수정될 수 있습니다.   const user = {   name: \"John\", };  user.name = \"Pete\";  console.log(user.name);      ```js Pete; ```  `const`는 `user`의 값을 고정하지만, 그 내용은 고정하지 않습니다.  `const`는 `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생합니다.  ## 📄 왜 변수와 상수를 사용할까?  복잡한 식을 컴퓨터가 매번 읽어낸다면 프로그래밍의 효율성이 떨어집니다.  변수와 상수에 값을 담아두면 컴퓨터가 매번 똑같은 일을 반복하지 않고 코드도 간결해집니다.  ```js const sum = 5 + 10;  if (sum % 3 === 0) {   console.log(\"야호\"); } ```  이렇게 값을 변수나 상수에 지정하면 컴퓨터가 5 + 10을 매번 계산하지 않고 코드를 실행할 수 있습니다.  ## 📄 변수 명명 규칙  - 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다. - 첫 글자는 숫자가 될 수 없습니다. - 대·소문자는 구별됩니다. `a`와 `A`는 다릅니다. - 비 라틴계 언어도 변수명에 사용할 수 있지만 권장하지 않습니다. - 예약어는 사용하지 않습니다. - 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하는 카멜표기법이 흔히 사용됩니다. - `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용합니다. - 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 a, b, c와 같은 짧은 이름은 피해야 합니다. - 최대한 서술적이고 간결하게 명명해 주세요. data와 value는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합니다. - 자신만의 규칙이나 소속된 팀의 규칙을 따릅니다. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 currentVisitor나 newManInTown이 아닌 currentUser나 newUser라는 이름으로 지어야 합니다. - 변수명은 클래스명과 관련지으면 좋습니다.  ## 출처  - 패스트캠퍼스 프론트엔드 강의  * [모던 자바스크립트 튜토리얼](https://ko.javascript.info/object)  ","categories": ["JavaScript"],
        "tags": ["JavaScript","변수","상수"],
        "url": "/javascript/javascript-variableConstant/",
        "teaser": null
      },{
        "title": "동적 임포트(Dynamic import)",
        "excerpt":"📄 동적 임포트(Dynamic import)   보통 코드의 최상단에서 import문을 사용해 클래스나 함수를 가져오는 것을 정적 import라고 합니다.   정적으로 모듈을 import한다면      import문에 동적 매개 변수를 사용할 수 없습니다. = 원시 문자열만 가능하기 때문에 함수 호출 결과값을 경로로 사용할 수 없습니다.   런타임이나 조건부로 모듈을 불러올 수 없습니다. = if문, 코드 블록에서 사용할 수 없습니다.   📄 동적으로 모듈 import 하는 방법   동적으로 모듈을 import한다면      프로미스 객체를 반환합니다. 프로미스 객체의 반환값은 불러온 모듈입니다.   코드의 위치에 관계없이 사용이 가능하기 때문에, 모듈들을 사용자가 필요로 할 때 불러올 수 있습니다.   import()를 호출하는 순간부터 로딩이 되기 때문에 성능을 향상시킬 수 있습니다.   import(\"./sum\").then((sum) =&gt; {   console.log(sum(1 + 2)); });  ","categories": ["JavaScript"],
        "tags": ["JavaScript","동적 임포트","import"],
        "url": "/javascript/javascript-dynamic-import/",
        "teaser": null
      },{
        "title": "[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기",
        "excerpt":"📄 리덕스 툴킷을 사용하지 않은 이유   리덕스를 인강을 통해서 배웠지만 처음엔 이해가 잘 안갔다. 리듀서, 액션 등등 새로운 키워드가 많았고 컨셉도 어려웠다. 배우고 꾸준히 사용해보지 않아서 고이 묻어둔 상태였는데 원티드에서 리덕스를 다루게 되어 다시 꺼내 보았다. 그렇게 리덕스를 사용해서 만든 과제물에 대해 팀원분에게 피드백을 듣게 되었고 리덕스의 컨셉을 이해하지 않았다는 것을 알게 되었다.   기존의 나는 api를 호출할 때 store에서 따로 상태관련 로직을 작성하지 않았다. 예를 들어 Post요청을 한다고 가정했을 때, 데이터를 Put요청을 통해 수정하고 바로 다시 Get요청으로 데이터를 불러와 변경된 데이터를 화면에 렌더링해서 보여줬다. 이 과정에서는 api호출이 총 두번 발생한다.   하지만 store에서 상태 관리 로직을 작성한다면 따로 Get요청을 하지 않아도 클라이언트단에서 변경된 데이터를 바로 렌더링 할 수 있었다. 같은 과정이지만 api요청이 한번으로 줄어들게 되는 것이었다. 단점으로는 코드가 무거워진다는 부분이 있지만 api호출이 줄어드는 만큼 확실히 사용자 입장에선 더 빠르게 느껴질 것 같다.   📄 기존의 리덕스 사용 방식   const commentSlice = createSlice({   name: \"comment\",   initialState: initialState,   reducers: {},   extraReducers: (builder) =&gt; {     builder.addCase(getComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(createComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(editComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(deleteComment.fulfilled, (state, action) =&gt; action.payload);   }, });  export default commentSlice;   redux-toolkit에서 제공하는 createAsyncThunk를 이용해 비동기 로직을 처리하고 댓글의 상태를 관리하는 리듀서를 작성했다. 상태 관련 로직이 전혀 없기 때문에 리듀서가 깔끔하고 각 액션이 어떤 일을 수행하는지 알 수 없다.   📄 개선된 리덕스 사용 방식   const todoReducer = (   state: TodoParam[] = initialState,   action: TodoActionType ) =&gt; {   switch (action.type) {     case GET_TODOS:       return action.payload;     case CREATE_TODO:       return [...state, action.payload];     case DELETE_TODO:       return state.filter((todo) =&gt; todo.id !== action.payload);     case UPDATE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload.id           ? { ...todo, todo: action.payload.todo, isCompleted: false }           : todo       );     case DONE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload           ? { ...todo, isCompleted: !todo.isCompleted }           : todo       );     default:       return state;   } };   리덕스를 제대로 다시 공부하기 위해 툴킷을 사용하지 않고 구현해보았다. 한번 Get요청을 통해 받아온 데이터를 관리하는 리듀서를 만들었다. 상태가 변경될때마다 새로고침을 하는게 아니라면 다시 Get요청을 하지 않아도 되니 api요청이 훨씬 줄어들었다.   지금은 규모가 작은 프로젝트지만 큰 프로젝트의 경우라면 관련 로직이 꽤 길어질 것 같은데 그때도 이렇게 관리를 하는게 맞는지 궁금해졌다. 이 부분은 좀더 찾아봐야 알 것 같다.  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","Redux"],
        "url": "/todolist-project/projects-todoList-redux/",
        "teaser": null
      },{
        "title": "Nodejs, npm, yarn",
        "excerpt":"📄 Node.js란?      Nodejs는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript의 런타임 입니다. (by Node 공식 페이지)       런타임이란? 특정 언어로 만든 프로그램을 실행할 수 있는 환경    Nodejs는 자바스크립트를 브라우저 내에서 말고도 다른환경에서 자바스크립트를 실행할 수 있게 합니다.   Node.js 의 유래   크롬같은 브라우저에는 html을 동적으로 움직일 수 있게하는 자바스크립트 해석 엔진이 있습니다.   크롬은 V8, 모질라는 SpiderMonkey를 사용합니다.   브라우저 중 크롬이 인기가 있는 이유중 하나는 빠른 속도입니다.   자바스크립트를 해석하는 속도가 빠르기 때문에 사용자가 브라우저를 이용할 때 속도가 빠르다고 느끼게 됩니다.   크롬은 사용하던 해석 엔진인 V8을 Node.js라는 이름으로 따로 출시합니다.   📄 npm(Node Packaged Manager)   npm은 Node.js의 패키지 관리자입니다.   npm은 Node.js로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램입니다.   npm을 사용하여 패키지를 설치하면 package.json에서 설치한 패키지가 자동으로 정리됩니다.   📄 yarn   yarn 또한 npm과 같이 javascript 패키지 매니저입니다.   yarn을 사용하면 npm 보다 더 나은 환경에서 자바스크립트를 실행할 수 있어 사용량이 높습니다.   yarn을 사용하는 이유   1. 속도   우선 npm보다 빠릅니다. 다운받은 패키지를 캐시에 저장하여 중복된 데이터는 다운로드하지 않고 캐시에 저장된 파일을 활용하기 때문입니다.   npm은 패키지를 설치할때 순차적으로 설치하는 반면, yarn은 병렬로 처리해 속도면에서 우수합니다.   2. 안정성과 보안   npm은 의존 관계를 가지는 다른 패키지들이 포함되지만 yarn은 package.json에 있는 파일만 설치한다고 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Nodejs","npm","yarn"],
        "url": "/javascript/javascript-jsruntime/",
        "teaser": null
      },{
        "title": "짝수와 홀수",
        "excerpt":"문제 📖   정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요.      num은 int 범위의 정수입니다.   0은 짝수입니다.   function solution(num) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(num) {   const answer = num % 2 === 0 ? \"Even\" : \"Odd\";   return answer; }  solution(4);   num을 2로 나누어 나머지값에 대한 유무를 삼항연산자로 표현하고, 상수 answer에 값을 할당에 결과값을 return시켰다.   Best Practice 👍   function evenOrOdd(num) {   return num % 2 ? \"Odd\" : \"Even\"; }   숫자 0은 false, 이외의 값은 true라는 점을 활용하니 코드가 더욱 간결해졌다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","짝수와홀수"],
        "url": "/programmers-lv1/evenandodd/",
        "teaser": null
      },{
        "title": "평균 구하기",
        "excerpt":"문제 📖   정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.      arr은 길이 1 이상, 100 이하인 배열입니다.   arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(arr) {   const answer = arr.reduce((a, c) =&gt; a + c) / arr.length;   return answer; }   배열 내장 함수인 reduce함수를 사용했다.   for문을 사용하는 것보다 훨씬 간결한 코드가 나왔다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","평균구하기","해시"],
        "url": "/programmers-lv1/programmers-arr/",
        "teaser": null
      },{
        "title": "폰켓몬",
        "excerpt":"문제 📖   당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.   홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.      첫 번째(3번), 두 번째(1번) 폰켓몬을 선택   첫 번째(3번), 세 번째(2번) 폰켓몬을 선택   첫 번째(3번), 네 번째(3번) 폰켓몬을 선택   두 번째(1번), 세 번째(2번) 폰켓몬을 선택   두 번째(1번), 네 번째(3번) 폰켓몬을 선택   세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.   당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.   나의 풀이 🙋‍♀️   function solution(nums) {   const totalNumber = Math.ceil(nums.length / 2);   const set = new Set(nums);   const newNums = [...set];    const answer =     Math.ceil(newNums.length) &gt; totalNumber       ? totalNumber       : Math.ceil(newNums.length);    return answer; }   우선 주어진 배열의 길이를 totalNumber에 저장해 answer에 최댓값으로 생각했다.   이후 set함수를 사용해서 배열의 중복요소를 제거했다.   최종 정답은 중복요소를 제거한 배열의 길이가 최댓값보다 크면 최댓값인 totalNumber, 작으면 중복요소를 제거한 배열의 길이로 설정했다.   Best Practice 👍   function solution(nums) {   const max = nums.length / 2;   const arr = [...new Set(nums)];    return arr.length &gt; max ? max : arr.length; }   다른 사람의 풀이를 보니 내가 너무 성급하게 정답을 제출했다는 것을 알았다.   내 풀이에서는 newNums.length에 쓸데없이 올림처리를 한 것을 지우지도 않았고, set함수를 사용할때 굳이 상수를 두번이나 선언한게 보인다.   답이 나와도 다시한번 보고 정리하는 습관을 가져야겠다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","폰켓몬","해시"],
        "url": "/programmers-lv1/programmers-phonecatmon/",
        "teaser": null
      },{
        "title": "약수의 합",
        "excerpt":"문제 📖   정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.      n은 0 이상 3000이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(n) {   let sum = n;   for (let i = 1; i &lt;= Math.floor(n / 2); i++) {     if (n % i === 0) sum += i;   }   return sum; }   간단하게 for문을 사용했다.   어차피 주어진 수 n의 절반까지만 정답의 유효 범위이기 때문에 반복 횟수를 조금이라도 줄이려고 신경썼다.   반복문을 통해 주어진 수 n을 정수로 나눈 값이 0일 경우, 총합 sum에 더해준다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","약수의 합"],
        "url": "/programmers-lv1/sumofdivisor/",
        "teaser": null
      },{
        "title": "🚨 Assignment to constant variable.",
        "excerpt":"🚨 Assignment to constant variable.   자바스크립트 퀴즈를 푸는데 코드에 빨간 표시도 안났는데 에러가 떴다.   직역하면 상수값을 변수에 할당했다는 뜻이다.   function countBiggerThanTen(numbers) {   let sum = 0;   numbers.forEach((number) =&gt; {     if (number &gt; 10) {       sum += 1; // TypeError: Assignment to constant variable.     }   });   console.log(sum); }   원인   이미 선언한 const 변수에 새로운 값을 할당했을 때 발생한다.   위 코드에서 계속 값이 바뀌는 sum을 상수로 선언했다.   해결   값을 재할당에서 사용할 수 있는 let으로 바꾸어 주었더니 정상적으로 동작했다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/javascript-assignment-to-constant-variable/",
        "teaser": null
      },{
        "title": "이벤트 버블링 (Event Bubbling), 이벤트 캡쳐 (Event Capture), 이벤트 위임 (Event Delegation)",
        "excerpt":"📄 이벤트 버블링 (Event Bubbling)   이벤트 버블링은 특정 요소에서 이벤트가 발생했을 때, 해당 이벤트가 더 상위 요소로 전달되는 과정입니다.   브라우저는 특정 요소에서 이벤트가 발생했을 때 그 이벤트를 최상위에 있는 요소까지 전파합니다.   이러한 과정을 이벤트 버블링이라고 합니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   three; two; one;   📄 이벤트 캡처 (Event Capture)   이벤트 캡처는 이벤트 버블링과 반대로 진행되는 이벤트 전달 과정입니다.   이벤트 캡처는 이벤트 버블링과 반대로 상위요소에서 하위요소로 이벤트 전달 과정이 진행됩니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   one; two; three;   addEventListener의 세번째 파라미터로 capture: true를 설정해주면 이벤트 캡처가 진행되어 가장 상위 요소에 적용된 이벤트가 먼저 발생합니다.   📄 이벤트 진행을 막고싶을 때는 어떻게 할까?   이벤트 버블링이나 이벤트 캡처를 구현할때 적용한 모든 요소에 이벤트를 실행하지 않고 중간에 멈추기 위한 속성이 있습니다. event.stopPropagation()을 사용하면 이벤트의 진행과정을 중단시킬 수 있습니다.   // 이벤트 버블링 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // three }  // 이벤트 캡쳐 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // one }   📄 이벤트 위임 (Event Delegation)   이벤트 위임은 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식입니다.   &lt;h1&gt;오늘의 할 일&lt;/h1&gt; &lt;ul class=\"itemList\"&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item1\" /&gt;     &lt;label for=\"item1\"&gt;이벤트 버블링 학습&lt;/label&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item2\" /&gt;     &lt;label for=\"item2\"&gt;이벤트 캡쳐 학습&lt;/label&gt;   &lt;/li&gt; &lt;/ul&gt;   // 새 리스트 아이템을 추가하는 코드 var itemList = document.querySelector(\".itemList\");  var li = document.createElement(\"li\"); var input = document.createElement(\"input\"); var label = document.createElement(\"label\"); var labelText = document.createTextNode(\"이벤트 위임 학습\");  input.setAttribute(\"type\", \"checkbox\"); input.setAttribute(\"id\", \"item3\"); label.setAttribute(\"for\", \"item3\"); label.appendChild(labelText); li.appendChild(input); li.appendChild(label); itemList.appendChild(li);  var itemList = document.querySelector(\".itemList\"); itemList.addEventListener(\"click\", function (event) {   alert(\"clicked\"); });   아이템이 새로 추가될 때마다 이벤트를 새로 추가하지 않고 상위 요소인 .itemList에 이벤트를 달아줌으로써 하위요소에도 이벤트가 등록되었습니다.   출처      캡틴 판교-이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","이벤트 버블링","이벤트 캡처","이벤트 위임"],
        "url": "/javascript/javascript-eventBubbling/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.   GitHub TIL레포에 공부내용을 기록해왔는데 이 블로그로 모든 내용을 옮겨야 한다.   내용이 꽤 많지만 전체적으로 한번씩 읽으면서 복습한다고 생각하고 여유롭게 이사해야겠다.   TIL 레포에서 GitHub 블로그로 이사하는 이유   우선, github 레포에서 보는 md파일은 가독성이 좋지 않다. 글씨의 크기나 간격이 편하게 읽기 좋은 정도는 아니다. 가장 큰 이유는 내가 지속적으로 관리하는 페이지를 가지고 싶었다. 이 블로그에 공부기록도 하지만 이외에 다양한 주제를 가지고 나를 표현하는 웹 사이트로 성장시킬 예정이다.  ","categories": ["일상"],
        "tags": ["Blog"],
        "url": "/%EC%9D%BC%EC%83%81/first-post/",
        "teaser": null
      },{
        "title": "완주하지 못한 선수",
        "excerpt":"문제 📖   수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.   마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.      마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.   completion의 길이는 participant의 길이보다 1 작습니다.   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.   참가자 중에는 동명이인이 있을 수 있습니다.   나의 풀이 #1 🙋‍♀️   function solution(participant, completion) {   const setParticipant = new Set(participant); // 1   if (setParticipant.size &lt; participant.length) {     // 2     const notCompletion = participant.filter((item) =&gt; {       if (setParticipant.has(item)) {         setParticipant.delete(item);       } else {         return item;       }     });     return notCompletion[0];   }   const answer = participant.filter((person) =&gt; !completion.includes(person)); // 3   return answer[0]; }      Set객체를 사용해서 participant 중복요소를 제거한다.   중복요소를 제거한 participant 객체(setParticipant)의 크기가 participant보다 작다면, 동명이인이 있다는 뜻이므로 filter함수를 사용해 완주하지 못한 선수의 이름을 구한다.   동명이인이 없는 경우 바로 완주하지 못한 선수의 이름을 구한다.   이 코드를 제출하며 정확성 체크는 통과하지만 효율성 체크는 통과하지 못한다.   효율성까지 테스트하는 문제는 처음이라 시간이 좀 걸려서 코드를 고쳤다.   나의 풀이 #2 🙋‍♀️   function solution(participant, completion) {   const sortedParticipant = participant.sort(); // 1   const sortedCompletion = completion.sort();    for (let i = 0; i &lt; sortedParticipant.length; i++) {     // 2     if (sortedParticipant[i] !== sortedCompletion[i]) {       // 3       return sortedParticipant[i];       break;     }   } }      참가자 배열과 완주자 배열의 문자열을 abc차순으로 정리한다.   for문을 사용해서 참가자 수만큼 반복문을 실행한다.   순차가 정리된 배열끼리 이름을 비교하게 되고, 이름이 같지 않으면 해당 이름을 정답으로 제출한다.   효율성 체크는 수행 시간과 메모리를 기준으로 평가된다.   코드의 시간복잡도와 저장된 메모리를 고려해야 통과할 수 있다.   반복문을 사용하는 경우에는 원하는 값이 도출되었을 때, 바로 반복문을 종료시킬 수 있어야 효율성이 증가한다.   그런면에서 배열에 for...in을 사용하는 것은 좋지 않다.   for...in은 모든 값을 조회해 효율성을 떨어뜨리기 때문이다.   Best Practice 👍   function solution(participant, completion) {   const map = new Map(); // 1    for (let i = 0; i &lt; participant.length; i++) {     let a = participant[i],       b = completion[i];      map.set(a, (map.get(a) || 0) + 1); // 2     map.set(b, (map.get(b) || 0) - 1); // 3   } // 4    for (let [k, v] of map) {     // 5     if (v &gt; 0) return k;   }    return \"nothing\"; }   해시의 컨셉을 정확히 접목시킨 풀이이다.   해시의 개념은 알고 있었지만 프로그래머스에서 이렇게 접목시킬 생각은 못했다.      우선 Map객체를 생성한다.   참가자 수만큼 반복문을 돌려 map에 키는 참가자 이름으로, 값은 기존에 1을 더해준다.   map에 완주자 이름의 키에 해당되는 값을 -1만큼 빼준다.   처음 for문을 나온 map의 키는 참가자이름이고 값은 0 또는 1이 된다.   완주하지 못한 참가자는 1의 값을 가지고 있으므로 해당 key의 값을 답으로 제출한다.   동명이인이 있을 경우에는 해당 이름의 값에 두번 1이 더해지고 한번 1이 빼지므로 마찬가지로 1이 된다.   풀이를 정리하자면 다음과 같게 된다.      sort로 풀면 O(NlogN)의 시간이 걸리지만 해시로 풀면 O(N)의 시간 복잡도를 가진다.   다음 해시 문제를 풀때는 꼭 Map을 사용해서 답을 낼 것이다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","완주하지 못한 선수","해시"],
        "url": "/programmers-lv1/programmers-notcolpletedplayer/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 사용자 폼 관련 Slice 리팩토링 (state 객체로 관리하기)",
        "excerpt":"❔ 리팩토링 이유   좋은 코드는 코드만 보고 어떤 일을 하는지 알 수 있는 코드라고 배웠다.   하지만 나의 코드는 코드만 보고 무슨일을 하는 지 알 수 없었다.   기존의 MemberForm 데이터 구조   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   value: [     { key: \"imageFile\", value: null, isValidate: true },     { key: \"username\", value: \"\", isValidate: false, emailAuth: false },     { key: \"email\", value: \"\", isValidate: false },     { key: \"password\", value: \"\", isValidate: false },   ], };   데이터 구조가 이렇게 되어있으면 값에 접근할 때 값의 이름이 아니라 index로 접근해야 했다.   처음 프로젝트를 시작할때 File 타입에 null이 할당되지 않아 객체 안에 굳이 key라는 이름의 key를 생성했다.   imageFile: File: null; // error   아마 내가 ‘imageFile’의 타입을 오로지 File로만 했던 모양인데 시간이 지나고 보니 코드가 굉장히 가독성이 없다는 것이 보였다.   💾 Components/SignUpForm   const result: UserParam = {   imageFile: userData[0].value,   username: userData[1].value!,   email: userData[2].value!,   password: userData[3].value!, };   userData에 index로 접근하기 때문에 해당 변수가 어떤 값을 가지고 있는지 알 수 없다.   이를 고치기 위해선 memberForm의 state 구조를 변경해야 했다.   ❕ 리팩토링 결과   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   memberForm: {     imageFile: null,     username: \"\",     email: \"\",     password: \"\",   } as Omit&lt;MemberFormParam, \"profileUrl\" &amp; \"imageUrl\"&gt;,   emailAuth: false,   isEditMode: false, };   💾 Components/SignUpForm   const result: UserParam = {   imageFile: memberForm.imageFile,   username: memberForm.username,   email: memberForm.email,   password: memberForm.password, };   값에 이름으로 접근하니 어떤 데이터가 할당되는지 알 수 있게 되었다.   💬 나의 생각   분명 코드를 작성할 때는 최선인 것 같았는데 지나고 보니 아닌 경우가 꽤 많다.   완성된 프로젝트라 하더라도 다시 보고 리팩토링을 계속 해주는 것이 좋겠다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","redux-toolkit","데이터구조"],
        "url": "/coding-swamp/projects-coding-swamp/",
        "teaser": null
      }]
