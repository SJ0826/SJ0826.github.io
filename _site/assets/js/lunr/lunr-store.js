var store = [{
        "title": "[TodoList-Project] 클래스로 작성하는 로그인/회원가입 axios통신",
        "excerpt":"📑 axios통신 로직을 클래스로 작성한 이유   꽤 여러번 투두리스트를 만들어봤지지만 axios 통신 로직은 항상 함수로만 작성했다. 원티드에서 강의를 듣고 클래스에 대해 고민하게 되었다. 클래스는 객체 형태로 state를 저장할 수 있기 때문에 state를 가진 모듈이라면 클래스로 작성하는 것이 좋다고 한다. 로그인/회원가입을 구현하는 로직은 url과 token을 가지고 있기 때문에 클래스로 작성을 하기로 결정했다. 이번에 본격적으로 구글링을 하는 연습을 하기 위해서 영어로 된 문서도 적극적으로 참고했다.   📑 httpClient.ts | axios Client를 담당   import axios, { AxiosInstance, AxiosRequestConfig } from \"axios\"; import { getLocalStorageToken } from \"../store/localStorage\";  declare module \"axios\" {   type AxiosRequest&lt;T = unknown&gt; = Promise&lt;T&gt;; } // 0  abstract class HttpClient {   // 1   protected readonly instance: AxiosInstance;    public constructor(baseURL: string) {     // 2     this.instance = axios.create({       baseURL: BASE_URL,     });      this._initializeRequestInterceptor(); // 3   }    private _initializeRequestInterceptor = () =&gt; {     // 4     this.instance.interceptors.request.use(this._handleRequest);   };    private _handleRequest = (config: InternalAxiosRequestConfig) =&gt; {     const accessToken = getLocalStorageToken();     if (accessToken &amp;&amp; config.headers) {       config.headers.Authorization = `Bearer ${accessToken}`;     }     return config;   }; }  export default HttpClient;           타입스크립트를 사용하고 있기 때문에 AxiosRequest가 무슨일을 하는지 알려줘야 한다. 이렇게 하면 response를 순수 data로 사용할때 타입스크립트가 에러를 내지 않는다고 한다.            우선, HttpClient라는 추상 클래스를 만들어 instance를 생성할 수 없게 만들어주었다. instance를 생성할 클래스는 기능별로 따로 만들었기 때문이다.            axios-instance를 생성하는 constructor이다. constructor로부터 base URL을 얻을 수 있다. axios.create는 protected 멤버로 설정된 instance에 저장되어 외부 클래스에서 사용할 수 없게 했다. 하지만 상속받은 클래스에서는 접근할 수 있다.            데이터를 요청하기 전 토큰이 있는지 확인해야 하기 때문에 axios의 interceptor메소드를 활용할 것이다. _는 private 메소드라고 암시하는 뜻이다.            interceptor메소드는 _handleRequest라는 콜백함수를 가진다. axios 요청시 로컬스토리지에 있는 값을 꺼내서 헤더에 Authorization 키를 설정할 수 있다.         📑 authAPI.ts | 로그인/회원가입 axios 통신을 담당   import { AxiosResponse } from \"axios\"; import { SIGNIN_URL, SIGNUP_URL } from \"../../constants/constants\"; import HttpClient from \"../httpClient\"; import { UserParam } from \"../../types/auth/UserInterface\";  class AuthAPI extends HttpClient {   public constructor() {     super();      this._initializeResponseInterceptor();   }    private _initializeResponseInterceptor = () =&gt; {     this.instance.interceptors.response.use(       this._handleResponse,       this._handleError     );   };    private _handleResponse = (response: AxiosResponse) =&gt; {     const responseCode = response.status;      switch (responseCode) {       case 200:         alert(\"로그인되었습니다.\");         break;       case 201:         alert(\"회원가입에 성공했습니다. 로그인해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }     return response;   };    protected _handleError = (error: AxiosError) =&gt; {     const { response: errorResponse } = error;     const errorCode = errorResponse.status;      switch (errorCode) {       case 400:         alert(\"동일한 이메일이 이미 존재합니다.\");         break;       case 401:         alert(\"아이디와 비밀번호를 확인해주세요.\");         break;       case 404:         alert(\"해당 사용자가 존재하지 않습니다. 회원가입을 진행해주세요.\");         break;       default:         alert(           \"로그인/회원가입 요청이 거절되었습니다. 네트워크를 확인하거나 관리자에게 문의해주세요.\"         );     }   };    public SignIn = (data: UserParam) =&gt; this.instance.post(SIGNIN_URL, data);    public SignUp = (data: UserParam) =&gt; this.instance.post(SIGNUP_URL, data); }  const authApi = new AuthAPI(); export { authApi };     참고      Enhance Your HTTP  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","axios","클래스"],
        "url": "/todolist-project/projects-todolist-axios/",
        "teaser": null
      },{
        "title": "최댓값과 최솟값",
        "excerpt":"문제 📖   문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.   예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다.      s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.   function solution(s) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(s) {   const stringToArray = s.split(\" \");   const stringToNumber = stringToArray.map((element) =&gt; parseInt(element));   const maxValue = Math.max(...stringToNumber);   const minValue = Math.min(...stringToNumber);   const answer = `${minValue} ${maxValue}`;   return answer; }   먼저 split 배열 내장 함수를 통해 공백을 기준으로 문자열을 구분했다.   이후 최댓값과 최솟값을 구하기 위해 구분된 배열의 문자들을 숫자로 바꾸어 주고,   spread연산자로 배열을 분해해서 최댓값과 최솟값을 구했다.   문자열을 반환해야 한다고해서 백틱으로 maxValue minValue을 감싸 return시켰다.   Best Practice 👍   # 1   function solution(s) {   const arr = s.split(\" \");    return Math.min(...arr) + \" \" + Math.max(...arr); }   우선, 내가 작성한 코드보다 훨씬 간결한 것을 확인했다.   내가 몰랐던 점은 다음과 같다.      Math가 문자열도 취급한다는 것   굳이 따로 변수나 상수에 값을 할당하는 것보다 바로 return을 시키는게 더 나을 때도 있다는 것   # 2   function solution(s) {   let min = Math.min.apply(null, s.split(\" \").map(Number));   let max = Math.max.apply(null, s.split(\" \").map(Number));   var answer = min + \" \" + max;   return answer; }   이 코드가 인상적이었던 점은 map함수를 사용하는 방식 때문이었다.   내 풀이를 보면 map을 사용할때 각각 요소에 parseInt를 적용해서 숫자로 변환하는 방식이었는데, 그냥 Number라고 적기만 해도 식이 진행된다는 것을 알게 되었다.  ","categories": ["programmers-lv2"],
        "tags": ["프로그래머스","최댓값과 최솟값"],
        "url": "/programmers-lv2/programmers-maxandmin/",
        "teaser": null
      },{
        "title": "2016년",
        "excerpt":"문제 📖   2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT   입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.      2016년은 윤년입니다.   2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   나의 풀이 🙋‍♀️   function solution(a, b) {   const dayOfTheWeek = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];   const daysOfMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   let sum = 0;    if (a === 1) {     sum = b;   } else {     for (let i = 0; i &lt;= a - 2; i++) {       // 1       sum += daysOfMonth[i];       if (i == a - 2) {         sum += b; //2       }     }   }    const index = sum - Math.floor(sum / 7) * 7; // 3    return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1]; }   내가 생각한 풀이의 순서는 다음과 같다.      주어진 월(a)전의 총 날짜를 더한 값을 구한다.. = sum   sum에 b를 더해 필요한 날짜를 모두 더한 값을 구한다.   sum에 7의 배수를 뺐을 때 나올 수 있는 한자리 수를 구해 dayOfTheWeek의 인덱스로 활용한다.   trouble shooting 1 💥   처음 코드   for (let i = 0; i &lt;= a - 2; i++) {   sum += daysOfMonth[i];   if (i == a - 2) {     sum += b;   } }   수정한 코드   if (a === 1) {   sum = b; } else {   for (let i = 0; i &lt;= a - 2; i++) {     sum += daysOfMonth[i];     if (i == a - 2) {       sum += b; //2     }   } }   이 부분은 왜 통과하지 못했는지 머리를 굴리다 1월인 경우, 2월인 경우 값을 대입해서 생각해보니 문제점을 찾을 수 있었다.   만약 1월이라면 a는 1이되는데 for문의 조건에 처음부터 충족되지 못해서 sum에 값이 들어가지 않았던 것이다.   if문으로 조건을 달아주긴 했지만 조건문속 반복문속 조건문.. 정말 맘에 들지 않는다..   trouble shooting 2 💥   처음 코드   return dayOfTheWeek[index - 1];   수정한 코드   return index === 0 ? dayOfTheWeek[6] : dayOfTheWeek[index - 1];   계산대로 하면 모든 케이스가 통과해야하는데 13개의 케이스 중 2개가 통과하지 못하고 계속 실패로 걸렸다.   테스트 케이스에 날짜를 하나 하나 추가해서 결과를 확인하던 중 이유를 알 수 있었다.   index가 0이 될 수도 있었던것이었다.   예를 들어 5월 5일인 경우, index가 126 - (18*7) = 0이 되는데 나는 결과값을 dayOfTheWeek[index-1]로만 리턴해서 결과가 undefined가 나왔던 것이다.   return할 때 삼항연산자를 이용해 index가 0이 될 경우의 케이스도 처리해주었다.   Best Practice #1 👍   function getDayName(a, b) {   var tempDate = new Date(2016, a - 1, b);    return tempDate.toString().slice(0, 3).toUpperCase(); }  //아래 코드는 테스트를 위한 코드입니다. console.log(getDayName(5, 24));   Date가 있는 걸 알긴 했지만 그러면 너무 단순해질것같아서 사용하지 않았다.   그래도 메소드를 사용한걸 보니 훨씬 보기 편하다.   Best Practice #2 👍   function solution(a, b) {   const monthDay = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];   const weekDay = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\"];    let days = b;   for (let i = 0; i &lt; a - 1; i++) days += monthDay[i];    return weekDay[days % 7]; }   코드가 흘러가는 구성이 내가 작성한 코드와 크게 다르지 않다.   하지만 간결함과 가독성이 크게 다르다.   for문의 조건식에서 &lt;=을 &lt;로 고쳤을뿐인데 if문이 하나 줄었다.   굳이 sum이라는 변수를 새로 만들지 않고 b에 값을 더해주었다.   굳이… Math.floor()를 사용하지 않고도 그냥 %연산자로 나머지값 계산해서 index로 처리해주었다…   만약 다른 사람이 푼 답에 Best Practice가 있다면 배열 내장 함수를 사용했을 것이라고 생각했는데 아니었다.   물론 배열 내장 함수를 사용할 수도 있지만 이 코드가 가독성도 좋고 제일 좋아보였다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","2016년"],
        "url": "/programmers-lv1/2016/",
        "teaser": null
      },{
        "title": "🚨 Cannot find module",
        "excerpt":"🚨 Cannot find module   자바스크립트 강의를 들으며 실습 도중 파일이 실행이 안됐다.      경로 설정 문제 인줄 알았는데 파일 설정을 잘못했다.   🔨 해결           확장자 명이 js로 되어 있는지 확인하고 고친다.            끝^^       느낀점   항상 오류가 발생하면 사실 대부분 이런 사소한 문제들인것 같다.   모든 과정을 꼼꼼히 살피자.   참고      [stackoverflow]https://stackoverflow.com/questions/9023672/how-do-i-resolve-cannot-find-module-error-using-node-js  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/cannot-find-module/",
        "teaser": null
      },{
        "title": "🚨 Cannot use import statement outside a module",
        "excerpt":"🐞 에러 발생   공연 검색기 프로젝트 중 에러가 발생했다.    ❔ 원인   해당 스크립트를 모듈로 인식하지 못해 import문을 쓸 수 없다는 뜻이다.   직접 스크립트의 타입을 지정해주어야 한다.   ❕ 해결   [index.html]   &lt;script src=\"main.js\" type=\"module\"&gt;&lt;/script&gt;   이렇게 해당 스크립트 태그에서 타입을 모듈로 지정해주면 에러가 해결된다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","import"],
        "url": "/javascript/javascript-cannot-use-import-statement-outside-a-module/",
        "teaser": null
      },{
        "title": "해시(Hash)",
        "excerpt":"📄 해시(Hash)      해시는 (Key, Value)로 데이터를 저장하는 자료구조입니다.   해시 함수는 임이의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환시켜주는 함수를 뜻합니다.   해시 함수를 사용하면 한 배열의 키에 해시함수를 적용해 고유한 인덱스를 생성할 수 있습니다.   참고      업비트 투자자보호센터  ","categories": ["structure"],
        "tags": ["자료구조","해시"],
        "url": "/structure/structure-hash/",
        "teaser": null
      },{
        "title": "논리 연산자를 이용한 조건문",
        "excerpt":"📄 논리 연산자를 이용한 조건문   조건문은 계산식뿐만 아니라 논리연산자를 이용해 완성할 수 있습니다.   📄 표현식 &amp;&amp; 표현식   &amp;&amp;는 and연산자로 불리며 조건 중 하나라도 거짓일 경우 거짓이 됩니다.   if (true &amp;&amp; true) {   console.log(\"두개 모두 참이면 참\"); }  if (true &amp;&amp; false) {   console.log(\"한개만 참이면 거짓\"); }  if (false &amp;&amp; false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 표현식 || 표현식   ||는 &amp;&amp;OR연산자**로 둘중 하나만 참이면 참이 됩니다.   if (true || true) {   console.log(\"두개 모두 참이면 참\"); }  if (true || false) {   console.log(\"한개만 참이면 참\"); }  if (false || false) {   console.log(\"두개 모두 거짓이면 거짓\"); }   결과      📄 !표현식   !는 NOT연산자로 반대의 결과값을 출력합니다.   if (!true) {   console.log(\"참이면 거짓\"); // 거짓이므로 출력되지 않음. }  if (!false) {   console.log(\"거짓이면 참\"); }   결과      📄 논리연산자를 이용한 조건부 실행   표현식은 앞을 먼저 평가하고 뒤를 평가합니다.   앞 표현식을 평가를 해서 참 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤의 표현식이 실행됩니다.   n % 5;  // 앞이 참이기 때문에 뒤가 실행이 되지 않음. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");  n = 6;  // 앞이 거짓이기 때문에 뒤가 실행됨. n % 5 === 0 || console.log(\"5로 나누어 떨어지지 않을 때만 실행\");   결과    📄 논리연산자 우선순위   논리연산자에는 우선순위가 있습니다.   NOT(!) &gt; AND(&amp;&amp;) &gt; OR(||) 순으로 NOT연산자가 제일 먼저 실행됩니다.   const value = !((true &amp;&amp; false) || (true &amp;&amp; false) || !false);   세가지 논리연산자가 동시에 쓰였지만,   우선순위가 적용되어 value는 false라는 값을 가지게 됩니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","논리연산자"],
        "url": "/javascript/javascript-logical-operator/",
        "teaser": null
      },{
        "title": "컨테이너와 전역 속성",
        "excerpt":"📄 컨테이너 태그   콘텐츠에 아무런 영향을 주지 않고, 여러 요소를 묶어 관리하기 편하게 만드는 역할을 하는 태그입니다.   div: 블록 레벨 컨테이너      페이지 전체 면적을 차지합니다.   span: 인라인 컨테이너   지정한 부분의 면적만 차지합니다.   📄 전역 속성   전역속성(Global attributes)은 모든 HTML 태그에서 공통으로 사용할 수 있는 속성입니다.   &lt;태그명 속성명=**속성값** 속성명=**속성값**&gt;콘텐츠&lt;/태그명&gt;   대표적인 전역 속성들      id: 요소에 고유한 이름을 부여하는 식별자 역할 속성입니다. id는 태그당 하나씩만 지정합니다.   class: 요소를 그룹 별로 묶을 수 있는 식별자 역할 속성입니다. class는 다중 지정 및 중복이 가능합니다.   style: 요소에 적용할 CSS스타일을 선언하는 속성입니다.   title: 요소의 추가 정보를 제공하는 텍스트 속성입니다. 사용자에게 툴팁을 제공합니다.  ","categories": ["HTML"],
        "tags": ["HTML","컨테이너","전역속성"],
        "url": "/html/html-container/",
        "teaser": null
      },{
        "title": "HTML 문서 기본 구조",
        "excerpt":"📄 HTML이란?      HyperText: 하이퍼링크를 통해 어떤 문서에서 다른 문서로 접근할 수 있는 텍스트   MarkUp: (콘텐츠를) 표시하다   Language: 언어   즉, HTML은 웹브라우저를 통해 표시되는 웹페이지의 콘텐츠를 정의하기 위해 사용하는 언어입니다.   📄 HTML 문서 기본 구조   ▪ &lt;!DOCTYPE html&gt;   문서의 첫 부분에서 문서 유형을 지정하는 단일 태그입니다.   &lt;!DOCTYPE html&gt;   ▪ &lt;html&gt; ~ &lt;/html&gt;   문서 유형을 지정한 후 실제 문서가 시작되고 끝나는 것을 나타내는 태그입니다.   &lt;html&gt;   ... &lt;/html&gt;   ▪ &lt;head&gt; ~ &lt;/head&gt;   웹 브라우저 화면에는 보이지 않지만 웹 브라우저가 알아야 할 정보들입니다.   ▪ &lt;meta charset=\"utf-8\"&gt;   문자 인코딩 및 문서 키워드 등에 대한 요약 정보를 기입하는 단일 태그입니다.  영문과 한글을 모두 사용하기 위해 utf-8 방식을 사용하는 것이 좋습니다.    ▪ &lt;title&gt; ~ &lt;/title&gt;   문서의 제목을 나타냅니다. 콘텐츠는 브라우저 탭에 표시됩니다.       ▪ &lt;body&gt; ~ &lt;/body&gt;   실제 브라우저 화면에 표시될 내용을 입력하는 태그입니다.     들여쓰기를 깔끔하게 해서 가독성을 높이자   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그"],
        "url": "/html/html-html-docs-structure/",
        "teaser": null
      },{
        "title": "이미지 표시하기",
        "excerpt":"📄 이미지를 보여주는 img 태그   html에서는 이미지를 보여줄 때 img라는 단일 태그를 사용합니다.   &lt;img src=\"표시할 이미지 파일\" alt=\"이미지설명\" /&gt;   이때 alt는 대체 택스트 역할을 합니다.   이미지가 로딩되기 전이나 이미지 로딩에 실패한 경우   이미지 대신에 대체 텍스트가 표시됩니다.   이미지 유실 상황에 대비하거나 시각 장애인을 위한 콘텐츠에 유용합니다.(음성인식기 활용)   📄 이미지 크기 조절하기   width와 height로 크기를 지정합니다.   이때 너비와 높이는 각각 픽셀(px)단위로 적용됩니다.   &lt;img   src=\"표시할 이미지 파일\"   alt=\"이미지 설명\"   width=\"너비 값\"   height=\"높이 값\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","img"],
        "url": "/html/html-image/",
        "teaser": null
      },{
        "title": "입력 요소 만들기(input)",
        "excerpt":"📄 input 태그   입력요소는 &lt;input&gt; 태그를 이용해 만들어 줍니다.   &lt;input&gt;태그는 인라인 요소이며, 단일 태그입니다.   &lt;input&gt;태그에는 name식별자를 추가하여 각각 어떤 특징을 가지는지 설명하는 것이 좋습니다.   📄 input 태그의 type 속성   type값에 따라 입력 요소의 형태나 입력 데이터 유형 등이 달라집니다.   1. text: 텍스트 메세지를 입력합니다.   &lt;input name=\"text\" type=\"text\" maxlength=\"5\" placeholder=\"메세지입력\" /&gt;      maxlength: 텍스트 최대 크기를 지정합니다.   place holder: 텍스트 입력 전 창에 띄워지는 텍스트를 지정합니다.   2. button: 버튼이 생성됩니다.   &lt;input name=\"button\" type=\"button\" value=\"PUSH\" /&gt;   3. color: 색을 지정할 수 있는 팔레트가 띄워 집니다.   &lt;input name=\"color\" type=\"color\" /&gt;   4. rage: 숫자로 된 값을 입력 할 수 있는 바를 만들어 줍니다.   &lt;input name=\"score\" type=\"range\" max=\"100\" min=\"0\" step=\"10\" /&gt;   5. date: 날짜를 입력할 수 있는 달력이 생성됩니다.   &lt;input name=\"birthdaty\" type=\"date\" /&gt;  ","categories": ["HTML"],
        "tags": ["HTML","input"],
        "url": "/html/html-input/",
        "teaser": null
      },{
        "title": "링크 만들기",
        "excerpt":"📄 링크(Link)   링크는 현재 문서에서 다른 문서로 이동할 수 있는 수단입니다.   링크는 a 태그를 사용합니다.   a 태그에 사용하는 속성      href: 링크가 참조하고자 하는 url을 입력합니다.   target: 링크 클릭 시 현재 탭에서 열지 새로운 탭에서 열지 결정합니다   &lt;a href=\"www.naver.com\" target=\"_self\"&gt; 현재 탭에서 열기(기본값) &lt;/a&gt;  &lt;a href=\"www.naver.com\" target=\"_blank\"&gt; 새로운 탭에서 열기 &lt;/a&gt;   이 외에도 href에 전화번호나 메일 주소 등을 지정 할 수 있습니다.   &lt;a href=\"tel:010-1234-5678\"&gt;   전화 걸기   &lt;!-- 데스크탑일 경우 전화기능이 없다면 사용 불가--&gt; &lt;/a&gt;  &lt;a href=\"mailto:ikosdu60@gmail.com\"&gt; 메일 쓰기 &lt;/a&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","link"],
        "url": "/html/html-link/",
        "teaser": null
      },{
        "title": "블록 레벨 요소와 인라인 요소",
        "excerpt":"📄 태그의 구분   블록 레벨 요소를 만드는 태그 vs 인라인 요소를 만드는 태그   📄 블록 레벨 요소   블록 레벨 요소는 페이지의 너비를 모두 차지하여 블록을 형성합니다.  아래와 같이 개발자도구(단축키:F12)를 사용하면  페이지의 너비를 모두 차지하고 있는 것을 확인할 수 있습니다.  블록 안에 블록을 생성하면 공간이 형성되어 층이 생깁니다.     📄 인라인 요소   인라인 요소는 콘텐츠를 표시하기 위해 필요한 공간만 차지합니다.  블록 요소 안에 인라인 요소를 넣어도 인라인 요소는 필요한 공간만 차지합니다.     ","categories": ["HTML"],
        "tags": ["HTML","블록 레벨","인라인 레벨"],
        "url": "/html/html-tag&inlinetext/",
        "teaser": null
      },{
        "title": "텍스트 태그 사용 방법과 특징",
        "excerpt":"📄 문단(paragraph)   문단 요소를 나타내는 태그로써, 가장 많이 사용되는 텍스트 태그 입니다.  문단과 문단 사이에는 공백이 있습니다.   &lt;p&gt;이것은 문단을 표시하는 태그입니다.&lt;/p&gt;   📄 제목(headline)   h 태그는 제목 요소를 나타냅니다.  숫자와 함께 사용되며, 숫자가 1일 때 가장 크고 6일 때 가장 작습니다.   &lt;h1&gt;제목을 나타내자!&lt;/h1&gt; &lt;h2&gt;제목을 나타내자!&lt;/h2&gt; &lt;h3&gt;제목을 나타내자!&lt;/h3&gt; &lt;h4&gt;제목을 나타내자!&lt;/h4&gt; &lt;h5&gt;제목을 나타내자!&lt;/h5&gt; &lt;h6&gt;제목을 나타내자!&lt;/h6&gt;   ✔ 결과   제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!  제목을 나타내자!   📄 수평선   hr 태그는 수평선을 표시하는 태그입니다.  주로 주제 변경 또는 내용 구분을 위해 단일 태그로 사용됩니다.   &lt;hr /&gt;   📄 줄바꿈태그와 공백문자   br태그는 줄바꿈을 담당하는 단일 태그입니다.   &lt;br /&gt;   html 문서에서 스페이스바로 공백을 두 번 이상 입력해도 표시되지 않습니다.  공백을 두 번 이상 표시할 때는 &amp;nbsp를 사용합니다.   &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","텍스트 태그"],
        "url": "/html/html-texttag/",
        "teaser": null
      },{
        "title": "CSS 함수",
        "excerpt":"📄 CSS 함수   CSS의 속성값을 지정할 때 함수의 성격을 적용할 수 있습니다.   CSS함수는 괄호 안에 인수를 전달하면, 인수에 따른 결과값을 속성에 적용하는 방식으로 동작합니다.   📄 calc()   CSS함수 중 계산을 담당하는 함수 입니다.   괄호안의 표현식을 결과값으로 적용합니다.   .message_text {   width: calc(100% - 100px); }   이렇게 message_text를 가변적인 크기로 설정이 가능합니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["calc"],
        "url": "/css/css-cssfunction/",
        "teaser": null
      },{
        "title": "폼(form) 태그",
        "excerpt":"📄 폼(form) 태그   form은 입력 요소를 감싸며 입력 값을 서버 측으로 제출합니다.  입력값을 클라이언트가 서버로 전송하면 서버 측에서는 데이터를 처리한 결과를 클라이언트에게 보내줍니다.   📄 폼(form)태그의 속성      action: 입력값을 전송할 서버의 url   method: 클라이언트가 입력한 데이터를 어떤 식으로 전송할 방법(GET or POST)   &lt;form action=\"example.php\" method=:\"POST\"&gt;     &lt;input type=\"submit\" value=\"전송\"&gt; &lt;/form&gt;       GET: 서버로 요청을 보내 응답을 받아냅니다. POST: 서버에 요청을 보내어 서버에 있는 데이터를 추가/수정/삭제한 후에 응답을 받아냅니다.   ","categories": ["HTML"],
        "tags": ["HTML","form"],
        "url": "/html/html-form/",
        "teaser": null
      },{
        "title": "HTML코드 기초 문법",
        "excerpt":"📄 태그(tag)   HTML 코드에서 정보(콘텐츠)를 정의하는 형식입니다.   &lt;태그명&gt; 여기에 콘텐츠를 기입합니다.&lt;/태그명&gt; &lt;/태그명&gt; // 단일 태그 사용 형태   📄 속성   태그의 부가적인 기능을 정의합니다.   &lt;태그명 속성명=\"속성값\"&gt;내용이 들어감&lt;/태그명&gt; &lt;태그 속성명=\"속성값\"/&gt; //단일 태그 사용 형태   📄 주석   사람에게는 보이지만, 웹브라우저에게는 보이지 않는 코드입니다.   주로 메모를 남기기 위해 사용됩니다.   &lt;!--** 이 사이에 작성한 내용은 주석으로 처리된다. **--&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","태그","속성","주석"],
        "url": "/html/html-html-grammner/",
        "teaser": null
      },{
        "title": "목록 표시하기",
        "excerpt":"📄 ul   순서 있는 항목은 &lt;ul&gt;태그로 작성합니다.   &lt;ul&gt;   &lt;li&gt;토끼&lt;/li&gt;   &lt;li&gt;다람쥐&lt;/li&gt;   &lt;li&gt;청설모&lt;/li&gt;   &lt;li&gt;호랑이&lt;/li&gt; &lt;/ul&gt;   이와 같이 항목 하나하나는 &lt;li&gt;로 표시합니다.   ul태그로 작성하면 앞에 숫자가 붙습니다.   📄 ol   순서 없는 항목은 &lt;ol&gt;태그로 작성합니다.   &lt;ol&gt;   &lt;li&gt;HTML&lt;/li&gt;   &lt;li&gt;CSS&lt;/li&gt;   &lt;li&gt;JAVAScript&lt;/li&gt;   &lt;ol&gt;&lt;/ol&gt; &lt;/ol&gt;   &lt;ul&gt;태그와 &lt;ol&gt;태그와 &lt;li&gt;태그는 모두 블록 레벨 요소를 만드는 태그입니다.  ","categories": ["HTML"],
        "tags": ["HTML","ul","ol","li"],
        "url": "/html/html-list/",
        "teaser": null
      },{
        "title": "메타(meta) 태그",
        "excerpt":"📄 메타(meta) 태그   meta 태그는 HTML 문서의 정보를 표시하는 태그입니다.   검색엔진 최적화에 기여하며, 검색 결과에도 영향을 끼칩니다.   개발자가 페이지를 참고할 때 도움이 되기도 합니다.   📄 메타 태그의 다양한 속성들   1. charset   문자 인코딩에 대한 요약 정보를 기입하는 속성입니다.   주로 영문과 한글을 모두 사용하기 위해 utf-8방식을 사용합니다.   &lt;meta charset=\"uth-8\" /&gt;   2. http-eqiv   콘텐츠 속성의 정보/값에 대한 HTTP 헤더를 제공합니다.   &lt;!-- IE 브라우저의 최신 버전의 엔진을 사용하라는 뜻--&gt; &lt;meta http-equiv=\"x-ua-compatible\" content=\"IE-edge\" /&gt; &lt;!-- 10초마다 페이지 새로고침하라는 뜻--&gt; &lt;meta http-equiv=\"refresh\" content=\"10\" /&gt;   3.name name 속성을 이름으로, content 속성을 값으로 하여 문서 정보를 제공합니다.   &lt;!--문서 제작자--&gt; &lt;meta name=\"author\" content=\"유노코딩\" /&gt; &lt;!-- 페이지에 대한 요약--&gt; &lt;meta name=\"desciption\" content=\"페이지에 대한 짧고 명확한 요약\" /&gt; &lt;!-- 페이지의 콘텐츠와 관련된, 쉼표로 구분한 키워드 목록--&gt; &lt;meta   name=\"keywords\"   content=\"예를 들면, 강아지, 고양이, 정보, 반려동물, 등등\" /&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","메타 태그","charset","http-eqiv","name"],
        "url": "/html/html-metatag/",
        "teaser": null
      },{
        "title": "select & textarea",
        "excerpt":"📄 select   select는 다수의 옵션(선택지)를 포함할 수 있는 선택 메뉴입니다.   메뉴 안에 포함되는 옵션은 option 태그를 사용하여 표시합니다.   &lt;select&gt;     &lt;option value=\"starbucks\"&gt;스타벅스&lt;/option&gt;     &lt;optio nvalue=\"coffeebean\"&gt;커피빈&lt;/option&gt;     &lt;option value=\"ediya\"&gt;이디야&lt;/option&gt;     &lt;option value=\"pascucci\"&gt;파스쿠찌&lt;/option&gt; &lt;/select&gt;      선택지에서 커피빈을 고른다 = cafe의 입력 값은 coffebean이다    📄 textarea   textarea는 여러 줄의 일반 텍스트를 입력할 수 있는 입력 요소입니다.   &lt;textarea name=\"letter\" rows=\"10\" cols=:10\"&gt;기본적으로 쓰여 있는 텍스트&lt;/textarea&gt;   출처      유노코딩  ","categories": ["HTML"],
        "tags": ["HTML","select","textarea"],
        "url": "/html/html-select&textarea/",
        "teaser": null
      },{
        "title": "CSS box-sizing",
        "excerpt":"📄 box-sizing 속성   box-sizing 속성은 너비와 높이가 포함할 영역을 변경함으로써 너비와 높이의 계산 방법을 결정할 수 있습니다.      content-box: 기본값. 너비와 높이가 콘텐츠 영역만을 포함합니다. padding이 추가 되어도 content크기는 보장받고 싶을 때 씁니다.   border-box: 너비와 높이가 안쪽 여백과 테두리까지 포함합니다.   div {   content-box: border-box; }      개발자도구를 통해 padding이 추가되어도 content크기는 변하지 않은 것을 확인할 수 있습니다.  ","categories": ["CSS"],
        "tags": ["content-box","border-box"],
        "url": "/css/css-boxsizing/",
        "teaser": null
      },{
        "title": "CSS 선택자",
        "excerpt":"📄 CSS 선택자   선택자는 어떤 요소에 대한 스타일을 정의할 것인지에 대한 정보입니다.   📄 선택자의 종류   1. 전체 선택자   애스터리스크(*)는 문서 내의 모든 요소를 의미합니다.   * {   color: blue; }   2. 태그 선택자(유형 선택자)   주어진 이름을 가진 요소를 선택합니다.   p {   color: blue; }   3. 클래스 선택자   주어진 class 속성값을 가진 요소를 선택합니다.   .text {   color: blue; }   4. 아이디 선택자   주어진 id 속성값을 가진 요소를 선택합니다.   #topic {   color: blue; }   5. 그룹 선택자   다양한 유형의 요소를 한꺼번에 선택하고자 할 때 사용합니다.  쉼표(,)를 이용해 선택자를 그룹화 합니다.   h1, p, div {   color: blue; }   📄 선택자의 우선순위   아이디 선택자 &gt; 클래스 선택자 &gt; 태그 선택자   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["css 선택자"],
        "url": "/css/css-cssSelector/",
        "teaser": null
      },{
        "title": "CSS기본문법",
        "excerpt":"📄 CSS란?   ▪ Cascading: 계단식  ▪ Style: 멋을 내다  ▪ Sheets: (종이)한 장    즉, 계단식으로 스타일을 정의하는 문서입니다.    css는 웹문서를 꾸며주기 위해 사용하는 언어입니다.    확장자는 *.css입니다.    css문서는 html문서와 함께 작업을 수행합니다.   &lt;link href=\"style.css\" rel=\"stylesheet\"&gt;   이와 같이 html문서에 css문서의 링크를 걸어주어 작업을 수행하게 됩니다.   📄 CSS 기본 구성   선택자 {   속성명: 속성값; }      선택자: 어떤 요소에 스타일을 적용할지에 대한 정보   {중괄호}: 선택한 요소에 적용할 스타일을 정의하는 영역   속성명: 어떤 스타일을 정의하고 싶은지에 대한 정보(색상, 크기 등)   속성값: 어떻게 정의하고 싶은지에 대한 정보   📄 주석   p {   /* 이 안에 작성하면 주석으로 처리됩니다. */ }   📄 HTML에 CSS문서를 적용하는 법      인라인 스타일: 태그에 직접 기술합니다.   스타일 태그: 스타일시트를 위한 태그를 추가하여 기술합니다   문서 간의 연결: 스타일시트 문서를 따로 작성하여 HTML 문서와 연결합니다.   &lt;link href=\"./style.css\" rel=\"stylesheet\" /&gt;      href: 연결하고자 하는 외부 소스의 url을 기술하는 속성   rel: 현재 문서(HTML)와 외부 소스의 연관 관계를 기술하는 속성    출처      유노코딩  ","categories": ["CSS"],
        "tags": ["css 구성","css 주석"],
        "url": "/css/css-cssgrammer/",
        "teaser": null
      },{
        "title": "display속성&border속성",
        "excerpt":"📄 display 속성   display 속성은 요소를 블록과 인라인 요소 중 어느 쪽으로 처리할지 정의합니다.   display 속성 값      inline: 인라인으로 처리   block: 블록 레벨로 처리   inline-block: 인라인으로 배치하되, 블록 레벨 요소의 속성을 추가할 수 있도록 처리   none: 존재는 하되, 디스플레이하지 않음   div {   display: inline; } div {   display: block; } div {   display: inline-block; } div {   display: none; }   📄 border 속성   요소가 차지하고 있는 영역에 테두리를 그릴 수 있습니다.  border 속성에는 속성값으로 테두리의 두께, 모양, 크기 등을 함께 지정할 수 있는데,  이러한 속성을 ‘단축속성’이라고 합니다.   &lt;!--두께가 2px인 직선 모양(solid)의 초록(green) 테두리를 만들어줘-- &gt; span {   border: 2px solid green; }   border 속성의 하위 속성      border-color: color 정의 방식과 동일   border-width: thin, medium, thick 등의 키워드 또는 px, em, rem 등의 단위   border-style: none, solid, dotted, dashed 등   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["display","border"],
        "url": "/css/css-display&border/",
        "teaser": null
      },{
        "title": "margin&padding 다루기",
        "excerpt":"📄 하위 속성 정의하기   div {   padding-top: 10px;   padding-right: 20px;   padding-bottom: 30px;   padding-lefr: 40px; }   위와 같이 margin에도 동일한 접미사를 붙여 개별 정의할 수 있습니다.   📄 여러 값을 한 번에 정의하기   span {   display: inline-block;   width: 100px;   height: 100px;   margin: 10px 20px 30px 40px;   &lt;!--순서: top-right-bottom-left--&gt;; }   위와 같이 padding에도 동일한 접미사를 붙여 개별 정의할 수 있습니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["margin","padding"],
        "url": "/css/css-margin&padding/",
        "teaser": null
      },{
        "title": "fixed&sticky",
        "excerpt":"📄 position: fixed;   요소를 일반적인 문서의 흐름에서 제거하고, 지정된 위치에 고정시킵니다.   .pos {   position: fixed;   top: 50px;   left: 50px; }      위에서부터 50px 왼쪽에서부터 50px 떨어진 자리에서 움직이지 않는다.    📄 position: sticky;   요소를 일반적인 문서 흐름에 따라 배치하고, 스크롤(roll)되는 가장 가까운 상위 요소에 대해 오프셋을 적용합니다.   .pos {   position: sticky; }      스크롤 이동으로 요소가 움직여도 스티키 요소는 고정된 상태를 유지한다.    출처      유노코딩  ","categories": ["CSS"],
        "tags": ["fixed","sticky"],
        "url": "/css/css-fixed&sticky/",
        "teaser": null
      },{
        "title": "float&clear",
        "excerpt":"📄 float   float속성은 요소가 문서의 흐름에서 제외되어 자신을 포함하고 있는 컨테이너의 왼쪽이나 오른쪽에 배치되게 합니다.  문서의 흐름에선 제외되지만, 필요한 만큼의 공간은 차지합니다.   주로 레이아웃을 구성할 때 블록레벨 요소를 가로 정렬하기 위해 사용됩니다.   float의 속성값      none: 기본값   left: 왼쪽부터 가로정렬   right: 오른쪽부터 가로정렬   float: left; float: right; margin: 0 auto; /* 중앙 정렬 */   📄 clear   clear속성은 float 요소 이후에 표시되는 요소의 동작들을 조절합니다.   컨테이너 요소에 float요소를 적용하고 이후 요소에 더이상 float을 적용하고 싶지 않을 때 사용합니다.   clear의 속성값      none: 기본값   left: float이 left인 요소의 아래로 내려가겠다    right: float이 right인 요소의 아래로 내려가겠다    both: float이 left및 right인 요소의 아래로 내려가겠다    .left {   background-color: #ff8c00;   width: 150px;   height: 50px;   float: left; } .right {   background-color: #9932cc;   width: 150px;   height: 50px;   float: right; } p {   clear: both; }   출처           유노코딩            Inpa Dev - Float 속성 간단 정리      ","categories": ["CSS"],
        "tags": ["fixed","sticky"],
        "url": "/css/css-float&clear/",
        "teaser": null
      },{
        "title": "z-index",
        "excerpt":"📄 z-index   z-index 속성은 요소의 쌓임 순서(stack order)를 정의합니다.  정수 값을 지정하여 쌓임 맥락(stacking context)에서의 레벨을 정의하는 방식으로 적용됩니다.  위치 지정 요소에 대해 적용할 수 있는 속성입니다.    .first {   z-index: 1; } .second {   z-index: 2; } .third {   z-index: 3; } .fourth {   z-index: 1; }   간단히 말해, 요소들의 z축 순서를 결정해 주는 속성입니다.      z-index은 정해진 정수 값이 있는 것이 아니라, 상대적인 수로 쌓임 맥락이 결정됩니다.   z-index의 숫자가 같을 경우에는, 나중에 쌓은 요소가 위로 오게 됩니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["z-index"],
        "url": "/css/css-z-index/",
        "teaser": null
      },{
        "title": "뷰포트(viewport)",
        "excerpt":"📄 뷰포트(viewport)   현재 화면에 보여지고 있는 영역을 의미합니다.   기기별로 뷰포트가 다르기때문에 보여지는 화면의 배율에 따라 화면이 다르게 보입니다.   html문서에서 이름이 뷰포트인 메타태그 설정을 확인할 수 있습니다.   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;      width=device-width : 너비를 기기의 너비 기준으로 초기화 한다. initial-scale=1.0 : 기기의 너비에 맞게 초기 scale를 지정한다.    이 메타태그 설정은 기기에 맞게 화면 배율을 조정해주기 때문에, 모바일 화면에서도 pc화면과 동일하게 콘텐츠의 크기가 유지되는 것을 확인할 수 있습니다.   📄 뷰포트 단위   뷰포트 크기를 기반으로 값을 계산하여 크기를 결정하는 가변단위들이 있습니다.   이는 반응형 웹을 만들 때 매우 유용하게 사용되는 단위들입니다.   ▪ font-size: 1vw;      화면 사이즈에서 너비의 100분의 1    화면 너비의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vh;      화면 사이즈에서 높이의 100분의 1    화면 높이의 백분율을 계산해서 크기를 조정합니다.   ▪ font-size: 1vmin;      화면 사이즈에서 너비와 높이 중 작은것의 100분의 1 너비와 높이 중 작은 것에 백분율을 맞춘다    ▪ font-size: 1vmax;      화면 사이즈에서 너비와 높이 중 큰것의 100분의 1 너비와 높이 중 큰 것에 백분율을 맞춘다.   ","categories": ["HTML"],
        "tags": ["HTML","뷰포트"],
        "url": "/html/html-viewport/",
        "teaser": null
      },{
        "title": "가변 동영상",
        "excerpt":"📄 가변 동영상   동영상도 이미지와 마찬가지로 화면 배율에 따라 가변적으로 크기를 설정할 수 있습니다.   다만 유튜브 등 동영상 서비스에 따라 성질이 다를 수 있어 주의해야 합니다.   📄 가변 동영상 설정 1 | vedio 태그   &lt;video src=\"./my-cat.mp4\" controls&gt;&lt;/video&gt;   동영상 파일을 직접 가지고 있다면, 이렇게 body태그안에서 video태그를 설정하면 됩니다.   컨트롤 속성으로 컨트롤 패널을 추가했습니다.   style태그에서 너비를 %단위로 지정하게 되면 화면 크기에 따라 동영상 화면 크기가 변합니다.   📄 가변 동영상 설정 2 | iframe 태그   하지만 동영상 파일을 직접 가지고 있지 않다면 유튜브 등 동영상 서비스를 이용하는 방법이 있습니다.   유튜브에서 원하는 동영상을 선택후 공유 &gt; 퍼가기를 선택합니다.      유튜브는 이렇게 iframe태그를 제공합니다.   이 iframe 태그를 body태그로 가져오면 웹페이지에 동영상을 설정할 수 있습니다.   ▪ iframe 태그의 문제점   style태그에서 iframe태그의 너비를 100%로 설정해주면 생각보다 동영상 화면 크기 전환이 자연스럽지 않은 것을 확인할 수 있습니다.   제공받은 iframe태그는 동영상 서비스에서 다양한 속성을 설정하는 등 단순하지 않은게 이유가 됩니다.   이 문제는 여백을 만들어주고 그 여백에 동영상 크기를 맞춤으로써 해결할 수 있습니다.   &lt;div class=\"player\"&gt;         &lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BYMM5Dh_tSY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;      여백을 설정해줄 div를 설정해준 후 iframe태그를 넣었습니다.   &lt;style&gt;      .player{        padding-top: 56.25%;        position: relative;       }      iframe{        position: absolute;        top: 0; left: 0;        width: 100%;        height: 100%;      } &lt;/style&gt;      스타일 태그안에서 클래스 선택자를 이용해 player로 설정한 div의 padding-top크기를 동영상의 종횡비에 맞추어 %단위로 지정했습니다.   iframe은 position을 이용해 위치를 고정시키고 너비와 높이를 부모 요소인 player에 맞게 100%설정했습니다.   이렇게 iframe태그로 동영상을 가져오면 크기 전환이 더 자연스럽고 보다 나은 웹 구현이 가능하게 됩니다.   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["가변 동영상","video","iframe"],
        "url": "/css/css-variable-video/",
        "teaser": null
      },{
        "title": "가변 이미지",
        "excerpt":"📄 가변 이미지   화면의 배율에 따라 크기가 달라지는 이미지 입니다.   보통 px로 고정을 시켜놓는 경우도 있지만, 그렇지 않은 경우에는 화면이 커질 수록 픽셀이 깨져보이는 현상이 발생합니다.   📄 가변 이미지 설정 1 | max-width 사용   이미지 너비를 %단위로 지정하고 max-width를 사용하면 화면이 커질수록 이미지크기가 증가하다가,  일정 크기에 도달하면 더이상 증가하지 않음으로써 이미지를 보호할 수 있습니다.    &lt;style&gt;         div{             width: 50%;/* body의 50%로 크기지정*/         }         img{              max-width: 640px; /*이미지 최대크기 지정*/         }  &lt;/style&gt;   주의할 점   width는 너비를 지정하는 속성이고, max-width는 최대 넓이 제한 길이를 지정하는 속성입니다.   혼동하지 않도록 조심해야 합니다.   📄 가변이미지 설정 2 | picture 태그 사용   주로 해상도 별로 이미지의 비율을 바꾸고 싶을때 picture태그를 사용합니다.   source태그를 통해서 이미지를 미디어 조건에 맞게 불러올 수 있습니다.    &lt;picture&gt;         &lt;source srcset=\"jake2.jpg\" media=\"(min-width: 800px)\"&gt;&lt;!--800px보다 이미지가 커지면 jake2이미지를 보여준다.--&gt;         &lt;img src=\"jake..jpg\"&gt;  &lt;/picture&gt;   출처      유노코딩  ","categories": ["CSS"],
        "tags": ["가변 이미지","max-width","picture"],
        "url": "/css/variable-image/",
        "teaser": null
      },{
        "title": "CSS 텍스트 꾸미기",
        "excerpt":"📄 font-family   글꼴을 정의합니다.   여러 개의 글꼴을 연달아 작성하여 우선순위를 정할 수 있습니다.   p {   font-family: Times.monospace, serif; }   📄 font-size   글자 크기를 정의합니다.      px: 모니터 상의 화소 하나 크기에 대응하는 절대적인 크기   span {   font-size: 16px; }      rem: &lt;html&gt; 태그의 font-size에 대응하는 상대적인 크기   span {   font-size: 2rem; }      em: 부모태그(상위태그)의 font-size에 대응하는 상대적인 크기   span {   font-size: 1.5em; }   📄 text-align   정렬 방식 정의합니다.      left/right: 왼쪽 또는 오른쪽 정렬한다.   center: 가운데 정렬한다.   justify: 양끝 정렬한다.(마지막 줄 제외)   p {   text-align: right; }   📄 color   글자 색상을 정의합니다.      키워드: 미리 정의된 색상별 키워드를 정의한다.   RGB 색상 코드: # + 여섯자리 16진수 값 형태로 지정한다.   RGB 함수: Red, Green, Blue의 수준을 각각 정의해 지정한다.   span {   color: red; } span {   color: #FF000; } span {   color: rgb(100%, 0%, 0%); }   📄 line-height   글자가 위치한 높이의 크기(행간)를 의미합니다.   단위를 입력하지 않으면 브라우저가 자동으로 배율로 인식합니다.   line-height: 52px;   📄 letter-spacing   텍스트의 자간을 설정합니다.   해당 수치만큼 자간이 가까워집니다.   letter-spacing: 20px; letter-spacing: -2px;   📄 word-spacing   띄어쓰기를 기준으로한 단어의 간격을 의미합니다.   word-spacing: 20px;   📄 text-indent   텍스트의 들여쓰기를 결정합니다.   text-indent: 50px;   📄 text-transform   영문 텍스트의 대/소문자를 바꿀 수 있습니다.   text-transform: none; text-transform: capitalize; text-transform: uppercase; text-transform: lowercase;   📄 overflow   콘텐츠가 커서 요소 안에서 내용을 다 보여주기 힘들 때, 어떤 방식으로 보여줄지 결정합니다.   overflow: visible(기본값); overflow: hidden; overflow: scroll; // 무조건 스크롤 적용 overflow: auto; // 콘텐츠 밖으로 텍스트가 넘쳤을때만 스크롤 적용   📄 text-overflow   텍스트가 한줄일 때, 요소 밖으로 넘치는 text를 어떻게 표기할지 결정합니다.   선행 조건      white-space: nowrap;   overflow: hidden;   text-overflow: clip(기본값); // 공간에 맞게 텍스트가 잘림 text-overflow: ellipsis; // 잘린 텍스트를 말줄임표를 이용해 표현     출처      강력한 CSS  ","categories": ["CSS"],
        "tags": ["font","text","line-height","letter","word","overflow"],
        "url": "/css/css-font/",
        "teaser": null
      },{
        "title": "CSS background",
        "excerpt":"📄 background   background는 콘텐츠의 배경을 정의합니다.   📄 background의 하위 속성   ▪ background-color   : 배경색을 정의합니다.   ▪ background-image   : 배경 이미지를 정의합니다.   background-image: url(이미지);   ▪ background-position   : 배경 이미지의 초기 위치를 정의합니다.   ▪ background-size   : 배경 이미지의 크기를 정의합니다.      cover: 이미지가 찌그러지지 않는 한도 내에서 최대로 설정합니다.   contain: 이미지가 찌그러지거나 잘리지 않는 한도 내에서 최대로 설정합니다.   ▪ background-repeat   : 배경 이미지의 반복 방법을 정의합니다.      no-repeat: 이미지를 반복하지 않습니다.(이미지가 콘텐츠보다 작을 경우 활용)   div {   background-image: url(이미지);   background-repeat: no-repeat;   background-position: center;   background-size: contain; }     background는 하위 속성을 연달아 정의할 수 있습니다.  매우 다양하여 사용자는 속성값을 정확한 값으로만 정의하면 됩니다.   background: no-repeat url(이미지);  ","categories": ["CSS"],
        "tags": ["backgroud"],
        "url": "/css/css-background/",
        "teaser": null
      },{
        "title": "position(relative & absolute)",
        "excerpt":"📄 position   position은 HTML 요소가 배치되는 방식을 방법을 정의합니다.   📄 position의 속성값    1. static: 기본값   position이 기본 속성일 때는 위치 조정이 불가능한 기본 HTML 요소의 상태가 됩니다.   따라서 top, left, bottom right를 사용할 수 없습니다.   .item2 {   position: static;   top: 30px; // 의미없는 코드   left: 30px; // 의미없는 코드 }    2. relative: 기본값   : 원래 있던 자리를 기준으로 요소의 위치를 조정할 수 있습니다.   div {   width: 100px;   height: 100px;   background-color: red;    position: relative;   top: 100px;   left: 100px; // 위에서부터 100px, 왼쪽에서부터 100px이동 }      원래 위치보다 위에서부터 100px, 왼쪽에서부터 100px 떨어진다.     3. absolute   : 요소를 일반적인 문서의 흐름에서 제거하고,   대상의 부모 요소 중 relative가 적용된 요소가 있다면 해당 위치를 절대 좌표의 기준으로 정합니다.   relative가 적용된 요소가 없다면 body태그를 기준으로 절대 위치를 정합니다.   div {   width: 100px;   height: 100px;   background-color: red;    position: absolute;   top: 100px;   left: 100px; }    4. fixed   : 스크롤과 무관하게 뷰포트를 기준으로 요소의 위치를 설정합니다.   스크롤을 내려도 화면에 고정되어 위치가 변하지 않습니다.   .item2 {   position: fixed;   top: 30px;   left: 30px; }    4. sticky   : 요소의 원래 위치에 있다가 스크롤이 내려가면 지정된 좌표에 고정됩니다.   기준은 부모 요소의 좌표입니다.   스크롤이 내려가지 않았을 때는 static처럼 작동하다가, 해당요소의 위치 아래로 스크롤이 내려가면 지정한 좌표에 고정됩니다.   .item2 {   position: sticky;   top: 30px;   left: 30px; } ---  ## 출처  - [강력한 CSS](https://www.inflearn.com/course/%EA%B0%95%EB%A0%A5-css-%EC%BD%94%EB%93%9C%EC%BA%A0%ED%94%84)  ","categories": ["CSS"],
        "tags": ["position","relative","absolute"],
        "url": "/css/css-position/",
        "teaser": null
      },{
        "title": "식별자(Identifier)",
        "excerpt":"📄 식별자(Identifier)   코드 내의 변수, 함수 혹은 속성을 식별하는 문자열을 식별자라고 합니다.   식별자를 통해서 이름을 지어주게 됩니다.   📄 식별자를 만들 때 규칙           식별자는 대소문자를 구분합니다.            유니코드 문자, $, 숫자를 사용할 수는 있지만, 숫자로 시작할 수는 없습니다.            예약어는 사용할 수 없고, 공백 문자도 사용할 수 없습니다.            한글도 가능은 하지만, 보통 영문을 사용합니다.       📄 주의할 점      식별자를 만들 때는 의미없는 이름보다는, 역할에 맞는 적절한 이름을 짓도록 해야합니다.   📄 식별자 가능 유무 확인하기   [식별자]https://mothereff.in/js-variables       사용가능한 식별자를 확인하는 페이지 입니다.    출처      패스트 캠퍼스 프론트엔드 올인원 패키지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","식별자"],
        "url": "/javascript/js-identifier/",
        "teaser": null
      },{
        "title": "조건문",
        "excerpt":"📄 조건문   조건문은 표현식이 참으로 평가될 때, 실행되는 블럭입니다.   if (true) {   console.log(\"항상 실행\"); // 출력됨. }  if (false) {   console.log(\"항상 실행되지 않음\"); // 출력되지 않음. }   조건이 참인 경우는 출력이 되고 거짓인 경우는 출력되지 않습니다.                  TIP       블록에 코드가 한줄이면, 중괄호는 생략 가능합니다.           if (true) console.log(\"항상 실행\");  if (false) console.log(\"항상 실행되지 않음\");   📄 표현식이 거짓으로 평가될 때   표현식이 거짓으로 평가될 때는 false만 있는 것이 아닙니다.   if (false) console.log(false); if (0) console.log(0); if (\"\") console.log(\"\"); if (null) console.log(null); if (undefined) console.log(undefined); if (NaN) console.log(NaN);   위의 경우 모두 거짓으로 평가되어 출력되지 않습니다.   📄 표현식이 참으로 평가될 때   마찬가지로 참인 경우도 여러가지 경우가 있습니다.   if (true) console.log(true); if (37) console.log(37); if (-37) console.log(-37); if (\"Mark\") console.log(\"Mark\"); if ({}) console.log({}); if ([]) console.log([]);   📄 if에 해당하지 않을 때 | else   if문으로 조건식을 작성하고 반대의 경우에는 간단하게 else로 작성할 수 있습니다.   const n = 15;  if (n % 3 === 0) {   console.log(\"n은 3의 배수 입니다.\"); } else if (n % 5 === 0) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   마찬가지로 한줄로 작성할 경우 중괄호 생략이 가능합니다.   if (n &gt; 0) console.log(\"n이 0보다 큰 경우\"); else console.log(\"n이 0보다 크지 않은 경우\");   📄 조건이 여러번 반복되는 경우   조건이 여러번 반복되는 경우에는, 조건을 변수나 상수에 넣어 작성할 수 있습니다.    const multipleOfThree = n % 3 === 0; const multipleOfFive = n % 5 === 0;  if (multipleOfThree &amp;&amp; multipleOfFive) {   console.log(\"n은 15의 배수입니다.\"); } else if (multipleOfThree) {   console.log(\"n은 3의 배수입니다.\"); } else if (multipleOfFive) {   console.log(\"n은 5의 배수 입니다.\"); } else {   console.log(\"n은 3의 배수도 아니고, 5의 배수도 아닙니다.\"); }   📄 삼항 연산자를 이용한 조건부 실행   조건 ? 조건이 참이면 실행되는 표현식 : 조건이 거짓이면 실행되는 표현식   삼항 연산자를 이용한 조건부 실행은 위의 형식으로 나타납니다.   중괄호 {}를 사용할 수 없는 문법이기 때문에 하나의 표현식으로 작성합니다.   let n = 5;  const message = n % 5 === 0 ? \"5의 배수 입니다.\" : \"5의 배수가 아닙니다.\"; console.log(message);   주의할 점   삼항연산자를 남발하면 오히려 보기 헷갈릴 수 있으니 가급적 여러번 사용하는 것은 지양합니다.    📄 switch를 이용한 조건문   switch뒤 괄호 안에 있는 값이 무엇인지 중괄호 안에 있는 코드들을 비교해서 실행합니다.   복수의 if문을 switch문으로 정리할 수 있습니다.      5의 배수 일 경우 case0으로 출력하는 조건문   switch (n % 5) {   case 0: {     console.log(\"5의 배수입니다.\");     break;   }   case 1:   case 2:   case 3:   case 4:     console.log(\"5의 배수가 아닙니다.\");    default:     console.log(n); }   만약에 해당 블럭이 실행된 후 다음 블럭을 거치지 않고 switch문을 나가고 싶다면, case문 안에서 break;를 실행합니다.   break와 case 문의 순서를 잘 조정하여, 원하는 코드를 만들어 낼 수 있도록 제대로 이해해야 합니다.   출처      패스트캠퍼스 프론트엔드 강의   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","조건문"],
        "url": "/javascript/js-conditional/",
        "teaser": null
      },{
        "title": "객체(Object)",
        "excerpt":"📄 객체란 무엇인가?   객체는 이름과 값으로 구성된 프로퍼티의 정렬되지 않은 집합체입니다.   객체를 생성할 때는 함수나 클래스를 이용할 수 있습니다.   쉽게 말해 함수나 클래스를 큰 틀로 생각하고 하나하나 찍어내는 것을 각각 객체라고 생각하면 됩니다.   이 객체는 인스턴스라고 부르기도 합니다.   new라는 키워드를 통해 객체를 생성합니다.   function A() {}  const a = new A(); // new를 통해서 함수 A의 객체가 만들어져 변수 a에 할당된다. console.log(a, typeof a); console.log(A());   📄 객체에 속성(프로퍼티)추가하기   함수에서 프로퍼티를 만들어 객체에 할당할 수 있습니다.   프로퍼티를 설정하면 각각의 성질을 가지는 속성을 만들게 됩니다.   function A(name) {   this.name = name; }  const a = new A(\"Mark\"); console.log(a);   함수를 속성으로 넣기   함수를 프로퍼티로 넣는 것또한 가능합니다.   function B() {   this.hello = function () {     console.log(\"hello\");   }; }  new B().hello();      함수B의 프로퍼티 hello에 ‘hello’를 출력하는 함수를 설정함.    📄 객체 리터럴   객체 리터럴은 중괄호 안에 프로퍼티를 정의하여 객체를 생성하는 방식입니다.   프로퍼티는 쉼표(,)로 구분합니다.   const b = {   name: \"Mark\", // name이라는 프로퍼티에 'Mark'라는 값 할당 };  console.log(b, typeof b);   결과   {   name: \"Mark\"; } object;   프로퍼티에 함수도 할당할 수 있습니다.   const c = {   name: \"Mark\",   hello1() {     console.log(\"hello1\", this.name);   },   hello2: function () {     console.log(\"hello2\", this.name);   },   hello3: () =&gt; {     console.log(\"hello3\", this);   }, };  c.hello1(); c.hello2(); c.hello3();   결과   hello1 Mark hello2 Mark hello3 {}  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체"],
        "url": "/javascript/javascript-object/",
        "teaser": null
      },{
        "title": "[클래스] 상속",
        "excerpt":"📄 클래스 상속   extends라는 키워들를 통해서 자식클래스가 부모클래스를 상속받습니다.   class Parent {}  class Child extends Parent {}   오버라이딩(override)   오버라이딩은 부모클래스에서 구현한 함수나 변수를 자식클래스에서 다시 구현하는 것입니다. 즉, 자식이 만든 함수가 부모가 만든 함수를 덮어씌우는 것을 오버라이딩이라고 합니다.   class Parent {   name = \"Lee\";    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age = 37;    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }      자식 클래스에서 부모클래스의 hello 함수를 오버라이딩 함.   📄 super (새로운 속성 추가하기)   자식클래스가 부모클래스로부터 상속을 받을 때, 새로운 속성을 추가하려면 super()로 부모클래스로부터 생성자를 호출해 초기값을 세팅합니다.   super은 생성자안에서 사용합니다.    class Parent {   name;    constructor(name) {     // name값을 받는 생성자     this.name = name;   }    hello() {     console.log(\"hello\", this.name);   } }  class Child extends Parent {   age;    constructor(name, age) {     super(name); //부모클래스의 생성자를 호출해 초기값 세팅     this.age = age;   }    hello() {     //오버라이딩     console.log(\"hello\", this.name, this.age);   } }   출처      패스트클래스  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스","상속"],
        "url": "/javascript/js-class2/",
        "teaser": null
      },{
        "title": "데이터 타입(Data type)",
        "excerpt":"📄 데이터 타입(Data type)   프로그램에서 다뤄지는 모든 데이터에는 다양한 종류가 있습니다.   그 종류들을 데이터 타입이라고 부릅니다.   📄 String   String은 데이터를 문자열로 표현합니다.   데이터를 문자열로 지정하는 경우 따옴표 혹은 쌍따옴표를 이용합니다.   let text = \"hello\"; let name = \"하이요\";   📄 boolean   boolean은 데이터의 참과 거짓을 지정하는 타입입니다.   let good = true; let loading = false;   📄 null과 undefined   null과 undifined는 둘다 의미가 없음을 뜻합니다.   하지만 분명한 차이점이 존재합니다.   null은 의미가 진짜 없다는 뜻을 가지고 있고,   undefined는 의미가 아직 정해지지 않았다는 뜻입니다.   let friend = null; let criminal;   위 코드를 출력하면   friend는 null을 그대로 출력하지만,   아무것도 값이 지정되지 않은 criminal은 undefined를 출력합니다.   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","데이터타입"],
        "url": "/javascript/javascript-datatype/",
        "teaser": null
      },{
        "title": "배열(Array)",
        "excerpt":"📄 배열(Array)   배열은 여러개의 항목이 들어있는 리스트를 뜻합니다.   배열은 대괄호([])를 사용하여 선언합니다.   대괄호 안에 들어가는 항목들은 숫자, 문자열 배열, 객체 등 이 있습니다.   const array = [1, 2, 3, 4, 5];      이름이 array인 배열을 선언함.    📄 배열에 새로운 항목 추가   배열에 새로운 항목을 추가할 때는 push라는 키워드를 사용합니다.   array.push(6);      배열에 6이라는 값을 추가함    이렇게 배열에 값을 추가하면 배열의 마지막에 추가 됩니다.    📄 배열의 크기 조회   배열의 크기를 조회 한다는 것은 배열에 몇개의 항목이 있는지 계산한다는 뜻입니다.   배열의 크기를 조회할 때는 length라는 키워드를 사용합니다.   console.log(array.length);      배열 array의 크기를 조회해서 출력한다.    출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","배열"],
        "url": "/javascript/javascript-array/",
        "teaser": null
      },{
        "title": "get & set 함수",
        "excerpt":"📄 get &amp; set 함수   클래스 내부에서 get과 set 함수를 이용해 값을 저장하고 불러올 수 있습니다.      get: 값을 조회한다.   set: 값을 저장한다.   📄 Getter함수   Getter함수는 특정 값을 실행이 아닌 조회하려고 할 때 사용됩니다.   조회하려는 값을 return키워드를 사용해 조회합니다.   const numbers = {   a: 1,   b: 2,   get sum() {     console.log(\"sum함수가 실행됩니다.\");     return this.a + this.b;   }, };      const numbers라는 객체의 a와 b를 합한 값을 조회하는 Getter함수 sum.    📄 Setter함수   Setter함수는 객체나 함수 밖에서 값을 설정하려고 할 때 사용됩니다.   그렇기 때문에 Getter함수와는 다르게 파라미터 값 설정은 필수입니다.   const dog = {   _a: 1,    set name(value) {     this._a = value;   }, };   출처      패스트캠퍼스 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","get","set"],
        "url": "/javascript/javascript-get&set/",
        "teaser": null
      },{
        "title": "함수",
        "excerpt":"📄 함수   함수는 특정코드를 하나의 명령으로 실행할 수 있게 해주는 기능입니다.   함수는 파라미터가 주어졌을 때 파라미터를 처리해서 결과를 만듭니다.   📄 선언방법   함수를 선언할 때는 functions이라는 키워드를 사용합니다.   함수의 결과 값을 나타낼 때는 return이라는 키워드를 사용합니다.   return되는 순간 함수는 종료됩니다.   functions add(a,b) { // add라는 이름의 함수에 파라미터값으로 a와 b를 받아서, a + b의 결과값을 return시키는 함수.     return a + b; }   📄 선언적 함수   선언적 함수는 함수에 이름을 붙여서 선언합니다.    function hello1() {   // 함수 선언   console.log(\"hello1\"); }  hello1(); //함수 호출   결과     📄 익명함수   함수의 이름을 만들어주지 않고 특정 변수에 함수를 할당하는 방식입니다.   const hello1 = function () {   console.log(\"hello1\"); };   결과     📄 선언적 함수와 익명함수의 차이점   선언적 함수는 호출이 먼저 나와있어도 문제없이 실행되지만,  익명함수는 호출이 먼저 나오면 에러가 발생합니다.   hello1(); // 선언적 함수는 호출이 먼저 나와있어도 문제없이 실행. hello2(); // 익명함수는 호출이 먼저나오면 문제 발생 function hello1() {   //선언적 함수   console.log(\"hello1\"); }  var hello2 = function () {   console.log(\"hello2\"); };   결과     📄 리턴   리턴은 함수를 실행하면 얻는 값입니다.   const hello3 = function (name) {   return `hello ${name}`; };   작은따옴표(‘)가 아닌 백틱(`)를 써야 합니다.   함수 안에서 함수를 만들어 리턴   리턴값으로 함수를 지정하여 리턴할 수 있습니다.    function plus(base) {   return function (num) {     return base + num;   }; }  const plus5 = plus(5); console.log(plus5(10));   📄 인자로 함수를 사용   함수를 호출하는 경우 인자로 함수를 사용할 수 있습니다.    function hello(c) {   console.log(\"hello\");   c(); }  hello(function () {   console.log(\"콜백\"); });   결과   hello; 콜백;   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","함수"],
        "url": "/javascript/js-function/",
        "teaser": null
      },{
        "title": "비구조화 할당",
        "excerpt":"📄 비구조화 할당   비구조화 할당을 다른 말로 표현하면 객체 구조 분해라고 할 수 있습니다. 말 그대로 객체의 구조를 분해해서 특정값을 추출하는 과정을 비구조화 할당이라고 합니다.   const ironMan = {   name: \"토니 스타크\",   actor: \"로버트 다우니 주니어\",   alias: \"아이언맨\", };  const { name } = ironMan; //객체 ironMan에서 name이란 값을 추출함. console.log(name);   결과   토니 스타크   중괄호({})를 사용해서 선언한 객체의 원하는 키를 뽑아냅니다.   객체뿐만아니라 배열에서도 비구조화 할당을 할수 있습니다.   const array = [1, 2];  const [one, two = 2] = array;  console.log(one); console.log(two);   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","객체","비구조화 할당"],
        "url": "/javascript/javascript-destructuringAssignment/",
        "teaser": null
      },{
        "title": "spread & rest",
        "excerpt":"📄 spread 연산자   spread연산자는 ES6문법에서 처음으로 등장했습니다.   spread연산자는 객체나 배열의 엘리먼트를 요소 하나하나로 펼쳐서 사용할 수 있게 합니다.   ...라는 키워드를 사용합니다.   기존 객체나 배열을 복사하고 추가적인 값을 넣어줄 때 주로 사용합니다.   const first = {   one: 1, };  const second = {   ...first, //first의 엘리먼트를 가져옴.   two: 2, };  consol.log(first); consol.log(second);   ✔ 결과   { one: 1} { one: 1, two: 2}   장점           spread연산자는 기존객체를 변경시키지 않고 복사해옵니다.            코드의 재사용성이 높아집니다.       📄 rest 연산자   rest연산자도 마찬가지로 ...키워드를 사용합니다.   차이점은 ‘나머지’라는 뜻을 가진것처럼 정해준 값 이외의 값을 복사해온다는 것입니다.   const numbers = [0, 1, 2, 3, 4, 5, 6];  const [one, ...rest] = numbers; //첫번째 값을 제외한 값을 rest로 가져온다. console.log(one); console.log(rest);   ✔ 결과   0; [(1, 2, 3, 4, 5, 6)];   출처      패스트캠퍼스 프론트엔드 강의  ","categories": ["JavaScript"],
        "tags": ["JavaScript","spread","rest"],
        "url": "/javascript/javascript-spread&rest/",
        "teaser": null
      },{
        "title": "불변객체(Immutable Object )",
        "excerpt":"📄 불변 객체란?   변수에 새로운 객체를 할당하더라도, 객체의 주소가 변하지 않는 객체   불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역메모리입니다.   불변 객체는 언제 필요할까?   모든 참조형 데이터가 가변성을 띠는 것은 아닙니다.   참조형 데이터가 가변성을 가질 때는 데이터 자체가 아닌 내부 프로퍼티를 변경하는 경우입니다.   내부 프로퍼티를 변경하면 변수가 가르키고 있는 데이터의 주소가 변경되기 때문입니다.   이러한 상황에서 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 불변객체가 필요합니다.   var user = {   name: \"Jaenam\",   gender: \"male\", };  var chanegeName = function (user, newName) {   var newUser = user;   newUser.name = newName;   return newUser; };  var user2 = chanegeName(user, \"Jung\");  if (user !== user2) {   console.log(\"유저 정보가 변경되었습니다.\"); // 실행되지 않음 } console.log(user.name, user2.name); console.log(user === user2);   결과    Jung Jung true   user과 newUser이 같은 데이터 주소를 참조하게 되어 newUser의 데이터가 변경될때 마다 user의 데이터도 변경됩니다.   따라서 user를 불변 객체로 만들어 줄 필요성이 보입니다.   📄 얕은 복사와 깊은 복사   1. 얕은 복사   중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사합니다.   얕은 복사를 하면 해당 프로퍼티에 대한 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키고, 사본을 바꾸면 원본이 바뀌고 원본을 바꾸면 사본이 바뀌는 현상이 일어납니다.   var copyObject = function (target) {   var result = {};   for (var prop in target) {     result[prop] = target[prop];   }   return result; };  var user = {   name: \"Jaenam\",   urls: {     portfolio: \"http://github.com/abc\",     blog: \"http://blog.com\",     facebood: \"http://facebook.com/abc\",   }, }; var user2 = copyObject(user);  user.name = \"Jung\"; console.log(user.name === user2.name); //false  user.urls.portfolio = \"http://portfolio.com\"; console.log(user.urls.portfolio === user2.urls.portfolio); // true  user2.urls.blog = \"\"; console.log(user.urls.blog === user2.urls.blog); //true   결과    false true true   user객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것을 확인할 수 있습니다..   user.urls의 프로퍼티에 대해서도 불변 객체로 만들 필요성이 생겼습니다.   깊은 복사   깊은 복사는 얕은 복사에서 한 단계 더 복사를 하는 것입니다.   객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하고, 참조형 데이터에는 다시 그 내부의 프로퍼티를 복사합니다.   var copyObjectDeep = function (target) {   var result = {};   if (typeof target === \"object\" &amp;&amp; target !== null) {     for (var prop in target) {       result[prop] = copyObjectDeep(target[prop]);     }   } else {     result = target;   }   return result; };   target이 객체인 경우 내부 프로퍼티를 순회하여 copyObjectDeep함수를 재귀적으로 호출하고, 원본과 사본이 서로 다른 객체를 참조하게 됩니다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","불변객체"],
        "url": "/javascript/javascript-immutableObject/",
        "teaser": null
      },{
        "title": "호이스팅(hoisting)",
        "excerpt":"📄 호이스팅(hoisting)   아래에 있는 선언을 먼저 끌어올리는 것을 호이스팅이라고 합니다.   변수나 함수를 먼저 호출하고 다음에 변수나 함수를 선언하게 되면 문제없이 함수의 결과값이 출력됩니다.    hello2(); // 함수 호출  function hello2() {   //함수 선언   console.log(\"hello2\"); }   함수뿐만 아니라 var키워드를 통한 호이스팅도 가능합니다.   age = 6; age++; console.log(age);  var age;   주의할 점   var로 변수를 선언함과 동시에 값을 지정했다면, 값을 제외한 선언만 호이스팅 됩니다.   console.log(name);  name = \"Mark\";  console.log(name);  var name = \"Sujin\";   결과      이렇게 호이스팅되어 먼저 출력된 name은 값을 제외한 선언만 끌어올리기 때문에 undifined라고 출력됩니다.   함수를 선언했을 때는 함수 전체를 끌어올립니다.   function a() {   var b; // 수집 대상 1. 변수는 선언부만 끌어올립니다.   function b() {} // 수집 대상 2. 함수 선언은 전체를 끌어올립니다.    console.log(b);   b = \"bbb\";   console.log(b);   console.log(b); } a();   결과   [Function: b] bbb bbb   📄 let을 이용한 호이스팅은 불가능!   let을 이용한 호이스팅은 불가능 합니다.   let은 무조건 선언이 우선시 되어야 합니다.   console.log(name);  name = \"MARK\";  console.log(name);  let name;   결과      출처      패스트캠퍼스 프론트엔드 강의   코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","호이스팅"],
        "url": "/javascript/javascript-hoisting/",
        "teaser": null
      },{
        "title": "명시적으로 this를 바인딩 하는 방법",
        "excerpt":"📄 명시적으로 this를 바인딩 하는 방법   this는 함수를 호출할 때 결정됩니다.   하지만 this가 가리키는 대상을 명시적으로 바인딩할 수 있습니다.   📄 call 메서드   call메서드는 호출 주체인 함수를 즉시 실행하도록 합니다.   Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])      첫 번째 인자를 this로 바인딩한다.   이후 인자들은 호출할 함수의 매개변수이다.   var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, };  obj.method(2, 3); obj.method.call({ a: 4 }, 5, 6);   call메서드의 첫번째 인자로 this가 가리키는 a값을 4로 변경합니다.   ✔ 결과   1 2 3 4 5 6   📄 apply 메서드   Function.prototype.apply(thisArg[, argsArray])      첫 번째 인자를 this로 바인딩한다.   두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다.   var func = function (a, b, c) {   console.log(this, a, b, c); }; func.apply({ x: 1 }, [4, 5, 6]);  var obj = {   a: 1,   method: function (x, y) {     console.log(this.a, x, y);   }, }; obj.method.apply({ a: 4 }, [5, 6]);   ✔ 결과   { x: 1 } 4 5 6 4 5 6   call/apply 메서드는 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있지만, 그럼에도 불구하고 ES5이하의 환경에서는 마땅한 대안이 없어 실무에서 광범위하게 활용됩니다.   📄 bind 메서드   Function.prototype.bind(thisArg[, arg1, arg2, ...])   bind메서드는 call과 비슷하지만,  즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 함수이다.      함수에 this를 미리 적용한다.   부분 적용 함수를 구현한다.   var func = function (a, b, c, d) {   console.log(this, a, b, c, d); }; func(1, 2, 3, 4); // Window{...} 1 2 3 4  var bindFunc1 = func.bind({ x: 1 }); bindFunc1(5, 6, 7, 8); // (1) {x: 1} 5 6 7 8  var bindFunc2 = func.bind({ x: 1 }, 4, 5); bindFunc2(6, 7); // (2) {x: 1} 4 5 6 7 bindFunc2(8, 9); // {x: 1} 4 5 8 9      this를 { x: 1}로 지정했다.    매개변수로 6, 7을 넘기면 this값이 바뀐 겂을 제외하고는 최초 func함수에 4, 5, 6, 7을 넘긴 것과 같은 동작을 한다. this의 지정과 함께 부분 적용 함수를 구현한 것이다.   출처      코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","this"],
        "url": "/javascript/javascript-thisbinding/",
        "teaser": null
      },{
        "title": "클로저(Closer)",
        "excerpt":"📄 클로저란   클로저란   어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상이다.   📄 클로저의 동작 원리   var outer = function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; }; var outer2 = outer(); console.log(outer2()); console.log(outer2());     ```js 2; 3; ```  `inner`함수의 실행 시점에는 `outer`함수가 이미 종료 되었는데 `outer`함수의 **LexicalEnvitonment**에 접근했다.  바로 가비지 컬렉터의 동작 방식 때문이다.  **가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함하지 않는다.**  외부함수인 `outer`의 실행이 종료 되더라도  내부함수인 `inner`함수는 언젠가 `outer2`를 실행함으로써 호출될 가능성이 열렸기 때문에   가비지 컬렉터의 수집대상에 포함되지 않는다.  ## 클로저와 메모리 관리  클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수의 메모리를 소모하도록 함으로써 발생한다.  하지만 클로저의 필요성이 사라진 시점에는 더이상 메모리를 소모하지 않게 해주어야 한다.  방법은 **참조 카운터를 0으로 만들어 주는 것**이다.  식별자에 참조형이 아닌 기본형 데이터(보통`null` 또는 `undefined`)를 할당해주면 가비지 컬렉터가 값을 수거해 갈 것이다.  ```js var outer = (function () {   var a = 1;   var inner = function () {     return ++a;   };   return inner; })(); console.log(outer()); console.log(outer()); outer = null; // outer 식별자의 inner 함수 참조를 끊음 ```  ```js (function () {   var a = 0;   var intervalId = null;   var inner = function () {     if (++a &gt;= 10) {       clearInterval(intervalId);       inner = null; // inner 식별자의 함수 참조를 끊음     }     console.log(a);   };   intervalId = setInterval(inner, 1000); })(); ```  이렇게 식별자에 기본형 데이터 값을 대입해서 함수 참조를 끊으면 메모리를 효율적으로 관리할 수 있다.  ## 출처  - 코어 자바스크립트  ","categories": ["JavaScript"],
        "tags": ["JavaScript","클로저"],
        "url": "/javascript/js-closer/",
        "teaser": null
      },{
        "title": "옵셔널 체이닝",
        "excerpt":"📄 옵셔널 체이닝   옵셔널 체이닝(optional chaining) ?.을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.     ?.은 ?.‘앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.   let user = null;  alert( user?.address ); // undefined alert( user?.address.street ); // undefined   user?.address로 주소를 읽으면 아래와 같이 user 객체가 존재하지 않더라도 에러가 발생하지 않습니다.   📄 주의할 점      ?.는 존재하지 않아도 되는 괜찮은 대상에만 사용해아 합니다.   ?.앞의 변수는 꼭 선언되어 있어야 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","옵셔널체이닝"],
        "url": "/javascript/js-optionalchaning/",
        "teaser": null
      },{
        "title": "원시값의 메서드",
        "excerpt":"📄 원시값이란?   원시값은 객체가 아니면서 메서드도 가지지 않는 데이터를 뜻한다.   자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다.   원시값에서도 객체에서처럼 메서드를 호출할 수 있다는 뜻이다.   📄 원시값을 객체처럼 사용하는 과정   let str = \"Hello\";  alert(str.toUpperCase()); // HELLO      문자열 str은 원시값이므로 프로퍼티 toUpperCase에 접근하는 순간 특별한 객체가 만들어진다.   메서드가 실행되고, 새로운 문자열이 반환된다.   특별한 객체는 파괴되고 원시값 str만 남는다.   📄 왜 이런 내부 프로세스가 생겨난 것일까?   자바스크립트는 다양한 고유한 프로퍼티와 메서드를 가지는 내장 객체를 제공한다.  하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다.  객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.  따라서 원시값에 메서드를 호출해 임시객체를 만들고 작업이 완료되면 임시객체를 파괴한다.   📄 주의할 점   원시값은 추가 데이터를 저장할 수 없다.   let str = \"Hello\";  str.test = 5;  alert(str.test);   엄격모드에서는 래퍼 객체를 수정하려 할 때 에러가 발생하고,  비 엄격 모드에서는 에러가 발생하진 않고 래퍼 객체에 프로퍼티 test가 추가되지만 래퍼 객체는 바로 삭제되기 때문에 마지막 줄이 실행될 땐 프로퍼티 test를 찾을 수 없다.   출처      모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","원시값"],
        "url": "/javascript/js-primitive/",
        "teaser": null
      },{
        "title": "반복문(Iteration)",
        "excerpt":"📄 반복문 for   for문은 어떤 유한한 횟수만큼 반복할 때 사용합니다.   for(초기화; 반복 조건; 반복이 된 후 실행되는 코드) {     반복이 되는 코드 블럭  }   초기화 하면서 선언된 변수를 중괄호 안 반복 블럭에서 사용할 수 있습니다.   반복문 종료하기 | break   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &gt; 2) {     break;   }   console.log(\"안녕하세요\", i); }      i가 0부터 4까지 1씩 증가하면서 출력하는데, 만약 i가 2보타 큰 경우는 반복을 종료한다.    결과     반복문 넘기기 | continue   반복되는 블럭 안에서 continue를 만나면 거기서 바로 해당 블럭은 종료됩니다.   그리고 이와 같이 다음 반복이 있으면 다음 반복으로 넘어갑니다.   for (let i = 0; i &lt; 5; i++) {   console.log(i);   if (i &lt; 2) {     continue;   }   console.log(\"안녕하세요\", i); }   결과    for 무한 루프   소괄호 ()안에 아무것도 적지 않고 세미콜론 ;만 작성하면 조건이 생성되지 않아 무한으로 출력합니다.   이런 경우 보통 for문 안에서 if문으로 조건을 생성하기도 합니다.   for (;;) {   console.log(\"안녕하세요\");   if (Math.random * 100 &gt; 90) {     break;   } }      랜덤숫자*100 이 90보다 크면 반복문 종료    📄 for in   for in반복문은 객체의 속성들을 반복하여 작업을 수행합니다.   객체의 key값에는 접근할 수 있지만 value에는 접근할 수 없습니다.   for(let(또는 const) in 객체이름) {}  console.log(Object.keys(객체이름)); // 객체의 키 받아오기 console.log(Object.values(객체이름)); //키의 값 받아오기 console.log(Object.entries(객체이름)); //배열 형태로 키와 값을 반환   📄 for of   ES6에 추가된 for...of반복문은 배열안의 것들을 반복할 때 사용합니다.   for of 구문을 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.   var iterable = [10, 20, 30];  for (let value of iterable) {   console.log(value); // 10, 20, 30 }   주의할 점   for..in은 배열에 사용할 순 있지만 되도록 쓰지 않는 편이 좋습니다.  for..in반복문은 모든 프로퍼티를 대상으로 순회하기 때문에 키가 숫자가 아닌 프로퍼티도 순회 대상이 되어 필요 없는 프로퍼티들이 문제를 일으킬 가능성이 생깁니다.  또한 for..in반복문은 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다.    📌 객체에는 for...in, 배열에는 for...of를 사용하자   📄 while   무한 반복 루프를 작성할 때 for문 뿐만 아니라 while문으로도 작성할 수 있습니다.   while (true) {   console.log(\"안녕하세요\");   if (Math.random() * 100 &gt; 90) {     break;   } }      Math.random() * 100이 90보다 크면 반복문 종료    do while   while문이 최초로 한번은 무조건 실행하도록 합니다.   do {   // 최초 한번은 무조건 실행   console.log(\"안녕하세요\"); } while (Math.random() * 100 &gt; 90);   출처      패스트캠퍼스   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","반복문"],
        "url": "/javascript/javascript-iteration/",
        "teaser": null
      },{
        "title": "[클래스] 클래스(Class)",
        "excerpt":"📄 클래스(Class)란   자바스크립트는 기본적으로 객체지향언어를 지원합니다.   es6문법에 class가 추가되어 좀더 강력한 객체지향언어를 지향하게 되었습니다.   Class는 객체를 생성하기 위한 템플릿이자 함수의 한 종류입니다.   클래스는 데이터와 이를 조작하는 코드를 하나로 추상화합니다.   📄 선언적 방식   class A {     constructor() {...}     method1() {...}     method2() {...} } //class A 생성  console.log(new A()); // class A의 세로운 객체를 출력   결과   A {}   클래스를 만들고 new A()를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성됩니다.  클래스 내부에서 정의한 메서드는 A.prototype에 저장됩니다.  객체의 기본 상태를 설정해주는 생성자 메서드 constructor()는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화할 수 있습니다.   주의할 점      메서드 사이에는 쉼표가 없습니다.        클래스의 선언적 방식에서 호이스팅은 일어나지 않습니다.       new키워들를 통해 호출하지 않으면 에러가 발생합니다.   클래스에 정의된 메서드는 열거할 수 없습니다. 클래스의 prototype프로퍼티에 추가된 메서드의 enumerable플래그는 false입니다.   클래스는 항상 엄격모드로 실행됩니다.(use strict)   📄 클래스 표현식   클래스의 표현식을 변수에 할당하는 방식으로 사용됩니다.   const B = class {};  console.log(new B());   결과   B {}   📄 클래스 필드로 바인딩 된 메서드   자바스크립트에서 this는 동적으로 결정됩니다.   따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출하게 되면 this는 메서드가 정의된 객체를 참조하지 않습니다.   class Button {   constructor(value) {     this.value = value;   }    click() {     cosole.log(this.value);   } }  let button = new Button(\"안녕하세요\");  setTimeout(button.click, 1000);   결과   undefined;   this의 컨텍스트를 알 수 없게 된 현상을 ‘잃어버린 this‘라고 합니다.  이러한 현상을 해결하기 위해 클래스 필드를 사용할 수 있습니다.    class Button {   constructor(value) {     this.value = value;   }    click = () =&gt; {     // 수정한 부분     alert(this.value);   }; }  let button = new Button(\"안녕하세요.\");  setTimeout(button.click, 1000);   결과   안녕하세요.   클래스 필스 click = () =&gt; {...}는 각 Button객체마다 독립적인 함수를 만들어주고 이 함수의 this를 해당 객체에 바인딩시켜줍니다.  클래스의 이러한 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야할 때 특히 유용합니다.   📄 멤버변수   멤버 변수는 메소드 밖에서 선언된 변수를 뜻합니다. 클래스의 멤버변수는 this라는 키워드를 사용하여 반드시 생성자에 만들어야 합니다.   class C {   name = \"no name\"; // 초기값 설정   age = 0;    constructor(name, age) {     // 생성자를 통해서 새로 할당.     this.name = name; // 멤버변수     this.age = age; // 멤버변수   } }  console.log(new C(\"Mark\", 37));   결과   C { name: 'Mark', age: 37 }   📄 멤버 함수   클래스에는 멤버변수 뿐만 아니라 멤버 함수도 생성할 수 있습니다.   class A {   // 방법1: 함수의 이름과 중괄호를 이용해 설정   hello1() {     console.log(\"hello1\", this);   }   // 방법2: 멤버변수 이름에 함수를 할당하는 방법   hello2 = () =&gt; {     console.log(\"hello2\", this);   }; }  new A().hello1(); new A().hello2();   결과   hello1 A { hello2: [Function: hello2] } hello2 A { hello2: [Function: hello2] }   출처           패스트캠퍼스              MDN web docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","클래스"],
        "url": "/javascript/js-class/",
        "teaser": null
      },{
        "title": "프로토타입(prototype)",
        "excerpt":"📄 프로토타입이란?   프로토타입의 한국어 뜻은 원형입니다.   프로토타입은 말 그대로 객체의 원형이라고 할 수 있는 것입니다.   Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용합니다.           생성자 함수에 기본으로 세팅되는 프로퍼티(F.prototype)는 [[Prototype]]과 다릅니다. F.prototype은 new F()를 호출할 때 만들어지는 새로운 객체의 [[Prototype]]을 설정합니다.       F.prototype의 값은 객체나 null만 가능합니다. 다른 값은 무시됩니다.   굳이 this라는 자기참조변수를 사용하지 않고 prototype으로 변수 p에 hello라는 함수를 할당했다.   function Person(name, age) {   this.name = name;   this.age = age;   //this.hello = function() {   //    console.log('hello', this.name, this.age);   //} }  Person.prototype.hello = function () {   console.log(\"hello\", this.name, this.age); };  const p = new Person(\"Mark\", 37);  p.hello();   결과   hello Mark 37   function Person() {} //Person함수 생성  Person.prototype.hello = function () {   //Person의 프로토타입으로 hello 함수 생성   console.log(\"hello\"); };  function Korean(region) {   //Korean 함수 생성   this.region = region;   this.where = function () {     console.log(\"where\", this.region);   }; }  Korean.prototype = Person.prototype; // 프로토타입을 이용해 부모의 프로퍼티를 자식의 프로퍼티에 할당  const k = new Korean(\"Seoul\"); // 변수 k에 객체 할당  k.hello(); k.where();   결과   hello1 where Seoul   📄 프로토타입 장점   프로토타입의 장점은 함수의 재사용성을 높인다는 것입니다.   프로토 타입을 사용해서 함수 밖에서 새로운 함수나 값을 선언한다면,   새로운 함수나 값을 기존 함수에 할당할 필요없이 prototype이라는 키워드 하나로 바로 사용가능하기 때문에 코드가 훨씬 간결해집니다.   📄 프로토타입 체인   프로토타입을 이용해 서로 이어져 있는 집합을 프로토타입 체인이라고 합니다.   위의 코드에 다음과 같은 코드를 이어서 작성합니다.   console.log(k instanceof Korean); console.log(k instanceof Person); console.log(k instanceof Object);   true; true; true;      Korean이 Person을 상속하고, Person이 Object를 상속하므로 true값이 나왔다.   느낀 점   자바스크립트 공부하면서 제일 난관에 봉착했다.  뭔가 알듯 말듯 헷갈리는 개념이다.  강의를 끝나면 모던자바스크립트튜토리얼도 보고 책도 보고 할텐데 그 과정에서 익숙해지며 습득될 수 있도록 꼼꼼히 학습해야겠다.     출처           패스트캠퍼스 프론트엔드 강의              생활코딩              MDN Web Docs      ","categories": ["JavaScript"],
        "tags": ["JavaScript","프로토타입"],
        "url": "/javascript/js-prototype/",
        "teaser": null
      },{
        "title": "[클래스] 정적 메서드와 정적 프로퍼티",
        "excerpt":"📄 정적 메서드(static method)   정적 메서드는 프로토타입이 아닌 클래스 함수 자체에 설정되어 있는 메서드이다.  클래스 안에서 static이라는 키워드를 사용해서 설정한다.   class User {   static staticMethod() {...} }   정적 메서드의 this는 무엇을 가리킬까?   클래스의 메서드가 호출될 때  this의 값은 클래스 생성자 그자체가 된다.    정적 메서드는 언제 사용할까?   정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 사용한다.  데이터베이스 관련 클래스에도 사용되곤한다.    📄 정적 프로퍼티(static property)   정적 프로퍼티또한 static이라는 키워드를 사용한다.   class User {   static staticProperty = \"John\"; }   정적 프로퍼티는 언제 사용할까?   정적 프로퍼티는 데이터를 클래스 수순에 저장하고 싶을 때 사용한다.  정적 프로퍼티 역시 개별 인스턴스에 묶이지 않는다.   정적 프로퍼티와 메서드의 상속   정적 프로퍼티와 정적 메서드는 상속이 가능하다.    class Animal {} class Rabbit extends Animal {}  // 정적 메서드 consol.log(Rabbit.__proto__ === Animal); // true  // 일반 메서드 consol.log(Rabbit.prototype.__proto__ === Animal.prototype); // true   클래스 Rabbit의 프로토타입이 클래스 Animal을 가리키게 한다.  따라서 Rabbit에서 원하는 프로퍼티나 메서드를 찾지 못하면 Animal로 검색이 이어진다.   출처   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","정적메서드","정적프로퍼티"],
        "url": "/javascript/js-static-method/",
        "teaser": null
      },{
        "title": "Promise",
        "excerpt":"📄 promise   프로미스는 주로 서버에서 데이터를 받아올 때 사용합니다.   서버에 요청을 보내고 데이터를 받아올 때, 아직 데이터를 다 받아오기도 전에 데이터를 다 받아온것 처럼 화면에 데이터를 표시하고 오류가 발생합니다.   이런 문제점을 해결하는 방법이 프로미스 입니다     프로미스는 ES6부터 JavaScript의 표준 내장 객체로 추가되었습니다.   📄 promise 처리 흐름   1. 프로미스가 생성자를 통해서 생성되면 pending(대기)상태가 됩니다.   new Promise((resolve, reject) =&gt; {}); //pending   2-1. pending상태로 돌입한 후 excutor 함수 인자 중 하나인 resolve 함수를 실행하면, fulfilled(이행)상태가 됩니다.   new Promise((resolve, reject) =&gt; {   // pending상태   // ... 비동기적인 상황이 되는 처리가 벌어짐.   resolve(); // fulfilled });   2-2. excutor 함수 인자 중 하나인 reject 함수를 실행하면, rejected (거부) 상태가 됩니다.   new Promise((resolve, reject) =&gt; {   reject(); //rejected });   3-1. 프로미스 객체가 fulfilled 되는 시점에 .then 안에 설정한 callback 함수가 실행됩니다.   p.then(/*callback*/);      p라는 프로미스 객체의 callback이 실행됨.    excutor의 resolve함수를 실행할 때 인자를 넣어 실행하면, then의 callback 함수의 인자로 받을 수 있습니다.   resolve('hello'); then((message) =&gt; {...})   3-2. 마찬가지로 프로미스 객체가 rejected되는 시점에 .catch안에 설정한 callback함수가 실행됩니다.   catch(() =&gt; {     console.log('/*callback*/'); });   executor의 reject 함수를 실행할 때 인자를 넣어 실행하면, catch의 callback함수의 인자로 받을 수 있습니다.   reject('error'); catch((reason) =&gt; {...})   보통 reject 함수를 실행하며 rejected 되는 이유를 넘기는데, 표준 내장 객체인 Error의 생성자를 이용하여 Error 객체를 만들 수 있습니다.   reject(new Error('bad')); catch((error) =&gt; {...});   4. fulfilled 되거나 rejected 된 후에 최종적으로 실행할 것이 있다면, .finally()를 설정하고, 함수를 인자로 넣습니다.   finally(() =&gt; {...});   📄 callback vs promise   비동기 작업을 하는 방법은 주로 callback과 promise가 있습니다.   1. callback   보통 비동기 작업을 할 때, callback함수를 인자로 넣어 로직이 끝나면 callback함수를 호출합니다.   이런 경우 함수가 아래로 진행되지 않고, callback 함수 안으로 진행됩니다.   function c(callback) {   setTimeout(() =&gt; {     callback();   }, 1000); }  c(() =&gt; {   console.log(\"1000ms 후에 callback 함수가 실행됩니다.\"); });  c(() =&gt; {   c(() =&gt; {     c(() =&gt; {       console.log(\"3000ms 후에 callback 함수가 실행됩니다\");     });   }); }); //callback hell (콜백 지옥)   2. promise 체이닝   promise방식에서는 then 함수에서 다시 프로미스 객체를 리턴하는 방법을 통해 체이닝하면, 비동기 적업을 순차적으로 아래로 표현할 수 있습니다.   function p() {   return new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {       resolve();     }, 1000);   }); }  p()   .then(() =&gt; {     return p(); // 다시 새로운 프로미스 객체를 만들어서 리턴한다.   })   .then(() =&gt; p())   .then(p)   .then(() =&gt; {     console.log(\"4000ms 후에 fulfilled 됩니다.\");   });   📄 value가 프로미스 객체인지 알 수 없는 경우   연결된 then 메서드를 실행합니다.   value가 프로미스 객체면, resolve 된 then 메서드를 실행합니다.   value가 프로미스 객체가 아니면, value를 인자로 보내면서 then메서드를 실행합니다.   Promise.resolve(/* value */); //프로미스라는 전역객체의 resolve함수를 실행하면서 동시에 promise를 만들어낸다.  Promise.resolve(   new Promise((resolve, reject) =&gt; {     // 비동기 프로미스 객체를 생성해서 resolve의 인자인 value값으로 설정.     setTimeout(() =&gt; {       resolve();     }, 1000);   }) ).then((data) =&gt; {   console.log(     \"프로미스 객체인 경우, resolve 된 결과를 받아 then이 실행됩니다.\",     data   ); });  Promise.resolve(\"bar\").then((data) =&gt; {   console.log(\"then 메서드가 없는 경우, fulfilled됩니다.\", data); });   promise.reject를 사용하면, catch로 연결된 rejected 상태로 변경됩니다.   Promise.reject(/* */);  Promise.reject(new Error(\"reason\"))   .then((error) =&gt; {})   .catch((error) =&gt; {     console.log(error);   });   📄 promise 객체를 배열로 생성하기   promise.all   프로미스 객체를 여러개를 생성하여,   배열로 만들어 인자로 넣고 Promise.all을 실행하면,   배열의 모든 프로미스 객체들이 fulfilled 되었을 때, then의 함수가 실행됩니다.   then의 함수의 인자로 프로미스 객체들의 resolve 인자값을 배열로 돌려줍니다.   Promise.all([프로미스 객체들]);   promise.all에 전달되는 프라미스 중 하나라도 거부되면, Promise.all이 반환하는 프라미스는 에러와 함께 바로 거부됩니다.   promise.allSettled   Promise.allSettled는 모든 프라미스가 처리될 때까지 기다립니다.   반환되는 배열은 다음과 같은 요소를 갖습니다.      응답이 성공할 경우 – {status:”fulfilled”, value:result}   에러가 발생한 경우 – {status:”rejected”, reason:error}   let urls = [   \"https://api.github.com/users/iliakan\",   \"https://api.github.com/users/Violet-Bora-Lee\",   \"https://no-such-url\", ];  Promise.allSettled(urls.map((url) =&gt; fetch(url))).then((results) =&gt; {   results.forEach((result, num) =&gt; {     if (result.status == \"fulfilled\") {       alert(`${urls[num]}: ${result.value.status}`);     }     if (result.status == \"rejected\") {       alert(`${urls[num]}: ${result.reason}`);     }   }); });   결과   [   {status: 'fulfilled', value: ...응답...},   {status: 'fulfilled', value: ...응답...},   {status: 'rejected', reason: ...에러 객체...} ]   promise.race   프로미스 객체 여러개를 생성하여,   배열로 만들어 인자로 넣고 Promise.race를 실행하면,   배열의 모든 프로미스 객체들 중 가장 먼저 fulfiiled된 것으로, then의 함수가 실행됩니다.   then의 함수의 인자로 가장 먼저 fulfilled 된 프로미스 개체의 resolve 인자값을 돌려줍니다.   Promise.race([프로미스 객체들]);   출처           패스트캠퍼스 강의              캡틴판교      ","categories": ["JavaScript"],
        "tags": ["JavaScript","Promise"],
        "url": "/javascript/javascript-promise/",
        "teaser": null
      },{
        "title": "콜백(Callback)",
        "excerpt":"📄 콜백   콜백 함수는 다른 코드를 인자로 넘겨주는 함수이다.  다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한다. 자바스크립트는 호스트 환경이 제공하는 여러 함수를 사용하면 비동기 동작을 수행할 수 있다.   📄 콜백은 어떤 경우에 사용될까?   function loadScript(src) {   // &lt;script&gt; 태그를 만들고 페이지에 태그를 추가합니다.   // 태그가 페이지에 추가되면 src에 있는 스크립트를 로딩하고 실행합니다.   let script = document.createElement(\"script\");   script.src = src;   document.head.append(script); }  loadScript(\"/my/script.js\"); // script.js엔 \"function newFunction() {…}\"이 있습니다.  newFunction(); // 함수가 존재하지 않는다는 에러가 발생합니다!   new Function()에서 에러가 발생하는 이유는 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문이다.    function loadScript(src, callback) {   let script = document.createElement('script');   script.src = src;    script.onload = () =&gt; callback(script);    document.head.append(script); }  loadScript('/my/script.js', function() {   // 콜백 함수는 스크립트 로드가 끝나면 실행됩니다.   newFunction(); // 이제 함수 호출이 제대로 동작합니다.   ... });   loadScript의 두 번째 인수에 스크립트 로딩이 끝난 후 실행될 함수인 콜백 함수를 추가했다.  두 번째 인수로 전달되 함수는 원하는 동작이 완료되었을 떄 실행된다.     이것을 콜백 기반 비동기 프로그래밍이라고 부른다.  비동기적으로 수행되어야할 필요성을 가진 코드에 콜백을 기반으로 접근할 수 있다.   📄 오류 우선 콜백   콜백함수를 이용해서 에러를 핸들링할 수 있다.   function loadScript(src, callback) {   let script = document.createElement(\"script\");   script.src = src;    script.onload = () =&gt; callback(null, script);   script.onerror = () =&gt;     callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));    document.head.append(script); }  loadScript(\"/my/script.js\", function (error, script) {   if (error) {     // 에러 처리   } else {     // 스크립트 로딩이 성공적으로 끝남   } });   오류 우선 콜백의 관례      callback의 첫 번째 인수는 에러를 위해 남겨둔다. 에러가 발생하면 이 인수를 이용해 callback(err)이 호출된다.   두 번째 인수는 에러가 발생하지 않았을 때를 위해 남겨둔다. 원하는 동작이 성공한 경우엔 callback(null, result1, result2)가 호출된다.   오류 우선 콜백의 장점   오류 우선 콜백을 사용하면, 단일 콜백 함수에서 에러 케이스와 성공 케이스 모두를 처리할 수 있다.   출처      코어 자바스크립트   모던 자바스크립트 튜토리얼  ","categories": ["JavaScript"],
        "tags": ["JavaScript","콜백"],
        "url": "/javascript/js-callback/",
        "teaser": null
      },{
        "title": "JS 문자열을 HTML 개체로 변환",
        "excerpt":"📄 JS 문자열을 HTML 개체로 변환   자바스크립트에서 작성한 문자열을 innerHTML 속성을 이용해 HTML로 변환시켜 주는 방법입니다.   const stringToHTML = function (str) {   const dom = document.createElement(\"div\");   dom.innerHTML = str;   return dom; }; console.log(stringToHTML(`&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;p&gt;How are you today?&lt;/p&gt;`));   결과   &lt;div&gt;   &lt;h1&gt;Hello world&lt;/h1&gt;   &lt;p&gt;How are you today?&lt;/p&gt; &lt;/div&gt;      domcument에 div 엘리먼트를 추가한다.   새로 생성된 div 인스턴스는 dom과 연결된다.   dom의 경우 innerHTML 속성을 설정해서 HTML 개체로 변환한다.   return은 strinToHTML 함수에 대한 dom 인스턴스가 된다.   출처      DelftStack-JavaScript에서 문자열을 HTML로 변환  ","categories": ["JavaScript"],
        "tags": ["JavaScript","문자열","HTML"],
        "url": "/javascript/javascript-stringtohtaml/",
        "teaser": null
      },{
        "title": "배열 내장 함수",
        "excerpt":"📄 배열 내장함수   자바스크립트 배열에는 자체적으로 내장되어 있는 함수들이 있습니다.   이 함수들을 잘 활용한다면 코드가 더욱 간결해지고 가독성이 높아질 수 있습니다.   📄 forEach   forEach함수는 기존의 for문을 대체할 수 있습니다.   const array = [a, b, c, d];  superheroes.forEach((item) =&gt; {   console.log(item); });   forEach의 파라미터로 각 원소에 대하여 처리하고 싶은 코드를 함수로 넣어줍니다.   이렇게 주어진 함수를 배열 요소 각각에 대해 실행합니다.   📄 map   map은 배열 안의 각 원소를 변환할 때 사용하며,   결과 값이 담긴 새로운 배열을 생성합니다.     map 함수의 파라미터로는 변화를 주는 함수를 전달해줍니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((n) =&gt; n * n);   map을 사용하면서 index값을 얻고 싶다면 함수의 두번째 파라미터를 이용하면 됩니다.   const array = [1, 2, 3, 4, 5, 6, 7, 8];  const squared = array.map((currentElement, index) =&gt; {   console.log(\"The current iteration is: \" + index); // 배열의 인덱스 값   console.log(\"The current element is: \" + currElement); // 배열의 현재 값 });   📄 IndexOf   IndexOf는 배열에서 원하는 항목이 몇번째 원소인지 찾아주는 함수입니다.   const superheroes = [\"아이언맨\", \"캡틴 아메리카\", \"토르\", \"닥터 스트레인지\"];  const index = superheroes.indexOf(\"토르\");   함수의 파라미터로 원하는 값을 넣어주면 몇번째 함수인지 반환합니다.   📄 findIndex &amp; find   만약 찾고자 하는 배열안의 값이 숫자나 문자열이라면 indexOf를 사용하지만   배열안의 값이 객체이거나 배열인 경우에는 사용할 수 없습니다.   그럴경우 사용하는 함수가 findIndex와 find입니다.   findIndex함수를 사용하고자 하면 함수에 검사하고자 하는 조건을 반환하는 함수를 넣습니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   }, ];  const index = todos.findIndex((todo) =&gt; todo.id === 3);      배열 todos에서 id가 3인 값의 index를 반환한다.    결과   `2`;   만약 Index아닌 객체나 배열의 값 전체를 반환하고자 하면 find함수를 사용합니다.   const index2 = todos.find((todo) =&gt; todo.id === 3);   결과   { id: 3, text: '객체와 배열 배우기', done: true }   📄 filter   filter함수는 특정조건을 만족하는 원소를 찾아서 그 원소들을 새로운 배열로 만듭니다.   const todos = [   {     id: 1,     text: \"자바스크립트 입문\",     done: true,   },   {     id: 2,     text: \"함수 배우기\",     done: true,   },   {     id: 3,     text: \"객체와 배열 배우기\",     done: true,   },   {     id: 4,     text: \"배열 내장함수 배우기\",     done: false,   }, ];  const tasksNotDone = todos.filter((todo) =&gt; todo.done === false); console.log(tasksNotDone);   결과   [{ id: 4, text: \"배열 내장함수 배우기\", done: false }];   📄 splice &amp; slice   splice함수 사용법   const spliced = 배열.splice(index number, n);      index number인 원소부터 n개를 지우겠다.    slice함수 사용법   const sliced = 배열.slice(index number, n);      index number인 원소부터 n개를 잘라내 새로운 배열을 생성한다.    공통점   두 함수 모두 배열을 잘라낼 때 사용합니다.   차이점   splice로 배열을 잘라내면 기존배열이 그대로 잘리지만, slice로 배열을 잘라내면 기존배열이 유지됩니다.   📄 shift &amp; unshift      shift: 배열의 첫번째 원소를 추출합니다.   unshift: 배열의 맨 앞에 원소를 추가합니다.   const value = numbers.shift(); // value라는 값에 배열 numbers의 첫번째 원소 할당. numbers.unshift(5); // 배열 numbers의 마지막 자리에 원소 5 추가.   📄 push &amp; pop      push: 배열의 마지막 원소를 추가합니다.   pop: 배열의 마지막 자리에 있는 원소를 추출합니다.   numbers.push(50); // numbers라는 배열에 값 50 추가 const value = numbers.pop(); // value에 numbers의 마지막 원소 할당   📄 reduce   reduce함수는 배열의 각 요소에 대해 주어진 리듀서 함수를 실행합니다.   배열안의 각 요소를 순회하며 callback함수의 실행 값을 누적하여 하나의 결과값을 반환합니다.   arr.reduce(callback, initialValue);   callback함수는 4개의 파라미터 값을 받습니다.      누산기 (acc): 콜백의 반환값을 누적합니다.   현재 값(cur): 처리할 현재 요소   현재 인덱스(idx): 처리할 현재 요소의 인덱스   원본 배열(src): reduce()를 호출한 배열   const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((acc, cur, idx) =&gt; {   return (acc += cur); }, 0); // 0은 초기값 console.log(result); // 15   출처           패스트캠퍼스 프론트엔드 강의            MDN      ","categories": ["JavaScript"],
        "tags": ["JavaScript","forEach","map","IndexOf","findIndex","filter","splice","slice","shift","push","pop","reduce"],
        "url": "/javascript/javascript-arrayfunction/",
        "teaser": null
      },{
        "title": "Fetch",
        "excerpt":"📄 Fetch   : 원격 API를 호출할 수 있는 자바스크립트 내장 함수   📄 Fetch 사용법   Fetch함수는 두가지의 인자를 받습니다.      URL   옵션객체   인자를 받아 Promise객체를 반환합니다.   반환된 객체는 API호출이 성공했을 때 응답(response) 객체를 resolve하고 실패했을 때는 예외(error)객체를 reject합니다.   fetch(url, options)   .then((response) =&gt; response.json())   .catch((error) =&gt; console.log(\"error:\", error));      Response: HTTP 응답 전체를 나타내는 객체. JSON 본문 콘텐츠를 추출하기 위해서는 json()메서드를 호출해야 합니다.   📄 GET 호출: 데이터 불러오기   fetch함수의 기본적인 동작은 GET입니다.   fetch(\"https://jsonplaceholder.typicode.com/posts/1\").then((response) =&gt;   console.log(response) );   ✔ 결과   Response {status: 200, ok: true, redirected: false, type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts/1\", …}   응답(response) 객체는 json메서드를 제공합니다.   json()을 호출하면 응답 객체로부터 JSON 포멧의 응답을 자바스크립트 객체로 변환해서 얻을 수 있습니다.   // json()을 활용하여 응답객체를 자바스크립트 객체로 변환 fetch(\"https://jsonplaceholder.typicode.com/posts/1\")   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   {   \"userId\": 1,   \"id\": 1,   \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",   \"body\": \"quia et suscipit↵suscipit recusandae consequuntur …strum rerum est autem sunt rem eveniet architecto\" }   📄 POST 호출: 데이터 생성하기   POST는 원격 API에서 관리하고 있는 데이터를 생성할 때 사용합니다.      method 옵션을 POST로 지정한다.   headers옵션을 통해 JSON포멧을 사용한다고 알려준다.   요청 전문을 JSON 포멧으로 직렬화하여 body옵션에 설정해준다.   fetch(\"https://jsonplaceholder.typicode.com/posts\", {   method: \"POST\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), }).then((response) =&gt; console.log(response));   ✔ 결과: 응답코드가 201 Created   Response {type: \"cors\", url: \"https://jsonplaceholder.typicode.com/posts\", redirected: false, status: 201, ok: true, …}  // json메서드로 응답객체를 호출했을 때(response.json()) {title: \"Test\", body: \"I am testing!\", userId: 1, id: 101}   📄 PUT, DELETE: 데이터 수정, 삭제하기   PUT과 DELETE는 데이터를 수정하거나 데이터를 삭제할 때 사용됩니다.   // PUT fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"PUT\",   headers: {     \"Content-Type\": \"application/json\",   },   body: JSON.stringify({     title: \"Test\",     body: \"I am testing!\",     userId: 1,   }), })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과     {title: \"Test\", body: \"I am testing!\", userId: 1, id: 1}   DELETE는 보낼 데이터가 없어 header와 body옵션이 필요하지 않습니다.   // DELETE fetch(\"https://jsonplaceholder.typicode.com/posts/1\", {   method: \"DELETE\", })   .then((response) =&gt; response.json())   .then((data) =&gt; console.log(data));   ✔ 결과   { }   📄 fetch 함수 커스텀화 하기   async function post(host, path, body, headers = {}) {   const url = `https://${host}/${path}`;   const options = {     method: \"POST\",     headers: {       \"Content-Type\": \"application/json\",       ...headers,     },     body: JSON.stringify(body),   };   const res = await fetch(url, options);   const data = await res.json();   if (res.ok) {     return data;   } else {     throw Error(data);   } }  post(\"jsonplaceholder.typicode.com\", \"posts\", {   title: \"Test\",   body: \"I am testing!\",   userId: 1, })   .then((data) =&gt; console.log(data))   .catch((error) =&gt; console.log(error));   출처      MDN-Fetch 사용하기   DaleSeo-fetch()함수로 원격 API호출하기  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Fetch"],
        "url": "/javascript/javascript-fetch/",
        "teaser": null
      },{
        "title": "getElementById 와 querySelector 비교",
        "excerpt":"📄 getElementById 와 querySelector 비교   getElementById와 querySelector의 공통점은 엘리먼트를 검색해서 반환한다는 것입니다.   하지만 둘의 사용법은 다르며 사용하는 상황에서 차이점을 드러냅니다.   📄 getElementById와 querySelector의 차이점   getElementById      id를 통해 엘리먼트를 반환한다.   만약 document에 해당 id가 없다면 null을 반환한다.   querySelector      selector의 구체적인 그룹과 일치하는 document의 첫번째 엘리먼트를 반환한다.   일치하는 요소가 없다면 null을 반환한다.   ✔ 예시   &lt;form id=\"userForm\"&gt;   &lt;input id=\"username\" type=\"text\" value=\"Guilherme\"&gt; &lt;/form&gt;   getElementById로 username을 가져올 때:   var username = document.getElementById(\"username\");   querySelector로 username을 가져올 때:   var username = document.querySelector(\"#userForm #username\");   =&gt; 결과는 같지만 querySelector로 가져올 때 더 구체적이고 한정적이다.   📄 querySelectorAll vs selectElementByClassName   하나가 아니라 여러개의 요소를 하나의 이름으로 한번에 얻고 싶을 때 사용하는 방법이다.   ✔ 예시   &lt;form id=\"productForm\"&gt;   &lt;input id=\"productOne\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productTwo\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt;   &lt;input id=\"productThree\" class=\"product\" type=\"text\" value=\"Product 1\" /&gt; &lt;/form&gt;   getElementByClassName으로 가져올 때: HTMLCollection에 리턴   var products = document.getElementByClassName(\"product\");   querySelectorAll로 가져올 때: NodeList에 리턴   var products = document.querySelectorAll(\"#productForm .product\");   둘다 인덱스를 제공해 인덱스 번호로 접근이 가능하지만, HTMLCollection항목은 name과 id속성으로도 접근할 수 있다.     엘리먼트에 접근할 때 방법이 두가지가 있어 어떤 상황에 어느 것을 사용하는지 궁금해서 정리를 시작했다.   구체적으로 엘리먼트를 선택하고 싶다면 querySelector를,   좀더 빠른 성능으로 접근하고 싶다면 getElementById를 사용하는 것이 좋다.   출처   *guinatal.github - qeurySelector vs getElementById  ","categories": ["JavaScript"],
        "tags": ["JavaScript","getElementById","querySelector"],
        "url": "/javascript/javascript-getElementById&querySelector/",
        "teaser": null
      },{
        "title": "JSON (JavaScript Object Notation)",
        "excerpt":"📄 JSON (JavaScript Object Notation)   : 데이터를 쉽게 교환하고 저장하기 위한 텍스트기반의 데이터 교환 표준   텍스트 기반이다 ❔   어떤 프로그래밍 언어에서도 JSON 데이터를 읽고 사용할 수 있다 ❕   즉, 데이터를 교환할때 어떤 프로그래밍언어도 쓸 수 있는 방법이다.   📄 JSON과 XML   XML(EXtensible Markup Language)은 문자기반의 마크업 언어로 데이터를 보여주는 것이 아닌 저장하고 전달하는 것 만을 목적으로 만들어졌다.   공통점      둘다 데이터를 저장하고 전달하기 위해 만들어졌다.   사람도 읽을 수 있다.   계층적인 데이터구조를 가진다.   다양한 프로그래밍 언어에 의해 파싱될 수 있다.   XMLHttpRequest 객체를 이용하여 서버로부터 데이터를 전송받을 수 있다.   차이점      JSON은 종료 태그를 사용하지 않는다.   JSON의 구문이 XML의 구문보다 짧다.   JSON 데이터가 XML 데이터보다 더 빨리 읽고 쓸 수 있다.   XML은 배열을 사용할 수 없지만, JSON은 배열을 사용할 수 있다.   XML은 XML 파서로 파싱되고, JSON은 자바스크립트 표준함수인 eval()함수로 파싱된다.   // XML 예제 &lt;dog&gt;     &lt;name&gt;식빵&lt;/name&gt;     &lt;family&gt;웰시코기&lt;family&gt;     &lt;age&gt;1&lt;/age&gt;     &lt;weight&gt;2.14&lt;/weight&gt; &lt;/dog&gt;  // JSON 예제 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }   JSON은 XML보다 더 빠른 처리속도를 가지고 있지만 전송받은 데이터의 무결성을 직접 인증해야하는 특징을 가지고 있다.   📄 JSON 문법   JSON은 객체 표기법 중 리터럴(literal)과 프로퍼티(property)를 표현하는 방법을 쓴다.      리터럴: 변수가 아닌 해석되는 값 자체 ex) 12(숫자 리터럴), “JSON”(문자열 리터럴), true(불리언 리터럴)   객체: 이름(name)과 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합   // 네쌍의 프로퍼티로 구성된 객체 {     \"name\": \"식빵\",     \"family\": \"웰시코기\",     \"age\": 1,     \"weight\": 2.14 }      JSON에서 주석을 사용하는것은 권장하지 않는다.   undefined 와 null   JSON에서는 undefined타입을 제공하지 않는다. 자바스크립트와 다르게 JSON에서 null은 값을 가지고 있지 않다는 의미를 가지는 하나의 데이터값을 가지고 있기 때문에 유의해서 사용해야 한다.   📄 자바스크립트와 JSON   자바스크립트에서 JSON을 사용하기 위해 3가지의 메소드를 제공한다.      JSON.stringify(): 인수로 전달받은 자바스크립트 객체를 문자열로 변환   JSON.parse(text): 인수로 받은 문자열을 자바스크립트 객체로 변환   toJSON: 자바스크립트의 Date 객체의 데이터를 JSON 형식의 문자열로 변환. Date.prototype 객체에서만 사용할 수 있다.   // toJSON 예제 var date = new Date(); // 자바스크립트 Date 객체  var str = date.toJSON(); // Date 객체를 JSON 형식의 문자열로 변환함.  document.getElementById(\"json\").innerHTML = date + \"&lt;br&gt;\";  document.getElementById(\"json\").innerHTML += str;   출처      TCP SCHOOL.com-JSON  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Json"],
        "url": "/javascript/javascript-json/",
        "teaser": null
      },{
        "title": "디바운싱(Debouncing)",
        "excerpt":"📄 디바운싱(debouncing)      이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술   연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것   디바운싱 기술는 검색 기능을 구현하는 경우에 가장 많이 사용됩니다.   이런 경우에는   j ja jav java   처럼 키워드 하나하나 인식해서 키워드 하나에 매번 이벤트가 발생하게 됩니다.   이렇게 처리해야하는 일이 여러번의 요청이 있을때 최종(혹은 처음) 요청의 처리결과만 내놓게 하는게 디바운싱입니다.   var timer; document.querySelector(\"#input\").addEventListener(\"input\", function (e) {   if (timer) {     clearTimeout(timer);   }   timer = setTimeout(function () {     console.log(\"여기에 ajax 요청\", e.target.value);   }, 200); });      타자를 칠 때(input 이벤트 발생)마다 타이머를 설정한다.   200ms동안 입력이 없으면 입력이 끝난 것으로 한다. (시간 자유 설정 가능)   200ms 이전에 타자 입력이 발생하면 이전 타이머는 취소하고 새로운 타이머를 다시 설정한다.   출처      제로초-쓰로틀링과 디바운싱  ","categories": ["JavaScript"],
        "tags": ["JavaScript","디바운싱"],
        "url": "/javascript/javascript-debouncing/",
        "teaser": null
      },{
        "title": "배열 중복 요소 없애기 (Set)",
        "excerpt":"📄 Set   배열을 다룰때 Set함수를 사용하면 중복된 요소를 없애고 값을 한번만 보여줍니다.   Set은 객체로 다루어지지만 배열의 타입이 Object이기 때문에 사용할 수 있습니다.   📄 Set 사용하기   var mySet = new Set();   mySet은 중복된 요소가 있으면 하나만 남기고 사라집니다.   mySet.add(1); // Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add(\"some text\"); // Set { 1, 5, 'some text' }   5를 두번 추가했지만 한개만 남습니다.   this.setHistoryData = (histData) =&gt; {   const avoidDulpli = [...new Set([histData, ...this.state.historyList])];   if (avoidDulpli.length &gt; 5) {     avoidDulpli.pop();   }   this.setState({     ...this.state,     historyList: avoidDulpli,   }); };   구현하던 프로젝트에서 검색기록을 내는 코드입니다.   검색한 데이터(histData)를 받아서 새로운 배열 avoidDulpli를 만들고,   new Set을 이용해 중복된 값은 제거되는 새로운 배열을 만들어 받아온 데이터(histData)가 앞에 추가됩니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Set"],
        "url": "/javascript/javasrcipt-arraySet/",
        "teaser": null
      },{
        "title": "이미지 랜덤 배치",
        "excerpt":"📄 이미지 랜덤 배치하기   목표: Vanila JavaScript로 새로고침 될 때마다 이미지가 특정 범위에 랜덤으로 배치된다.   원하는 범위의 위치를 받아와서 이미지의 left와 right 값을 지정해주자!    📄 1. 원하는 feild의 위치를 파악한다.   const fieldRect = field.getBoundingClientRect(); function initGame() {   console.log(fieldRect); }   getBoundingClientRect를 이용해 출력하면 지정한 요소의 위치를 콘솔창에서 확인할 수 있다.   📄 2. feild에 추가하기 전에 이미지를 생성하는 함수를 만들어준다.   // 랜덤으로 숫자를 생성하는 함수 function randomNumber(min, max) {   return Math.random() * (max - min) + min; }  // 아이템을 생성하는 함수 function addItem(className, count, imgPath) {   const x1 = 0;   const y1 = 0;   // 이미지가 feild에서 벗어나는 것을 막기 위해 최댓값을 조정한다.   const x2 = fieldRect.width - CARROT_SIZE;   const y2 = fieldRect.height - CARROT_SIZE;    for (let i = 0; i &lt; count; i++) {     const item = document.createElement(\"img\"); // 이미지 추가!     item.setAttribute(\"class\", className); // 이미지에 클래스 속성추가!     item.setAttribute(\"src\", imgPath); // 이미지 경로 추가!     item.style.position = \"absolute\"; // feild에 상대적으로 오프셋 적용     const x = randomNumber(x1, x2); // 최솟값 x1와 최댓값 x2 사이에서 랜덤으로 숫자를 받아 상수 x에 할당!     const y = randomNumber(y1, y2); // 최솟값 y1와 최댓값 y2 사이에서 랜덤으로 숫자를 받아 상수 y에 할당!     item.style.left = `${x}px`; // 추가한 이미지의 left값에 x값 할당!     item.style.top = `${y}px`; // 추가한 이미지의 top에 y값 할당!     field.appendChild(item); // field에 해당 이미지를 추가   } }   📄 3. addItem함수에 값을 지정한다.   function initGame() {   addItem(\"carrot\", 5, \"carrot.png\"); // 당근 이미지 5개!   addItem(\"bug\", 5, \"bug.png\"); // 벌레 이미지 5개! }   결과      새로고침할 때 마다 당근 5개와 벌레 5개가 배치된다.   느낀점   강의 전혀 안보고 하려고 했는데 실패했다~   이미지를 랜덤으로 배치하는 함수가 따로 있는 줄 알았다.  모든게 함수나 API로 있진 않나보다.  구글링할때 많은 사람들이 제이쿼리를 쓰는 것을 보았다.  생각보다 바닐라로 구현하는 내용은 보지 못했다.  코드를 혼자서 완성시키는 것은 지금 당장 해내지 못할지라도 강의에서 보여주는 코드를 완벽하게 이해하고 넘어가서 다음에 사용하는 경우가 생긴다면 그때는 꼭 적용시켜서 스스로 해낼 것이다.    출처      드림코딩  ","categories": ["JavaScript"],
        "tags": ["JavaScript"],
        "url": "/javascript/js-image-random/",
        "teaser": null
      },{
        "title": "async 함수로 데이터 fetch하기",
        "excerpt":"📄 async 함수로 데이터 fetch하기   서버로부터 데이터를 fetch해오는 방법은 여러가지가 있다. 보통 promise를 사용하거나 async await문을 사용한다.   📄 Promise를 통한 비동기 코딩의 문제점   1. 디버깅   function fetchAuthorName(postId) {   return fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)     .then((response) =&gt; response.json())     .then((post) =&gt; post.userId)     .then((userId) =&gt; {       return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)         .then((response) =&gt; response.json())         .then((user) =&gt; user1.name); // 의도한 Error     }); }  fetchAuthorName(1).then((name) =&gt; console.log(\"name:\", name));   ✔ 결과   ReferenceError: user1 is not defined     at fetch.then.then.then.then.then (&lt;anonymous&gt;:7:29)   동일한 이름의 메소드인 여러개의 then()중에서 정확히 어디서 에러가 발생했는지 에러 메세지만 보고는 알 수 없다.   2. 예외처리   Promise를 사용하면 try/catch대신 catch()메서드만 사용하여 예외처리를 해야한다. 비동기, 동기 코드가 섞인 경우에는 예외 처리를 하는 과정이 복잡해질 수 있다.   3. 들여쓰기   실제 프로젝트에서 비동기 처리 코드는 길고 복잡하기 마련인데, 무한 then() 메서드에 빠지게 되면 코드의 가독성이 매우 떨어진다.   📄 aync/await를 통해 데이터 fetch해오기   async/await를 사용하면 Promise가 가진 문제점들을 해결해 줄 수 있다.   Promise 사용했을 때:   fetch(`https://api.idiots.band/api/search?keyword=${e.target.value}`)   .then((x) =&gt; x.json())   .then((data) =&gt; {     console.log(JSON.stringify(data, null, 2));   });   async-await 사용했을 때:   onSearchBand: async (inputValue) =&gt; {   const postResponse = await fetch(     `https://api.idiots.band/api/search?keyword=${inputValue}`   );   const post = await postResponse.json();   this.setState(post); };      fetch함수를 사용하는 함수를 aysnc 함수로 만들어준다.   fetch함수에 await를 걸어준다.   await로 가져온 데이터는 .json()을 호출해서 한번 더 await를 걸어준다.   예외처리 하기 주의사항   export const getSearchData = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const postResponse = await fetch(url);   if (postResponse.ok) {     const data = await postResponse.json();     return data;   } else {     throw new Error(data);   } };   이 코드는 에러는 나지 않지만 성능이 떨어진다.      async 함수는 모두 Promise를 리턴한다.   reponse.ok인 경우도 Promise가 리턴된다.   하지만 throw new Error(data)를 선언한다면 async 함수는 Promise&lt;Response&gt; | Promise&lt;void&gt;로 타입이 잡히게 된다.   따라서 reponse.ok를 선언했다면 예외처리를 할 경우도 Promise를 반환하게 하는 것이 바람직하다.   // 바람직한 코드  export const getSearchBand = async (value) =&gt; {   const url = `https://api.idiots.band/api/search?keyword=${value}`;   const response = await fetch(url);   if (response.ok) {     return response.json();   }   return Promise.reject(new Error(\"API 요청에 실패 했습니다.\")); };   출처      DaleSeo - 비동기 처리 3부 async/await  ","categories": ["JavaScript"],
        "tags": ["JavaScript","async"],
        "url": "/javascript/javascript-datafetchByAsync/",
        "teaser": null
      },{
        "title": "변수(variable)와 상수(constant)",
        "excerpt":"📄 선언이란?   특정 이름에 특정 값을 담는 것을 선언이라고 합니다.   선언을 하는 방식에는 두가지가 있습니다.   하나는 변수이고 다른 하나는 상수입니다.   📄 변수   변수에는 고정된 값이 아닌 바뀔 수 있는 값을 담습니다.   let이라는 키워드를 사용하여 변수를 선언합니다.   let value = 1;      value라는 변수를 선언하고, 1이라는 값을 담았다.    📄 상수   상수는 변수와 다르게 고정된 값을 가집니다.   상수를 선언할 때는 const라는 키워드를 사용합니다.   const a = 1; a = 2;   상수는 고정된 값을 담기 때문에 위와 같은 코드에는 오류가 발생합니다.   한번 선언되어 1이라는 값을 가지고 있는 상수 a에 다른 값을 다시 넣었기 때문입니다.    주의할 점   상수 객체는 수정될 수 있습니다.   const user = {   name: \"John\", };  user.name = \"Pete\";  console.log(user.name);      ```js Pete; ```  `const`는 `user`의 값을 고정하지만, 그 내용은 고정하지 않습니다.  `const`는 `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생합니다.  ## 📄 왜 변수와 상수를 사용할까?  복잡한 식을 컴퓨터가 매번 읽어낸다면 프로그래밍의 효율성이 떨어집니다.  변수와 상수에 값을 담아두면 컴퓨터가 매번 똑같은 일을 반복하지 않고 코드도 간결해집니다.  ```js const sum = 5 + 10;  if (sum % 3 === 0) {   console.log(\"야호\"); } ```  이렇게 값을 변수나 상수에 지정하면 컴퓨터가 5 + 10을 매번 계산하지 않고 코드를 실행할 수 있습니다.  ## 📄 변수 명명 규칙  - 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다. - 첫 글자는 숫자가 될 수 없습니다. - 대·소문자는 구별됩니다. `a`와 `A`는 다릅니다. - 비 라틴계 언어도 변수명에 사용할 수 있지만 권장하지 않습니다. - 예약어는 사용하지 않습니다. - 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하는 카멜표기법이 흔히 사용됩니다. - `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용합니다. - 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 a, b, c와 같은 짧은 이름은 피해야 합니다. - 최대한 서술적이고 간결하게 명명해 주세요. data와 value는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합니다. - 자신만의 규칙이나 소속된 팀의 규칙을 따릅니다. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 currentVisitor나 newManInTown이 아닌 currentUser나 newUser라는 이름으로 지어야 합니다. - 변수명은 클래스명과 관련지으면 좋습니다.  ## 출처  - 패스트캠퍼스 프론트엔드 강의  * [모던 자바스크립트 튜토리얼](https://ko.javascript.info/object)  ","categories": ["JavaScript"],
        "tags": ["JavaScript","변수","상수"],
        "url": "/javascript/javascript-variableConstant/",
        "teaser": null
      },{
        "title": "동적 임포트(Dynamic import)",
        "excerpt":"📄 동적 임포트(Dynamic import)   보통 코드의 최상단에서 import문을 사용해 클래스나 함수를 가져오는 것을 정적 import라고 합니다.   정적으로 모듈을 import한다면      import문에 동적 매개 변수를 사용할 수 없습니다. = 원시 문자열만 가능하기 때문에 함수 호출 결과값을 경로로 사용할 수 없습니다.   런타임이나 조건부로 모듈을 불러올 수 없습니다. = if문, 코드 블록에서 사용할 수 없습니다.   📄 동적으로 모듈 import 하는 방법   동적으로 모듈을 import한다면      프로미스 객체를 반환합니다. 프로미스 객체의 반환값은 불러온 모듈입니다.   코드의 위치에 관계없이 사용이 가능하기 때문에, 모듈들을 사용자가 필요로 할 때 불러올 수 있습니다.   import()를 호출하는 순간부터 로딩이 되기 때문에 성능을 향상시킬 수 있습니다.   import(\"./sum\").then((sum) =&gt; {   console.log(sum(1 + 2)); });  ","categories": ["JavaScript"],
        "tags": ["JavaScript","동적 임포트","import"],
        "url": "/javascript/javascript-dynamic-import/",
        "teaser": null
      },{
        "title": "[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기",
        "excerpt":"📄 리덕스 툴킷을 사용하지 않은 이유   리덕스를 인강을 통해서 배웠지만 처음엔 이해가 잘 안갔다. 리듀서, 액션 등등 새로운 키워드가 많았고 컨셉도 어려웠다. 배우고 꾸준히 사용해보지 않아서 고이 묻어둔 상태였는데 원티드에서 리덕스를 다루게 되어 다시 꺼내 보았다. 그렇게 리덕스를 사용해서 만든 과제물에 대해 팀원분에게 피드백을 듣게 되었고 리덕스의 컨셉을 이해하지 않았다는 것을 알게 되었다.   기존의 나는 api를 호출할 때 store에서 따로 상태관련 로직을 작성하지 않았다. 예를 들어 Post요청을 한다고 가정했을 때, 데이터를 Put요청을 통해 수정하고 바로 다시 Get요청으로 데이터를 불러와 변경된 데이터를 화면에 렌더링해서 보여줬다. 이 과정에서는 api호출이 총 두번 발생한다.   하지만 store에서 상태 관리 로직을 작성한다면 따로 Get요청을 하지 않아도 클라이언트단에서 변경된 데이터를 바로 렌더링 할 수 있었다. 같은 과정이지만 api요청이 한번으로 줄어들게 되는 것이었다. 단점으로는 코드가 무거워진다는 부분이 있지만 api호출이 줄어드는 만큼 확실히 사용자 입장에선 더 빠르게 느껴질 것 같다.   📄 기존의 리덕스 사용 방식   const commentSlice = createSlice({   name: \"comment\",   initialState: initialState,   reducers: {},   extraReducers: (builder) =&gt; {     builder.addCase(getComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(createComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(editComment.fulfilled, (state, action) =&gt; action.payload);     builder.addCase(deleteComment.fulfilled, (state, action) =&gt; action.payload);   }, });  export default commentSlice;   redux-toolkit에서 제공하는 createAsyncThunk를 이용해 비동기 로직을 처리하고 댓글의 상태를 관리하는 리듀서를 작성했다. 상태 관련 로직이 전혀 없기 때문에 리듀서가 깔끔하고 각 액션이 어떤 일을 수행하는지 알 수 없다.   📄 개선된 리덕스 사용 방식   const todoReducer = (   state: TodoParam[] = initialState,   action: TodoActionType ) =&gt; {   switch (action.type) {     case GET_TODOS:       return action.payload;     case CREATE_TODO:       return [...state, action.payload];     case DELETE_TODO:       return state.filter((todo) =&gt; todo.id !== action.payload);     case UPDATE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload.id           ? { ...todo, todo: action.payload.todo, isCompleted: false }           : todo       );     case DONE_TODO:       return state.map((todo) =&gt;         todo.id === action.payload           ? { ...todo, isCompleted: !todo.isCompleted }           : todo       );     default:       return state;   } };   리덕스를 제대로 다시 공부하기 위해 툴킷을 사용하지 않고 구현해보았다. 한번 Get요청을 통해 받아온 데이터를 관리하는 리듀서를 만들었다. 상태가 변경될때마다 새로고침을 하는게 아니라면 다시 Get요청을 하지 않아도 되니 api요청이 훨씬 줄어들었다.   지금은 규모가 작은 프로젝트지만 큰 프로젝트의 경우라면 관련 로직이 꽤 길어질 것 같은데 그때도 이렇게 관리를 하는게 맞는지 궁금해졌다. 이 부분은 좀더 찾아봐야 알 것 같다.  ","categories": ["TodoList-Project"],
        "tags": ["TodoList","Redux"],
        "url": "/todolist-project/projects-todoList-redux/",
        "teaser": null
      },{
        "title": "Nodejs, npm, yarn",
        "excerpt":"📄 Node.js란?      Nodejs는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript의 런타임 입니다. (by Node 공식 페이지)       런타임이란? 특정 언어로 만든 프로그램을 실행할 수 있는 환경    Nodejs는 자바스크립트를 브라우저 내에서 말고도 다른환경에서 자바스크립트를 실행할 수 있게 합니다.   Node.js 의 유래   크롬같은 브라우저에는 html을 동적으로 움직일 수 있게하는 자바스크립트 해석 엔진이 있습니다.   크롬은 V8, 모질라는 SpiderMonkey를 사용합니다.   브라우저 중 크롬이 인기가 있는 이유중 하나는 빠른 속도입니다.   자바스크립트를 해석하는 속도가 빠르기 때문에 사용자가 브라우저를 이용할 때 속도가 빠르다고 느끼게 됩니다.   크롬은 사용하던 해석 엔진인 V8을 Node.js라는 이름으로 따로 출시합니다.   📄 npm(Node Packaged Manager)   npm은 Node.js의 패키지 관리자입니다.   npm은 Node.js로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램입니다.   npm을 사용하여 패키지를 설치하면 package.json에서 설치한 패키지가 자동으로 정리됩니다.   📄 yarn   yarn 또한 npm과 같이 javascript 패키지 매니저입니다.   yarn을 사용하면 npm 보다 더 나은 환경에서 자바스크립트를 실행할 수 있어 사용량이 높습니다.   yarn을 사용하는 이유   1. 속도   우선 npm보다 빠릅니다. 다운받은 패키지를 캐시에 저장하여 중복된 데이터는 다운로드하지 않고 캐시에 저장된 파일을 활용하기 때문입니다.   npm은 패키지를 설치할때 순차적으로 설치하는 반면, yarn은 병렬로 처리해 속도면에서 우수합니다.   2. 안정성과 보안   npm은 의존 관계를 가지는 다른 패키지들이 포함되지만 yarn은 package.json에 있는 파일만 설치한다고 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Nodejs","npm","yarn"],
        "url": "/javascript/javascript-jsruntime/",
        "teaser": null
      },{
        "title": "짝수와 홀수",
        "excerpt":"문제 📖   정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요.      num은 int 범위의 정수입니다.   0은 짝수입니다.   function solution(num) {   var answer = \"\";   return answer; }   나의 풀이 🙋‍♀️   function solution(num) {   const answer = num % 2 === 0 ? \"Even\" : \"Odd\";   return answer; }  solution(4);   num을 2로 나누어 나머지값에 대한 유무를 삼항연산자로 표현하고, 상수 answer에 값을 할당에 결과값을 return시켰다.   Best Practice 👍   function evenOrOdd(num) {   return num % 2 ? \"Odd\" : \"Even\"; }   숫자 0은 false, 이외의 값은 true라는 점을 활용하니 코드가 더욱 간결해졌다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","짝수와홀수"],
        "url": "/programmers-lv1/evenandodd/",
        "teaser": null
      },{
        "title": "평균 구하기",
        "excerpt":"문제 📖   정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.      arr은 길이 1 이상, 100 이하인 배열입니다.   arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(arr) {   const answer = arr.reduce((a, c) =&gt; a + c) / arr.length;   return answer; }   배열 내장 함수인 reduce함수를 사용했다.   for문을 사용하는 것보다 훨씬 간결한 코드가 나왔다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","평균구하기","해시"],
        "url": "/programmers-lv1/programmers-arr/",
        "teaser": null
      },{
        "title": "폰켓몬",
        "excerpt":"문제 📖   당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.   홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.      첫 번째(3번), 두 번째(1번) 폰켓몬을 선택   첫 번째(3번), 세 번째(2번) 폰켓몬을 선택   첫 번째(3번), 네 번째(3번) 폰켓몬을 선택   두 번째(1번), 세 번째(2번) 폰켓몬을 선택   두 번째(1번), 네 번째(3번) 폰켓몬을 선택   세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.   당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.   나의 풀이 🙋‍♀️   function solution(nums) {   const totalNumber = Math.ceil(nums.length / 2);   const set = new Set(nums);   const newNums = [...set];    const answer =     Math.ceil(newNums.length) &gt; totalNumber       ? totalNumber       : Math.ceil(newNums.length);    return answer; }   우선 주어진 배열의 길이를 totalNumber에 저장해 answer에 최댓값으로 생각했다.   이후 set함수를 사용해서 배열의 중복요소를 제거했다.   최종 정답은 중복요소를 제거한 배열의 길이가 최댓값보다 크면 최댓값인 totalNumber, 작으면 중복요소를 제거한 배열의 길이로 설정했다.   Best Practice 👍   function solution(nums) {   const max = nums.length / 2;   const arr = [...new Set(nums)];    return arr.length &gt; max ? max : arr.length; }   다른 사람의 풀이를 보니 내가 너무 성급하게 정답을 제출했다는 것을 알았다.   내 풀이에서는 newNums.length에 쓸데없이 올림처리를 한 것을 지우지도 않았고, set함수를 사용할때 굳이 상수를 두번이나 선언한게 보인다.   답이 나와도 다시한번 보고 정리하는 습관을 가져야겠다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","폰켓몬","해시"],
        "url": "/programmers-lv1/programmers-phonecatmon/",
        "teaser": null
      },{
        "title": "약수의 합",
        "excerpt":"문제 📖   정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.      n은 0 이상 3000이하인 정수입니다.   나의 풀이 🙋‍♀️   function solution(n) {   let sum = n;   for (let i = 1; i &lt;= Math.floor(n / 2); i++) {     if (n % i === 0) sum += i;   }   return sum; }   간단하게 for문을 사용했다.   어차피 주어진 수 n의 절반까지만 정답의 유효 범위이기 때문에 반복 횟수를 조금이라도 줄이려고 신경썼다.   반복문을 통해 주어진 수 n을 정수로 나눈 값이 0일 경우, 총합 sum에 더해준다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","약수의 합"],
        "url": "/programmers-lv1/sumofdivisor/",
        "teaser": null
      },{
        "title": "🚨 Assignment to constant variable.",
        "excerpt":"🚨 Assignment to constant variable.   자바스크립트 퀴즈를 푸는데 코드에 빨간 표시도 안났는데 에러가 떴다.   직역하면 상수값을 변수에 할당했다는 뜻이다.   function countBiggerThanTen(numbers) {   let sum = 0;   numbers.forEach((number) =&gt; {     if (number &gt; 10) {       sum += 1; // TypeError: Assignment to constant variable.     }   });   console.log(sum); }   원인   이미 선언한 const 변수에 새로운 값을 할당했을 때 발생한다.   위 코드에서 계속 값이 바뀌는 sum을 상수로 선언했다.   해결   값을 재할당에서 사용할 수 있는 let으로 바꾸어 주었더니 정상적으로 동작했다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","에러","상수","변수"],
        "url": "/javascript/javascript-assignment-to-constant-variable/",
        "teaser": null
      },{
        "title": "이벤트 버블링 (Event Bubbling), 이벤트 캡쳐 (Event Capture), 이벤트 위임 (Event Delegation)",
        "excerpt":"📄 이벤트 버블링 (Event Bubbling)   이벤트 버블링은 특정 요소에서 이벤트가 발생했을 때, 해당 이벤트가 더 상위 요소로 전달되는 과정입니다.   브라우저는 특정 요소에서 이벤트가 발생했을 때 그 이벤트를 최상위에 있는 요소까지 전파합니다.   이러한 과정을 이벤트 버블링이라고 합니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   three; two; one;   📄 이벤트 캡처 (Event Capture)   이벤트 캡처는 이벤트 버블링과 반대로 진행되는 이벤트 전달 과정입니다.   이벤트 캡처는 이벤트 버블링과 반대로 상위요소에서 하위요소로 이벤트 전달 과정이 진행됩니다.   // html &lt;body&gt;   &lt;div class=\"one\"&gt;     &lt;div class=\"two\"&gt;       &lt;div class=\"three\"&gt;&lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;;  // js var divs = document.querySelectorAll(\"div\"); divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   console.log(event.currentTarget.className); }   ✔ 결과   one; two; three;   addEventListener의 세번째 파라미터로 capture: true를 설정해주면 이벤트 캡처가 진행되어 가장 상위 요소에 적용된 이벤트가 먼저 발생합니다.   📄 이벤트 진행을 막고싶을 때는 어떻게 할까?   이벤트 버블링이나 이벤트 캡처를 구현할때 적용한 모든 요소에 이벤트를 실행하지 않고 중간에 멈추기 위한 속성이 있습니다. event.stopPropagation()을 사용하면 이벤트의 진행과정을 중단시킬 수 있습니다.   // 이벤트 버블링 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // three }  // 이벤트 캡쳐 예제 divs.forEach(function (div) {   div.addEventListener(\"click\", logEvent, {     capture: true, // default 값은 false입니다.   }); });  function logEvent(event) {   event.stopPropagation();   console.log(event.currentTarget.className); // one }   📄 이벤트 위임 (Event Delegation)   이벤트 위임은 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식입니다.   &lt;h1&gt;오늘의 할 일&lt;/h1&gt; &lt;ul class=\"itemList\"&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item1\" /&gt;     &lt;label for=\"item1\"&gt;이벤트 버블링 학습&lt;/label&gt;   &lt;/li&gt;   &lt;li&gt;     &lt;input type=\"checkbox\" id=\"item2\" /&gt;     &lt;label for=\"item2\"&gt;이벤트 캡쳐 학습&lt;/label&gt;   &lt;/li&gt; &lt;/ul&gt;   // 새 리스트 아이템을 추가하는 코드 var itemList = document.querySelector(\".itemList\");  var li = document.createElement(\"li\"); var input = document.createElement(\"input\"); var label = document.createElement(\"label\"); var labelText = document.createTextNode(\"이벤트 위임 학습\");  input.setAttribute(\"type\", \"checkbox\"); input.setAttribute(\"id\", \"item3\"); label.setAttribute(\"for\", \"item3\"); label.appendChild(labelText); li.appendChild(input); li.appendChild(label); itemList.appendChild(li);  var itemList = document.querySelector(\".itemList\"); itemList.addEventListener(\"click\", function (event) {   alert(\"clicked\"); });   아이템이 새로 추가될 때마다 이벤트를 새로 추가하지 않고 상위 요소인 .itemList에 이벤트를 달아줌으로써 하위요소에도 이벤트가 등록되었습니다.   출처      캡틴 판교-이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지  ","categories": ["JavaScript"],
        "tags": ["JavaScript","이벤트 버블링","이벤트 캡처","이벤트 위임"],
        "url": "/javascript/javascript-eventBubbling/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.   GitHub TIL레포에 공부내용을 기록해왔는데 이 블로그로 모든 내용을 옮겨야 한다.   내용이 꽤 많지만 전체적으로 한번씩 읽으면서 복습한다고 생각하고 여유롭게 이사해야겠다.   TIL 레포에서 GitHub 블로그로 이사하는 이유   우선, github 레포에서 보는 md파일은 가독성이 좋지 않다. 글씨의 크기나 간격이 편하게 읽기 좋은 정도는 아니다. 가장 큰 이유는 내가 지속적으로 관리하는 페이지를 가지고 싶었다. 이 블로그에 공부기록도 하지만 이외에 다양한 주제를 가지고 나를 표현하는 웹 사이트로 성장시킬 예정이다.  ","categories": ["일상"],
        "tags": ["Blog"],
        "url": "/%EC%9D%BC%EC%83%81/first-post/",
        "teaser": null
      },{
        "title": "완주하지 못한 선수",
        "excerpt":"문제 📖   수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.   마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.      마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.   completion의 길이는 participant의 길이보다 1 작습니다.   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.   참가자 중에는 동명이인이 있을 수 있습니다.   나의 풀이 #1 🙋‍♀️   function solution(participant, completion) {   const setParticipant = new Set(participant); // 1   if (setParticipant.size &lt; participant.length) {     // 2     const notCompletion = participant.filter((item) =&gt; {       if (setParticipant.has(item)) {         setParticipant.delete(item);       } else {         return item;       }     });     return notCompletion[0];   }   const answer = participant.filter((person) =&gt; !completion.includes(person)); // 3   return answer[0]; }      Set객체를 사용해서 participant 중복요소를 제거한다.   중복요소를 제거한 participant 객체(setParticipant)의 크기가 participant보다 작다면, 동명이인이 있다는 뜻이므로 filter함수를 사용해 완주하지 못한 선수의 이름을 구한다.   동명이인이 없는 경우 바로 완주하지 못한 선수의 이름을 구한다.   이 코드를 제출하며 정확성 체크는 통과하지만 효율성 체크는 통과하지 못한다.   효율성까지 테스트하는 문제는 처음이라 시간이 좀 걸려서 코드를 고쳤다.   나의 풀이 #2 🙋‍♀️   function solution(participant, completion) {   const sortedParticipant = participant.sort(); // 1   const sortedCompletion = completion.sort();    for (let i = 0; i &lt; sortedParticipant.length; i++) {     // 2     if (sortedParticipant[i] !== sortedCompletion[i]) {       // 3       return sortedParticipant[i];       break;     }   } }      참가자 배열과 완주자 배열의 문자열을 abc차순으로 정리한다.   for문을 사용해서 참가자 수만큼 반복문을 실행한다.   순차가 정리된 배열끼리 이름을 비교하게 되고, 이름이 같지 않으면 해당 이름을 정답으로 제출한다.   효율성 체크는 수행 시간과 메모리를 기준으로 평가된다.   코드의 시간복잡도와 저장된 메모리를 고려해야 통과할 수 있다.   반복문을 사용하는 경우에는 원하는 값이 도출되었을 때, 바로 반복문을 종료시킬 수 있어야 효율성이 증가한다.   그런면에서 배열에 for...in을 사용하는 것은 좋지 않다.   for...in은 모든 값을 조회해 효율성을 떨어뜨리기 때문이다.   Best Practice 👍   function solution(participant, completion) {   const map = new Map(); // 1    for (let i = 0; i &lt; participant.length; i++) {     let a = participant[i],       b = completion[i];      map.set(a, (map.get(a) || 0) + 1); // 2     map.set(b, (map.get(b) || 0) - 1); // 3   } // 4    for (let [k, v] of map) {     // 5     if (v &gt; 0) return k;   }    return \"nothing\"; }   해시의 컨셉을 정확히 접목시킨 풀이이다.   해시의 개념은 알고 있었지만 프로그래머스에서 이렇게 접목시킬 생각은 못했다.      우선 Map객체를 생성한다.   참가자 수만큼 반복문을 돌려 map에 키는 참가자 이름으로, 값은 기존에 1을 더해준다.   map에 완주자 이름의 키에 해당되는 값을 -1만큼 빼준다.   처음 for문을 나온 map의 키는 참가자이름이고 값은 0 또는 1이 된다.   완주하지 못한 참가자는 1의 값을 가지고 있으므로 해당 key의 값을 답으로 제출한다.   동명이인이 있을 경우에는 해당 이름의 값에 두번 1이 더해지고 한번 1이 빼지므로 마찬가지로 1이 된다.   풀이를 정리하자면 다음과 같게 된다.      sort로 풀면 O(NlogN)의 시간이 걸리지만 해시로 풀면 O(N)의 시간 복잡도를 가진다.   다음 해시 문제를 풀때는 꼭 Map을 사용해서 답을 낼 것이다.  ","categories": ["programmers-lv1"],
        "tags": ["프로그래머스","완주하지 못한 선수","해시"],
        "url": "/programmers-lv1/programmers-notcolpletedplayer/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] 사용자 폼 관련 Slice 리팩토링 (state 객체로 관리하기)",
        "excerpt":"❔ 리팩토링 이유   좋은 코드는 코드만 보고 어떤 일을 하는지 알 수 있는 코드라고 배웠다.   하지만 나의 코드는 코드만 보고 무슨일을 하는 지 알 수 없었다.   기존의 MemberForm 데이터 구조   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   value: [     { key: \"imageFile\", value: null, isValidate: true },     { key: \"username\", value: \"\", isValidate: false, emailAuth: false },     { key: \"email\", value: \"\", isValidate: false },     { key: \"password\", value: \"\", isValidate: false },   ], };   데이터 구조가 이렇게 되어있으면 값에 접근할 때 값의 이름이 아니라 index로 접근해야 했다.   처음 프로젝트를 시작할때 File 타입에 null이 할당되지 않아 객체 안에 굳이 key라는 이름의 key를 생성했다.   imageFile: File: null; // error   아마 내가 ‘imageFile’의 타입을 오로지 File로만 했던 모양인데 시간이 지나고 보니 코드가 굉장히 가독성이 없다는 것이 보였다.   💾 Components/SignUpForm   const result: UserParam = {   imageFile: userData[0].value,   username: userData[1].value!,   email: userData[2].value!,   password: userData[3].value!, };   userData에 index로 접근하기 때문에 해당 변수가 어떤 값을 가지고 있는지 알 수 없다.   이를 고치기 위해선 memberForm의 state 구조를 변경해야 했다.   ❕ 리팩토링 결과   💾 store/member/memberFormSlice.ts   const initialMemberForm = {   memberForm: {     imageFile: null,     username: \"\",     email: \"\",     password: \"\",   } as Omit&lt;MemberFormParam, \"profileUrl\" &amp; \"imageUrl\"&gt;,   emailAuth: false,   isEditMode: false, };   💾 Components/SignUpForm   const result: UserParam = {   imageFile: memberForm.imageFile,   username: memberForm.username,   email: memberForm.email,   password: memberForm.password, };   값에 이름으로 접근하니 어떤 데이터가 할당되는지 알 수 있게 되었다.   💬 나의 생각   분명 코드를 작성할 때는 최선인 것 같았는데 지나고 보니 아닌 경우가 꽤 많다.   완성된 프로젝트라 하더라도 다시 보고 리팩토링을 계속 해주는 것이 좋겠다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","redux-toolkit","데이터구조"],
        "url": "/coding-swamp/projects-coding-swamp/",
        "teaser": null
      },{
        "title": "[모여봐요 코딩의 늪] useState 비동기 에러 처리하기",
        "excerpt":"🐞 문제발생   사용자의 프로필을 수정하는 과정에서 useState를 사용해 form을 변경하는데, state가 업데이트 되지 않았다.   ▪ 문제 코드    ... const initialEditForm = {   profileUrl: '',   imageFile: null,   username: '',   imageUrl: '', }  const [memberForm, setMemberForm] = useState(initialEditForm)  ...  const onChangeProfileImg = useCallback(     async (e: ChangeEvent&lt;HTMLElement&gt;) =&gt; {       const ImageFiles = (e.target as HTMLInputElement).files       if (ImageFiles &amp;&amp; ImageFiles[0]) {         const url = URL.createObjectURL(ImageFiles[0])         setMemberForm({ ...memberForm, imageFile: ImageFiles[0] }) // 문제부분         setMemberForm({ ...memberForm, imageUrl: url })       }     },     [imgInputRef],   )    이 부분을 해결하려고 imageFile만 담는 state를 생성했을 때는 값이 바뀌는 것을 확인했는데, 도대체 왜 처음 작성했던 코드에서는 state가 변경되지 않는지 너무 궁금해서 꽤 오래 코드를 수정하고 손봤다.   그래도 해결이 안되서 오키에 질문글을 작성하고 이유를 알 수 있었다.   🔨 문제해결   문제는 useState의 비동기 처리 방식이었다.   useState가 비동기로 동작한다는 것을 어렴풋이 알고있었지만 어떻게 처리가 진행되는지 몰라서 문제가 어디서 발생했는지 정확히 모르고 애먼 코드들만 뜯어보고 답답해했다.  왜 imageUrl은 변경이 적용되고 첫번째 setState를 호출해서 적용한 imageFile은 변경이 안될까?   💡 useState는 비동기적으로 처리가 진행되기 때문에 useState를 두번 호출할 때, 마지막 호출시 처음 state의 변경분은 반영되지 않기 때문이다!   리액트는 성능을 최적화하기 위해 setState가 연속 호출되면 배치처리를 통해 한번에 렌더링한다고 한다.      배치(batch)란? 리액트가 여러개의 state 업데이트를 하나의 리렌더링으로 묶는 것    따라서, 위 코드에서 문제가 발생한 이유는 기존 memberForm에 imageFile이 더해진 상태로 변경된 것이 state에 적용되기 전에 다시 memberForm을 재사용하기 때문에 imageFile에 관한 변경사항이 적용되지 않고 imageUrl이 더해진 값으로 state가 적용되기 때문이었던 것이다.   ▪ 변경된 코드   setMemberForm({ ...memberForm, imageFile: ..., imageUrl: url })   setState를 한번만 호출해서 비동기 상황을 발생시키지 않게 고쳤고, 문제는 해결되었다.  비동기에 관한 삽질은 api통신을 할 때만 생길줄 알았던 내 안일한 생각이 가장 큰 문제였다.  안다고 다 아는게 아니라는 것을 다시 한번 뇌에 새기게 되었다.  ","categories": ["coding-swamp"],
        "tags": ["모코늪","useState","비동기"],
        "url": "/coding-swamp/projects-codingswamp-useState-asynchronous/",
        "teaser": null
      },{
        "title": "tsconfig.json 파일 살펴보기",
        "excerpt":"📄 tsconfig.json 파일이란?  tsconfig.json 파일은 타입스크립트 프로젝트에서 타입스크립트에 관한 환경설정을 할 수 있는 타입스크립트 컴파일러 설정파일입니다.   📄 tsconfig.json 파일에서 사용하는 옵션   tsconfig.json 파일에는 다양한 옵션이 있지만, 자주 사용되는 옵션을 정리했습니다.   {   \"compilerOptions\": {     \"module\" :\"CommonJS\",     \"target\": \"es5\",       \"esModuleInterop\": true,                                 \"moduleResolution\": \"node\",                               \"outDir\": \"dist\",     \"baseUrl\": \".\",     \"sourceMap\": true,     \"downlevelIteration\": true,     \"noImplicitAny\": false,     \"paths\": {\"*\": [\"node_modules/*\"]}                                  },   \"include\": [\"src/**/*\"] }       include: 타입스크립트 컴파일러 대상이 되는 경로   ▪ module 키     컴파일된 ES5 자바스크립트 코드는 웹브라우저와 노드제이에스에서 양쪽에서 동작해야 한다.   하지만, 웹브라우저와 노드제이에스는 동작방식이 다르다. (웹 브라우저: amd, 노드제이에스: commonjs )   따라서, module키로 동작 대상 플랫폼이 무엇인지 구분해주는 역할을 한다.   ▪ moduleResolution 키     moduule이 어떤 값을 가지느냐에 따라 다르게 설정된다.   commonjs는 node로 설정하고, amd는 classic으로 설정한다.   ▪ target 키     트랜스파일할 대상 자바스크립트의 버전을 설정한다.   보통 es5를 설정한다.   ▪ baseUrl &amp; OutDir 키     트랜스파일된 자바스크립트 파일을 저장하는 경로   OutDir은 baseUrl 설정값을 기준으로 하위 디렉토리를 뜻한다.   ▪ paths 키     소스 파일의 import 문에서 from 부분을 해석할 때 찾아야 하는 디렉토리를 설정한다.   node-module을 포함한 이유는 찾아야하는 소스가 외부 패키지일 경우를 위해 설정한 것이다.   ▪ esModuleInterop 키     웹 브라우저에서 동작한다는 가정으로 만들어진 오픈소스 자바스크립트 라이브러리가 CommonJS방식으로 동작하는 타입스크립트 코드에서 실행될 수 있도록 설정   ▪ sourceMap 키     소스맵 파일 생성 유무를 설정한다.   소스맵 파일에는 변환된 자바스크립트 코드가 타입스크립트 코드의 어느 부분에 해당하는지 보여준다.   ▪ downlevelIteration 키     타입스크립트의 생성기(generator) 구문이 정상적으로 동작하도록 설정   ▪ nolmplicitAny 키     지정하지 않은 타입을 암시적으로 any로 설정하게 한다.   false로 설정하면 타입을 지정하지 않았을 때, 에러메세지가 표시되지 않고 넘어간다.   참고      Do It 타입스크립트 프로그래밍 (책)  ","categories": ["TypeScript"],
        "tags": ["tsconfig"],
        "url": "/typescript/typescript-tsconfig/",
        "teaser": null
      },{
        "title": "[Leaning Typescript] system of a clown",
        "excerpt":"🤡 system of a clown      🎈 Help me, please!  I planned an elaborate clown-themed surprise party for my best friend. The whole event was planned using a few files of TypeScript code I’d written.  My friend somehow caught wind of the party and enlisted the clowns’ help to vandalize the program. Not only did the clowns remove or make incorrect my TypeScript type annotations, they introduced subtle bugs by subtly changing some of the values.  Could you please add correct type annotations in my files and fix any bugs detected by TypeScript? You’re my surprise clown celebration’s last hope! 🤡    🎈 도와주라주!  내 베프를 위해 삐에로 컨셉의 깜짝 파티를 준비했어. 모든 이벤트가 내가 쓴 몇개의 타입스크립트 파일로 준비되어 있지.  근데 내 친구가 어떻게든 정보를 들어가지고 프로그램을 파괴하기 위해 삐에로들한테 도움을 요청한거야! 삐에로들은 내 타입스크립트 애너테이션을 지우고 망가뜨리는것 뿐만 아니라, 일부 값들을 교묘하게 바꿔버리며 버그마저 도입해버렸어.  내 파일에 올바른 애너테이션을 추가하고 버그를 잡아줄 수 있어? 너는 내 깜짝 삐에로 파티의 마지막 희망이야! 🤡      타입 애너테이션 (type annotation)? 타입에 주석을 다는 것으로 변수나 함수의 타입을 설정하는 것.  ex) let name: string = ‘sujin’    🎈 Step 1: Clowning Around      The first area of code I’ll need you to fix is the activity assignment engine. It repeatedly creates groups of size 5-10 guests. Each group is directed to go to an activity, which can hold up to a certain number of them at a time.   It looks like the clowns didn’t change too much on this one. They mostly just removed a few type annotations and changed one value.   Could you please add back missing type annotations to avoid evolving or implicit anys, and fix the wrong value?    ▪ 요약: 액티비티 할당 엔진에서 타입 애너테이션을 추가하고 오류난 부분을 고쳐라!   📃 문제 코드   let remainingGuests = 20; while (true) {   // Each group of guests will be size 5-10   const guestsToAssign = Math.floor(Math.random() * 5) + 5;   let activity; // Those were some nice type annotations you had here!   let capacity; // It'd be a shame if we ... *erased* them! 😈   let requiresSupplies;   switch (Math.floor(Math.random() * 5)) {     case 0:       activity = \"balloon animals\";       capacity = 5;       requiresSupplies = true;       break;     case 1:       activity = \"face painting\";       capacity = \"1\";       requiresSupplies = true;       break;     case 2:       activity = \"juggling\";       capacity = 3;       requiresSupplies = true;       break;     default:       activity = \"dancing\";       capacity = 10;       break;   }   console.log(`${guestsToAssign} of us will enjoy ${activity}.`);   for (let i = 0; i &lt; guestsToAssign; i += capacity) {     console.log(`\\t${capacity} will enter the ${activity} activity.`);   }   remainingGuests -= guestsToAssign;   if (remainingGuests &lt; 0) {     break;   }   console.log(`We have ${remainingGuests} remaining guests to entertain.\\n`); } console.log(\"\\nAll done!\"); export {};   문제로 나온 이 코드를 tsc명령어를 이용해 컴파일하면 다음과 같은 오류가 발생합니다.      산술 연산자에 string값이 할당되고 있는 상황입니다.   📃 풀이 과정   오류가 난 부분을 보니, 산술 연산자에 string값이 할당되어 컴파일과정에서 막혀버렸습니다.   해당 변수 capacity를 찾습니다.   switch문안에서 문자열로 되어 있는 capacity를 찾아 숫자로 고칩니다.    case 1:       activity = \"face painting\";       // capacity = \"1\";       capacity = 1; // 수정       requiresSupplies = true;       break;   요구사항대로 변수가 선언된 부분에서 타입 애너테이션도 추가합니다.   let activity; // Those were some nice type annotations you had here! let capacity; // It'd be a shame if we ... *erased* them! 😈 let requiresSupplies;   ✔ 수정된 전체 코드   let remainingGuests = 20;  while (true) {   // Each group of guests will be size 5-10   const guestsToAssign = Math.floor(Math.random() * 5) + 5;   let activity: string; // Those were some nice type annotations you had here!   let capacity: number; // It'd be a shame if we ... *erased* them! 😈   let requiresSupplies: boolean;    switch (Math.floor(Math.random() * 5)) {     case 0:       activity = \"balloon animals\";       capacity = 5;       requiresSupplies = true;       break;     case 1:       activity = \"face painting\";       capacity = 1;       requiresSupplies = true;       break;     case 2:       activity = \"juggling\";       capacity = 3;       requiresSupplies = true;       break;     default:       activity = \"dancing\";       capacity = 10;       break;   }    console.log(`${guestsToAssign} of us will enjoy ${activity}.`);    for (let i = 0; i &lt; guestsToAssign; i += capacity) {     console.log(`\\t${capacity} will enter the ${activity} activity.`);   }    remainingGuests -= guestsToAssign;   if (remainingGuests &lt; 0) {     break;   }    console.log(`We have ${remainingGuests} remaining guests to entertain.\\n`); }  console.log(\"\\nAll done!\");  export {};   🎈 Step 2: Clown Availability      The second and -thank heavens- final area of code I’ll need you to fix is my clown assignment planner. I use this to print which clowns will be partying with which guests.   Oh, and they introduced several unsettling clown puns in comments.  It’s because of those puns that I can’t fix the code myself.  The clowns again changed a few things around, but nothing more than an incorrect type annotation or different value for a variable.  Could you please fix up the file to have no TypeScript complaints? x   ","categories": ["TypeScript"],
        "tags": ["learning typescript","type system","clowning around"],
        "url": "/typescript/typescript-learning-typescript-clowning-around/",
        "teaser": null
      },{
        "title": "🍸 칵테일 러브 좀비",
        "excerpt":"   ▪ 제목: 칵테일, 러브, 좀비  ▪ 작가: 조예은  ▪ 출판사: 안전가옥  ▪ 독서 기간: ? ~ 2023/03/16  ▪ 읽은 방식: 전자책     칵테일, 러브, 좀비는 4개의 단편소설로 구성된 한국 미스터리소설이다. 반전과 미스테리를 좋아하는 독자라면 필수로 읽어야 하는 작품집이라 생각한다. 그만큼 유명하기도 하다.   수록된 작품 중 가장 인상깊었던 작품을 고르자면 습지와 오버랩 나이프, 나이프라 할 수 있겠는데 이유는 서로 다르다.   습지는 귀신이 나오지만 무섭지 않다. 오히려 긴장감 넘치는 책 분위기 속에서 살짝 긴장을 풀고 차분하게 읽을 수 있는 분위기를 풍기는 내용이다. 미스테리 스릴러 소설이라고 무조건 빠른 호흡과 높은 텐션이 필수일 필요가 없다는 점을 새로이 알게 해준 작품이다.   이에 반해 오버랩 나이프, 나이프는 읽는 내내 책 종이가 넘어가는게 아까울 정도로 빠져들었다. 이때 혼자 카페에 앉아 책을 읽었는데 반전을 맞이할 때마다 표정관리하느라 꽤나 힘들었다. 조예은 작가님의 작품은 스토리가 흔하지 않고 결말이 뻔하지 않다. 작품의 제목조차 처음에는 어떤 뜻인지 알 수 없다. 오버랩 나이프, 나이프. 어떤 내용이 전개될지 도통 알기 힘들다. 작품을 다 읽고 다시 제목을 보았을 때 제목에서 다 알려주고 있다는걸 깨닫고는 무언가 당해버린 기분이 든다. 미루고 미뤘던 젤리장수 대학살도 조만간 읽어야 겠다.  ","categories": ["books"],
        "tags": ["칵테일 러브 좀비","조예은","안전가옥","추리/미스테리"],
        "url": "/books/books-cocktail-love-jombie/",
        "teaser": "/assets%5Cimage%5CPenguin.jpg"
      }]
