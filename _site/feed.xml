<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-10T11:52:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">완주하지 못한 선수</title><link href="http://localhost:4000/programmers-lv1/programmers-notcolpletedplayer/" rel="alternate" type="text/html" title="완주하지 못한 선수" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-notcolpletedplayer</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-notcolpletedplayer/"><![CDATA[<h2 id="문제-">문제 📖</h2>

<p>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</p>

<p>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
  <li>completion의 길이는 participant의 길이보다 1 작습니다.</li>
  <li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
  <li>참가자 중에는 동명이인이 있을 수 있습니다.</li>
</ul>

<h2 id="나의-풀이-1-️">나의 풀이 #1 🙋‍♀️</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">participant</span><span class="p">,</span> <span class="nx">completion</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">setParticipant</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">(</span><span class="nx">participant</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">setParticipant</span><span class="p">.</span><span class="nx">size</span> <span class="o">&lt;</span> <span class="nx">participant</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="kd">const</span> <span class="nx">notCompletion</span> <span class="o">=</span> <span class="nx">participant</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">if </span><span class="p">(</span><span class="nx">setParticipant</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">setParticipant</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">item</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="nx">notCompletion</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">participant</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">completion</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">person</span><span class="p">));</span> <span class="c1">// 3</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Set</code>객체를 사용해서 <code class="language-plaintext highlighter-rouge">participant</code> 중복요소를 제거한다.</li>
  <li>중복요소를 제거한 <code class="language-plaintext highlighter-rouge">participant</code> 객체(<code class="language-plaintext highlighter-rouge">setParticipant</code>)의 크기가 <code class="language-plaintext highlighter-rouge">participant</code>보다 작다면, 동명이인이 있다는 뜻이므로 <code class="language-plaintext highlighter-rouge">filter</code>함수를 사용해 완주하지 못한 선수의 이름을 구한다.</li>
  <li>동명이인이 없는 경우 바로 완주하지 못한 선수의 이름을 구한다.</li>
</ol>

<p>이 코드를 제출하며 정확성 체크는 통과하지만 효율성 체크는 통과하지 못한다.</p>

<p>효율성까지 테스트하는 문제는 처음이라 시간이 좀 걸려서 코드를 고쳤다.</p>

<h2 id="나의-풀이-2-️">나의 풀이 #2 🙋‍♀️</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">participant</span><span class="p">,</span> <span class="nx">completion</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">sortedParticipant</span> <span class="o">=</span> <span class="nx">participant</span><span class="p">.</span><span class="nf">sort</span><span class="p">();</span> <span class="c1">// 1</span>
  <span class="kd">const</span> <span class="nx">sortedCompletion</span> <span class="o">=</span> <span class="nx">completion</span><span class="p">.</span><span class="nf">sort</span><span class="p">();</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">sortedParticipant</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">sortedParticipant</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">sortedCompletion</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="c1">// 3</span>
      <span class="k">return</span> <span class="nx">sortedParticipant</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>참가자 배열과 완주자 배열의 문자열을 abc차순으로 정리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">for</code>문을 사용해서 참가자 수만큼 반복문을 실행한다.</li>
  <li>순차가 정리된 배열끼리 이름을 비교하게 되고, 이름이 같지 않으면 해당 이름을 정답으로 제출한다.</li>
</ol>

<p>효율성 체크는 수행 시간과 메모리를 기준으로 평가된다.</p>

<p>코드의 시간복잡도와 저장된 메모리를 고려해야 통과할 수 있다.</p>

<p>반복문을 사용하는 경우에는 원하는 값이 도출되었을 때, 바로 반복문을 종료시킬 수 있어야 효율성이 증가한다.</p>

<p>그런면에서 배열에 <code class="language-plaintext highlighter-rouge">for...in</code>을 사용하는 것은 좋지 않다.</p>

<p><code class="language-plaintext highlighter-rouge">for...in</code>은 모든 값을 조회해 효율성을 떨어뜨리기 때문이다.</p>

<h2 id="best-practice-">Best Practice 👍</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">participant</span><span class="p">,</span> <span class="nx">completion</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span> <span class="c1">// 1</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">participant</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">participant</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
      <span class="nx">b</span> <span class="o">=</span> <span class="nx">completion</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

    <span class="nx">map</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 2</span>
    <span class="nx">map</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 3</span>
  <span class="p">}</span> <span class="c1">// 4</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 5</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">k</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="dl">"</span><span class="s2">nothing</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>해시의 컨셉을 정확히 접목시킨 풀이이다.</p>

<p>해시의 개념은 알고 있었지만 프로그래머스에서 이렇게 접목시킬 생각은 못했다.</p>

<ol>
  <li>우선 <code class="language-plaintext highlighter-rouge">Map</code>객체를 생성한다.</li>
  <li>참가자 수만큼 반복문을 돌려 <code class="language-plaintext highlighter-rouge">map</code>에 키는 참가자 이름으로, 값은 기존에 1을 더해준다.</li>
  <li>map에 완주자 이름의 키에 해당되는 값을 <code class="language-plaintext highlighter-rouge">-1</code>만큼 빼준다.</li>
  <li>처음 <code class="language-plaintext highlighter-rouge">for</code>문을 나온 <code class="language-plaintext highlighter-rouge">map</code>의 키는 참가자이름이고 값은 0 또는 1이 된다.</li>
  <li>완주하지 못한 참가자는 1의 값을 가지고 있으므로 해당 key의 값을 답으로 제출한다.</li>
  <li>동명이인이 있을 경우에는 해당 이름의 값에 두번 1이 더해지고 한번 1이 빼지므로 마찬가지로 1이 된다.</li>
</ol>

<p>풀이를 정리하자면 다음과 같게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/223395946-3b217984-2284-408b-916f-8c85a22952fe.png" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">sort</code>로 풀면 <strong>O(NlogN)</strong>의 시간이 걸리지만 해시로 풀면 <strong>O(N)</strong>의 시간 복잡도를 가진다.</p>

<p>다음 해시 문제를 풀때는 꼭 <code class="language-plaintext highlighter-rouge">Map</code>을 사용해서 답을 낼 것이다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="프로그래머스" /><category term="완주하지 못한 선수" /><category term="해시" /><summary type="html"><![CDATA[프로그래머스 Lv1. 완주하지 못한 선수]]></summary></entry><entry><title type="html">github.io 블로그 시작하기</title><link href="http://localhost:4000/%EC%9D%BC%EC%83%81/first-post/" rel="alternate" type="text/html" title="github.io 블로그 시작하기" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-05T22:06:00+09:00</updated><id>http://localhost:4000/%EC%9D%BC%EC%83%81/first-post</id><content type="html" xml:base="http://localhost:4000/%EC%9D%BC%EC%83%81/first-post/"><![CDATA[<p>GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.</p>

<p>GitHub TIL레포에 공부내용을 기록해왔는데 이 블로그로 모든 내용을 옮겨야 한다.</p>

<p>내용이 꽤 많지만 전체적으로 한번씩 읽으면서 복습한다고 생각하고 여유롭게 이사해야겠다.</p>

<h3 id="til-레포에서-github-블로그로-이사하는-이유">TIL 레포에서 GitHub 블로그로 이사하는 이유</h3>

<p>우선, github 레포에서 보는 md파일은 가독성이 좋지 않다.
글씨의 크기나 간격이 편하게 읽기 좋은 정도는 아니다.
가장 큰 이유는 내가 지속적으로 관리하는 페이지를 가지고 싶었다.
이 블로그에 공부기록도 하지만 이외에 다양한 주제를 가지고 나를 표현하는 웹 사이트로 성장시킬 예정이다.</p>]]></content><author><name>Sujin Kim</name></author><category term="일상" /><category term="Blog" /><summary type="html"><![CDATA[GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.]]></summary></entry><entry><title type="html">약수의 합</title><link href="http://localhost:4000/programmers-lv1/sumofdivisor/" rel="alternate" type="text/html" title="약수의 합" /><published>2023-02-20T00:00:00+09:00</published><updated>2023-02-20T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/sumofdivisor</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/sumofdivisor/"><![CDATA[<h2 id="문제-">문제 📖</h2>

<p>정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>n은 0 이상 3000이하인 정수입니다.</li>
</ul>

<h2 id="나의-풀이-️">나의 풀이 🙋‍♀️</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>간단하게 <code class="language-plaintext highlighter-rouge">for</code>문을 사용했다.</p>

<p>어차피 주어진 수 <code class="language-plaintext highlighter-rouge">n</code>의 절반까지만 정답의 유효 범위이기 때문에 반복 횟수를 조금이라도 줄이려고 신경썼다.</p>

<p>반복문을 통해 주어진 수 <code class="language-plaintext highlighter-rouge">n</code>을 정수로 나눈 값이 0일 경우, 총합 <code class="language-plaintext highlighter-rouge">sum</code>에 더해준다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="프로그래머스" /><category term="약수의 합" /><summary type="html"><![CDATA[프로그래머스 Lv1. 약수의 합 풀이]]></summary></entry><entry><title type="html">평균 구하기</title><link href="http://localhost:4000/programmers-lv1/programmers-arr/" rel="alternate" type="text/html" title="평균 구하기" /><published>2023-02-17T00:00:00+09:00</published><updated>2023-02-17T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-arr</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-arr/"><![CDATA[<h2 id="문제-">문제 📖</h2>

<p>정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.</p>

<ul>
  <li>arr은 길이 1 이상, 100 이하인 배열입니다.</li>
  <li>arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.</li>
</ul>

<h2 id="나의-풀이-️">나의 풀이 🙋‍♀️</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">c</span><span class="p">)</span> <span class="o">/</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>배열 내장 함수인 <code class="language-plaintext highlighter-rouge">reduce</code>함수를 사용했다.</p>

<p><code class="language-plaintext highlighter-rouge">for</code>문을 사용하는 것보다 훨씬 간결한 코드가 나왔다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="프로그래머스" /><category term="평균구하기" /><category term="해시" /><summary type="html"><![CDATA[프로그래머스 Lv1. 평균 구하기 풀이]]></summary></entry><entry><title type="html">폰켓몬</title><link href="http://localhost:4000/programmers-lv1/programmers-phonecatmon/" rel="alternate" type="text/html" title="폰켓몬" /><published>2023-02-17T00:00:00+09:00</published><updated>2023-02-17T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-phonecatmon</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-phonecatmon/"><![CDATA[<h2 id="문제-">문제 📖</h2>

<p>당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.</p>

<p>홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.</p>

<ul>
  <li>첫 번째(3번), 두 번째(1번) 폰켓몬을 선택</li>
  <li>첫 번째(3번), 세 번째(2번) 폰켓몬을 선택</li>
  <li>첫 번째(3번), 네 번째(3번) 폰켓몬을 선택</li>
  <li>두 번째(1번), 세 번째(2번) 폰켓몬을 선택</li>
  <li>두 번째(1번), 네 번째(3번) 폰켓몬을 선택</li>
  <li>세 번째(2번), 네 번째(3번) 폰켓몬을 선택
이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.</li>
</ul>

<p>당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.</p>

<h2 id="나의-풀이-️">나의 풀이 🙋‍♀️</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">totalNumber</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">const</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">newNums</span> <span class="o">=</span> <span class="p">[...</span><span class="kd">set</span><span class="p">];</span>

  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span>
    <span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="nx">newNums</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">totalNumber</span>
      <span class="p">?</span> <span class="nx">totalNumber</span>
      <span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="nx">newNums</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>우선 주어진 배열의 길이를 <code class="language-plaintext highlighter-rouge">totalNumber</code>에 저장해 answer에 최댓값으로 생각했다.</p>

<p>이후 <code class="language-plaintext highlighter-rouge">set</code>함수를 사용해서 배열의 중복요소를 제거했다.</p>

<p>최종 정답은 중복요소를 제거한 배열의 길이가 최댓값보다 크면 최댓값인 <code class="language-plaintext highlighter-rouge">totalNumber</code>, 작으면 중복요소를 제거한 배열의 길이로 설정했다.</p>

<h2 id="best-practice-">Best Practice 👍</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nc">Set</span><span class="p">(</span><span class="nx">nums</span><span class="p">)];</span>

  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="nx">max</span> <span class="p">?</span> <span class="nx">max</span> <span class="p">:</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>다른 사람의 풀이를 보니 내가 너무 성급하게 정답을 제출했다는 것을 알았다.</p>

<p>내 풀이에서는 <code class="language-plaintext highlighter-rouge">newNums.length</code>에 쓸데없이 올림처리를 한 것을 지우지도 않았고, <code class="language-plaintext highlighter-rouge">set</code>함수를 사용할때 굳이 상수를 두번이나 선언한게 보인다.</p>

<p>답이 나와도 다시한번 보고 정리하는 습관을 가져야겠다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="프로그래머스" /><category term="폰켓몬" /><category term="해시" /><summary type="html"><![CDATA[프로그래머스 Lv1. 폰켓몬 풀이]]></summary></entry><entry><title type="html">짝수와 홀수</title><link href="http://localhost:4000/programmers-lv1/evenandodd/" rel="alternate" type="text/html" title="짝수와 홀수" /><published>2023-02-16T00:00:00+09:00</published><updated>2023-02-16T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/evenandodd</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/evenandodd/"><![CDATA[<h2 id="문제-">문제 📖</h2>

<p>정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>num은 int 범위의 정수입니다.</li>
  <li>0은 짝수입니다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">answer</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="나의-풀이-️">나의 풀이 🙋‍♀️</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">Even</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Odd</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">solution</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">num</code>을 2로 나누어 나머지값에 대한 유무를 삼항연산자로 표현하고, 상수 <code class="language-plaintext highlighter-rouge">answer</code>에 값을 할당에 결과값을 <code class="language-plaintext highlighter-rouge">return</code>시켰다.</p>

<h2 id="best-practice-">Best Practice 👍</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">evenOrOdd</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">Odd</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Even</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>숫자 0은 <code class="language-plaintext highlighter-rouge">false</code>, 이외의 값은 <code class="language-plaintext highlighter-rouge">true</code>라는 점을 활용하니 코드가 더욱 간결해졌다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="프로그래머스" /><category term="짝수와홀수" /><summary type="html"><![CDATA[프로그래머스 Lv1. 짝수와 홀수]]></summary></entry><entry><title type="html">[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기</title><link href="http://localhost:4000/todolist-project/projects-todoList-redux/" rel="alternate" type="text/html" title="[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기" /><published>2023-01-31T00:00:00+09:00</published><updated>2023-01-31T22:06:00+09:00</updated><id>http://localhost:4000/todolist-project/projects-todoList-redux</id><content type="html" xml:base="http://localhost:4000/todolist-project/projects-todoList-redux/"><![CDATA[<h2 id="-리덕스-툴킷을-사용하지-않은-이유">📄 리덕스 툴킷을 사용하지 않은 이유</h2>

<p>리덕스를 인강을 통해서 배웠지만 처음엔 이해가 잘 안갔다. 리듀서, 액션 등등 새로운 키워드가 많았고 컨셉도 어려웠다. 배우고 꾸준히 사용해보지 않아서 고이 묻어둔 상태였는데 원티드에서 리덕스를 다루게 되어 다시 꺼내 보았다. 그렇게 리덕스를 사용해서 만든 과제물에 대해 팀원분에게 피드백을 듣게 되었고 리덕스의 컨셉을 이해하지 않았다는 것을 알게 되었다.</p>

<p>기존의 나는 api를 호출할 때 store에서 따로 상태관련 로직을 작성하지 않았다.
예를 들어 Post요청을 한다고 가정했을 때, 데이터를 Put요청을 통해 수정하고 바로 다시 Get요청으로 데이터를 불러와 변경된 데이터를 화면에 렌더링해서 보여줬다. 이 과정에서는 api호출이 총 두번 발생한다.</p>

<p>하지만 store에서 상태 관리 로직을 작성한다면 따로 Get요청을 하지 않아도 클라이언트단에서 변경된 데이터를 바로 렌더링 할 수 있었다. 같은 과정이지만 api요청이 한번으로 줄어들게 되는 것이었다. 단점으로는 코드가 무거워진다는 부분이 있지만 api호출이 줄어드는 만큼 확실히 사용자 입장에선 더 빠르게 느껴질 것 같다.</p>

<h2 id="-기존의-리덕스-사용-방식">📄 기존의 리덕스 사용 방식</h2>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">commentSlice</span> <span class="o">=</span> <span class="nf">createSlice</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">comment</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">initialState</span><span class="p">:</span> <span class="nx">initialState</span><span class="p">,</span>
  <span class="na">reducers</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">extraReducers</span><span class="p">:</span> <span class="p">(</span><span class="nx">builder</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">getComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">createComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">editComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">deleteComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">});</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">commentSlice</span><span class="p">;</span>
</code></pre></div></div>

<p>redux-toolkit에서 제공하는 <code class="language-plaintext highlighter-rouge">createAsyncThunk</code>를 이용해 비동기 로직을 처리하고 댓글의 상태를 관리하는 리듀서를 작성했다.
상태 관련 로직이 전혀 없기 때문에 리듀서가 깔끔하고 각 액션이 어떤 일을 수행하는지 알 수 없다.</p>

<h2 id="-개선된-리덕스-사용-방식">📄 개선된 리덕스 사용 방식</h2>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">todoReducer</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">state</span><span class="p">:</span> <span class="nx">TodoParam</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">,</span>
  <span class="nx">action</span><span class="p">:</span> <span class="nx">TodoActionType</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="na">GET_TODOS</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
    <span class="k">case</span> <span class="na">CREATE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[...</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">];</span>
    <span class="k">case</span> <span class="na">DELETE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">!==</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="k">case</span> <span class="na">UPDATE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nx">id</span>
          <span class="p">?</span> <span class="p">{</span> <span class="p">...</span><span class="nx">todo</span><span class="p">,</span> <span class="na">todo</span><span class="p">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nx">todo</span><span class="p">,</span> <span class="na">isCompleted</span><span class="p">:</span> <span class="kc">false</span> <span class="p">}</span>
          <span class="p">:</span> <span class="nx">todo</span>
      <span class="p">);</span>
    <span class="k">case</span> <span class="na">DONE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span>
          <span class="p">?</span> <span class="p">{</span> <span class="p">...</span><span class="nx">todo</span><span class="p">,</span> <span class="na">isCompleted</span><span class="p">:</span> <span class="o">!</span><span class="nx">todo</span><span class="p">.</span><span class="nx">isCompleted</span> <span class="p">}</span>
          <span class="p">:</span> <span class="nx">todo</span>
      <span class="p">);</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>리덕스를 제대로 다시 공부하기 위해 툴킷을 사용하지 않고 구현해보았다.
한번 Get요청을 통해 받아온 데이터를 관리하는 리듀서를 만들었다.
상태가 변경될때마다 새로고침을 하는게 아니라면 다시 Get요청을 하지 않아도 되니 api요청이 훨씬 줄어들었다.</p>

<p>지금은 규모가 작은 프로젝트지만 큰 프로젝트의 경우라면 관련 로직이 꽤 길어질 것 같은데 그때도 이렇게 관리를 하는게 맞는지 궁금해졌다. 이 부분은 좀더 찾아봐야 알 것 같다.</p>]]></content><author><name>Sujin Kim</name></author><category term="TodoList-Project" /><category term="TodoList" /><category term="Redux" /><summary type="html"><![CDATA[툴킷을 사용하지 않고 redux만을 이용한 전역상태 관리]]></summary></entry><entry><title type="html">변수(variable)와 상수(constant)</title><link href="http://localhost:4000/javascript/javascript-variableConstant/" rel="alternate" type="text/html" title="변수(variable)와 상수(constant)" /><published>2022-12-15T00:00:00+09:00</published><updated>2022-12-15T22:06:00+09:00</updated><id>http://localhost:4000/javascript/javascript-variableConstant</id><content type="html" xml:base="http://localhost:4000/javascript/javascript-variableConstant/"><![CDATA[<h2 id="-선언이란">📄 선언이란?</h2>

<p>특정 이름에 특정 값을 담는 것을 선언이라고 합니다.</p>

<p>선언을 하는 방식에는 두가지가 있습니다.</p>

<p>하나는 변수이고 다른 하나는 상수입니다.</p>

<h2 id="-변수">📄 변수</h2>

<p>변수에는 고정된 값이 아닌 <strong>바뀔 수 있는 값</strong>을 담습니다.</p>

<p><code class="language-plaintext highlighter-rouge">let</code>이라는 키워드를 사용하여 변수를 선언합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>value라는 변수를 선언하고, 1이라는 값을 담았다.</p>
</blockquote>

<h2 id="-상수">📄 상수</h2>

<p>상수는 변수와 다르게 <strong>고정된 값</strong>을 가집니다.</p>

<p>상수를 선언할 때는 <code class="language-plaintext highlighter-rouge">const</code>라는 키워드를 사용합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>상수는 고정된 값을 담기 때문에 위와 같은 코드에는 오류가 발생합니다.</p>

<p>한번 선언되어 1이라는 값을 가지고 있는 상수 a에 다른 값을 다시 넣었기 때문입니다.<br /></p>

<h3 id="주의할-점">주의할 점</h3>

<p><strong>상수 객체는 수정될 수 있습니다.</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Pete</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</code></pre></div></div>

<결과><br />

```js
Pete;
```

`const`는 `user`의 값을 고정하지만, 그 내용은 고정하지 않습니다.

`const`는 `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생합니다.

## 📄 왜 변수와 상수를 사용할까?

복잡한 식을 컴퓨터가 매번 읽어낸다면 프로그래밍의 효율성이 떨어집니다.

변수와 상수에 값을 담아두면 컴퓨터가 매번 똑같은 일을 반복하지 않고 코드도 간결해집니다.

```js
const sum = 5 + 10;

if (sum % 3 === 0) {
  console.log("야호");
}
```

이렇게 값을 변수나 상수에 지정하면 컴퓨터가 5 + 10을 매번 계산하지 않고 코드를 실행할 수 있습니다.

## 📄 변수 명명 규칙

- 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다.
- 첫 글자는 숫자가 될 수 없습니다.
- 대·소문자는 구별됩니다. `a`와 `A`는 다릅니다.
- 비 라틴계 언어도 변수명에 사용할 수 있지만 권장하지 않습니다.
- 예약어는 사용하지 않습니다.
- 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하는 카멜표기법이 흔히 사용됩니다.
- `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용합니다.
- 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 a, b, c와 같은 짧은 이름은 피해야 합니다.
- 최대한 서술적이고 간결하게 명명해 주세요. data와 value는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합니다.
- 자신만의 규칙이나 소속된 팀의 규칙을 따릅니다. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 currentVisitor나 newManInTown이 아닌 currentUser나 newUser라는 이름으로 지어야 합니다.
- 변수명은 클래스명과 관련지으면 좋습니다.

## 출처

- 패스트캠퍼스 프론트엔드 강의

* [모던 자바스크립트 튜토리얼](https://ko.javascript.info/object)
</결과>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="변수" /><category term="상수" /></entry><entry><title type="html">배열 중복 요소 없애기 (Set)</title><link href="http://localhost:4000/javascript/javasrcipt-arraySet/" rel="alternate" type="text/html" title="배열 중복 요소 없애기 (Set)" /><published>2022-11-29T00:00:00+09:00</published><updated>2022-11-29T22:06:00+09:00</updated><id>http://localhost:4000/javascript/javasrcipt-arraySet</id><content type="html" xml:base="http://localhost:4000/javascript/javasrcipt-arraySet/"><![CDATA[<h2 id="-set">📄 Set</h2>

<p>배열을 다룰때 <code class="language-plaintext highlighter-rouge">Set</code>함수를 사용하면 중복된 요소를 없애고 값을 한번만 보여줍니다.</p>

<p><code class="language-plaintext highlighter-rouge">Set</code>은 객체로 다루어지지만 배열의 타입이 <code class="language-plaintext highlighter-rouge">Object</code>이기 때문에 사용할 수 있습니다.</p>

<h2 id="-set-사용하기">📄 Set 사용하기</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mySet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mySet</code>은 중복된 요소가 있으면 하나만 남기고 사라집니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mySet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Set { 1 }</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Set { 1, 5 }</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// Set { 1, 5 }</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">some text</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// Set { 1, 5, 'some text' }</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">5</code>를 두번 추가했지만 한개만 남습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">setHistoryData</span> <span class="o">=</span> <span class="p">(</span><span class="nx">histData</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">avoidDulpli</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nc">Set</span><span class="p">([</span><span class="nx">histData</span><span class="p">,</span> <span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">historyList</span><span class="p">])];</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">avoidDulpli</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">avoidDulpli</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">this</span><span class="p">.</span><span class="nf">setState</span><span class="p">({</span>
    <span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span>
    <span class="na">historyList</span><span class="p">:</span> <span class="nx">avoidDulpli</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>구현하던 프로젝트에서 검색기록을 내는 코드입니다.</p>

<p>검색한 데이터(<code class="language-plaintext highlighter-rouge">histData</code>)를 받아서 새로운 배열 <code class="language-plaintext highlighter-rouge">avoidDulpli</code>를 만들고,</p>

<p><code class="language-plaintext highlighter-rouge">new Set</code>을 이용해 중복된 값은 제거되는 새로운 배열을 만들어 받아온 데이터(<code class="language-plaintext highlighter-rouge">histData</code>)가 앞에 추가됩니다.</p>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="Set" /></entry><entry><title type="html">이미지 랜덤 배치</title><link href="http://localhost:4000/javascript/js-image-random/" rel="alternate" type="text/html" title="이미지 랜덤 배치" /><published>2022-11-29T00:00:00+09:00</published><updated>2022-11-29T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-image-random</id><content type="html" xml:base="http://localhost:4000/javascript/js-image-random/"><![CDATA[<h2 id="-이미지-랜덤-배치하기">📄 이미지 랜덤 배치하기</h2>

<p><strong>목표: Vanila JavaScript로 새로고침 될 때마다 이미지가 특정 범위에 랜덤으로 배치된다.</strong></p>

<p>원하는 범위의 위치를 받아와서 <strong>이미지의 left와 right 값을 지정</strong>해주자!<br /></p>

<h2 id="-1-원하는-feild의-위치를-파악한다">📄 1. 원하는 feild의 위치를 파악한다.</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fieldRect</span> <span class="o">=</span> <span class="nx">field</span><span class="p">.</span><span class="nf">getBoundingClientRect</span><span class="p">();</span>
<span class="kd">function</span> <span class="nf">initGame</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">fieldRect</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getBoundingClientRect</code>를 이용해 출력하면 지정한 요소의 위치를 콘솔창에서 확인할 수 있다.</p>

<h2 id="-2-feild에-추가하기-전에-이미지를-생성하는-함수를-만들어준다">📄 2. feild에 추가하기 전에 이미지를 생성하는 함수를 만들어준다.</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 랜덤으로 숫자를 생성하는 함수</span>
<span class="kd">function</span> <span class="nf">randomNumber</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span><span class="p">)</span> <span class="o">+</span> <span class="nx">min</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 아이템을 생성하는 함수</span>
<span class="kd">function</span> <span class="nf">addItem</span><span class="p">(</span><span class="nx">className</span><span class="p">,</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">imgPath</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 이미지가 feild에서 벗어나는 것을 막기 위해 최댓값을 조정한다.</span>
  <span class="kd">const</span> <span class="nx">x2</span> <span class="o">=</span> <span class="nx">fieldRect</span><span class="p">.</span><span class="nx">width</span> <span class="o">-</span> <span class="nx">CARROT_SIZE</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">y2</span> <span class="o">=</span> <span class="nx">fieldRect</span><span class="p">.</span><span class="nx">height</span> <span class="o">-</span> <span class="nx">CARROT_SIZE</span><span class="p">;</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">img</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 이미지 추가!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">"</span><span class="s2">class</span><span class="dl">"</span><span class="p">,</span> <span class="nx">className</span><span class="p">);</span> <span class="c1">// 이미지에 클래스 속성추가!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">"</span><span class="s2">src</span><span class="dl">"</span><span class="p">,</span> <span class="nx">imgPath</span><span class="p">);</span> <span class="c1">// 이미지 경로 추가!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">absolute</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// feild에 상대적으로 오프셋 적용</span>
    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nf">randomNumber</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">);</span> <span class="c1">// 최솟값 x1와 최댓값 x2 사이에서 랜덤으로 숫자를 받아 상수 x에 할당!</span>
    <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nf">randomNumber</span><span class="p">(</span><span class="nx">y1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span> <span class="c1">// 최솟값 y1와 최댓값 y2 사이에서 랜덤으로 숫자를 받아 상수 y에 할당!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span> <span class="c1">// 추가한 이미지의 left값에 x값 할당!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span> <span class="c1">// 추가한 이미지의 top에 y값 할당!</span>
    <span class="nx">field</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span> <span class="c1">// field에 해당 이미지를 추가</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="-3-additem함수에-값을-지정한다">📄 3. addItem함수에 값을 지정한다.</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">initGame</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">addItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">carrot</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="dl">"</span><span class="s2">carrot.png</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 당근 이미지 5개!</span>
  <span class="nf">addItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">bug</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bug.png</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 벌레 이미지 5개!</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="결과">결과</h4>

<p><img src="https://user-images.githubusercontent.com/56298540/184609114-2aaf8d9f-db80-40b6-9a59-a9b7b67ea962.PNG" alt="캡처" /></p>

<p>새로고침할 때 마다 당근 5개와 벌레 5개가 배치된다.</p>

<h2 id="느낀점">느낀점</h2>

<p>강의 전혀 안보고 하려고 했는데 실패했다~ <br />
이미지를 랜덤으로 배치하는 함수가 따로 있는 줄 알았다.<br />
모든게 함수나 API로 있진 않나보다.<br />
구글링할때 많은 사람들이 제이쿼리를 쓰는 것을 보았다.<br />
생각보다 바닐라로 구현하는 내용은 보지 못했다.<br />
코드를 혼자서 완성시키는 것은 지금 당장 해내지 못할지라도 강의에서 보여주는 코드를 완벽하게 이해하고 넘어가서 다음에 사용하는 경우가 생긴다면 그때는 꼭 적용시켜서 스스로 해낼 것이다.<br /></p>

<h2 id="출처">출처</h2>

<ul>
  <li>드림코딩</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /></entry></feed>