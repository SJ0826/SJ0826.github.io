<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-15T17:32:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">[프로그래머스 / Lv 2] 카펫</title><link href="http://localhost:4000/programmers-lv2/programmers-%EC%B9%B4%ED%8E%AB/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 카펫" /><published>2023-04-15T00:00:00+09:00</published><updated>2023-04-15T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EC%B9%B4%ED%8E%AB</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EC%B9%B4%ED%8E%AB/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.</p>

<p>Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.</p>

<p>Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.</li>
  <li>노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.</li>
  <li>카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">brown</span><span class="p">,</span> <span class="nx">yellow</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">brown</span> <span class="o">+</span> <span class="nx">yellow</span><span class="p">;</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">height</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">height</span> <span class="o">&lt;=</span> <span class="nx">brown</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">height</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">sum</span> <span class="o">%</span> <span class="nx">height</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">sum</span> <span class="o">/</span> <span class="nx">height</span><span class="p">;</span>

      <span class="nf">if </span><span class="p">((</span><span class="nx">height</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">===</span> <span class="nx">yellow</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>직사각형의 최소길이는 3이므로 3부터 <code class="language-plaintext highlighter-rouge">brown/2</code>까지 반복문을 돌린다.</li>
  <li><code class="language-plaintext highlighter-rouge">sum</code>을 <code class="language-plaintext highlighter-rouge">height</code>로 나누어 0이 떨어지는 경우는 직사각형의 가로, 세로 길이가 정수가 되는 경우이므로 <code class="language-plaintext highlighter-rouge">width</code>를 구해서 답을 반환한다.</li>
</ol>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="완전탐색" /><summary type="html"><![CDATA[프로그래머스 Lv 2 카펫]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 핸드폰 번호 가리기</title><link href="http://localhost:4000/programmers-lv1/programmers-%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8-%EA%B0%80%EB%A6%AC%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 핸드폰 번호 가리기" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-14T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%ED%95%B8%EB%93%9C%ED%8F%B0%20%EB%B2%88%ED%98%B8%20%EA%B0%80%EB%A6%AC%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8-%EA%B0%80%EB%A6%AC%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.
전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>phone_number는 길이 4 이상, 20이하인 문자열입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">phone_number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">.</span><span class="nf">repeat</span><span class="p">(</span><span class="nx">phone_number</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="nx">phone_number</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>문자열 메소드인 <code class="language-plaintext highlighter-rouge">repeat</code>으로 보여질 숫자 4개를 제외한 개수로 “*“을 만든다.</li>
  <li>주어진 <code class="language-plaintext highlighter-rouge">phone_number</code>를 뒤에서 4개로 잘라 붙여서 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">hide_numbers</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">\d(?=\d{4})</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>정규식을 이용한 풀이입니다.<br />
<code class="language-plaintext highlighter-rouge">?=</code>가 숫자 앞에오면 그 뒤에있는 숫자가 일치하는지 확인하는 정규식 문법입니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="repeat" /><category term="정규식" /><summary type="html"><![CDATA[프로그래머스 Lv 1 핸드폰 번호 가리기]]></summary></entry><entry><title type="html">[메세지가 도착했습니다] 둘다 사용해보고 작성하는 Styled-Components와 SCSS의 차이점</title><link href="http://localhost:4000/random-message/random-message-styled-component%EC%99%80-scss%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/" rel="alternate" type="text/html" title="[메세지가 도착했습니다] 둘다 사용해보고 작성하는 Styled-Components와 SCSS의 차이점" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-14T22:06:00+09:00</updated><id>http://localhost:4000/random-message/random-message-styled-component%EC%99%80%20scss%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90</id><content type="html" xml:base="http://localhost:4000/random-message/random-message-styled-component%EC%99%80-scss%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/"><![CDATA[<h2 id="-scss-scss">📄 SCSS? SCSS!</h2>

<p>처음으로 프로젝트에 SCSS를 사용했다.<br />
두가지 사용경험에 우선 차이점이 있다면 styled-components는 일단 다른 코드를 보며 무작정 사용하고 SCSS는 인강을 보고 공부했다는 점이다.<br />
styled-component를 계속 사용하다보니 CSS-in-CSS문법에 둔해져 그냥 구글링과 공식문서를 보고 사용하기엔 감이 잘 오지 않아 인강을 들을 수 밖에 없었다.<br />
빨리 SCSS를 사용해 보고 싶어서 인강은 하루만에 다 들었다.<br /></p>

<h2 id="-scss-사용하니-좋았던-점">📄 SCSS 사용하니 좋았던 점</h2>

<h3>1. 좀 더 나은 스타일 구조화</h3>

<p>아주 객관적이지만 SCSS를 사용했을 때 프로젝트 구조를 잡기가 더 쉬웠다.<br />
styled-component의 경우 베이스 코드를 작성하기 위해 <strong>createGlobalStyle</strong>을 사용해 <code class="language-plaintext highlighter-rouge">index</code>파일에서 import하고 태그를 생성하는 과정이 있는 반면, SCSS에서는 베이스 코들르 작성하고 <strong>import하면 바로 사용</strong>할 수 있었다.<br />
큰 차이는 아니지만 처음 styled-components를 사용했을 때 createGlobalStyle 태그를 생성해야하는 위치가 헷갈려 애먹었던 적이 있다.</p>

<p><strong>💾 base.scss</strong></p>

<ul>
  <li>프로젝트를 진행하며 점점 추가될 예정인 내 base 코드</li>
</ul>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="s2">"NanumBarunpen"</span><span class="p">;</span>
  <span class="nl">box-sizing</span><span class="p">:</span> <span class="n">border-box</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">html</span> <span class="p">{</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">body</span> <span class="p">{</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">button</span> <span class="p">{</span>
  <span class="nl">font-weight</span><span class="p">:</span> <span class="nb">bold</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>좀더 시각적으로 나았던 부분이 하나 더 있다.<br />
SCSS는 <strong>파일 아이콘</strong>이 있어 좀더 확실히 구분되는 느낌을 준다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/231812925-e84556cd-f856-4035-8050-e392303937a9.png" alt="image" /></p>

<p>styled-components는 어떤게 스타일 파일인지 직관적으로 눈에 들어오지 않는다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/231813201-baa363ba-65ec-4c32-a9d6-6951f1c306a0.png" alt="image" /></p>

<h3>2. 매번 설치할 필요가 없다.</h3>

<p>저번에 인강들으면서 전역으로 한번 설치해놓으니 매번 설치할 필요가 없다.<br />
왠지 프로젝트가 가벼워진 기분이든다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install -g sass // 요거 한번만 설치하면 끝
</code></pre></div></div>

<h3>3. 코드 재사용 문법이 더 잘되어 있다.</h3>

<ul>
  <li>변수
    <ul>
      <li>theme color를 지정할 때 유용</li>
      <li>media-query에도 사용할 예정</li>
    </ul>
  </li>
  <li>중첩</li>
  <li>mixin</li>
  <li>extend</li>
</ul>

<p>styled-component도 물론 중복 코드를 처리할 수 있지만, styled-component 고유 문법이 아니다.<br />
styled-component를 사용했을 때는 그냥 이렇게 보통 객체를 생성해 key-value형태로 사용했다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// styled-component</span>

<span class="kd">const</span> <span class="nx">theme</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">mainColor</span><span class="p">:</span> <span class="s2">`#CCD6A6`</span><span class="p">,</span>
  <span class="na">bgGroundColor1</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#FFFFFF</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bgGroundColor2</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#F8F9FA</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bgGroundColor3</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#E9ECEF</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bgGroundColor4</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#F4EAD5</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>SCSS에서는 따로 스타일을 위한 변수 선언 및 사용이 가능하다.</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// scss</span>

<span class="nv">$main-color</span><span class="p">:</span> <span class="mh">#39b5e0</span><span class="p">;</span>

<span class="nv">$back-ground-light</span><span class="p">:</span> <span class="mh">#ffffff</span><span class="p">;</span>
<span class="nv">$back-ground-light2</span><span class="p">:</span> <span class="mh">#f6f1f1</span><span class="p">;</span>
</code></pre></div></div>

<p>뿐만 아니라 mixin문법으로 자주 사용하는 스타일을 저장해 꺼내쓰고, extend문법으로 부모 스타일을 상속받아 사용할 수 있다.</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.messageList__content</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">1em</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="no">wheat</span><span class="p">;</span>
  <span class="nl">border-bottom</span><span class="p">:</span> <span class="m">1px</span> <span class="nb">solid</span> <span class="nv">$point-blue1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.messageList__header</span> <span class="p">{</span>
  <span class="k">@extend</span> <span class="nc">.messageList__content</span> <span class="nc">...</span><span class="p">;</span> <span class="c1">// 💡</span>
<span class="p">}</span>

<span class="nc">.messageList_list</span> <span class="p">{</span>
  <span class="k">@extend</span> <span class="nc">.messageList__content</span> <span class="nc">...</span><span class="p">;</span> <span class="c1">// 💡</span>
<span class="p">}</span>
</code></pre></div></div>

<h3>4. 코드가 색이 칠해져 있다 🤩</h3>

<p>사실 이게 styled-componets의 가장 큰 단점이라고 생각한다.<br />
코드가 한 색깔로 되어 있다는 것이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">HeaderWrapper</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-sizing: inherit;
  height: 100%;

  @media (max-width: 1920px) {
    width: calc(100% - 20rem);
  }

  @media (max-width: 1080px) {
    width: calc(100% - 8rem);
  }

  @media (max-width: 600px) {
    width: calc(100% - 3rem);
  }
`</span><span class="p">;</span>
</code></pre></div></div>

<p>혹시 바로 몰라 찾아 보니 vscode에 vscode-styled-components이라는 extension이 있다고 한다.<br />
진작 찾아봤으면 좋았을껄…</p>

<h2 id="-scss-사용하니-불편했던-점">📄 SCSS 사용하니 불편했던 점</h2>

<h3>1. 처치 곤란한 CSS파일들</h3>

<p>작성은 SCSS로 하지만 컴파일되면 모두 CSS로 변환되어 새로운 CSS파일이 자동으로 생긴다.<br />
나에게 가장 큰 진입장벽이 CSS파일을 관리하는 것이었다.<br /></p>

<ol>
  <li>SCSS파일이 위치한 곳마다 CSS파일을 둔다.</li>
  <li>CSS파일 경로를 설정해 한 폴더에 몰아버린다.</li>
</ol>

<p>여기까지 알아 뒀는데 인강을 듣고 한가지 방법을 더 알게 되었고 프로젝트에 도입했다.</p>

<ol>
  <li>main.scss에 모든 scss파일을 import해 컴파일 되는 파일은 main.scss파일 하나만 되게 만든다.</li>
</ol>

<p>3번의 방법을 사용하면 결국 나오는 .CSS확장자를 가진 파일은 main.css하나만 존재한다.<br />
아마 프로젝트가 큰 경우에는 main.scss 파일이 너무 무거워져 사용하면 안될 것 같다.<br /></p>

<p>이렇게 하면 또 번거로운 점이 생긴다.</p>

<ul>
  <li>Styled-Components의 경우: styled.js –(<strong>import</strong>)–&gt; index.tsx</li>
  <li>SCSS의 경우: _index.scss –(<strong>import</strong>)–&gt; main.scss –(<strong>compile</strong>)–&gt; main.css –(<strong>import</strong>)–&gt; (root경로의)index.tsx</li>
</ul>

<p>일단 인강에서 배운대로만 하면 이렇게 징검다리가 생기는데 분명 더 나은 방법이 있을 것이다.<br />
요즘 프로젝트 구조를 참고하는 <a href="https://github.com/sendbird/sendbird-uikit-react">sendbird Github</a>는 나처럼 한번에 모아서 컴파일 하지도 않고 CSS파일이 숨겨져 있는지 보이지도 않는다.<br />
검색해도 방법 찾기가 쉽지 않다.</p>

<h3>2. 컴파일로 인한 속도 저하</h3>

<p>Scss파일을 컴파일하기 위해 터미널말고 <strong>Watch Sass</strong> extension을 사용하고 있다.<br />
문제는 파일이 변경(저장)되면 즉시 컴파일 한다는 점이다. <br />
ctrl + s가 습관인 나는 굉장히 여러번 컴파일을 하는데 OUTPUT창이 계속 움직인다…<br />
만약 프로젝트 크기가 굉장히 큰 경우에는 적용한 스타일을 바로바로 빠르게 확인하기 어려울듯 싶다.</p>

<h3>3. props 참조가 안된다.</h3>

<p>이 부분은 styled-component의 가장 큰 장점인듯 싶다.<br />
styled-component를 사용할 때 매우 유용하게 사용해 이 부분도 굉장히 불편하게 느껴졌다.<br /></p>

<p>SCSS에서 props를 설정하는 방법은 여러가지가 있다.</p>

<ol>
  <li>className을 배열로 선언해 사용</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">./Button.scss</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">Button</span><span class="p">({</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">size</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">className</span><span class="o">=</span><span class="p">{[</span><span class="dl">"</span><span class="s2">Button</span><span class="dl">"</span><span class="p">,</span> <span class="nx">size</span><span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="nx">Button</span><span class="p">.</span><span class="nx">defaultProps</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">size</span><span class="p">:</span> <span class="dl">"</span><span class="s2">medium</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Button</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>className을 리터럴로 만들어 사용</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">./Button.scss</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">Button</span><span class="p">({</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">size</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="s2">`Button </span><span class="p">${</span><span class="nx">size</span><span class="p">}</span><span class="s2">`</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="nx">Button</span><span class="p">.</span><span class="nx">defaultProps</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">size</span><span class="p">:</span> <span class="dl">"</span><span class="s2">medium</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Button</span><span class="p">;</span>
</code></pre></div></div>

<p>이를 보완하기 위해 <strong>classnames</strong>라는 라이브러리를 많이 사용한다고 한다.<br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">classNames</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; 'foo bar'</span>
<span class="nf">classNames</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="na">bar</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span> <span class="c1">// =&gt; 'foo bar'</span>
<span class="nf">classNames</span><span class="p">({</span> <span class="dl">"</span><span class="s2">foo-bar</span><span class="dl">"</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span> <span class="c1">// =&gt; 'foo-bar'</span>
<span class="nf">classNames</span><span class="p">({</span> <span class="dl">"</span><span class="s2">foo-bar</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span> <span class="c1">// =&gt; ''</span>
<span class="nf">classNames</span><span class="p">({</span> <span class="na">foo</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="p">{</span> <span class="na">bar</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span> <span class="c1">// =&gt; 'foo bar'</span>
<span class="nf">classNames</span><span class="p">({</span> <span class="na">foo</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span> <span class="c1">// =&gt; 'foo bar'</span>
<span class="nf">classNames</span><span class="p">([</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">]);</span> <span class="c1">// =&gt; 'foo bar'</span>

<span class="c1">// 동시에 여러개의 타입으로 받아올 수 도 있습니다.</span>
<span class="nf">classNames</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="na">bar</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">duck</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span> <span class="dl">"</span><span class="s2">baz</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="na">quux</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span> <span class="c1">// =&gt; 'foo bar baz quux'</span>

<span class="c1">// false, null, 0, undefined 는 무시됩니다.</span>
<span class="nf">classNames</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span> <span class="na">baz</span><span class="p">:</span> <span class="kc">null</span> <span class="p">},</span> <span class="dl">""</span><span class="p">);</span> <span class="c1">// =&gt; 'bar 1'</span>
</code></pre></div></div>

<hr />

<p>SCSS와 Styled-Component는 둘다 CSS 스타일링에 많이 사용되는 언어이고 장단점이 있어 사용자 특성에 따라 사용되는 것 같다.<br />
SCSS를 꼭 사용해보고 싶었는데 하루 써보고 신나서 바로 블로그에 포스팅하러 달려왔다.<br />
계속 사용해볼 예정인데 아마 오늘 알게 된 내용보다 더 많은 걸 알게 될 것 같다.</p>

<h2 id="코드-참고">코드 참고</h2>

<ul>
  <li><a href="https://react.vlpt.us/styling/01-sass.html">벨로퍼트와 함께하는 모던 리액트</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="random-message" /><category term="Styled-Components" /><category term="SCSS" /></entry><entry><title type="html">[React] 줄글 props로 넘겨 줄바꿈하기</title><link href="http://localhost:4000/react/react-%EC%A4%84%EA%B8%80-props%EB%A1%9C-%EB%84%98%EA%B2%A8-%EC%A4%84%EB%B0%94%EA%BF%88%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[React] 줄글 props로 넘겨 줄바꿈하기" /><published>2023-04-13T00:00:00+09:00</published><updated>2023-04-13T22:06:00+09:00</updated><id>http://localhost:4000/react/react-%EC%A4%84%EA%B8%80%20props%EB%A1%9C%20%EB%84%98%EA%B2%A8%20%EC%A4%84%EB%B0%94%EA%BF%88%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/react-%EC%A4%84%EA%B8%80-props%EB%A1%9C-%EB%84%98%EA%B2%A8-%EC%A4%84%EB%B0%94%EA%BF%88%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-줄글-props로-넘겨-줄바꿈하는-방법">📄 줄글 props로 넘겨 줄바꿈하는 방법</h2>

<ol>
  <li>줄바꿈하는 곳에 <code class="language-plaintext highlighter-rouge">\n</code>을 입력한다.</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">GetStart</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">description</span> <span class="o">=</span> <span class="s2">`메세지가 도착했습니다는 익명 렌덤 메신저 💌 입니다.\n쉽게 뱉을 수 없었던 비밀 또는 모르는 누군가에게 보낼 응원의 메세지
					모두 좋아요.\n 💡 rule 1 메세지는 단 한명에게만 전달됩니다.\n 💡 rule 2 먼저 메세지를 보내야 익명의 누군가에게 메세지를 받을
					수 있습니다.\n 💡 rule 3 메세지의 상대방은 매번 바뀝니다.`</span><span class="p">;</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">start__container</span><span class="dl">"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Logo</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">SpeechBubble</span> <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">description</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">GetStart</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>텍스트가 들어가는 태그 css에 <code class="language-plaintext highlighter-rouge">white-space: pre-line</code>을 설정한다.</li>
</ol>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.start__description__content</span> <span class="p">{</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="err">$</span><span class="n">back-ground-light</span><span class="p">;</span>
  <span class="nl">white-space</span><span class="p">:</span> <span class="n">pre-line</span><span class="p">;</span> <span class="err">//</span> <span class="err">💡</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">1em</span><span class="p">;</span>
  <span class="nl">border-top-right-radius</span><span class="p">:</span> <span class="m">30px</span><span class="p">;</span>
  <span class="nl">border-top-left-radius</span><span class="p">:</span> <span class="m">30px</span><span class="p">;</span>
  <span class="nl">border-bottom-right-radius</span><span class="p">:</span> <span class="m">30px</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">black</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Sujin Kim</name></author><category term="React" /><category term="props" /><category term="줄바꿈" /></entry><entry><title type="html">[프로그래머스 / Lv 2] 영어 끝말잇기 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 영어 끝말잇기 by JS" /><published>2023-04-13T00:00:00+09:00</published><updated>2023-04-13T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EC%98%81%EC%96%B4%20%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.</p>

<p>1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
이전에 등장했던 단어는 사용할 수 없습니다.
한 글자인 단어는 인정되지 않습니다.
다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tank → kick → know → wheel → land → dream → mother → robot → tank
</code></pre></div></div>

<p>위 끝말잇기는 다음과 같이 진행됩니다.</p>

<ul>
  <li>1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.</li>
  <li>2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.</li>
  <li>3번 사람이 자신의 첫 번째 차례에 know를 말합니다.</li>
  <li>1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.</li>
  <li>(계속 진행)
끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.</li>
</ul>

<p>사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.</li>
  <li>words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.</li>
  <li>단어의 길이는 2 이상 50 이하입니다.</li>
  <li>모든 단어는 알파벳 소문자로만 이루어져 있습니다.</li>
  <li>끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.</li>
  <li>정답은 [ 번호, 차례 ] 형태로 return 해주세요.</li>
  <li>만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">words</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1</span>
    <span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nx">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="c1">// 2</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="nf">at</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="c1">// 3</span>
      <span class="nx">answer</span> <span class="o">=</span> <span class="p">[(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nx">n</span> <span class="p">?</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nx">n</span> <span class="p">:</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">((</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">n</span><span class="p">)];</span> <span class="c1">// 4</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="c1">// 5</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 문자열 배열 <code class="language-plaintext highlighter-rouge">words</code>를 순환한다.</li>
  <li>첫번째 반복의 경우 stack의 값이 비어있어 연산과정에서 에러가 발생하므로, <code class="language-plaintext highlighter-rouge">words</code>의 첫번째 값을 삽입 후 반복문을 이어간다.</li>
  <li>만약 <code class="language-plaintext highlighter-rouge">stack</code>에 현재 순환되고 있는 순서의 <code class="language-plaintext highlighter-rouge">word[i]</code>값이 있거나 끝말잇기에 실패한다면,</li>
  <li>가장 먼저탈락한 사람의 번호와 몇 번째 차례 탈락인지 구하고 반복문을 나온다.</li>
  <li>위 조건문에 해당하지 않을 경우, <code class="language-plaintext highlighter-rouge">stack</code>에 값을 추가한다.</li>
</ol>

<p>이 문제는 예전에 봤던 모 기업의 코딩테스트에서는 풀지 못했는데 이번에는 풀어서 뿌듯합니다.😤<br />
시간이 좀 걸렸던 이유는 배열의 인덱스는 0부터 시작하고 문제기준 인덱스는 1부터 시작해 헷갈렸기 때문입니다. 대체 왜 배열을 만든 사람은 첫번째 숫자를 0으로 한걸까요.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">words</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">now</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">answer</span> <span class="o">=</span>
      <span class="nx">answer</span> <span class="o">||</span>
      <span class="p">(</span><span class="nx">words</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">idx</span><span class="p">).</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">prev</span> <span class="o">!==</span> <span class="nx">now</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">?</span> <span class="nx">idx</span>
        <span class="p">:</span> <span class="nx">answer</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">now</span><span class="p">[</span><span class="nx">now</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">},</span> <span class="dl">""</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">answer</span> <span class="p">?</span> <span class="p">[(</span><span class="nx">answer</span> <span class="o">%</span> <span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">answer</span> <span class="o">/</span> <span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>첫번째 인덱스에서는 <code class="language-plaintext highlighter-rouge">answer</code>값을 0인 그대로 넘기고 <code class="language-plaintext highlighter-rouge">prev</code>에 값의 마지막 문자열을 담는다.</li>
  <li>요구사항 조건에 해당하는 경우 <code class="language-plaintext highlighter-rouge">answer</code>에 해당 인덱스를 담는다.</li>
  <li><code class="language-plaintext highlighter-rouge">answer</code>에 값이 0이 아닌 경우, 가장 먼저 탈락한 사람의 번호와 탈락 차례를 반환한다. (0의 경우 [0,0]을 반환)</li>
</ol>

<p>이 풀이는 속도에선 크게 차이가 없었으나, <code class="language-plaintext highlighter-rouge">reduce</code>함수를 잘 사용해서 Best Practice로 선정했습니다.<br />
이 풀이의 단점은 reduce함수를 사용했기 때문에 break문을 사용할 수 없어 모든 경우를 연산해야 한다는 점이 있습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="스택" /><summary type="html"><![CDATA[프로그래머스 Lv 2 영어 끝말잇기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 나누어 떨어지는 숫자 배열 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 나누어 떨어지는 숫자 배열 by JS" /><published>2023-04-13T00:00:00+09:00</published><updated>2023-04-13T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4%20%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94%20%EC%88%AB%EC%9E%90%20%EB%B0%B0%EC%97%B4</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.
divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.</p>

<ul>
  <li>arr은 자연수를 담은 배열입니다.</li>
  <li>정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.</li>
  <li>divisor는 자연수입니다.</li>
  <li>array는 길이 1 이상인 배열입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="nx">divisor</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="nx">answer</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span> <span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>filter 메소드로 <code class="language-plaintext highlighter-rouge">divisor</code>로 나누어 떨어지는 수를 배열 <code class="language-plaintext highlighter-rouge">answer</code>에 담는다.</li>
  <li><code class="language-plaintext highlighter-rouge">answer</code>의 길이가 0이면 [-1], 0이 아니면 true를 반환하므로 <code class="language-plaintext highlighter-rouge">answer</code>을 오름차순한 값을 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">_</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="p">(</span><span class="nx">e</span> <span class="o">%</span> <span class="nx">divisor</span><span class="p">));</span>
  <span class="k">return</span> <span class="nx">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">?</span> <span class="nx">_</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">$</span> <span class="o">-</span> <span class="nx">_</span><span class="p">)</span> <span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>filter연산을 좀더 간소화한 풀이입니다. 👍</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="" /><summary type="html"><![CDATA[프로그래머스 Lv 1 나누어 떨어지는 숫자 배열 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 서울에서 김서방 찾기</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 서울에서 김서방 찾기" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C%20%EA%B9%80%EC%84%9C%EB%B0%A9%20%EC%B0%BE%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>String형 배열 seoul의 element중 “Kim”의 위치 x를 찾아, “김서방은 x에 있다”는 String을 반환하는 함수, solution을 완성하세요. seoul에 “Kim”은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.</p>

<ul>
  <li>seoul은 길이 1 이상, 1000 이하인 배열입니다.</li>
  <li>seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다.</li>
  <li>“Kim”은 반드시 seoul 안에 포함되어 있습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">seoul</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`김서방은 </span><span class="p">${</span><span class="nx">seoul</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="dl">"</span><span class="s2">Kim</span><span class="dl">"</span><span class="p">)}</span><span class="s2">에 있다`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>배열 내장 메소드인 <code class="language-plaintext highlighter-rouge">indexOf()</code>를 사용했습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="indexOf" /><summary type="html"><![CDATA[프로그래머스 Lv 1 서울에서 김서방 찾기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 최소직사각형 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 최소직사각형 by JS" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C%20%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.</p>

<p>아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.</p>

<p>명함 번호 가로 길이 세로 길이</p>

<ul>
  <li>1 60 50</li>
  <li>2 30 70</li>
  <li>3 60 30</li>
  <li>4 80 40</li>
</ul>

<p>가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.</p>

<p>모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>sizes의 길이는 1 이상 10,000 이하입니다.
    <ul>
      <li>sizes의 원소는 [w, h] 형식입니다.</li>
      <li>w는 명함의 가로 길이를 나타냅니다.</li>
      <li>h는 명함의 세로 길이를 나타냅니다.</li>
      <li>w와 h는 1 이상 1,000 이하인 자연수입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sortedSizes</span> <span class="o">=</span> <span class="nx">sizes</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">arr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">));</span> <span class="c1">// 1</span>
  <span class="kd">let</span> <span class="nx">card</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">sizes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">?</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">?</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 3</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 배열 <code class="language-plaintext highlighter-rouge">sizes</code>를 순회하여 가로길이에 더 큰 값이 가도록 정렬한다.</li>
  <li>정렬한 배열 <code class="language-plaintext highlighter-rouge">sortedSizes</code>를 반복문을 돌려 가로, 세로 각 최댓값을 구한다.</li>
  <li>구한 최댓값끼리 곱해 답을 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">rotated</span> <span class="o">=</span> <span class="nx">sizes</span><span class="p">.</span><span class="nf">map</span><span class="p">(([</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">w</span> <span class="o">&lt;</span> <span class="nx">h</span> <span class="p">?</span> <span class="p">[</span><span class="nx">h</span><span class="p">,</span> <span class="nx">w</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">]));</span>

  <span class="kd">let</span> <span class="nx">maxSize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="nx">rotated</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(([</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">w</span> <span class="o">&gt;</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>비슷한 방식으로 풀었지만 개인적으로 삼항연산자보다 if문을 사용한게 더 깔끔하다고 느꼈습니다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="완전 탐색" /><summary type="html"><![CDATA[프로그래머스 Lv 1 최소직사각형 찾기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 짝지어 제거하기 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 짝지어 제거하기 by JS" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4%20%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.</p>

<p>예를 들어, 문자열 S = baabaa 라면</p>

<p>b aa baa → bb aa → aa →</p>

<p>의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.</p>

<ul>
  <li>문자열의 길이 : 1,000,000이하의 자연수</li>
  <li>문자열은 모두 소문자로 이루어져 있습니다.</li>
</ul>

<h2 id="️-나의-풀이-1">🙋‍♀️ 나의 풀이 1</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">s</span><span class="p">];</span> <span class="c1">// 0</span>
  <span class="nf">while </span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1</span>
    <span class="nx">arr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span>
      <span class="c1">// 2</span>
      <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 3</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 문자열을 배열 <code class="language-plaintext highlighter-rouge">arr</code>로 바꾼다.</li>
  <li>while문 배열의 길이가 0이될 때까지 반복한다.</li>
  <li>배열 요소의 앞 뒤 인덱스가 모두 다른 것만 남도록 조건을 주어 <code class="language-plaintext highlighter-rouge">arr</code>를 바꿔준다.</li>
  <li>만약 바꾼 <code class="language-plaintext highlighter-rouge">arr</code>의 길이와 처음 주어진 문자열 <code class="language-plaintext highlighter-rouge">s</code>의 길이가 같다면 반복문을 나온다.</li>
  <li><code class="language-plaintext highlighter-rouge">arr</code>의 값이 있으면 0 없으면 1을 반환한다.</li>
</ol>

<p>이 코드는 문제가 있습니다.</p>

<p>O(N^2)의 시간복잡도를 가지고 있어 몇개의 테스트코드를 통과하지 못했습니다.</p>

<p>좀 더 나은 시간복잡도를 내기 위해 스택개념을 사용해보기로 했습니다.</p>

<h2 id="️-나의-풀이-2">🙋‍♀️ 나의 풀이 2</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>문자열 s를 순서대로 stack에 넣는다.</li>
  <li>만약 들어온 문자열이 중복으로 또 들어오면 내보낸다. <code class="language-plaintext highlighter-rouge">pop() pop()</code>!!!</li>
</ol>

<p>다른 풀이를 보니 모두 스택 개념을 적용했네요.</p>

<p>스택을 이용해 푸니 시간복잡도가 O(N)이 되어 모든 테스트코드를 통과할 수 있었습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="스택" /><summary type="html"><![CDATA[프로그래머스 Lv 2 짝지어 제거하기 찾기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 콜라츠 추측</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 콜라츠 추측" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-04-10T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0%20%EC%B6%94%EC%B8%A1</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/"><![CDATA[<h2 id="-문제-출처">📄 문제 출처</h2>

<p>1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.</p>

<p>예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.</p>

<ul>
  <li>입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">while </span><span class="p">(</span><span class="nx">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">num</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">answer</span> <span class="o">===</span> <span class="mi">500</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>재귀함수를 사용해 볼까 하다가 성능상 반복문이 더 좋을 것 같아 <code class="language-plaintext highlighter-rouge">while</code>문에 조건을 걸어 <code class="language-plaintext highlighter-rouge">num</code>가 1이 될때 까지 반복했습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">collatz</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">?</span> <span class="nx">count</span> <span class="o">&gt;=</span> <span class="mi">500</span>
      <span class="p">?</span> <span class="o">-</span><span class="mi">1</span>
      <span class="p">:</span> <span class="nx">count</span>
    <span class="p">:</span> <span class="nf">collatz</span><span class="p">(</span><span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="nx">count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그래도 재귀함수를 사용한 풀이는 멋있네요.</p>

<p>삼항 연산자를 중첩으로 사용할 수 있다는 것도 처음 알아갑니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="콜라츠 추측" /><summary type="html"><![CDATA[프로그래머스 Lv 1 콜라츠 추측 문제 풀이]]></summary></entry></feed>