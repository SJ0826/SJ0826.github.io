<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-07T10:42:45+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">github.io 블로그 시작하기</title><link href="http://localhost:4000/%EC%9D%BC%EC%83%81/first-post/" rel="alternate" type="text/html" title="github.io 블로그 시작하기" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-05T22:06:00+09:00</updated><id>http://localhost:4000/%EC%9D%BC%EC%83%81/first-post</id><content type="html" xml:base="http://localhost:4000/%EC%9D%BC%EC%83%81/first-post/"><![CDATA[<p>GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.</p>

<p>GitHub TIL레포에 공부내용을 기록해왔는데 이 블로그로 모든 내용을 옮겨야 한다.</p>

<p>내용이 꽤 많지만 전체적으로 한번씩 읽으면서 복습한다고 생각하고 여유롭게 이사해야겠다.</p>

<h3 id="til-레포에서-github-블로그로-이사하는-이유">TIL 레포에서 GitHub 블로그로 이사하는 이유</h3>

<p>우선, github 레포에서 보는 md파일은 가독성이 좋지 않다.
글씨의 크기나 간격이 편하게 읽기 좋은 정도는 아니다.
가장 큰 이유는 내가 지속적으로 관리하는 페이지를 가지고 싶었다.
이 블로그에 공부기록도 하지만 이외에 다양한 주제를 가지고 나를 표현하는 웹 사이트로 성장시킬 예정이다.</p>]]></content><author><name>Sujin Kim</name></author><category term="일상" /><category term="Blog" /><summary type="html"><![CDATA[GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.]]></summary></entry><entry><title type="html">[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기</title><link href="http://localhost:4000/projects/projects-todoList-redux/" rel="alternate" type="text/html" title="[TodoList-Project] 툴킷없이 리덕스 사용해서 전역상태 관리하기" /><published>2023-01-31T00:00:00+09:00</published><updated>2023-01-31T22:06:00+09:00</updated><id>http://localhost:4000/projects/projects-todoList-redux</id><content type="html" xml:base="http://localhost:4000/projects/projects-todoList-redux/"><![CDATA[<h2 id="-리덕스-툴킷을-사용하지-않은-이유">📄 리덕스 툴킷을 사용하지 않은 이유</h2>

<p>리덕스를 인강을 통해서 배웠지만 처음엔 이해가 잘 안갔다. 리듀서, 액션 등등 새로운 키워드가 많았고 컨셉도 어려웠다. 배우고 꾸준히 사용해보지 않아서 고이 묻어둔 상태였는데 원티드에서 리덕스를 다루게 되어 다시 꺼내 보았다. 그렇게 리덕스를 사용해서 만든 과제물에 대해 팀원분에게 피드백을 듣게 되었고 리덕스의 컨셉을 이해하지 않았다는 것을 알게 되었다.</p>

<p>기존의 나는 api를 호출할 때 store에서 따로 상태관련 로직을 작성하지 않았다.
예를 들어 Post요청을 한다고 가정했을 때, 데이터를 Put요청을 통해 수정하고 바로 다시 Get요청으로 데이터를 불러와 변경된 데이터를 화면에 렌더링해서 보여줬다. 이 과정에서는 api호출이 총 두번 발생한다.</p>

<p>하지만 store에서 상태 관리 로직을 작성한다면 따로 Get요청을 하지 않아도 클라이언트단에서 변경된 데이터를 바로 렌더링 할 수 있었다. 같은 과정이지만 api요청이 한번으로 줄어들게 되는 것이었다. 단점으로는 코드가 무거워진다는 부분이 있지만 api호출이 줄어드는 만큼 확실히 사용자 입장에선 더 빠르게 느껴질 것 같다.</p>

<h2 id="-기존의-리덕스-사용-방식">📄 기존의 리덕스 사용 방식</h2>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">commentSlice</span> <span class="o">=</span> <span class="nf">createSlice</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">comment</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">initialState</span><span class="p">:</span> <span class="nx">initialState</span><span class="p">,</span>
  <span class="na">reducers</span><span class="p">:</span> <span class="p">{},</span>
  <span class="na">extraReducers</span><span class="p">:</span> <span class="p">(</span><span class="nx">builder</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">getComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">createComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">editComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nf">addCase</span><span class="p">(</span><span class="nx">deleteComment</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">});</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">commentSlice</span><span class="p">;</span>
</code></pre></div></div>

<p>redux-toolkit에서 제공하는 <code class="language-plaintext highlighter-rouge">createAsyncThunk</code>를 이용해 비동기 로직을 처리하고 댓글의 상태를 관리하는 리듀서를 작성했다.
상태 관련 로직이 전혀 없기 때문에 리듀서가 깔끔하고 각 액션이 어떤 일을 수행하는지 알 수 없다.</p>

<h2 id="-개선된-리덕스-사용-방식">📄 개선된 리덕스 사용 방식</h2>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">todoReducer</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">state</span><span class="p">:</span> <span class="nx">TodoParam</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">,</span>
  <span class="nx">action</span><span class="p">:</span> <span class="nx">TodoActionType</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">switch </span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="na">GET_TODOS</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
    <span class="k">case</span> <span class="na">CREATE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[...</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">];</span>
    <span class="k">case</span> <span class="na">DELETE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">!==</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
    <span class="k">case</span> <span class="na">UPDATE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nx">id</span>
          <span class="p">?</span> <span class="p">{</span> <span class="p">...</span><span class="nx">todo</span><span class="p">,</span> <span class="na">todo</span><span class="p">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nx">todo</span><span class="p">,</span> <span class="na">isCompleted</span><span class="p">:</span> <span class="kc">false</span> <span class="p">}</span>
          <span class="p">:</span> <span class="nx">todo</span>
      <span class="p">);</span>
    <span class="k">case</span> <span class="na">DONE_TODO</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span>
          <span class="p">?</span> <span class="p">{</span> <span class="p">...</span><span class="nx">todo</span><span class="p">,</span> <span class="na">isCompleted</span><span class="p">:</span> <span class="o">!</span><span class="nx">todo</span><span class="p">.</span><span class="nx">isCompleted</span> <span class="p">}</span>
          <span class="p">:</span> <span class="nx">todo</span>
      <span class="p">);</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>리덕스를 제대로 다시 공부하기 위해 툴킷을 사용하지 않고 구현해보았다.
한번 Get요청을 통해 받아온 데이터를 관리하는 리듀서를 만들었다.
상태가 변경될때마다 새로고침을 하는게 아니라면 다시 Get요청을 하지 않아도 되니 api요청이 훨씬 줄어들었다.</p>

<p>지금은 규모가 작은 프로젝트지만 큰 프로젝트의 경우라면 관련 로직이 꽤 길어질 것 같은데 그때도 이렇게 관리를 하는게 맞는지 궁금해졌다. 이 부분은 좀더 찾아봐야 알 것 같다.</p>]]></content><author><name>Sujin Kim</name></author><category term="Projects" /><category term="TodoList" /><category term="Redux" /><summary type="html"><![CDATA[툴킷을 사용하지 않고 redux만을 이용한 전역상태 관리]]></summary></entry><entry><title type="html">이미지 랜덤 배치</title><link href="http://localhost:4000/javascript/js-image-random/" rel="alternate" type="text/html" title="이미지 랜덤 배치" /><published>2022-11-29T00:00:00+09:00</published><updated>2022-11-29T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-image-random</id><content type="html" xml:base="http://localhost:4000/javascript/js-image-random/"><![CDATA[<h2 id="-이미지-랜덤-배치하기">📄 이미지 랜덤 배치하기</h2>

<p><strong>목표: Vanila JavaScript로 새로고침 될 때마다 이미지가 특정 범위에 랜덤으로 배치된다.</strong></p>

<p>원하는 범위의 위치를 받아와서 <strong>이미지의 left와 right 값을 지정</strong>해주자!<br /></p>

<h2 id="-1-원하는-feild의-위치를-파악한다">📄 1. 원하는 feild의 위치를 파악한다.</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fieldRect</span> <span class="o">=</span> <span class="nx">field</span><span class="p">.</span><span class="nf">getBoundingClientRect</span><span class="p">();</span>
<span class="kd">function</span> <span class="nf">initGame</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">fieldRect</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getBoundingClientRect</code>를 이용해 출력하면 지정한 요소의 위치를 콘솔창에서 확인할 수 있다.</p>

<h2 id="-2-feild에-추가하기-전에-이미지를-생성하는-함수를-만들어준다">📄 2. feild에 추가하기 전에 이미지를 생성하는 함수를 만들어준다.</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 랜덤으로 숫자를 생성하는 함수</span>
<span class="kd">function</span> <span class="nf">randomNumber</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span><span class="p">)</span> <span class="o">+</span> <span class="nx">min</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 아이템을 생성하는 함수</span>
<span class="kd">function</span> <span class="nf">addItem</span><span class="p">(</span><span class="nx">className</span><span class="p">,</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">imgPath</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 이미지가 feild에서 벗어나는 것을 막기 위해 최댓값을 조정한다.</span>
  <span class="kd">const</span> <span class="nx">x2</span> <span class="o">=</span> <span class="nx">fieldRect</span><span class="p">.</span><span class="nx">width</span> <span class="o">-</span> <span class="nx">CARROT_SIZE</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">y2</span> <span class="o">=</span> <span class="nx">fieldRect</span><span class="p">.</span><span class="nx">height</span> <span class="o">-</span> <span class="nx">CARROT_SIZE</span><span class="p">;</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">img</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 이미지 추가!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">"</span><span class="s2">class</span><span class="dl">"</span><span class="p">,</span> <span class="nx">className</span><span class="p">);</span> <span class="c1">// 이미지에 클래스 속성추가!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nf">setAttribute</span><span class="p">(</span><span class="dl">"</span><span class="s2">src</span><span class="dl">"</span><span class="p">,</span> <span class="nx">imgPath</span><span class="p">);</span> <span class="c1">// 이미지 경로 추가!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">absolute</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// feild에 상대적으로 오프셋 적용</span>
    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nf">randomNumber</span><span class="p">(</span><span class="nx">x1</span><span class="p">,</span> <span class="nx">x2</span><span class="p">);</span> <span class="c1">// 최솟값 x1와 최댓값 x2 사이에서 랜덤으로 숫자를 받아 상수 x에 할당!</span>
    <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nf">randomNumber</span><span class="p">(</span><span class="nx">y1</span><span class="p">,</span> <span class="nx">y2</span><span class="p">);</span> <span class="c1">// 최솟값 y1와 최댓값 y2 사이에서 랜덤으로 숫자를 받아 상수 y에 할당!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span> <span class="c1">// 추가한 이미지의 left값에 x값 할당!</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span> <span class="c1">// 추가한 이미지의 top에 y값 할당!</span>
    <span class="nx">field</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span> <span class="c1">// field에 해당 이미지를 추가</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="-3-additem함수에-값을-지정한다">📄 3. addItem함수에 값을 지정한다.</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">initGame</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">addItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">carrot</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="dl">"</span><span class="s2">carrot.png</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 당근 이미지 5개!</span>
  <span class="nf">addItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">bug</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bug.png</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 벌레 이미지 5개!</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="결과">결과</h4>

<p><img src="https://user-images.githubusercontent.com/56298540/184609114-2aaf8d9f-db80-40b6-9a59-a9b7b67ea962.PNG" alt="캡처" /></p>

<p>새로고침할 때 마다 당근 5개와 벌레 5개가 배치된다.</p>

<h2 id="느낀점">느낀점</h2>

<p>강의 전혀 안보고 하려고 했는데 실패했다~ <br />
이미지를 랜덤으로 배치하는 함수가 따로 있는 줄 알았다.<br />
모든게 함수나 API로 있진 않나보다.<br />
구글링할때 많은 사람들이 제이쿼리를 쓰는 것을 보았다.<br />
생각보다 바닐라로 구현하는 내용은 보지 못했다.<br />
코드를 혼자서 완성시키는 것은 지금 당장 해내지 못할지라도 강의에서 보여주는 코드를 완벽하게 이해하고 넘어가서 다음에 사용하는 경우가 생긴다면 그때는 꼭 적용시켜서 스스로 해낼 것이다.<br /></p>

<h2 id="출처">출처</h2>

<ul>
  <li>드림코딩</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /></entry><entry><title type="html">콜백(Callback)</title><link href="http://localhost:4000/javascript/js-callback/" rel="alternate" type="text/html" title="콜백(Callback)" /><published>2022-09-06T00:00:00+09:00</published><updated>2022-09-06T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-callback</id><content type="html" xml:base="http://localhost:4000/javascript/js-callback/"><![CDATA[<h2 id="-콜백">📄 콜백</h2>

<p>콜백 함수는 <strong>다른 코드를 인자로 넘겨주는 함수</strong>이다.<br />
다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한다.
자바스크립트는 호스트 환경이 제공하는 여러 함수를 사용하면 <strong>비동기 동작</strong>을 수행할 수 있다.</p>

<h2 id="-콜백은-어떤-경우에-사용될까">📄 콜백은 어떤 경우에 사용될까?</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">loadScript</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// &lt;script&gt; 태그를 만들고 페이지에 태그를 추가합니다.</span>
  <span class="c1">// 태그가 페이지에 추가되면 src에 있는 스크립트를 로딩하고 실행합니다.</span>
  <span class="kd">let</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">script</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">loadScript</span><span class="p">(</span><span class="dl">"</span><span class="s2">/my/script.js</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// script.js엔 "function newFunction() {…}"이 있습니다.</span>

<span class="nf">newFunction</span><span class="p">();</span> <span class="c1">// 함수가 존재하지 않는다는 에러가 발생합니다!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">new Function()</code>에서 에러가 발생하는 이유는 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문이다.<br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">loadScript</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>

  <span class="nx">script</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">callback</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>

  <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">loadScript</span><span class="p">(</span><span class="dl">'</span><span class="s1">/my/script.js</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 콜백 함수는 스크립트 로드가 끝나면 실행됩니다.</span>
  <span class="nf">newFunction</span><span class="p">();</span> <span class="c1">// 이제 함수 호출이 제대로 동작합니다.</span>
  <span class="p">...</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">loadScript</code>의 두 번째 인수에 스크립트 로딩이 끝난 후 실행될 함수인 콜백 함수를 추가했다.<br />
두 번째 인수로 전달되 함수는 원하는 동작이 완료되었을 떄 실행된다.<br /><br /></p>

<p>이것을 <strong>콜백 기반 비동기 프로그래밍</strong>이라고 부른다.<br />
비동기적으로 수행되어야할 필요성을 가진 코드에 콜백을 기반으로 접근할 수 있다.</p>

<h2 id="-오류-우선-콜백">📄 오류 우선 콜백</h2>

<p>콜백함수를 이용해서 에러를 핸들링할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">loadScript</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">script</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>

  <span class="nx">script</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">script</span><span class="p">);</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
    <span class="nf">callback</span><span class="p">(</span><span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">src</span><span class="p">}</span><span class="s2">를 불러오는 도중에 에러가 발생했습니다.`</span><span class="p">));</span>

  <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">loadScript</span><span class="p">(</span><span class="dl">"</span><span class="s2">/my/script.js</span><span class="dl">"</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">script</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 에러 처리</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 스크립트 로딩이 성공적으로 끝남</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="오류-우선-콜백의-관례">오류 우선 콜백의 관례</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">callback</code>의 첫 번째 인수는 에러를 위해 남겨둔다. 에러가 발생하면 이 인수를 이용해 <code class="language-plaintext highlighter-rouge">callback(err)</code>이 호출된다.</li>
  <li>두 번째 인수는 에러가 발생하지 않았을 때를 위해 남겨둔다. 원하는 동작이 성공한 경우엔 <code class="language-plaintext highlighter-rouge">callback(null, result1, result2)</code>가 호출된다.</li>
</ol>

<h3 id="오류-우선-콜백의-장점">오류 우선 콜백의 장점</h3>

<p>오류 우선 콜백을 사용하면, 단일 콜백 함수에서 에러 케이스와 성공 케이스 모두를 처리할 수 있다.</p>

<h2 id="출처">출처</h2>

<ul>
  <li>코어 자바스크립트</li>
  <li><a href="https://ko.javascript.info/callbacks">모던 자바스크립트 튜토리얼</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="콜백" /></entry><entry><title type="html">[클래스] 클래스(Class)</title><link href="http://localhost:4000/javascript/js-class/" rel="alternate" type="text/html" title="[클래스] 클래스(Class)" /><published>2022-09-05T00:00:00+09:00</published><updated>2022-09-05T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-class</id><content type="html" xml:base="http://localhost:4000/javascript/js-class/"><![CDATA[<h2 id="-클래스class란">📄 클래스(Class)란</h2>

<p>자바스크립트는 기본적으로 객체지향언어를 지원합니다.</p>

<p>es6문법에 class가 추가되어 좀더 강력한 객체지향언어를 지향하게 되었습니다.</p>

<p>Class는 객체를 생성하기 위한 템플릿이자 함수의 한 종류입니다.</p>

<p>클래스는 데이터와 이를 조작하는 코드를 하나로 추상화합니다.</p>

<h2 id="-선언적-방식">📄 선언적 방식</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="nf">method1</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="nf">method2</span><span class="p">()</span> <span class="p">{...}</span>
<span class="p">}</span> <span class="c1">//class A 생성</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">new</span> <span class="nc">A</span><span class="p">());</span> <span class="c1">// class A의 세로운 객체를 출력</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">A</span> <span class="p">{}</span>
</code></pre></div></div>

<p>클래스를 만들고 <code class="language-plaintext highlighter-rouge">new A()</code>를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성됩니다.<br />
클래스 내부에서 정의한 메서드는 <code class="language-plaintext highlighter-rouge">A.prototype</code>에 저장됩니다.<br />
객체의 기본 상태를 설정해주는 생성자 메서드 <code class="language-plaintext highlighter-rouge">constructor()</code>는 <code class="language-plaintext highlighter-rouge">new</code>에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화할 수 있습니다.</p>

<h3 id="주의할-점">주의할 점</h3>

<ul>
  <li>메서드 사이에는 쉼표가 없습니다.</li>
  <li>
    <p>클래스의 선언적 방식에서 호이스팅은 일어나지 않습니다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">new</code>키워들를 통해 호출하지 않으면 에러가 발생합니다.</li>
  <li>클래스에 정의된 메서드는 열거할 수 없습니다. 클래스의 <code class="language-plaintext highlighter-rouge">prototype</code>프로퍼티에 추가된 메서드의 <code class="language-plaintext highlighter-rouge">enumerable</code>플래그는 <code class="language-plaintext highlighter-rouge">false</code>입니다.</li>
  <li>클래스는 항상 엄격모드로 실행됩니다.(<code class="language-plaintext highlighter-rouge">use strict</code>)</li>
</ul>

<h2 id="-클래스-표현식">📄 클래스 표현식</h2>

<p>클래스의 표현식을 변수에 할당하는 방식으로 사용됩니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">B</span> <span class="o">=</span> <span class="kd">class</span> <span class="err">{};

</span><span class="nc">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">new</span> <span class="nc">B</span><span class="p">());</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">B</span> <span class="p">{}</span>
</code></pre></div></div>

<h2 id="-클래스-필드로-바인딩-된-메서드">📄 클래스 필드로 바인딩 된 메서드</h2>

<p>자바스크립트에서 <code class="language-plaintext highlighter-rouge">this</code>는 동적으로 결정됩니다.</p>

<p>따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출하게 되면 <code class="language-plaintext highlighter-rouge">this</code>는 메서드가 정의된 객체를 참조하지 않습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Button</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">click</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">cosole</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">button</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Button</span><span class="p">(</span><span class="dl">"</span><span class="s2">안녕하세요</span><span class="dl">"</span><span class="p">);</span>

<span class="nf">setTimeout</span><span class="p">(</span><span class="nx">button</span><span class="p">.</span><span class="nx">click</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">undefined</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">this</code>의 컨텍스트를 알 수 없게 된 현상을 ‘잃어버린 <code class="language-plaintext highlighter-rouge">this</code>‘라고 합니다.<br />
이러한 현상을 해결하기 위해 클래스 필드를 사용할 수 있습니다.<br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Button</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">click</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 수정한 부분</span>
    <span class="nf">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">button</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Button</span><span class="p">(</span><span class="dl">"</span><span class="s2">안녕하세요.</span><span class="dl">"</span><span class="p">);</span>

<span class="nf">setTimeout</span><span class="p">(</span><span class="nx">button</span><span class="p">.</span><span class="nx">click</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>안녕하세요.
</code></pre></div></div>

<p>클래스 필스 <code class="language-plaintext highlighter-rouge">click = () =&gt; {...}</code>는 각 <code class="language-plaintext highlighter-rouge">Button</code>객체마다 독립적인 함수를 만들어주고 이 함수의 <code class="language-plaintext highlighter-rouge">this</code>를 해당 객체에 바인딩시켜줍니다.<br />
클래스의 이러한 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야할 때 특히 유용합니다.</p>

<h2 id="-멤버변수">📄 멤버변수</h2>

<p>멤버 변수는 메소드 밖에서 선언된 변수를 뜻합니다.
클래스의 멤버변수는 this라는 키워드를 사용하여 반드시 생성자에 만들어야 합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">no name</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 초기값 설정</span>
  <span class="nx">age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 생성자를 통해서 새로 할당.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span> <span class="c1">// 멤버변수</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span> <span class="c1">// 멤버변수</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">new</span> <span class="nc">C</span><span class="p">(</span><span class="dl">"</span><span class="s2">Mark</span><span class="dl">"</span><span class="p">,</span> <span class="mi">37</span><span class="p">));</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">C</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Mark</span><span class="dl">'</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="mi">37</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="-멤버-함수">📄 멤버 함수</h2>

<p>클래스에는 멤버변수 뿐만 아니라 멤버 함수도 생성할 수 있습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="c1">// 방법1: 함수의 이름과 중괄호를 이용해 설정</span>
  <span class="nf">hello1</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello1</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// 방법2: 멤버변수 이름에 함수를 할당하는 방법</span>
  <span class="nx">hello2</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello2</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nc">A</span><span class="p">().</span><span class="nf">hello1</span><span class="p">();</span>
<span class="k">new</span> <span class="nc">A</span><span class="p">().</span><span class="nf">hello2</span><span class="p">();</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">hello1</span> <span class="nx">A</span> <span class="p">{</span> <span class="nl">hello2</span><span class="p">:</span> <span class="p">[</span><span class="nb">Function</span><span class="p">:</span> <span class="nx">hello2</span><span class="p">]</span> <span class="p">}</span>
<span class="nx">hello2</span> <span class="nx">A</span> <span class="p">{</span> <span class="nl">hello2</span><span class="p">:</span> <span class="p">[</span><span class="nb">Function</span><span class="p">:</span> <span class="nx">hello2</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="출처">출처</h2>

<ul>
  <li>
    <p>패스트캠퍼스<br /><br /></p>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes">MDN web docs</a></p>
  </li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="클래스" /><summary type="html"><![CDATA[클래스(Class)]]></summary></entry><entry><title type="html">[클래스] 정적 메서드와 정적 프로퍼티</title><link href="http://localhost:4000/javascript/js-static-method/" rel="alternate" type="text/html" title="[클래스] 정적 메서드와 정적 프로퍼티" /><published>2022-09-05T00:00:00+09:00</published><updated>2022-09-05T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-static-method</id><content type="html" xml:base="http://localhost:4000/javascript/js-static-method/"><![CDATA[<h2 id="-정적-메서드static-method">📄 정적 메서드(static method)</h2>

<p>정적 메서드는 프로토타입이 아닌 <strong>클래스 함수 자체에 설정되어 있는 메서드</strong>이다.<br />
클래스 안에서 <code class="language-plaintext highlighter-rouge">static</code>이라는 키워드를 사용해서 설정한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nf">staticMethod</span><span class="p">()</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="정적-메서드의-this는-무엇을-가리킬까">정적 메서드의 this는 무엇을 가리킬까?</h3>

<p>클래스의 메서드가 호출될 때<br />
<code class="language-plaintext highlighter-rouge">this</code>의 값은 <strong>클래스 생성자</strong> 그자체가 된다.<br /></p>

<h3 id="정적-메서드는-언제-사용할까">정적 메서드는 언제 사용할까?</h3>

<p>정적 메서드는 어떤 특정한 객체가 아닌 <strong>클래스에 속한 함수를 구현하고자 할 때</strong> 사용한다.<br />
데이터베이스 관련 클래스에도 사용되곤한다.<br /></p>

<h2 id="-정적-프로퍼티static-property">📄 정적 프로퍼티(static property)</h2>

<p>정적 프로퍼티또한 <code class="language-plaintext highlighter-rouge">static</code>이라는 키워드를 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">staticProperty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="정적-프로퍼티는-언제-사용할까">정적 프로퍼티는 언제 사용할까?</h3>

<p>정적 프로퍼티는 데이터를 클래스 수순에 저장하고 싶을 때 사용한다.<br />
정적 프로퍼티 역시 개별 인스턴스에 묶이지 않는다.</p>

<h2 id="정적-프로퍼티와-메서드의-상속">정적 프로퍼티와 메서드의 상속</h2>

<p>정적 프로퍼티와 정적 메서드는 상속이 가능하다.<br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Animal</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="nc">Rabbit</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="p">{}</span>

<span class="c1">// 정적 메서드</span>
<span class="nx">consol</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">Rabbit</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Animal</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// 일반 메서드</span>
<span class="nx">consol</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">Rabbit</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>클래스 <code class="language-plaintext highlighter-rouge">Rabbit</code>의 프로토타입이 클래스 <code class="language-plaintext highlighter-rouge">Animal</code>을 가리키게 한다.<br />
따라서 <code class="language-plaintext highlighter-rouge">Rabbit</code>에서 원하는 프로퍼티나 메서드를 찾지 못하면 <code class="language-plaintext highlighter-rouge">Animal</code>로 검색이 이어진다.</p>

<h2 id="출처">출처</h2>

<p><a href="https://ko.javascript.info/static-properties-methods">모던 자바스크립트 튜토리얼</a></p>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="정적메서드" /><category term="정적프로퍼티" /></entry><entry><title type="html">프로토타입(prototype)</title><link href="http://localhost:4000/javascript/js-prototype/" rel="alternate" type="text/html" title="프로토타입(prototype)" /><published>2022-09-05T00:00:00+09:00</published><updated>2022-09-05T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-prototype</id><content type="html" xml:base="http://localhost:4000/javascript/js-prototype/"><![CDATA[<h2 id="-프로토타입이란">📄 프로토타입이란?</h2>

<p>프로토타입의 한국어 뜻은 <strong>원형</strong>입니다.</p>

<p>프로토타입은 말 그대로 객체의 원형이라고 할 수 있는 것입니다.</p>

<p>Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용합니다.</p>

<ul>
  <li>
    <p>생성자 함수에 기본으로 세팅되는 프로퍼티<code class="language-plaintext highlighter-rouge">(F.prototype)</code>는 <code class="language-plaintext highlighter-rouge">[[Prototype]]</code>과 다릅니다. <code class="language-plaintext highlighter-rouge">F.prototype</code>은 <code class="language-plaintext highlighter-rouge">new F()</code>를 호출할 때 만들어지는 새로운 객체의 <code class="language-plaintext highlighter-rouge">[[Prototype]]</code>을 설정합니다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">F.prototype</code>의 값은 객체나 <code class="language-plaintext highlighter-rouge">null</code>만 가능합니다. 다른 값은 무시됩니다.</li>
  <li>굳이 this라는 자기참조변수를 사용하지 않고 prototype으로 변수 p에 hello라는 함수를 할당했다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="c1">//this.hello = function() {</span>
  <span class="c1">//    console.log('hello', this.name, this.age);</span>
  <span class="c1">//}</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Mark</span><span class="dl">"</span><span class="p">,</span> <span class="mi">37</span><span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nf">hello</span><span class="p">();</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">hello</span> <span class="nx">Mark</span> <span class="mi">37</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Person</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//Person함수 생성</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//Person의 프로토타입으로 hello 함수 생성</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nf">Korean</span><span class="p">(</span><span class="nx">region</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//Korean 함수 생성</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">region</span> <span class="o">=</span> <span class="nx">region</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">where</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">where</span><span class="dl">"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">region</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">Korean</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// 프로토타입을 이용해 부모의 프로퍼티를 자식의 프로퍼티에 할당</span>

<span class="kd">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Korean</span><span class="p">(</span><span class="dl">"</span><span class="s2">Seoul</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// 변수 k에 객체 할당</span>

<span class="nx">k</span><span class="p">.</span><span class="nf">hello</span><span class="p">();</span>
<span class="nx">k</span><span class="p">.</span><span class="nf">where</span><span class="p">();</span>
</code></pre></div></div>

<p>결과</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">hello1</span>
<span class="nx">where</span> <span class="nx">Seoul</span>
</code></pre></div></div>

<h2 id="-프로토타입-장점">📄 프로토타입 장점</h2>

<p>프로토타입의 장점은 <strong>함수의 재사용성을 높인다는 것</strong>입니다.</p>

<p>프로토 타입을 사용해서 함수 밖에서 새로운 함수나 값을 선언한다면,</p>

<p>새로운 함수나 값을 기존 함수에 할당할 필요없이 <code class="language-plaintext highlighter-rouge">prototype</code>이라는 키워드 하나로 바로 사용가능하기 때문에 코드가 훨씬 간결해집니다.</p>

<h2 id="-프로토타입-체인">📄 프로토타입 체인</h2>

<p>프로토타입을 이용해 서로 이어져 있는 집합을 <strong>프로토타입 체인</strong>이라고 합니다.</p>

<p>위의 코드에 다음과 같은 코드를 이어서 작성합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">k</span> <span class="k">instanceof</span> <span class="nx">Korean</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">k</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">k</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">true</span><span class="p">;</span>
<span class="kc">true</span><span class="p">;</span>
<span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Korean</code>이 <code class="language-plaintext highlighter-rouge">Person</code>을 상속하고, <code class="language-plaintext highlighter-rouge">Person</code>이 <code class="language-plaintext highlighter-rouge">Object</code>를 상속하므로 <code class="language-plaintext highlighter-rouge">true</code>값이 나왔다.</li>
</ul>

<h2 id="느낀-점">느낀 점</h2>

<p>자바스크립트 공부하면서 제일 난관에 봉착했다.<br />
뭔가 알듯 말듯 헷갈리는 개념이다.<br />
강의를 끝나면 모던자바스크립트튜토리얼도 보고 책도 보고 할텐데 그 과정에서 익숙해지며 습득될 수 있도록 꼼꼼히 학습해야겠다.<br /><br /></p>

<h2 id="출처">출처</h2>

<ul>
  <li>
    <p>패스트캠퍼스 프론트엔드 강의<br /><br /></p>
  </li>
  <li>
    <p><a href="https://opentutorials.org/course/743/6573">생활코딩</a><br /><br /></p>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes">MDN Web Docs</a></p>
  </li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="프로토타입" /><summary type="html"><![CDATA[프로토타입(prototype)]]></summary></entry><entry><title type="html">원시값의 메서드</title><link href="http://localhost:4000/javascript/js-primitive/" rel="alternate" type="text/html" title="원시값의 메서드" /><published>2022-09-02T00:00:00+09:00</published><updated>2022-09-02T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-primitive</id><content type="html" xml:base="http://localhost:4000/javascript/js-primitive/"><![CDATA[<h2 id="-원시값이란">📄 원시값이란?</h2>

<p>원시값은 객체가 아니면서 메서드도 가지지 않는 데이터를 뜻한다.</p>

<p>자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다.</p>

<p><strong>원시값에서도 객체에서처럼 메서드를 호출할 수 있다</strong>는 뜻이다.</p>

<h2 id="-원시값을-객체처럼-사용하는-과정">📄 원시값을 객체처럼 사용하는 과정</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>

<span class="nf">alert</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">());</span> <span class="c1">// HELLO</span>
</code></pre></div></div>

<ol>
  <li>문자열 <code class="language-plaintext highlighter-rouge">str</code>은 원시값이므로 프로퍼티 <code class="language-plaintext highlighter-rouge">toUpperCase</code>에 접근하는 순간 특별한 객체가 만들어진다.</li>
  <li>메서드가 실행되고, 새로운 문자열이 반환된다.</li>
  <li>특별한 객체는 파괴되고 원시값 <code class="language-plaintext highlighter-rouge">str</code>만 남는다.</li>
</ol>

<h2 id="-왜-이런-내부-프로세스가-생겨난-것일까">📄 왜 이런 내부 프로세스가 생겨난 것일까?</h2>

<p>자바스크립트는 다양한 고유한 프로퍼티와 메서드를 가지는 내장 객체를 제공한다.<br />
하지만, 이런 기능을 사용하면 <strong>시스템 자원이 많이 소모</strong>된다.<br />
객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.<br />
따라서 원시값에 메서드를 호출해 임시객체를 만들고 작업이 완료되면 임시객체를 파괴한다.</p>

<h2 id="-주의할-점">📄 주의할 점</h2>

<p>원시값은 추가 데이터를 저장할 수 없다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let str = "Hello";

str.test = 5;

alert(str.test);
</code></pre></div></div>

<p>엄격모드에서는 래퍼 객체를 수정하려 할 때 에러가 발생하고,<br />
비 엄격 모드에서는 에러가 발생하진 않고 래퍼 객체에 프로퍼티 <code class="language-plaintext highlighter-rouge">test</code>가 추가되지만 래퍼 객체는 바로 삭제되기 때문에 마지막 줄이 실행될 땐 프로퍼티 <code class="language-plaintext highlighter-rouge">test</code>를 찾을 수 없다.</p>

<h2 id="출처">출처</h2>

<ul>
  <li><a href="https://ko.javascript.info/primitives-methods">모던 자바스크립트 튜토리얼</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="원시값" /></entry><entry><title type="html">옵셔널 체이닝</title><link href="http://localhost:4000/javascript/js-optionalchaning/" rel="alternate" type="text/html" title="옵셔널 체이닝" /><published>2022-09-02T00:00:00+09:00</published><updated>2022-09-02T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-optionalchaning</id><content type="html" xml:base="http://localhost:4000/javascript/js-optionalchaning/"><![CDATA[<h2 id="-옵셔널-체이닝">📄 옵셔널 체이닝</h2>

<p>옵셔널 체이닝(optional chaining) <code class="language-plaintext highlighter-rouge">?.</code>을 사용하면 <strong>프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근</strong>할 수 있습니다.<br /><br /></p>

<p><code class="language-plaintext highlighter-rouge">?.</code>은 <code class="language-plaintext highlighter-rouge">?.</code>‘앞’의 평가 대상이 <code class="language-plaintext highlighter-rouge">undefined</code>나 <code class="language-plaintext highlighter-rouge">null</code>이면 평가를 멈추고 <code class="language-plaintext highlighter-rouge">undefined</code>를 반환합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">user?.address</code>로 주소를 읽으면 아래와 같이 <code class="language-plaintext highlighter-rouge">user</code> 객체가 존재하지 않더라도 에러가 발생하지 않습니다.</p>

<h2 id="-주의할-점">📄 주의할 점</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?.</code>는 존재하지 않아도 되는 괜찮은 대상에만 사용해아 합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">?.</code>앞의 변수는 꼭 선언되어 있어야 합니다.</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="옵셔널체이닝" /></entry><entry><title type="html">클로저(Closer)</title><link href="http://localhost:4000/javascript/js-closer/" rel="alternate" type="text/html" title="클로저(Closer)" /><published>2022-08-29T00:00:00+09:00</published><updated>2022-08-29T22:06:00+09:00</updated><id>http://localhost:4000/javascript/js-closer</id><content type="html" xml:base="http://localhost:4000/javascript/js-closer/"><![CDATA[<h2 id="-클로저란">📄 클로저란</h2>

<p>클로저란 <br />
어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상이다.</p>

<h2 id="-클로저의-동작-원리">📄 클로저의 동작 원리</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">++</span><span class="nx">a</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">inner</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">outer2</span> <span class="o">=</span> <span class="nf">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">outer2</span><span class="p">());</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">outer2</span><span class="p">());</span>
</code></pre></div></div>

<결과>

```js
2;
3;
```

`inner`함수의 실행 시점에는 `outer`함수가 이미 종료 되었는데 `outer`함수의 **LexicalEnvitonment**에 접근했다.

바로 가비지 컬렉터의 동작 방식 때문이다.

**가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함하지 않는다.**

외부함수인 `outer`의 실행이 종료 되더라도<br />
내부함수인 `inner`함수는 언젠가 `outer2`를 실행함으로써 호출될 가능성이 열렸기 때문에 <br />
가비지 컬렉터의 수집대상에 포함되지 않는다.

## 클로저와 메모리 관리

클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수의 메모리를 소모하도록 함으로써 발생한다.

하지만 클로저의 필요성이 사라진 시점에는 더이상 메모리를 소모하지 않게 해주어야 한다.

방법은 **참조 카운터를 0으로 만들어 주는 것**이다.

식별자에 참조형이 아닌 기본형 데이터(보통`null` 또는 `undefined`)를 할당해주면 가비지 컬렉터가 값을 수거해 갈 것이다.

```js
var outer = (function () {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner;
})();
console.log(outer());
console.log(outer());
outer = null; // outer 식별자의 inner 함수 참조를 끊음
```

```js
(function () {
  var a = 0;
  var intervalId = null;
  var inner = function () {
    if (++a &gt;= 10) {
      clearInterval(intervalId);
      inner = null; // inner 식별자의 함수 참조를 끊음
    }
    console.log(a);
  };
  intervalId = setInterval(inner, 1000);
})();
```

이렇게 식별자에 기본형 데이터 값을 대입해서 함수 참조를 끊으면 메모리를 효율적으로 관리할 수 있다.

## 출처

- 코어 자바스크립트
</결과>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="클로저" /><summary type="html"><![CDATA[클로저(Closer)]]></summary></entry></feed>