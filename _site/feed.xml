<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-10T17:48:25+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">[프로그래머스 / Lv 2] 위장</title><link href="http://localhost:4000/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 위장" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-04-10T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.</p>

<p>예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.</p>

<p>스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.</li>
  <li>스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.</li>
  <li>같은 이름을 가진 의상은 존재하지 않습니다.</li>
  <li>clothes의 모든 원소는 문자열로 이루어져 있습니다.</li>
  <li>모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.</li>
  <li>스파이는 하루에 최소 한 개의 의상은 입습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">clothes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">clothesMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span> <span class="c1">// 1</span>
  <span class="nx">clothes</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">clothesMap</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nx">clothesMap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="p">});</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">cloth</span><span class="p">,</span> <span class="nx">num</span><span class="p">]</span> <span class="k">of</span> <span class="nx">clothesMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span> <span class="o">*=</span> <span class="nx">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 3</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이번 문제는 해시 개념을 이용한 문제입니다.</p>

<ul>
  <li>각 (옷의 종류가 가진 옷의 개수 +1)를 곱해서 답을 구한다. +1은 해당 옷을 입지 않았을 때의 경우이다.</li>
  <li>스파이는 하루 최소 한개의 의상을 입으므로 모든 옷을 입지 않았을 경우(-1)를 빼준다.</li>
</ul>

<p>예전에 풀었던 [완주하지 못한 선수]를 풀 때 봤던 <code class="language-plaintext highlighter-rouge">map()</code>메소드를 사용해보았습니다.</p>

<ol>
  <li>주어진 의상을 의상별로 정리할 데이터를 담을 Map 객체(<code class="language-plaintext highlighter-rouge">clothesMap</code>)를 생성한다.</li>
  <li><code class="language-plaintext highlighter-rouge">clothes</code>를 순회하며 같은 의상의 이름에 값을 누적하며 더해준다.(+1)</li>
  <li>완성된 <code class="language-plaintext highlighter-rouge">clothesMap</code>에 있는 의상의 개수끼리 곱한다.</li>
  <li>옷을 아예 입지 않은 경우를 제외시키 위해 answer에 <code class="language-plaintext highlighter-rouge">-1</code>을 하고 답을 반환한다.</li>
</ol>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="해시" /><summary type="html"><![CDATA[프로그래머스 Lv 2 위장 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 콜라츠 추측</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 콜라츠 추측" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-04-10T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0%20%EC%B6%94%EC%B8%A1</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/"><![CDATA[<h2 id="-문제-출처">📄 문제 출처</h2>

<p>1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.</p>

<p>예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.</p>

<ul>
  <li>입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">while </span><span class="p">(</span><span class="nx">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">num</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">answer</span> <span class="o">===</span> <span class="mi">500</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>재귀함수를 사용해 볼까 하다가 성능상 반복문이 더 좋을 것 같아 <code class="language-plaintext highlighter-rouge">while</code>문에 조건을 걸어 <code class="language-plaintext highlighter-rouge">num</code>가 1이 될때 까지 반복했습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">collatz</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">?</span> <span class="nx">count</span> <span class="o">&gt;=</span> <span class="mi">500</span>
      <span class="p">?</span> <span class="o">-</span><span class="mi">1</span>
      <span class="p">:</span> <span class="nx">count</span>
    <span class="p">:</span> <span class="nf">collatz</span><span class="p">(</span><span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="nx">count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그래도 재귀함수를 사용한 풀이는 멋있네요.</p>

<p>삼항 연산자를 중첩으로 사용할 수 있다는 것도 처음 알아갑니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="콜라츠 추측" /><summary type="html"><![CDATA[프로그래머스 Lv 1 콜라츠 추측 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 가장 큰 수</title><link href="http://localhost:4000/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 가장 큰 수" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5%20%ED%81%B0%20%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.</p>

<p>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.</p>

<p>0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>numbers의 길이는 1 이상 100,000 이하입니다.</li>
  <li>numbers의 원소는 0 이상 1,000 이하입니다.</li>
  <li>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">numbers</span>
    <span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="dl">""</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span> <span class="p">:</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 배열 <code class="language-plaintext highlighter-rouge">numbers</code>를 순회해 sort()메소드를 적용한다.’</li>
  <li>인접한 두 수를 순서를 바꿔 비교하고 내림차순한다.</li>
  <li>완성된 배열을 join(““)으로 문자열로 바꾼다.</li>
  <li>만약 [0, 0, 0]인경우 답이 “000”이 되므로 삼항연산자를 이용해 첫번째 자릿수가 0인경우 0을 바로 반환한다.</li>
</ol>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="가장 큰 수" /><category term="정렬" /><category term="sort" /><summary type="html"><![CDATA[프로그래머스 Lv 2 가장 큰 수]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 두 정수 사이의 합</title><link href="http://localhost:4000/programmers-lv1/programmers-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4-%ED%95%A9/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 두 정수 사이의 합" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EB%91%90%20%EC%A0%95%EC%88%98%20%EC%82%AC%EC%9D%B4%20%ED%95%A9</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4-%ED%95%A9/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.
예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.</p>

<ul>
  <li>a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.</li>
  <li>a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.</li>
  <li>a와 b의 대소관계는 정해져있지 않습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="p">[</span><span class="nx">newA</span><span class="p">,</span> <span class="nx">newB</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">].</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">newA</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">newB</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 정수를 배열에 담아 정렬후 구조분해 할당을 사용해 새로운 값을 만들었다.</li>
  <li>반복문으로 <code class="language-plaintext highlighter-rouge">newA</code>부터 <code class="language-plaintext highlighter-rouge">newB</code>까지의 합을 구해 답을 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">adder</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">s</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Math 메소드를 적절히 활용한 풀이입니다. 👍</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="sort" /><summary type="html"><![CDATA[프로그래머스 Lv 1 두 정수 사이의 합 문제 풀이]]></summary></entry><entry><title type="html">[알고리즘] 정렬 (sorting)</title><link href="http://localhost:4000/algorithm/algorithm-%EC%A0%95%EB%A0%AC/" rel="alternate" type="text/html" title="[알고리즘] 정렬 (sorting)" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T22:06:00+09:00</updated><id>http://localhost:4000/algorithm/algorithm-%EC%A0%95%EB%A0%AC</id><content type="html" xml:base="http://localhost:4000/algorithm/algorithm-%EC%A0%95%EB%A0%AC/"><![CDATA[<h2 id="-정렬-알고리즘">📄 정렬 알고리즘</h2>

<p>정렬 알고리즘은 물건을 정리하는 것 처럼 데이터를 <strong>정해진 순서대로 나열</strong>하는 알고리즘입니다.</p>

<p>정렬 알고리즘에는 대표적으로 <span style="color: #FAAB78; font-weight: bold">버블 정렬</span>, <span style="color: #FAAB78; font-weight: bold">선택 정렬</span>, <span style="color: #FAAB78; font-weight: bold">삽입 정렬</span>이 있습니다.</p>

<h2 id="-버블-정렬-bubble-sort">📄 버블 정렬 (Bubble Sort)</h2>

<p>버블 정렬은 매 사이클마다 모든 배열 요소를 비교합니다.</p>

<ol>
  <li>0번째 원소와 1번째 원소를 비교 &amp; swap</li>
  <li>1번째 원소와 2번째 원소를 비교 &amp; swap</li>
  <li>n-1번째 원소와 n번째 원소를 비교 &amp; swap</li>
</ol>

<p>버블 정렬은 중첩 반복이 발생하므로 <strong>O(N^2)</strong>의 시간복잡도를 가집니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">bubble</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">if </span><span class="p">(</span><span class="nx">input</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">input</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// swap</span>
        <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
        <span class="nx">input</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="nx">input</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
        <span class="nx">tmp</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이때 최악의 경우 <strong>모든 요소를 swap</strong>해야 하기 때문에 직관적이지만 비효율적인 방식이라 자주 사용되진 않습니다.</p>

<h2 id="-선택-정렬-selection-sort">📄 선택 정렬 (Selection Sort)</h2>

<p>선택 정렬은 원소를 넣을 위치(인덱스)를 미리 정해놓고, 데이터셋을 순회하여 해당 원소를 찾습니다.</p>

<p>쉽게 얘기하자면, 오름차순으로 정리할 때 가장 작은 수를 찾아 맨 앞과 교환한다는 뜻입니다.</p>

<ol>
  <li>주어진 데이터셋에서 최소값을 찾는다.</li>
  <li>해당 값을 맨 앞의 요소와 swap한다.</li>
  <li>두번째 요소부터 위 과정을 반복한다.</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">selectionSort</span> <span class="p">(</span><span class="nx">array</span><span class="p">){</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>
      <span class="nf">if </span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]){</span>
        <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span> <span class="c1">// 1</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">minIndex</span> <span class="o">!==</span> <span class="nx">i</span><span class="p">){</span> <span class="c1">// 2</span>
      <span class="kd">let</span> <span class="nx">swamp</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">];</span>
      <span class="nx">array</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">swamp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">array</span>
<span class="p">}</span>
</code></pre></div></div>

<p>선택 정렬은 정렬이 되어 있는 경우, 되어 있지 않은 경우 모든 <strong>O(N^2)</strong>의 시간 복잡도를 가집니다.</p>

<h2 id="-삽입-정렬">📄 삽입 정렬</h2>

<p>삽입 정렬은 한 사이클동안 모든 요소를 순환하지 않습니다.</p>

<p>사이클마다 해당 요소를 왼쪽에 있는 값들과 비교하고 알맞은 자리에 해당 요소를 삽입합니다.</p>

<ol>
  <li>두번째 요소를 왼쪽 요소와 비교하고 데이터셋을 정렬한다.</li>
  <li>세번째 요소를 첫번째 요소와 두번째 요소와 비교하고 데이터셋을 정렬한다.</li>
  <li>배열의 크기만큼 위 과정을 반복한다.</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="nf">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">array</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">array</span><span class="p">[</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">left</span><span class="p">];</span>
      <span class="nx">left</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">array</span><span class="p">[</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>삽입 정렬의 경우 정렬이 모두 되어 있는 최선의 경우에는 <strong>O(N)</strong>의 시간복잡도를 가지고,<br />
정렬이 되어 있지 않은 최악의 경우에는 <strong>O(N^2)</strong>의 시간 복잡도를 가집니다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=Bor_CRWEIXo">노마드 코더 - 어? 재밌네? 정렬 알고리즘, 한방에 이해하기!</a></li>
  <li><a href="https://im-developer.tistory.com/133">Code Playground</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="Algorithm" /><category term="버블 정렬" /><category term="선택 정렬" /><category term="삽입 정렬" /></entry><entry><title type="html">[프로그래머스 / Lv 1] 하샤드 수</title><link href="http://localhost:4000/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 하샤드 수" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C%20%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>x는 1 이상, 10000 이하인 정수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">x</span><span class="p">.</span><span class="nf">toString</span><span class="p">()].</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">return </span><span class="p">(</span><span class="nx">acc</span> <span class="o">+=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">cur</span><span class="p">));</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">%</span> <span class="nx">sum</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 숫자(x)를 문자열로 변환 후, 각 자릿값을 배열의 요소로 만든다.</li>
  <li>배열의 요소를 reduce메소드를 사용해 더한 누적값을 변수 <code class="language-plaintext highlighter-rouge">sum</code>에 할당한다.</li>
  <li>요구사항대로 주어진 숫자를 누적값으로 나누었을 때 0이 되는지에 대한 boolean값을 반환한다.</li>
</ol>

<p>처음으로 프로그래머스에서 reduce함수를 사용했습니다. <br />
점점 응용하는 메소드가 생길수록 뿌듯합니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Harshad</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="dl">""</span><span class="p">).</span><span class="nf">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">b</span> <span class="o">+</span> <span class="o">+</span><span class="nx">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>반환값을 true/false가 아닌 0과 1을 통해 표현할 수도 있다는 것을 적용한 식입니다. 👍</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="하샤드 수" /><category term="reduce" /><summary type="html"><![CDATA[프로그래머스 Lv 1 하샤드 수 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] k번째수</title><link href="http://localhost:4000/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] k번째수" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.</p>

<p>예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면</p>

<p>array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.
1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.
2에서 나온 배열의 3번째 숫자는 5입니다.
배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>array의 길이는 1 이상 100 이하입니다.</li>
  <li>array의 각 원소는 1 이상 100 이하입니다.</li>
  <li>commands의 길이는 1 이상 50 이하입니다.</li>
  <li>commands의 각 원소는 길이가 3입니다.</li>
</ul>

<h2 id="️-나의-풀이-1">🙋‍♀️ 나의 풀이 #1</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">commands</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">commands</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span>
      <span class="nx">array</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]).</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)[</span>
        <span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">]</span>
    <span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/56298540/230713712-3a7bcde9-3dd8-4bda-9072-05edb083103c.png" alt="image" /></p>

<p>주어진 배열 array를 요구사항대로 자르고 sort() 메소드로 정렬했습니다.</p>

<p>그래도 정렬 알고리즘을 배웠으니 한번 메소드를 사용하지 않고 풀어보겠습니다.</p>

<h3 id="️-나의-풀이-2">🙋‍♀️ 나의 풀이 #2</h3>

<p>삽입 정렬을 사용한 풀이입니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">commands</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">commands</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">slicedArray</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="c1">// 삽입 정렬 시작</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">slicedArray</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="nf">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span><span class="p">];</span>
        <span class="nx">left</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">slicedArray</span><span class="p">[</span><span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/56298540/230713681-e96b3412-0e75-49d2-8f7a-2955653ddc57.png" alt="image" /></p>

<p>속도면에서는 크게 다른 점이 없습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">commands</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">commands</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">command</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">sPosition</span><span class="p">,</span> <span class="nx">ePosition</span><span class="p">,</span> <span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="nx">command</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">array</span>
      <span class="p">.</span><span class="nf">filter</span><span class="p">(</span>
        <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">fIndex</span> <span class="o">&gt;=</span> <span class="nx">sPosition</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">fIndex</span> <span class="o">&lt;=</span> <span class="nx">ePosition</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">)</span>
      <span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">newArray</span><span class="p">[</span><span class="nx">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>주어진 조건 <code class="language-plaintext highlighter-rouge">commands</code>를 구조 분해 할당을 사용해 가독성을 높인 풀이입니다.</p>

<p>slice 메소드가 아니라 filter 메소드를 사용해 배열을 자를 수도 있다는걸 하나 알아갑니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="정렬" /><category term="k번째 수" /><summary type="html"><![CDATA[프로그래머스 Lv 1 k번째수 sort 메소드 대신 정렬 알고리즘으로 풀어보기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 기능 개발 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 기능 개발 by JS" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EA%B8%B0%EB%8A%A5%20%EA%B0%9C%EB%B0%9C</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.</p>

<p>또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</p>

<p>먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</p>

<ul>
  <li>작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.</li>
  <li>작업 진도는 100 미만의 자연수입니다.</li>
  <li>작업 속도는 100 이하의 자연수입니다.</li>
  <li>배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">progresses</span><span class="p">,</span> <span class="nx">speeds</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">hundreds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">while </span><span class="p">(</span><span class="nx">progresses</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">progresses</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">progresses</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">speeds</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span> <span class="c1">// 2</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">progresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">while </span><span class="p">(</span><span class="nx">progresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">progresses</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
        <span class="nx">speeds</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
        <span class="nx">hundreds</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="c1">// 3</span>
      <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">hundreds</span><span class="p">);</span> <span class="c1">// 4</span>
      <span class="nx">hundreds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>시간 복잡도: O(n^2)</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">progresses</code>의 길이가 0이 될 때까지 반복문을 실행합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">progresses</code>에 인덱스를 맞춰 <code class="language-plaintext highlighter-rouge">speeds</code>를 더해줍니다.</li>
  <li>만약 <code class="language-plaintext highlighter-rouge">progresses</code>의 첫번째 인덱스의 값이 100보다 큰 경우 <code class="language-plaintext highlighter-rouge">shift</code>메소드를 사용해 각 각 배열들의 첫번째 원소를 추출하고, 추출된 횟수를 나타내는 변수 <code class="language-plaintext highlighter-rouge">hundreds</code>에 1을 더합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">progresses</code>의 첫번째 인덱스가 100보다 크지 않아 반복문을 나오면, 작업이 완료된 기능의 개수인 <code class="language-plaintext highlighter-rouge">hundreds</code>를 <code class="language-plaintext highlighter-rouge">answer</code>에 추가합니다.</li>
</ol>

<p>문제를 풀 때 중첩 반복문이 나오면 답은 나와도 성능상 좋지 않게 느껴져 아쉽습니다.<br /></p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">progresses</span><span class="p">,</span> <span class="nx">speeds</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">days</span> <span class="o">=</span> <span class="nx">progresses</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">progress</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="nx">progress</span><span class="p">)</span> <span class="o">/</span> <span class="nx">speeds</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
  <span class="p">);</span>
  <span class="kd">let</span> <span class="nx">maxDay</span> <span class="o">=</span> <span class="nx">days</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">days</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">days</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">maxDay</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">answer</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">maxDay</span> <span class="o">=</span> <span class="nx">days</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">answer</span><span class="p">[</span><span class="o">++</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>각 기능들이 배포에 걸리는 시간을 배열로 만들어(<code class="language-plaintext highlighter-rouge">days</code>) 조건에 따라 <code class="language-plaintext highlighter-rouge">maxDay</code>를 바꿔가며 <code class="language-plaintext highlighter-rouge">days</code>를 순환합니다.</p>

<p>아예 접근방식이 달라버리네요. 이럴수가 있다니..<br />
속도나 성능을 떠나서 풀이 방식이 신기합니다.<br />
처음에 눈으로 보고 이해가 안가서 종이에 하나하나 조건을 줘가면서 이해했습니다. 세상엔 똑똑한 사람이 많네요.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="스택/큐" /><category term="while" /><summary type="html"><![CDATA[프로그래머스 Lv 2 기능 개발 문제 풀이]]></summary></entry><entry><title type="html">Math 메소드 정리</title><link href="http://localhost:4000/javascript/javascript-Math-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="Math 메소드 정리" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T22:06:00+09:00</updated><id>http://localhost:4000/javascript/javascript-Math%20%EB%A9%94%EC%86%8C%EB%93%9C%20%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/javascript/javascript-Math-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/"><![CDATA[<h2 id="-mathabsnumber">📄 Math.abs(number)</h2>

<p>▪ 용도: 인수의 <strong>절댓값</strong>을 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span> <span class="c1">// 0</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">([]);</span> <span class="c1">// 0</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// 0</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h2 id="-mathroundnumber">📄 Math.round(number)</h2>

<p>▪ 용도: 소수점 이하를 <strong>반올림</strong>한 정수를 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mf">1.2</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="o">-</span><span class="mf">1.6</span><span class="p">);</span> <span class="c1">// -2</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">round</span><span class="p">();</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h2 id="-mathceilnumber">📄 Math.ceil(number)</h2>

<p>▪ 용도: 소수점 이하를 <strong>올림</strong>한 정수를 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="mf">1.4</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">();</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h2 id="-mathfloornumber">📄 Math.floor(number)</h2>

<p>▪ 용도: 소수점 이하를 <strong>내림</strong>한 정수를 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="mf">1.4</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="o">-</span><span class="mf">1.8</span><span class="p">);</span> <span class="c1">// -2</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">();</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h2 id="-mathsqrtnumber">📄 Math.sqrt(number)</h2>

<p>▪ 용도: 인수의 <strong>제곱근</strong>을 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> <span class="c1">// 3</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">);</span> <span class="c1">// NaN</span>
<span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">();</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h2 id="-mathrandom">📄 Math.random()</h2>

<p>▪ 용도: <strong>0에서 1미만의 랜덤 숫자</strong>를 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">random</span><span class="p">();</span> <span class="c1">// 0.xxxxxxxx</span>
</code></pre></div></div>

<h2 id="-mathpownumber-number">📄 Math.pow(number, number)</h2>

<p>▪ 용도: 첫번째 인수를 밑, 두번째 인수를 지수로한 <strong>거듭제곱근</strong>을 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// 256</span>

<span class="c1">// ES7 거듭 제곱 연산자</span>
<span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 256</span>
</code></pre></div></div>

<h2 id="-mathmaxnumbers">📄 Math.max(numbers)</h2>

<p>▪ 용도: 인수 중 <strong>최댓값</strong>을 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 3</span>
</code></pre></div></div>

<h2 id="-mathminnumbers">📄 Math.min(numbers)</h2>

<p>▪ 용도: 인수 중 <strong>최솟값</strong>을 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div>]]></content><author><name>Sujin Kim</name></author><category term="JavaScript" /><category term="Math" /></entry><entry><title type="html">[알고리즘] 시간 복잡도와 빅오(Big O) 계산법</title><link href="http://localhost:4000/algorithm/algorithm-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/" rel="alternate" type="text/html" title="[알고리즘] 시간 복잡도와 빅오(Big O) 계산법" /><published>2023-04-07T00:00:00+09:00</published><updated>2023-04-07T22:06:00+09:00</updated><id>http://localhost:4000/algorithm/algorithm-%EC%8B%9C%EA%B0%84%20%EB%B3%B5%EC%9E%A1%EB%8F%84</id><content type="html" xml:base="http://localhost:4000/algorithm/algorithm-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/"><![CDATA[<h2 id="-시간-복잡도">📄 시간 복잡도</h2>

<p>프로그래머스 문제를 푸는데 이제 점점 성능을 고려해야할 필요성이 생겼습니다.<br />
효율성 테스트를 넘어가야 하기 때문이죠. 🥶<br />
똑같은 답일지라도 빨리 답이 나오는 코드가 더 좋은 성능을 가진 코드인데 이를 구별할 수 있게 하는 것이 시간 복잡도입니다.</p>

<p>시간 복잡도는</p>

<p><strong>입력 값에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마나 걸리는 지 알려주는 지표</strong>입니다.</p>

<p>이 시간 복잡도를 나타내주는 방법 중 하나가 <span style="color: #6096B4; font-weight: bold;">빅오(Big O) 표기법</span>입니다.</p>

<h2 id="-빅오big-o-표기법의-종류">📄 빅오(Big O) 표기법의 종류</h2>

<p><img src="https://user-images.githubusercontent.com/56298540/230600786-4f4d7814-6fb9-4f3a-bf53-822590f98846.png" alt="image" /></p>

<h3 id="-o1--constant-complexity">▪ O(1) | Constant Complexity</h3>

<p>O(1)는 <span style="color: #FAAB78">입력값에 상관없이 정해진 스텝의 계산을 실행</span>합니다.</p>

<p>콘솔을 한번만 찍는 함수는 아무리 큰 입력값이 오더라도 계산에 영향을 끼치지 않습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">constantComplexity</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>

<span class="nf">constantComplexity</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
</code></pre></div></div>

<ul>
  <li>스택의 push, pop</li>
</ul>

<h3 id="-on--linear-complexity">▪ O(n) | linear complexity</h3>

<p>O(n)는 <span style="color: #FAAB78">입력값이 증가함에 따라 시간이 같은 비율로 증가</span>합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">linearComplexity</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++&gt;</span><span class="p">){</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>for 문</li>
</ul>

<h3 id="-on--quadratic-complexity">▪ O(n²) | Quadratic Complexity</h3>

<p>O(n)는 <span style="color: #FAAB78">입력값이 증가함에 따라 시간이 n²으로 증가</span>합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">quadraticComplexity</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>이중 for문</li>
  <li>삽입정렬(insertion sort)</li>
  <li>선택정렬(selection sort)</li>
  <li>거품정렬(bubble sort)</li>
</ul>

<h3 id="-olog-n--logarithmic-complexity">▪ O(log N) | Logarithmic Complexity</h3>

<p>O(n)는 <span style="color: #FAAB78">입력값에 따라 처리 시간이 증가</span>합니다.</p>

<p>O(n)은 입력 값이 1이 될 때까지 절반으로 나누는 작업을 반복합니다.<br />
따라서 입력값에 따라 처리 시간이 증가하지만, 비례해서 증가하는 것이 아니므로 O(1)다음으로 빠른 계산법입니다.</p>

<ul>
  <li>이진 트리 탐색</li>
  <li>퀵 정렬(quick sort)</li>
  <li>병합정렬(merge sort)</li>
  <li>힙 정렬(heap Sort)</li>
</ul>

<h2 id="출처">출처</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=BEVnxbxBqi8">노마드 코더 - 개발자라면 이제는 알아야하는 Big O 설명해드림. 10분컷.</a></li>
  <li><a href="https://velog.io/@shitaikoto/Algorithm-Time-complexity">shitai.koto - [Algorithm] 시간 복잡도(Time complexity) 학습</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="Algorithm" /><category term="시간 복잡도" /><category term="빅오 계산법" /></entry></feed>