<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-29T12:56:31+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">[Next.js] Next.js의 페이지 사전렌더링</title><link href="http://localhost:4000/nextjs/nextjs-next.js%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%A0%84%EB%A0%8C%EB%8D%94%EB%A7%81/" rel="alternate" type="text/html" title="[Next.js] Next.js의 페이지 사전렌더링" /><published>2023-05-29T00:00:00+09:00</published><updated>2023-05-29T22:06:00+09:00</updated><id>http://localhost:4000/nextjs/nextjs-next.js%EC%9D%98%20%ED%8E%98%EC%9D%B4%EC%A7%80%20%EC%82%AC%EC%A0%84%EB%A0%8C%EB%8D%94%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/nextjs/nextjs-next.js%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%82%AC%EC%A0%84%EB%A0%8C%EB%8D%94%EB%A7%81/"><![CDATA[<h2 id="-nextjs가-페이지를-준비하고-사전-렌더링을-하는-방법">📄 Next.js가 페이지를 준비하고 사전 렌더링을 하는 방법</h2>

<blockquote>
  <p>💡 Hydration이란? HTML을 미리 렌더링하고, 그 뒤에 요청이 오면 chunk단위로 js를 보내주어 이벤트가 작동하는 것</p>
</blockquote>

<p>Next.js의 사전렌더링은 기존 리액트의 CRA와 다르게 완성된 HTML을 브라우저에 보내주는 방법이다.</p>

<p>사전 렌더링은 첫번째 페이지에만 적용되며, 첫번째 페이지 렌더링이 끝아면 다시 SPA로 돌아간다.</p>

<p>이렇게 미리 완성된 HTML 페이지를 가져오면 두가지 이점이 생긴다.</p>

<ol>
  <li>사용자는 데이터가 실질적으로 로딩될때까지 기다리지 않아도 된다. =&gt; <strong>사용자 경험 최적화</strong></li>
  <li>구글 검색엔진이 실질적 데이터가 들어있는 HTML코드를 읽고 해석한다. =&gt; <strong>SEO 최적화</strong></li>
</ol>

<p>Next.js 가 사전렌더링을 구현하는 방법은 <strong>SSG, SSR</strong>이 있다.</p>

<p>⭐ 중요한 사실은 Next.js는 어떤 작업을 하지 않아도 기본적으로 사전렌더링을 한다는 점이다. SSG, SSR은 사전렌더링을 하는 방식을 정하기 위한 요소라는 점을 이해해야한다.</p>

<h3 id="-ssgserver-side-generation-static-site-generation">🔴 SSG(Server-Side-Generation, Static-Site-Generation)</h3>

<ul>
  <li>사용 방법: 페이지에 <code class="language-plaintext highlighter-rouge">getStaticProps</code>함수를 추가한다.</li>
  <li>사용 목적
    <ol>
      <li>페이지가 사전 생성되어야 하는 것을 Next.js에게 알려준다.</li>
      <li>만약 Next.js가 사전렌더링을 하지 않도록 설정되었을 때, getStaticProps함수로 특정 페이지를 사전렌더링 하도록 지정할 수 있다.</li>
    </ol>
  </li>
  <li>페이지 생성 시기: 프로젝트 빌드시</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">HomePage</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">products</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">products</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">product</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">product</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">product</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nf">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="c1">// 항상 객체를 반환한다.</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">products</span><span class="p">:</span> <span class="p">[{</span> <span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">p1</span><span class="dl">"</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Product 1</span><span class="dl">"</span> <span class="p">}],</span>
    <span class="p">},</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HomePage</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getStaticProp</code>가 포함된 페이지 파일이 실행되면 발생하는 순서를 다음과 같다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">getStaticProps</code>함수를 먼저 호출한다. 함수안에 컴포넌트에서 사용될 데이터를 페칭해오는 작업을 한다.</li>
  <li>컴포넌트 함수를 실행한다.</li>
</ol>

<h2 id="참고">참고</h2>

<ul>
  <li>
    <p><a href="https://www.udemy.com/course/nextjs-react-incl-two-paths">유데미 Nextjs.&amp;React - 완전 정복 가이드</a></p>
  </li>
  <li>
    <p><a href="https://nextjs.org/docs">Next.js 공식 문서</a></p>
  </li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="Nextjs" /><category term="SSG" /><category term="SSR" /><summary type="html"><![CDATA[Next.js가 페이지를 사전 렌더링하고 데이터를 페칭하는 방법]]></summary></entry><entry><title type="html">[Next.js] Next.js란?</title><link href="http://localhost:4000/nextjs/nextjs-Nextjs%EB%9E%80/" rel="alternate" type="text/html" title="[Next.js] Next.js란?" /><published>2023-05-17T00:00:00+09:00</published><updated>2023-05-17T22:06:00+09:00</updated><id>http://localhost:4000/nextjs/nextjs-Nextjs%EB%9E%80</id><content type="html" xml:base="http://localhost:4000/nextjs/nextjs-Nextjs%EB%9E%80/"><![CDATA[<h2 id="-nextjs는-무엇일까">📄 Next.js는 무엇일까?</h2>

<ul>
  <li>리액트 프레임 워크</li>
  <li>리액트JS의 풀스택 프레임 워크</li>
</ul>

<p>🎲 리액트를 더 잘 사용하기 위해 만들어진 리액트 프레임워크</p>

<h2 id="-주요-기능">📄 주요 기능</h2>

<ul>
  <li>서버 사이드 렌더링 (사전 렌더링)
    <ul>
      <li>풀스택 프레임워크라 불리는 이유</li>
      <li>리액트 페이지, 컴포넌트를 서버 측에서 미리 렌더링</li>
      <li>SEO에 유리 + 로딩 경험 유리 -&gt; 서버로부터 받은 모든 정보가 html에 포함되어 있기 때문</li>
    </ul>
  </li>
  <li>파일 기반 라우팅
    <ul>
      <li>기존 리액트는 라우터가 아예 없음. 리액트 라우터 사용했음.</li>
      <li>페이지 폴더의 이름으로 url을 결정한다.</li>
    </ul>
  </li>
  <li>⭐ 풀스택 쌉가능
    <ul>
      <li>백엔드 API를 리액트 프로젝트에 추가할 수 있다.</li>
      <li>독립적인 REST API 프로젝트를 구축하지 않아도 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="참고">참고</h2>

<ul>
  <li>
    <p><a href="https://www.udemy.com/course/nextjs-react-incl-two-paths">유데미 Nextjs.&amp;React - 완전 정복 가이드</a></p>
  </li>
  <li>
    <p><a href="https://nextjs.org/docs">Next.js 공식 문서</a></p>
  </li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="Nextjs" /><category term="Next.js" /><summary type="html"><![CDATA[Next.js 이해하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 삼총사 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 삼총사 by JS" /><published>2023-05-09T00:00:00+09:00</published><updated>2023-05-05T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%82%BC%EC%B4%9D%EC%82%AC</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%82%BC%EC%B4%9D%EC%82%AC/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.</p>

<p>한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요.</p>

<ul>
  <li>3 ≤ number의 길이 ≤ 13</li>
  <li>-1,000 ≤ number의 각 원소 ≤ 1,000</li>
  <li>서로 다른 학생의 정수 번호가 같을 수 있습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">number</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">number</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">number</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">if </span><span class="p">(</span><span class="nx">number</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">number</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="nx">number</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>자바스크립트를 공부하면서 삼중 for문은 처음 사용해보았습니다.</p>

<p>이중 for문도 불안한데 삼중으로 중첩되니 달달 떨리네요.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="for문" /><summary type="html"><![CDATA[삼중 for문으로 가능한 조합의 수 구하기]]></summary></entry><entry><title type="html">[React-Query 02] 리액트 쿼리로 페이지네이션 작업하기</title><link href="http://localhost:4000/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BF%BC%EB%A6%AC%EB%A1%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[React-Query 02] 리액트 쿼리로 페이지네이션 작업하기" /><published>2023-05-08T00:00:00+09:00</published><updated>2023-05-08T22:06:00+09:00</updated><id>http://localhost:4000/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EC%BF%BC%EB%A6%AC%EB%A1%9C%20%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98%20%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BF%BC%EB%A6%AC%EB%A1%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-페이지네이션-작업에-리액트-쿼리가-하는-일">📄 페이지네이션 작업에 리액트 쿼리가 하는 일</h2>

<p>페이지네이션 작업에서 다음 페이지 버튼을 눌렀을 경우에 리액트는 새로운 데이터를 불러오기 위해 api를 호출합니다.</p>

<p>이때 사용자는 데이터를 불러오는 시간만큼 기다려야 하기 때문에 사용자 경험이 안좋아지는 결과를 초래합니다.</p>

<p>리액트 쿼리를 사용해 호출 가능성이 있는 데이터를 미리 불러오는 작업, 즉 <strong>프리페칭(Prefetching)</strong>을 사용해 미리 다음 페이지의 데이터를 불러온다면 사용자는 페이지에 나타날 정보를 위해 기다릴 필요성이 사라지게 됩니다.</p>

<blockquote>
  <p>📌 프리페칭(Prefetching)이란?
호출 가능성이 있는 데이터를 미리 불러오는 작업. 데이터를 미리 불러와 캐시에 데이터를 저장한다.</p>
</blockquote>

<h2 id="-리액트-쿼리로-페이지네이션-구현하기">📄 리액트 쿼리로 페이지네이션 구현하기</h2>

<h3 id="1-쿼리-설정하기">1. 쿼리 설정하기</h3>

<p>페이지네이션을 위해 쿼리를 설정합니다.</p>

<p>페이지 별 게시글을 불러오는 함수를 쿼리함수로 설정했는데 이때 쿼리키를 동일하게 한다면 모든 페이지가 같은 정보를 표시하게 됩니다.</p>

<p>쿼리키를 동일하게 했을 경우 어떤 트리거가 있어야만 데이터를 리페칭할 수 있는데 다음 페이지 버튼을 클릭한다고 트리거가 발생하지 않습니다.</p>

<p>트리거가 발생하는 기준은 다음과 같습니다.</p>

<ol>
  <li>컴포넌트 리마운트</li>
  <li>윈도우 리포커징</li>
  <li>리페칭함수 실행</li>
  <li>자동 리페칭</li>
  <li>mutation 이후 쿼리 무효화</li>
</ol>

<p>이전/다음 버튼을 클릭했을 때 트리거가 발생하도록 <strong>쿼리키를 배열로</strong>작성했습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">isError</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">isLoading</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">useQuery</span><span class="p">(</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">posts</span><span class="dl">"</span><span class="p">,</span> <span class="nx">currentPage</span><span class="p">],</span> <span class="c1">// 🎉</span>
  <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">fetchPosts</span><span class="p">(</span><span class="nx">currentPage</span><span class="p">),</span>
  <span class="p">{</span>
    <span class="na">staleTime</span><span class="p">:</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="na">keepPreviousData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="nf">if </span><span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/h3&gt;</span><span class="err">;
</span><span class="nf">if </span><span class="p">(</span><span class="nx">isError</span><span class="p">)</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Oops</span><span class="p">,</span> <span class="nx">something</span> <span class="nx">went</span> <span class="nx">wrong</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">error</span><span class="p">.</span><span class="nf">toString</span><span class="p">()}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>📌 keepPreviousData: 새 데이터가 요청되는 동안 마지막으로 성공한 fetch Data로 유지해 사용자 경험을 향상시킬 수 있다.</p>
</blockquote>

<h3 id="2-프리페칭-함수-설정하기">2. 프리페칭 함수 설정하기</h3>

<p>현재 페이지가 변경될 때마다 프리페칭 함수를 실행시키기 위해 <strong>useEffect</strong>함수를 사용합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">currentPage</span> <span class="o">&lt;</span> <span class="nx">maxPostPage</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nextPage</span> <span class="o">=</span> <span class="nx">currentPage</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">queryClient</span><span class="p">.</span><span class="nf">prefetchQuery</span><span class="p">([</span><span class="dl">"</span><span class="s2">posts</span><span class="dl">"</span><span class="p">,</span> <span class="nx">nextPage</span><span class="p">],</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">fetchPosts</span><span class="p">(</span><span class="nx">nextPage</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">currentPage</span><span class="p">,</span> <span class="nx">queryClient</span><span class="p">]);</span>
</code></pre></div></div>

<p>최대 페이지 (<code class="language-plaintext highlighter-rouge">maxPostPage</code>)에서는 실행되지 않도록 if 조건문을 사용했습니다.</p>

<p>쿼리를 설정했을 때와 마찬가지로 쿼리키를 배열로 설정합니다.</p>

<h3 id="3-return-함수-작성하기">3. return 함수 작성하기</h3>

<p>각 버튼의 <code class="language-plaintext highlighter-rouge">disabled</code> 속성을 이용해 페이지가 1일 경우, 최대 페이지일 경우에 버튼이 비활성화 되도록 설정합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">pages</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">button</span>
    <span class="nx">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">currentPage</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">}</span>
    <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">setCurrentPage</span><span class="p">((</span><span class="nx">previosValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">previosValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}}</span>
  <span class="o">&gt;</span>
    <span class="nx">Previous</span> <span class="nx">page</span>
  <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">Page</span> <span class="p">{</span><span class="nx">currentPage</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">button</span>
    <span class="nx">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">currentPage</span> <span class="o">&gt;=</span> <span class="nx">maxPostPage</span><span class="p">}</span>
    <span class="c1">// onClick함수에 프리페칭 작업을 하지 않는 이유: setState함수는 비동기로 실행되기 때문에 현재 페이지가 무엇인지 정확히 알 방법이 없다.</span>
    <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">setCurrentPage</span><span class="p">((</span><span class="nx">previousValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">previousValue</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}}</span>
  <span class="o">&gt;</span>
    <span class="nx">Next</span> <span class="nx">page</span>
  <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p>프리페칭 함수를 onClick함수에 바로 작성하지 않은 이유가 있습니다.</p>

<p>setState함수는 비동기로 실행되기 때문에 프리페칭이 진행될 시점에는 현재 페이지가 무엇인지 정확히 알 방법이 없기 때문입니다.</p>

<p>따라서 useEffect의 의존성 배열에 조건을 걸어 프리페칭이 실행되도록 하는 것이 적합합니다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://www.udemy.com/course/react-query-react/">udemy - React Query: React로 서버 상태 관리하기</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="React" /><category term="prefetching" /><category term="keepPreviousData" /><summary type="html"><![CDATA[다음 페이지 데이터 프리페칭하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 시저 암호 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 시저 암호 by JS" /><published>2023-05-05T00:00:00+09:00</published><updated>2023-05-05T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80%20%EC%95%94%ED%98%B8</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.</p>

<ul>
  <li>공백은 아무리 밀어도 공백입니다.</li>
  <li>s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.</li>
  <li>s의 길이는 8000이하입니다.</li>
  <li>n은 1 이상, 25이하인 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">MINCODE</span> <span class="o">=</span> <span class="mi">97</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">MAXCODE</span> <span class="o">=</span> <span class="mi">122</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="kd">let</span> <span class="nx">store</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">store</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()[</span><span class="nx">i</span><span class="p">].</span><span class="nf">charCodeAt</span><span class="p">()</span> <span class="o">+</span> <span class="nx">n</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">store</span> <span class="o">&gt;</span> <span class="mi">122</span><span class="p">)</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">store</span> <span class="o">-</span> <span class="nx">MAXCODE</span> <span class="o">+</span> <span class="nx">MINCODE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">store</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="nx">store</span><span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">toUpperCase</span><span class="p">())</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">store</span><span class="p">);</span>
    <span class="nx">store</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>문자열의 아스키 코드를 구하고 n만큼 더한다.</li>
  <li>만약 더한 값이 122보다 크다면 더한 값 - 122 + 97 - 1 을 해준다.</li>
  <li>해당 문자열이 대문자인지 확인 후 값을 변환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">upper</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">lower</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">abcdefghijklmnopqrstuvwxyz</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">answer</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">text</span> <span class="o">==</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">answer</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">textArr</span> <span class="o">=</span> <span class="nx">upper</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">?</span> <span class="nx">upper</span> <span class="p">:</span> <span class="nx">lower</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">textArr</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">textArr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="nx">index</span> <span class="o">-=</span> <span class="nx">textArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">answer</span> <span class="o">+=</span> <span class="nx">textArr</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아스키코드가 아닌 배열로 작성한 풀이입니다.</p>

<ol>
  <li>우선, 주어진 문자열을 순환할때 해당 문자열이 소문자인지 대문자인지 확인합니다. (<code class="language-plaintext highlighter-rouge">textArr</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">textArr</code>에 해당 문자열의 인덱스를 구한 후 n만큼 더합니다.</li>
  <li>만약 <code class="language-plaintext highlighter-rouge">textArr</code>의 길이보다 길어질 경우 그만큼 값을 빼서 정확한 위치를 구합니다.</li>
</ol>

<p>아스키코드를 사용한 풀이보다 오히려 가독성이 좋은 것 같습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="아스키 코드" /><category term="배열" /></entry><entry><title type="html">[React-Query 01] 쿼리 생성 및 로딩/에러 상태 관리하기</title><link href="http://localhost:4000/react/react-reactquery/" rel="alternate" type="text/html" title="[React-Query 01] 쿼리 생성 및 로딩/에러 상태 관리하기" /><published>2023-05-05T00:00:00+09:00</published><updated>2023-05-05T22:06:00+09:00</updated><id>http://localhost:4000/react/react-reactquery</id><content type="html" xml:base="http://localhost:4000/react/react-reactquery/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/56298540/236417752-b3d3dad8-8f8d-472b-b553-9254d4ff4ddc.png" alt="image" /></p>

<h2 id="-리액트-쿼리-공부를-시작한-이유">📄 리액트 쿼리 공부를 시작한 이유</h2>

<p>프로젝트를 진행할 때, 상태관리를 위해 redux를 사용하는데 서버 데이터를 위한 로직이 과도하게 커져 상태를 관리하기가 어려웠습니다.</p>

<p>Redux-thunk를 사용하긴 했지만 이또한 store가 비대해져 한번에 관리하는게 맞는지 의문이 들었습니다.</p>

<p>그래서 리액트 쿼리를 이용해 서버에서 오는 데이터는 따로 관리해보고자 공부를 시작하게 되었습니다.</p>

<h2 id="-리액트-쿼리란">📄 리액트 쿼리란?</h2>

<ul>
  <li>
    <p>역할: <strong>서버의 상태를 관리</strong>하는 리액트 라이브러리</p>
  </li>
  <li>
    <p>특징</p>
    <ul>
      <li>서버에서 오는 데이터 전송 결과에 따라 비동기 처리 로직이 가능하다.</li>
      <li>서버의 데이터에 변경이 생기면 클라이언트가 다시 데이터를 가져오지 않아도 알아서 업데이트 된다.</li>
      <li>데이터를 캐시해서 전달할 수 있다.</li>
      <li>데이터에 만료시간을 정할 수 있다. -&gt; 만료되지 않은 데이터는 refetching해도 변경이 적용되지 않을 수 있게 설정할 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="-리액트-쿼리-개발자-도구-사용하기">📄 리액트 쿼리 개발자 도구 사용하기</h2>

<ul>
  <li>방법: <code class="language-plaintext highlighter-rouge">QueryClientProvider</code>태그 안에 <code class="language-plaintext highlighter-rouge">ReactQueryDevtools</code>를 작성한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="c1">// provide React Query client to App</span>
    <span class="o">&lt;</span><span class="nx">QueryClientProvider</span> <span class="nx">client</span><span class="o">=</span><span class="p">{</span><span class="nx">qeuryClient</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Blog</span> <span class="nx">Posts</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">Posts</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">ReactQueryDevtools</span> <span class="o">/&gt;</span> <span class="c1">// 🎉</span>
    <span class="o">&lt;</span><span class="sr">/QueryClientProvider</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ReactQueryDevtools</code>를 추가하면 해당 태그가 있는 페이지의 위치에 리액트 쿼리 개발자 도구가 생성됩니다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/236421070-48da8913-b162-4769-8bae-7ea6a2b7e876.png" alt="image" /></p>

<p>개발자 도구를 통해 데이터가 서버로부터 로딩중인지, 만료된 데이터인지 등등 다양한 정보를 제공받고, Actions 탭에서는 데이터관련 작업을 실행할 수 있습니다.</p>

<h2 id="-리액트-쿼리-시작하기">📄 리액트 쿼리 시작하기</h2>

<p>리액트 쿼리를 사용하기 위해서는 여느 상태관리 라이브러리처럼 최상단 컴포넌트인 App.jsx에서 Provider 컴포넌트를 설정해야 합니다.</p>

<ul>
  <li>QueryClient: 캐싱기능과 기본 옵션을 자녀 컴포넌트에서도 사용할 수 있게 해준다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">qeuryClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryClient</span><span class="p">();</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="c1">// provide React Query client to App</span>
    <span class="o">&lt;</span><span class="nx">QueryClientProvider</span> <span class="nx">client</span><span class="o">=</span><span class="p">{</span><span class="nx">qeuryClient</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Blog</span> <span class="nx">Posts</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">Posts</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">ReactQueryDevtools</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/QueryClientProvider</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="-stale-time">📄 stale Time?</h2>

<ul>
  <li>뜻: 리액트 쿼리가 가져오는 데이터의 만료 시간 (기본 값: 0)</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>🎲 key point</td>
      <td>데이터는 만료되었을 때만 리페칭이 가능하다.</td>
    </tr>
  </tbody>
</table>

<p>리액트 쿼리는 만료 시간을 기본 값으로 0을 설정해 클라이언트가 만료된 데이터를 제공받을 가능성을 낮추어 줍니다.</p>

<p>만약 데이터의 만료시간을 5초로 설정했을 경우, 처음 데이터를 fetching 한 후 5초안에 데이터를 refetching했을 때 만료시간이 다 되지 않았으므로 데이터는 update되지 않습니다.</p>

<h2 id="-로딩-상태와-에러상태-처리하기">📄 로딩 상태와 에러상태 처리하기</h2>

<p>리액트 쿼리로 서버의 데이터를 가져오기 위해 <code class="language-plaintext highlighter-rouge">useQeury</code>라는 키워드를 사용합니다.</p>

<ul>
  <li>인자 1: 쿼리 키 (<code class="language-plaintext highlighter-rouge">post</code>): 서버에서 가져오는 데이터에 이름을 부여</li>
  <li>인자 2: 쿼리 함수 (<code class="language-plaintext highlighter-rouge">fetchPosts</code>): 서버에서 데이터를 가져오는 로직을 작성 (비동기)</li>
  <li>인자 3: 옵션 (<code class="language-plaintext highlighter-rouge">{ staleTime: 2000}</code>): 만료시간을 2초로 설정</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">isError</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">isLoading</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">useQuery</span><span class="p">(</span><span class="dl">"</span><span class="s2">posts</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetchPosts</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">staleTime</span><span class="p">:</span> <span class="mi">2000</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<h3>▪ 로딩 상태 처리하기</h3>

<p>useQuery로 가져온 쿼리 데이터 posts를 구조분해해서 나온 isLoading을 활용하여 로딩이 되는 중이라면, <code class="language-plaintext highlighter-rouge">Loading...</code>을 화면에 보여줍니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/h3&gt;</span><span class="err">;
</span></code></pre></div></div>

<h4>📌 isLoading과 isFetching의 차이점</h4>

<ul>
  <li>isFetching: 비동기 쿼리 함수가 해결되지 않았을 때 (데이터를 가져오는 중일 때)</li>
  <li>isLoading: 비동기 쿼리 함수가 해결되지 않았을 때 (데이터를 가져오는 중일 때) + 쿼리에 대해 캐시된 데이터가 없을 때 (isFetching의 하위 집합)</li>
</ul>

<h3>▪ 에러 상태 처리하기</h3>

<p>리액트 쿼리는 데이터를 가져올 때 fetching이 성공될 때까지 <strong>세번의 로딩 시도</strong>후 안되면 에러라고 판단합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="nx">isError</span><span class="p">)</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Oops</span><span class="p">,</span> <span class="nx">something</span> <span class="nx">went</span> <span class="nx">wrong</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">error</span><span class="p">.</span><span class="nf">toString</span><span class="p">()}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
</code></pre></div></div>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://www.udemy.com/course/react-query-react/">udemy - React Query: React로 서버 상태 관리하기</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="React" /><category term="react-query" /><summary type="html"><![CDATA[유데미 리액트 쿼리 인강 듣고 정리한 기록]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 예산 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%98%88%EC%82%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 예산 by JS" /><published>2023-05-04T00:00:00+09:00</published><updated>2023-05-04T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%98%88%EC%82%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%98%88%EC%82%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.</p>

<p>물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.</p>

<p>부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.</li>
  <li>d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.</li>
  <li>budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">budget</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">d</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">budget</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">budget</span> <span class="o">-</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="nx">budget</span> <span class="o">=</span> <span class="nx">budget</span> <span class="o">-</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>배열을 오름차순으로 정리한다.</li>
  <li>budget이 0이 될 때까지 배열 d의 값을 하나씩 뺀다.</li>
  <li>예산을 뺀 값이 마이너스가 되면 for문을 종료한다.</li>
  <li>부서가 한개인 경우 조건(<code class="language-plaintext highlighter-rouge">budget - d[i] &lt; 0</code>)을 걸어 for문을 종료한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">budget</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">d</span>
    <span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">count</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">count</span> <span class="o">+</span> <span class="p">((</span><span class="nx">budget</span> <span class="o">-=</span> <span class="nx">price</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>sort와 reduce 메소드를 연달아 사용한 풀이입니다.</p>

<p><code class="language-plaintext highlighter-rouge">((budget -= price) &gt;= 0)</code>결과에 따라 0 또는 1이 되네요.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="" /></entry><entry><title type="html">[프로그래머스 / Lv 1] 이상한 문자 만들기 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 이상한 문자 만들기 by JS" /><published>2023-04-30T00:00:00+09:00</published><updated>2023-04-30T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C%20%EB%AC%B8%EC%9E%90%20%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.</p>

<ul>
  <li>문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.</li>
  <li>첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newS</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nf">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[...</span><span class="nx">value</span><span class="p">]</span>
      <span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">char</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nf">return </span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">char</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span> <span class="p">:</span> <span class="nx">char</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">newS</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>단어 <code class="language-plaintext highlighter-rouge">s</code>를 공백을 기준으로 잘라 배열을 생성한다.(<code class="language-plaintext highlighter-rouge">newS</code>)</li>
  <li>주어진 조건에 맞게 단어를 배열로 만든 후 각 글자를 대문자 또는 소문자로 변환하고 다시 문자열로 만든다.</li>
</ol>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="toUpperCase()" /><category term="toLowerCase()" /><summary type="html"><![CDATA[문자열 홀짝 기준으로 대문자/소문자 만들기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 3진법 뒤집기 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 3진법 뒤집기 by JS" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95%20%EB%92%A4%EC%A7%91%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>n은 1 이상 100,000,000 이하인 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">parseInt</span><span class="p">([...</span><span class="nx">n</span><span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">3</span><span class="p">)].</span><span class="nf">reverse</span><span class="p">().</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>toString에 들어가는 인자는 적용한 숫자를 n진법으로 나타낼 때 사용합니다.</p>

<p>n.toString(3)은 숫자 n을 3진법으로 변환한다는 뜻입니다.</p>

<p>3진법으로 변환한 숫자 n을 spread연산자로 배열에 담아 뒤집은뒤 다시 문자열로 변환했습니다.</p>

<p>parseInt의 두번째 인자에는 해당 값이 몇진법인지 나타내는 숫자를 입력합니다.</p>

<p><code class="language-plaintext highlighter-rouge">parseInt([...n.toString(3)].reverse().join(""), 3)</code>는 앞뒤 반전한 3진법을 다시 10진법으로 변환해주는 역할을 합니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="toString" /><category term="parseInt" /><summary type="html"><![CDATA[toString()으로 n진법 나타내기]]></summary></entry><entry><title type="html">[모여봐요 코딩의 늪] 모코숲 뜯어고치기 시작</title><link href="http://localhost:4000/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2-%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0-%EC%8B%9C%EC%9E%91/" rel="alternate" type="text/html" title="[모여봐요 코딩의 늪] 모코숲 뜯어고치기 시작" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T22:06:00+09:00</updated><id>http://localhost:4000/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2%20%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0%20%EC%8B%9C%EC%9E%91</id><content type="html" xml:base="http://localhost:4000/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2-%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0-%EC%8B%9C%EC%9E%91/"><![CDATA[<h2 id="-나는-왜-이-프로젝트를-처음부터-뜯어고치는-재공사를-시작하는가">📄 나는 왜 이 프로젝트를 처음부터 뜯어고치는 재공사를 시작하는가</h2>

<p>모코숲은 나의 애증의 프로젝트..</p>

<p>백엔드를 담당하시는 분과 todolist이후 처음으로 진행하는 프로젝트이다.</p>

<p>처음으로 여러가지 기능을 만들다보니 제대로 꼬여버렸다.</p>

<p>신나서 막 짓고 쌓다보니 새로운 기능을 추가하기도 참 어렵게 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/235301875-9cc90398-e28a-4f67-b5c8-ac450e3f989e.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/56298540/235301888-c1f717a4-06e2-4c6f-98d3-08774df69fe5.png" alt="image" /></p>

<p>굉장히 많은 오류들이 있었다.</p>

<p>cors 에러 + 레이아웃 우장창 + 알 수 없는 렌더링 등등…</p>

<p>할 건 많은데 다른 일까지 겹쳐서 다시 손대기가 굉장히 두려운 프로젝트다.</p>

<p>일단 프로젝트를 다시 시작해야하는 이유는 다음과 같다</p>

<h3 id="1-꼬여버린-레이아웃">1. 꼬여버린 레이아웃</h3>

<p>사실 레이아웃 같은걸 투두리스트말고 만들어봤어야지 아무것도 모르는 상태에서 제대로 된 틀을 설정하지 않고 시작해 페이지를 받쳐주는 틀이 엉망이 되었다. 사실 그래서 모 인강사이트에서 개발자도구를 켜서 참고하면서 했는데 하다보니 내 코드가 아니게 되어 스타일이 이상해졌을 때 어떻게 손대야 할지 감이 안잡혔다.</p>

<h3 id="2-사용자-접근성-고려">2. 사용자 접근성 고려</h3>

<p>현재 진행되어 있는 프로젝트는 로그인/회원가입이 안되어 있으면 메인페이지에 접근하지 못한다. URL로 접근하더라도 라우터가 튕겨보낸다.</p>

<p>백엔드 개발자 분에게 웹 성격 특성상 서비스를 먼저 둘러보는 것이 사용자 접근에 더 좋을 것이라는 피드백을 들었다. 맨 처음 접속한 페이지를 로그인페이지가 아니라 메인 페이지로 변경하고 public/private 라우터도 싹다 바꿔줄 예정이다.</p>

<h3 id="3-꼬여버린-전역-상태-관리">3. 꼬여버린 전역 상태 관리</h3>

<p>전역 상태 관리가 제대로 꼬였다. 각 state의 성격대로 잘 구분한줄 알았는데 그렇지 않더랬다…
서버에서 받아온 하나의 데이터를 여러 slice에서 관리하게 되고 이걸 고치자니 아예 로직이 엉켜버렸다.</p>

<h3 id="4-디자인이-마음에-아주-안든다">4. 디자인이 마음에 아주 안든다</h3>

<p>왜 디자인을 이렇게 한건지 모르겠다. 처음 만들때 simple is the best 인것을… 욕심이 과했는지 아니면 너무 많이 봐서 그러는지 모르겠고 프로젝트한테 미안하지만 살짝 어디 내놓기 창피하다.</p>

<h3 id="5-전혀-재사용되고-있지-않는-컴포넌트들">5. 전혀 재사용되고 있지 않는 컴포넌트들</h3>

<p>컴포넌트를 재사용하지 않으면 리액트를 왜 사용할까…🥶 props나 state다루는 것이 익숙하지 않으니 컴포넌트를 재사용하는 것이 거의 없다. 지금은 이걸 좀 공부하기 위해 다른 사람이 만든 프로젝트(예. sendbird)를 열어보며 어렵지만 감을 잡아가고 있는 중이다. 이것을 토대로 프로젝트 설계를 다시 할 예정이다.</p>

<h2 id="️-결론">🏃‍♀️ 결론!</h2>

<p>조급하지 말자.</p>

<p>할게 쌓여 있으면 불안한 내 성격이 프로젝트를 망쳤다.</p>

<p>하나의 기능을 만들더라도 차분하게 설계하고 시작하자.</p>

<h2 id="-목표">🍀 목표</h2>

<ol>
  <li>피그마로 스타일 설계 진행하기</li>
  <li>디자인은 심플하게. 난 디자인 전공이 아니다. 슬프다.</li>
  <li>버그를 미루지 말자. 미루면 눈덩이처럼 증가해서 굉장히 힘들다.</li>
  <li>구글링하고 남의 코드를 참고하되 된다고 끝내지말고 공부해서 내것으로 만들어 나중에 오류가 발생해도 당황하지 말자.</li>
  <li>힘내자…</li>
</ol>]]></content><author><name>Sujin Kim</name></author><category term="coding-swamp" /><category term="모코늪" /><category term="재시작" /><summary type="html"><![CDATA[애증의 프로젝트 모코숲 다시 뜯어고치기 시작]]></summary></entry></feed>