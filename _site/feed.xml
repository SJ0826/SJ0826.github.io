<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-08T19:44:40+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">[React-Query 02] 리액트 쿼리로 페이지네이션 작업하기</title><link href="http://localhost:4000/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BF%BC%EB%A6%AC%EB%A1%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[React-Query 02] 리액트 쿼리로 페이지네이션 작업하기" /><published>2023-05-08T00:00:00+09:00</published><updated>2023-05-08T22:06:00+09:00</updated><id>http://localhost:4000/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EC%BF%BC%EB%A6%AC%EB%A1%9C%20%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98%20%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/react-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BF%BC%EB%A6%AC%EB%A1%9C-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-페이지네이션-작업에-리액트-쿼리가-하는-일">📄 페이지네이션 작업에 리액트 쿼리가 하는 일</h2>

<p>페이지네이션 작업에서 다음 페이지 버튼을 눌렀을 경우에 리액트는 새로운 데이터를 불러오기 위해 api를 호출합니다.</p>

<p>이때 사용자는 데이터를 불러오는 시간만큼 기다려야 하기 때문에 사용자 경험이 안좋아지는 결과를 초래합니다.</p>

<p>리액트 쿼리를 사용해 호출 가능성이 있는 데이터를 미리 불러오는 작업, 즉 <strong>프리페칭(Prefetching)</strong>을 사용해 미리 다음 페이지의 데이터를 불러온다면 사용자는 페이지에 나타날 정보를 위해 기다릴 필요성이 사라지게 됩니다.</p>

<blockquote>
  <p>📌 프리페칭(Prefetching)이란?
호출 가능성이 있는 데이터를 미리 불러오는 작업. 데이터를 미리 불러와 캐시에 데이터를 저장한다.</p>
</blockquote>

<h2 id="-리액트-쿼리로-페이지네이션-구현하기">📄 리액트 쿼리로 페이지네이션 구현하기</h2>

<h3 id="1-쿼리-설정하기">1. 쿼리 설정하기</h3>

<p>페이지네이션을 위해 쿼리를 설정합니다.</p>

<p>페이지 별 게시글을 불러오는 함수를 쿼리함수로 설정했는데 이때 쿼리키를 동일하게 한다면 모든 페이지가 같은 정보를 표시하게 됩니다.</p>

<p>쿼리키를 동일하게 했을 경우 어떤 트리거가 있어야만 데이터를 리페칭할 수 있는데 다음 페이지 버튼을 클릭한다고 트리거가 발생하지 않습니다.</p>

<p>트리거가 발생하는 기준은 다음과 같습니다.</p>

<ol>
  <li>컴포넌트 리마운트</li>
  <li>윈도우 리포커징</li>
  <li>리페칭함수 실행</li>
  <li>자동 리페칭</li>
  <li>mutation 이후 쿼리 무효화</li>
</ol>

<p>이전/다음 버튼을 클릭했을 때 트리거가 발생하도록 <strong>쿼리키를 배열로</strong>작성했습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">isError</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">isLoading</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">useQuery</span><span class="p">(</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">posts</span><span class="dl">"</span><span class="p">,</span> <span class="nx">currentPage</span><span class="p">],</span> <span class="c1">// 🎉</span>
  <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">fetchPosts</span><span class="p">(</span><span class="nx">currentPage</span><span class="p">),</span>
  <span class="p">{</span>
    <span class="na">staleTime</span><span class="p">:</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="na">keepPreviousData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="nf">if </span><span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/h3&gt;</span><span class="err">;
</span><span class="nf">if </span><span class="p">(</span><span class="nx">isError</span><span class="p">)</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Oops</span><span class="p">,</span> <span class="nx">something</span> <span class="nx">went</span> <span class="nx">wrong</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">error</span><span class="p">.</span><span class="nf">toString</span><span class="p">()}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>📌 keepPreviousData: 새 데이터가 요청되는 동안 마지막으로 성공한 fetch Data로 유지해 사용자 경험을 향상시킬 수 있다.</p>
</blockquote>

<h3 id="2-프리페칭-함수-설정하기">2. 프리페칭 함수 설정하기</h3>

<p>현재 페이지가 변경될 때마다 프리페칭 함수를 실행시키기 위해 <strong>useEffect</strong>함수를 사용합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">currentPage</span> <span class="o">&lt;</span> <span class="nx">maxPostPage</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nextPage</span> <span class="o">=</span> <span class="nx">currentPage</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">queryClient</span><span class="p">.</span><span class="nf">prefetchQuery</span><span class="p">([</span><span class="dl">"</span><span class="s2">posts</span><span class="dl">"</span><span class="p">,</span> <span class="nx">nextPage</span><span class="p">],</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">fetchPosts</span><span class="p">(</span><span class="nx">nextPage</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">currentPage</span><span class="p">,</span> <span class="nx">queryClient</span><span class="p">]);</span>
</code></pre></div></div>

<p>최대 페이지 (<code class="language-plaintext highlighter-rouge">maxPostPage</code>)에서는 실행되지 않도록 if 조건문을 사용했습니다.</p>

<p>쿼리를 설정했을 때와 마찬가지로 쿼리키를 배열로 설정합니다.</p>

<h3 id="3-return-함수-작성하기">3. return 함수 작성하기</h3>

<p>각 버튼의 <code class="language-plaintext highlighter-rouge">disabled</code> 속성을 이용해 페이지가 1일 경우, 최대 페이지일 경우에 버튼이 비활성화 되도록 설정합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">pages</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">button</span>
    <span class="nx">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">currentPage</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">}</span>
    <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">setCurrentPage</span><span class="p">((</span><span class="nx">previosValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">previosValue</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}}</span>
  <span class="o">&gt;</span>
    <span class="nx">Previous</span> <span class="nx">page</span>
  <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">Page</span> <span class="p">{</span><span class="nx">currentPage</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">button</span>
    <span class="nx">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">currentPage</span> <span class="o">&gt;=</span> <span class="nx">maxPostPage</span><span class="p">}</span>
    <span class="c1">// onClick함수에 프리페칭 작업을 하지 않는 이유: setState함수는 비동기로 실행되기 때문에 현재 페이지가 무엇인지 정확히 알 방법이 없다.</span>
    <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">setCurrentPage</span><span class="p">((</span><span class="nx">previousValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">previousValue</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}}</span>
  <span class="o">&gt;</span>
    <span class="nx">Next</span> <span class="nx">page</span>
  <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p>프리페칭 함수를 onClick함수에 바로 작성하지 않은 이유가 있습니다.</p>

<p>setState함수는 비동기로 실행되기 때문에 프리페칭이 진행될 시점에는 현재 페이지가 무엇인지 정확히 알 방법이 없기 때문입니다.</p>

<p>따라서 useEffect의 의존성 배열에 조건을 걸어 프리페칭이 실행되도록 하는 것이 적합합니다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://www.udemy.com/course/react-query-react/">udemy - React Query: React로 서버 상태 관리하기</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="React" /><category term="prefetching" /><category term="keepPreviousData" /><summary type="html"><![CDATA[다음 페이지 데이터 프리페칭하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 시저 암호 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 시저 암호 by JS" /><published>2023-05-05T00:00:00+09:00</published><updated>2023-05-05T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80%20%EC%95%94%ED%98%B8</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.</p>

<ul>
  <li>공백은 아무리 밀어도 공백입니다.</li>
  <li>s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.</li>
  <li>s의 길이는 8000이하입니다.</li>
  <li>n은 1 이상, 25이하인 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">MINCODE</span> <span class="o">=</span> <span class="mi">97</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">MAXCODE</span> <span class="o">=</span> <span class="mi">122</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="kd">let</span> <span class="nx">store</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">store</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()[</span><span class="nx">i</span><span class="p">].</span><span class="nf">charCodeAt</span><span class="p">()</span> <span class="o">+</span> <span class="nx">n</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">store</span> <span class="o">&gt;</span> <span class="mi">122</span><span class="p">)</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">store</span> <span class="o">-</span> <span class="nx">MAXCODE</span> <span class="o">+</span> <span class="nx">MINCODE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">store</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="nx">store</span><span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">toUpperCase</span><span class="p">())</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">store</span><span class="p">);</span>
    <span class="nx">store</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>문자열의 아스키 코드를 구하고 n만큼 더한다.</li>
  <li>만약 더한 값이 122보다 크다면 더한 값 - 122 + 97 - 1 을 해준다.</li>
  <li>해당 문자열이 대문자인지 확인 후 값을 변환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">upper</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">lower</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">abcdefghijklmnopqrstuvwxyz</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">answer</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">text</span> <span class="o">==</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">answer</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">textArr</span> <span class="o">=</span> <span class="nx">upper</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">?</span> <span class="nx">upper</span> <span class="p">:</span> <span class="nx">lower</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">textArr</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">textArr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="nx">index</span> <span class="o">-=</span> <span class="nx">textArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">answer</span> <span class="o">+=</span> <span class="nx">textArr</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아스키코드가 아닌 배열로 작성한 풀이입니다.</p>

<ol>
  <li>우선, 주어진 문자열을 순환할때 해당 문자열이 소문자인지 대문자인지 확인합니다. (<code class="language-plaintext highlighter-rouge">textArr</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">textArr</code>에 해당 문자열의 인덱스를 구한 후 n만큼 더합니다.</li>
  <li>만약 <code class="language-plaintext highlighter-rouge">textArr</code>의 길이보다 길어질 경우 그만큼 값을 빼서 정확한 위치를 구합니다.</li>
</ol>

<p>아스키코드를 사용한 풀이보다 오히려 가독성이 좋은 것 같습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="아스키 코드" /><category term="배열" /></entry><entry><title type="html">[React-Query 01] 쿼리 생성 및 로딩/에러 상태 관리하기</title><link href="http://localhost:4000/react/react-reactquery/" rel="alternate" type="text/html" title="[React-Query 01] 쿼리 생성 및 로딩/에러 상태 관리하기" /><published>2023-05-05T00:00:00+09:00</published><updated>2023-05-05T22:06:00+09:00</updated><id>http://localhost:4000/react/react-reactquery</id><content type="html" xml:base="http://localhost:4000/react/react-reactquery/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/56298540/236417752-b3d3dad8-8f8d-472b-b553-9254d4ff4ddc.png" alt="image" /></p>

<h2 id="-리액트-쿼리-공부를-시작한-이유">📄 리액트 쿼리 공부를 시작한 이유</h2>

<p>프로젝트를 진행할 때, 상태관리를 위해 redux를 사용하는데 서버 데이터를 위한 로직이 과도하게 커져 상태를 관리하기가 어려웠습니다.</p>

<p>Redux-thunk를 사용하긴 했지만 이또한 store가 비대해져 한번에 관리하는게 맞는지 의문이 들었습니다.</p>

<p>그래서 리액트 쿼리를 이용해 서버에서 오는 데이터는 따로 관리해보고자 공부를 시작하게 되었습니다.</p>

<h2 id="-리액트-쿼리란">📄 리액트 쿼리란?</h2>

<ul>
  <li>
    <p>역할: <strong>서버의 상태를 관리</strong>하는 리액트 라이브러리</p>
  </li>
  <li>
    <p>특징</p>
    <ul>
      <li>서버에서 오는 데이터 전송 결과에 따라 비동기 처리 로직이 가능하다.</li>
      <li>서버의 데이터에 변경이 생기면 클라이언트가 다시 데이터를 가져오지 않아도 알아서 업데이트 된다.</li>
      <li>데이터를 캐시해서 전달할 수 있다.</li>
      <li>데이터에 만료시간을 정할 수 있다. -&gt; 만료되지 않은 데이터는 refetching해도 변경이 적용되지 않을 수 있게 설정할 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="-리액트-쿼리-개발자-도구-사용하기">📄 리액트 쿼리 개발자 도구 사용하기</h2>

<ul>
  <li>방법: <code class="language-plaintext highlighter-rouge">QueryClientProvider</code>태그 안에 <code class="language-plaintext highlighter-rouge">ReactQueryDevtools</code>를 작성한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="c1">// provide React Query client to App</span>
    <span class="o">&lt;</span><span class="nx">QueryClientProvider</span> <span class="nx">client</span><span class="o">=</span><span class="p">{</span><span class="nx">qeuryClient</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Blog</span> <span class="nx">Posts</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">Posts</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">ReactQueryDevtools</span> <span class="o">/&gt;</span> <span class="c1">// 🎉</span>
    <span class="o">&lt;</span><span class="sr">/QueryClientProvider</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ReactQueryDevtools</code>를 추가하면 해당 태그가 있는 페이지의 위치에 리액트 쿼리 개발자 도구가 생성됩니다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/236421070-48da8913-b162-4769-8bae-7ea6a2b7e876.png" alt="image" /></p>

<p>개발자 도구를 통해 데이터가 서버로부터 로딩중인지, 만료된 데이터인지 등등 다양한 정보를 제공받고, Actions 탭에서는 데이터관련 작업을 실행할 수 있습니다.</p>

<h2 id="-리액트-쿼리-시작하기">📄 리액트 쿼리 시작하기</h2>

<p>리액트 쿼리를 사용하기 위해서는 여느 상태관리 라이브러리처럼 최상단 컴포넌트인 App.jsx에서 Provider 컴포넌트를 설정해야 합니다.</p>

<ul>
  <li>QueryClient: 캐싱기능과 기본 옵션을 자녀 컴포넌트에서도 사용할 수 있게 해준다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">qeuryClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QueryClient</span><span class="p">();</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="c1">// provide React Query client to App</span>
    <span class="o">&lt;</span><span class="nx">QueryClientProvider</span> <span class="nx">client</span><span class="o">=</span><span class="p">{</span><span class="nx">qeuryClient</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Blog</span> <span class="nx">Posts</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">Posts</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">ReactQueryDevtools</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/QueryClientProvider</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="-stale-time">📄 stale Time?</h2>

<ul>
  <li>뜻: 리액트 쿼리가 가져오는 데이터의 만료 시간 (기본 값: 0)</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>🎲 key point</td>
      <td>데이터는 만료되었을 때만 리페칭이 가능하다.</td>
    </tr>
  </tbody>
</table>

<p>리액트 쿼리는 만료 시간을 기본 값으로 0을 설정해 클라이언트가 만료된 데이터를 제공받을 가능성을 낮추어 줍니다.</p>

<p>만약 데이터의 만료시간을 5초로 설정했을 경우, 처음 데이터를 fetching 한 후 5초안에 데이터를 refetching했을 때 만료시간이 다 되지 않았으므로 데이터는 update되지 않습니다.</p>

<h2 id="-로딩-상태와-에러상태-처리하기">📄 로딩 상태와 에러상태 처리하기</h2>

<p>리액트 쿼리로 서버의 데이터를 가져오기 위해 <code class="language-plaintext highlighter-rouge">useQeury</code>라는 키워드를 사용합니다.</p>

<ul>
  <li>인자 1: 쿼리 키 (<code class="language-plaintext highlighter-rouge">post</code>): 서버에서 가져오는 데이터에 이름을 부여</li>
  <li>인자 2: 쿼리 함수 (<code class="language-plaintext highlighter-rouge">fetchPosts</code>): 서버에서 데이터를 가져오는 로직을 작성 (비동기)</li>
  <li>인자 3: 옵션 (<code class="language-plaintext highlighter-rouge">{ staleTime: 2000}</code>): 만료시간을 2초로 설정</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">isError</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">isLoading</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">useQuery</span><span class="p">(</span><span class="dl">"</span><span class="s2">posts</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetchPosts</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">staleTime</span><span class="p">:</span> <span class="mi">2000</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<h3>▪ 로딩 상태 처리하기</h3>

<p>useQuery로 가져온 쿼리 데이터 posts를 구조분해해서 나온 isLoading을 활용하여 로딩이 되는 중이라면, <code class="language-plaintext highlighter-rouge">Loading...</code>을 화면에 보여줍니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/h3&gt;</span><span class="err">;
</span></code></pre></div></div>

<h4>📌 isLoading과 isFetching의 차이점</h4>

<ul>
  <li>isFetching: 비동기 쿼리 함수가 해결되지 않았을 때 (데이터를 가져오는 중일 때)</li>
  <li>isLoading: 비동기 쿼리 함수가 해결되지 않았을 때 (데이터를 가져오는 중일 때) + 쿼리에 대해 캐시된 데이터가 없을 때 (isFetching의 하위 집합)</li>
</ul>

<h3>▪ 에러 상태 처리하기</h3>

<p>리액트 쿼리는 데이터를 가져올 때 fetching이 성공될 때까지 <strong>세번의 로딩 시도</strong>후 안되면 에러라고 판단합니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if </span><span class="p">(</span><span class="nx">isError</span><span class="p">)</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">Oops</span><span class="p">,</span> <span class="nx">something</span> <span class="nx">went</span> <span class="nx">wrong</span><span class="o">&lt;</span><span class="sr">/h3</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">error</span><span class="p">.</span><span class="nf">toString</span><span class="p">()}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
</code></pre></div></div>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://www.udemy.com/course/react-query-react/">udemy - React Query: React로 서버 상태 관리하기</a></li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="React" /><category term="react-query" /><summary type="html"><![CDATA[유데미 리액트 쿼리 인강 듣고 정리한 기록]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 예산 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%98%88%EC%82%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 예산 by JS" /><published>2023-05-04T00:00:00+09:00</published><updated>2023-05-04T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%98%88%EC%82%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%98%88%EC%82%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.</p>

<p>물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.</p>

<p>부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.</li>
  <li>d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.</li>
  <li>budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">budget</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">d</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">budget</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">budget</span> <span class="o">-</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="nx">budget</span> <span class="o">=</span> <span class="nx">budget</span> <span class="o">-</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>배열을 오름차순으로 정리한다.</li>
  <li>budget이 0이 될 때까지 배열 d의 값을 하나씩 뺀다.</li>
  <li>예산을 뺀 값이 마이너스가 되면 for문을 종료한다.</li>
  <li>부서가 한개인 경우 조건(<code class="language-plaintext highlighter-rouge">budget - d[i] &lt; 0</code>)을 걸어 for문을 종료한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">budget</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">d</span>
    <span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">count</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">count</span> <span class="o">+</span> <span class="p">((</span><span class="nx">budget</span> <span class="o">-=</span> <span class="nx">price</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>sort와 reduce 메소드를 연달아 사용한 풀이입니다.</p>

<p><code class="language-plaintext highlighter-rouge">((budget -= price) &gt;= 0)</code>결과에 따라 0 또는 1이 되네요.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="" /></entry><entry><title type="html">[프로그래머스 / Lv 1] 이상한 문자 만들기 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 이상한 문자 만들기 by JS" /><published>2023-04-30T00:00:00+09:00</published><updated>2023-04-30T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C%20%EB%AC%B8%EC%9E%90%20%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.</p>

<ul>
  <li>문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.</li>
  <li>첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newS</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nf">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[...</span><span class="nx">value</span><span class="p">]</span>
      <span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">char</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nf">return </span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">char</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span> <span class="p">:</span> <span class="nx">char</span><span class="p">.</span><span class="nf">toUpperCase</span><span class="p">();</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">newS</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>단어 <code class="language-plaintext highlighter-rouge">s</code>를 공백을 기준으로 잘라 배열을 생성한다.(<code class="language-plaintext highlighter-rouge">newS</code>)</li>
  <li>주어진 조건에 맞게 단어를 배열로 만든 후 각 글자를 대문자 또는 소문자로 변환하고 다시 문자열로 만든다.</li>
</ol>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="toUpperCase()" /><category term="toLowerCase()" /><summary type="html"><![CDATA[문자열 홀짝 기준으로 대문자/소문자 만들기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 3진법 뒤집기 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 3진법 뒤집기 by JS" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95%20%EB%92%A4%EC%A7%91%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>n은 1 이상 100,000,000 이하인 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">parseInt</span><span class="p">([...</span><span class="nx">n</span><span class="p">.</span><span class="nf">toString</span><span class="p">(</span><span class="mi">3</span><span class="p">)].</span><span class="nf">reverse</span><span class="p">().</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>toString에 들어가는 인자는 적용한 숫자를 n진법으로 나타낼 때 사용합니다.</p>

<p>n.toString(3)은 숫자 n을 3진법으로 변환한다는 뜻입니다.</p>

<p>3진법으로 변환한 숫자 n을 spread연산자로 배열에 담아 뒤집은뒤 다시 문자열로 변환했습니다.</p>

<p>parseInt의 두번째 인자에는 해당 값이 몇진법인지 나타내는 숫자를 입력합니다.</p>

<p><code class="language-plaintext highlighter-rouge">parseInt([...n.toString(3)].reverse().join(""), 3)</code>는 앞뒤 반전한 3진법을 다시 10진법으로 변환해주는 역할을 합니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="toString" /><category term="parseInt" /><summary type="html"><![CDATA[toString()으로 n진법 나타내기]]></summary></entry><entry><title type="html">[모여봐요 코딩의 늪] 모코숲 뜯어고치기 시작</title><link href="http://localhost:4000/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2-%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0-%EC%8B%9C%EC%9E%91/" rel="alternate" type="text/html" title="[모여봐요 코딩의 늪] 모코숲 뜯어고치기 시작" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T22:06:00+09:00</updated><id>http://localhost:4000/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2%20%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0%20%EC%8B%9C%EC%9E%91</id><content type="html" xml:base="http://localhost:4000/coding-swamp/%EB%AA%A8%EC%BD%94%EC%88%B2-%EB%9C%AF%EC%96%B4%EA%B3%A0%EC%B9%98%EA%B8%B0-%EC%8B%9C%EC%9E%91/"><![CDATA[<h2 id="-나는-왜-이-프로젝트를-처음부터-뜯어고치는-재공사를-시작하는가">📄 나는 왜 이 프로젝트를 처음부터 뜯어고치는 재공사를 시작하는가</h2>

<p>모코숲은 나의 애증의 프로젝트..</p>

<p>백엔드를 담당하시는 분과 todolist이후 처음으로 진행하는 프로젝트이다.</p>

<p>처음으로 여러가지 기능을 만들다보니 제대로 꼬여버렸다.</p>

<p>신나서 막 짓고 쌓다보니 새로운 기능을 추가하기도 참 어렵게 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/235301875-9cc90398-e28a-4f67-b5c8-ac450e3f989e.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/56298540/235301888-c1f717a4-06e2-4c6f-98d3-08774df69fe5.png" alt="image" /></p>

<p>굉장히 많은 오류들이 있었다.</p>

<p>cors 에러 + 레이아웃 우장창 + 알 수 없는 렌더링 등등…</p>

<p>할 건 많은데 다른 일까지 겹쳐서 다시 손대기가 굉장히 두려운 프로젝트다.</p>

<p>일단 프로젝트를 다시 시작해야하는 이유는 다음과 같다</p>

<h3 id="1-꼬여버린-레이아웃">1. 꼬여버린 레이아웃</h3>

<p>사실 레이아웃 같은걸 투두리스트말고 만들어봤어야지 아무것도 모르는 상태에서 제대로 된 틀을 설정하지 않고 시작해 페이지를 받쳐주는 틀이 엉망이 되었다. 사실 그래서 모 인강사이트에서 개발자도구를 켜서 참고하면서 했는데 하다보니 내 코드가 아니게 되어 스타일이 이상해졌을 때 어떻게 손대야 할지 감이 안잡혔다.</p>

<h3 id="2-사용자-접근성-고려">2. 사용자 접근성 고려</h3>

<p>현재 진행되어 있는 프로젝트는 로그인/회원가입이 안되어 있으면 메인페이지에 접근하지 못한다. URL로 접근하더라도 라우터가 튕겨보낸다.</p>

<p>백엔드 개발자 분에게 웹 성격 특성상 서비스를 먼저 둘러보는 것이 사용자 접근에 더 좋을 것이라는 피드백을 들었다. 맨 처음 접속한 페이지를 로그인페이지가 아니라 메인 페이지로 변경하고 public/private 라우터도 싹다 바꿔줄 예정이다.</p>

<h3 id="3-꼬여버린-전역-상태-관리">3. 꼬여버린 전역 상태 관리</h3>

<p>전역 상태 관리가 제대로 꼬였다. 각 state의 성격대로 잘 구분한줄 알았는데 그렇지 않더랬다…
서버에서 받아온 하나의 데이터를 여러 slice에서 관리하게 되고 이걸 고치자니 아예 로직이 엉켜버렸다.</p>

<h3 id="4-디자인이-마음에-아주-안든다">4. 디자인이 마음에 아주 안든다</h3>

<p>왜 디자인을 이렇게 한건지 모르겠다. 처음 만들때 simple is the best 인것을… 욕심이 과했는지 아니면 너무 많이 봐서 그러는지 모르겠고 프로젝트한테 미안하지만 살짝 어디 내놓기 창피하다.</p>

<h3 id="5-전혀-재사용되고-있지-않는-컴포넌트들">5. 전혀 재사용되고 있지 않는 컴포넌트들</h3>

<p>컴포넌트를 재사용하지 않으면 리액트를 왜 사용할까…🥶 props나 state다루는 것이 익숙하지 않으니 컴포넌트를 재사용하는 것이 거의 없다. 지금은 이걸 좀 공부하기 위해 다른 사람이 만든 프로젝트(예. sendbird)를 열어보며 어렵지만 감을 잡아가고 있는 중이다. 이것을 토대로 프로젝트 설계를 다시 할 예정이다.</p>

<h2 id="️-결론">🏃‍♀️ 결론!</h2>

<p>조급하지 말자.</p>

<p>할게 쌓여 있으면 불안한 내 성격이 프로젝트를 망쳤다.</p>

<p>하나의 기능을 만들더라도 차분하게 설계하고 시작하자.</p>

<h2 id="-목표">🍀 목표</h2>

<ol>
  <li>피그마로 스타일 설계 진행하기</li>
  <li>디자인은 심플하게. 난 디자인 전공이 아니다. 슬프다.</li>
  <li>버그를 미루지 말자. 미루면 눈덩이처럼 증가해서 굉장히 힘들다.</li>
  <li>구글링하고 남의 코드를 참고하되 된다고 끝내지말고 공부해서 내것으로 만들어 나중에 오류가 발생해도 당황하지 말자.</li>
  <li>힘내자…</li>
</ol>]]></content><author><name>Sujin Kim</name></author><category term="coding-swamp" /><category term="모코늪" /><category term="재시작" /><summary type="html"><![CDATA[애증의 프로젝트 모코숲 다시 뜯어고치기 시작]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 최대공약수와 최소공배수 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 최대공약수와 최소공배수 by JS" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80%20%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.</p>

<ul>
  <li>두 수는 1이상 1000000이하의 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">gcd</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">b</span> <span class="p">:</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">lcm</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">)</span> <span class="o">/</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">[</span><span class="nf">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">),</span> <span class="nf">lcm</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>저번 문제에서 공부한 유클리드호제법으로 최대공약수(<code class="language-plaintext highlighter-rouge">gcd</code>)와 최소공배수(<code class="language-plaintext highlighter-rouge">lcm</code>)을 계산해 풀었습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">gcdlcm</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">r</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">ab</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span> <span class="p">(</span><span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span> <span class="nx">ab</span> <span class="o">/</span> <span class="nx">b</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>재귀함수가 아닌 for문을 사용해 최대공약수를 찾는 풀이입니다.</p>

<p><code class="language-plaintext highlighter-rouge">a % b</code>가 0이 될 때까지 반복문을 실행합니다.</p>

<p>재귀함수로만 풀릴 줄 알았는데 for문으로 풀려서 신기하네요:)</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="최대공약수" /><category term="최소공배수" /><summary type="html"><![CDATA[유클리드 호제법으로 최대공약수와 최소공배수 구하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 멀리 뛰기 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%EA%B7%A4-%EA%B3%A0%EB%A5%B4%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 멀리 뛰기 by JS" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-26T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EA%B7%A4%20%EA%B3%A0%EB%A5%B4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EA%B7%A4-%EA%B3%A0%EB%A5%B4%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 ‘k’개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.</p>

<p>예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.</p>

<p>경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>1 ≤ k ≤ tangerine의 길이 ≤ 100,000</li>
  <li>1 ≤ tangerine의 원소 ≤ 10,000,000</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">tangerine</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">tangerineObject</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="nx">tangerine</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tangerineObject</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tangerineObject</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="kd">const</span> <span class="nx">tangerineNum</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">values</span><span class="p">(</span><span class="nx">tangerineObject</span><span class="p">).</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">acc</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="nx">acc</span> <span class="o">+=</span> <span class="nx">tangerineNum</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">tangerine</code>배열에서 과일이름이 중복된 횟수를 계산해 새로운 객체 <code class="language-plaintext highlighter-rouge">tangerineObject</code>에 이름과 과일의 개수를 매칭해 저장한다.</li>
  <li>과일 개수를 내림차순으로 정렬해 배열에 저장한다.(<code class="language-plaintext highlighter-rouge">tangerineNum</code>)</li>
  <li>정렬된 배열에서 앞에서부터 k개의 요소를 더하여, 그 합이 k이상이되는 최소값을 구한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">tangerine</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">tDict</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="nx">tangerine</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">tDict</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">tDict</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">tArr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">values</span><span class="p">(</span><span class="nx">tDict</span><span class="p">).</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">);</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">t</span> <span class="k">of</span> <span class="nx">tArr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">k</span> <span class="o">&gt;</span> <span class="nx">t</span><span class="p">)</span> <span class="nx">k</span> <span class="o">-=</span> <span class="nx">t</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>최솟값을 구할때 저는 변수(<code class="language-plaintext highlighter-rouge">acc</code>)를 선언해 누적값을 구했는데, 이 풀이에서는 따로 변수를 선언하지 않고 주어진 <code class="language-plaintext highlighter-rouge">k</code>에서 값을 빼주며 0이 되었을 때 반복문을 나오게 했습니다 👍</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="" /></entry><entry><title type="html">[프로그래머스 / Lv 1] 행렬의 덧셈 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 행렬의 덧셈 by JS" /><published>2023-04-27T00:00:00+09:00</published><updated>2023-04-27T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98%20%EB%8D%A7%EC%85%88</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">index</span><span class="p">]));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>for문으로 주어진 배열의 인덱스만큼 반복문을 돌린다.</li>
  <li>배열의 요소가 배열이니 다시한번 map을 사용해 값을 더해준 후 <code class="language-plaintext highlighter-rouge">answer</code>에 값을 삽입한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sumMatrix</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">A</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">idx1</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">val</span><span class="p">,</span> <span class="nx">idx2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">val</span> <span class="o">+</span> <span class="nx">B</span><span class="p">[</span><span class="nx">idx1</span><span class="p">][</span><span class="nx">idx2</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>map을 두번 사용해 배열의 값을 더한 풀이입니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="배열" /><summary type="html"><![CDATA[배열 더하기]]></summary></entry></feed>