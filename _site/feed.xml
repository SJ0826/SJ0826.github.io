<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-28T19:34:27+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">[프로그래머스 / Lv 1] 최대공약수와 최소공배수 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 최대공약수와 최소공배수 by JS" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80%20%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.</p>

<ul>
  <li>두 수는 1이상 1000000이하의 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">gcd</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">b</span> <span class="p">:</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">lcm</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">)</span> <span class="o">/</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">[</span><span class="nf">gcd</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">),</span> <span class="nf">lcm</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>저번 문제에서 공부한 유클리드호제법으로 최대공약수(<code class="language-plaintext highlighter-rouge">gcd</code>)와 최소공배수(<code class="language-plaintext highlighter-rouge">lcm</code>)을 계산해 풀었습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">gcdlcm</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">r</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">ab</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span> <span class="p">(</span><span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span> <span class="nx">ab</span> <span class="o">/</span> <span class="nx">b</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>재귀함수가 아닌 for문을 사용해 최대공약수를 찾는 풀이입니다.</p>

<p><code class="language-plaintext highlighter-rouge">a % b</code>가 0이 될 때까지 반복문을 실행합니다.</p>

<p>재귀함수로만 풀릴 줄 알았는데 for문으로 풀려서 신기하네요:)</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="최대공약수" /><category term="최소공배수" /><summary type="html"><![CDATA[유클리드 호제법으로 최대공약수와 최소공배수 구하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 행렬의 덧셈 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 행렬의 덧셈 by JS" /><published>2023-04-27T00:00:00+09:00</published><updated>2023-04-27T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98%20%EB%8D%A7%EC%85%88</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">index</span><span class="p">]));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>for문으로 주어진 배열의 인덱스만큼 반복문을 돌린다.</li>
  <li>배열의 요소가 배열이니 다시한번 map을 사용해 값을 더해준 후 <code class="language-plaintext highlighter-rouge">answer</code>에 값을 삽입한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sumMatrix</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">A</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">idx1</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">val</span><span class="p">,</span> <span class="nx">idx2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">val</span> <span class="o">+</span> <span class="nx">B</span><span class="p">[</span><span class="nx">idx1</span><span class="p">][</span><span class="nx">idx2</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>map을 두번 사용해 배열의 값을 더한 풀이입니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="배열" /><summary type="html"><![CDATA[배열 더하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 멀리 뛰기 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%EB%A9%80%EB%A6%AC-%EB%9B%B0%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 멀리 뛰기 by JS" /><published>2023-04-26T00:00:00+09:00</published><updated>2023-04-26T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EB%A9%80%EB%A6%AC%20%EB%9B%B0%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EB%A9%80%EB%A6%AC-%EB%9B%B0%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
(1칸, 1칸, 1칸, 1칸)
(1칸, 2칸, 1칸)
(1칸, 1칸, 2칸)
(2칸, 1칸, 1칸)
(2칸, 2칸)
의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.</p>

<ul>
  <li>n은 1 이상, 2000 이하인 정수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1234567</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>처음 문제를 보고 DFS로 접근했더니 시간 초과가 되어 동적 계산법(DP)로 다시 생각했습니다.</p>

<p>n이 1일 경우 -&gt; 1<br />
n이 2일 경우 -&gt; 2<br />
n이 3일 경우 -&gt; 3<br />
n이 4일 경우 -&gt; 5<br />
n이 5일 경우 -&gt; 8<br />
n이 6일 경우 -&gt; 13<br /></p>

<p>문제의 답이 피보나치 수열로 이루어져 있습니다.</p>

<p>따라서 배열 (<code class="language-plaintext highlighter-rouge">dp</code>)의 맨 앞과 두번째 수를 1과 2로 만들고 그 뒤의 값들을 구하면 답을 알 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">% 1234567</code>연산을 for문 안에서 한 이유는 dp[n - 1]의 크기가 커져 오버 플로우가 발생하기 때문입니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">jumpCase</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nx">num</span><span class="p">;</span>

  <span class="k">return</span> <span class="nf">jumpCase</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">jumpCase</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>같은 방식을 재귀함수로 풀어낸 풀이입니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="" /></entry><entry><title type="html">[프로그래머스 / Lv 1] 문자열 다루기 기본 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 문자열 다루기 기본 by JS" /><published>2023-04-26T00:00:00+09:00</published><updated>2023-04-26T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%8B%A4%EB%A3%A8%EA%B8%B0%20%EA%B8%B0%EB%B3%B8</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다.</p>

<ul>
  <li>s는 길이 1 이상, 길이 8 이하인 문자열입니다.</li>
  <li>s는 영문 알파벳 대소문자 또는 0부터 9까지 숫자로 이루어져 있습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">4</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">6</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
  <span class="k">return</span> <span class="o">!</span><span class="nf">isNaN</span><span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>처음에 주어진 문자열 전체를 숫자로 바꿨는데 테스트 케이스 오류가 발생했습니다.</p>

<p>알고보니 문자 <code class="language-plaintext highlighter-rouge">e</code>가 포함되면 Number()가 지수로 인식해 <code class="language-plaintext highlighter-rouge">e</code>를 숫자로 판별했던 것이었습니다.</p>

<p>따라서 for문을 돌려 문자 하나하나에 Number()를 적용해주어야 했습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">6</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nf">isNaN</span><span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])))</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>문자열에 Number() 메소드를 적용하면 NAN이 되니, isNaN()을 사용해 이를 판별했습니다.</p>

<p>isNaN을 !!isNaN으로 사용하면 더 간결하겠지만, 주어진 문자열이 “0000”인 경우에는 0도 false로 인식하므로 사용할 수 없었습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">alpha_string46</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/^</span><span class="se">\d{6}</span><span class="sr">$|^</span><span class="se">\d{4}</span><span class="sr">$/</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">regex</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>정규식을 이용한 풀이입니다.</p>

<p>주어진 문자열이 6개 혹은 4개의 숫자(d)로 이루어져 있는지 바로 확인할 수 있습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="문자열" /><summary type="html"><![CDATA[문자열이 숫자로만 이루어져 있는지 확인하기]]></summary></entry><entry><title type="html">[메세지가 도착했습니다] Firestore를 사용해 원격으로 DB관리하기</title><link href="http://localhost:4000/random-message/random-message-FireStore%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9B%90%EA%B2%A9%EC%9C%BC%EB%A1%9C-DB%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[메세지가 도착했습니다] Firestore를 사용해 원격으로 DB관리하기" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T22:06:00+09:00</updated><id>http://localhost:4000/random-message/random-message-FireStore%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%B4%20%EC%9B%90%EA%B2%A9%EC%9C%BC%EB%A1%9C%20DB%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/random-message/random-message-FireStore%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9B%90%EA%B2%A9%EC%9C%BC%EB%A1%9C-DB%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-사용-계기">📄 사용 계기</h2>

<p>혼자 간단한 토이프로젝트를 만들게 되었는데, 이때 사용할 REST API를 만들기에는 시간이 부족했습니다.</p>

<p>Firestore를 사용하면 어렵지 않고 빠르게 DB를 만들어 통신할 수 있어 사용하게 되었습니다.</p>

<h2 id="-firestore-db-구조">📄 Firestore DB 구조</h2>

<p>Firebase 페이지에서 Firestore를 생성하면 다음과 같은 DB를 만들 수 있습니다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/234165551-86d0b88f-9ea8-4214-95a2-2a7dfd35cc7a.png" alt="image" /></p>

<p>제가 사용하고 싶던 기능은 다음과 같습니다.</p>

<ul>
  <li>메세지 가져오기 (GET)</li>
  <li>메세지 생성하기 (CREATE)</li>
  <li>메세지 삭제하기 (DELETE)</li>
</ul>

<h2 id="-vscode에서-firestore와-통신하기">📄 VSCode에서 Firestore와 통신하기</h2>

<p>프로젝트 설정탭에서 <strong>SDK 설정 및 구성</strong>을 확인하면 제품의 SDK를 확인할 수 있습니다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/234166648-2d3b993c-fed2-480c-a3fe-77039dbdd355.png" alt="image" /></p>

<h4 id="0-npm-install-firebase">0. npm install firebase</h4>

<h4 id="1-src폴더-내에-firebasejs-파일-생성">1. src폴더 내에 firebase.js 파일 생성</h4>

<p>firestore를 사용해주기 위해 firebase를 초기화 합니다.</p>

<p>저는 SDK를 환경변수로 설정해 가려줬습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">initializeApp</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">firebase/app</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">getFirestore</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">firebase/firestore</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">firebaseConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">apiKey</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_API_KEY</span><span class="p">,</span>
  <span class="na">authDomain</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_AUTH_DOMAIN</span><span class="p">,</span>
  <span class="na">projectId</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_PROJECT_ID</span><span class="p">,</span>
  <span class="na">storageBucket</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_STORAGE_BUCKET</span><span class="p">,</span>
  <span class="na">messagingSenderId</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_MESSAGING_SENDER_ID</span><span class="p">,</span>
  <span class="na">appId</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_API_ID</span><span class="p">,</span>
  <span class="na">measurementId</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_FB_MEASUREMENT_ID</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">firebaseApp</span> <span class="o">=</span> <span class="nf">initializeApp</span><span class="p">(</span><span class="nx">firebaseConfig</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">firebaseDB</span> <span class="o">=</span> <span class="nf">getFirestore</span><span class="p">(</span><span class="nx">firebaseApp</span><span class="p">);</span>

<span class="k">export</span> <span class="p">{</span> <span class="nx">firebaseDB</span> <span class="p">};</span>
</code></pre></div></div>

<h4 id="2-basedb-설정하기">2. baseDB 설정하기</h4>

<p>DB를 사용하는 작업에서 공통으로 사용되는 부분을 따로 만들었습니다.</p>

<p>💾 lib/db/baseDB.ts</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">firebaseDB</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../../firebase</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">collection</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">firebase/firestore</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">baseDB</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="nf">collection</span><span class="p">(</span><span class="nx">firebaseDB</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Messages</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">db</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">baseDB</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">collection</code>은 Firestore에서 생성했던 컬렉션 이름을 기준으로 데이터를 관리합니다.</p>

<h4 id="3-데이터-가져오기--삭제하기">3. 데이터 가져오기 + 삭제하기</h4>

<p>저는 가져오자마자 삭제하는 작업을 해야했기 때문에 함수 하나에 동시에 작업했습니다.</p>

<p>💾 lib/db/getMessages.ts</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getMessage</span> <span class="o">=</span> <span class="nf">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">getDocs</span><span class="p">(</span><span class="nf">baseDB</span><span class="p">());</span> <span class="c1">// Get 🎉</span>
    <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">docs</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">doc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="p">...(</span><span class="nx">doc</span><span class="p">.</span><span class="nf">data</span><span class="p">()</span> <span class="k">as</span> <span class="nx">docInterface</span><span class="p">),</span>
      <span class="na">id</span><span class="p">:</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
    <span class="p">}));</span>
    <span class="kd">const</span> <span class="nx">selectedData</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nf">getRandomNum</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
    <span class="k">await</span> <span class="nf">deleteDoc</span><span class="p">(</span><span class="nf">doc</span><span class="p">(</span><span class="nx">firebaseDB</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Messages</span><span class="dl">"</span><span class="p">,</span> <span class="nx">selectedData</span><span class="p">.</span><span class="nx">id</span><span class="p">));</span> <span class="c1">// Delete 🎉</span>
    <span class="k">return</span> <span class="nx">selectedData</span><span class="p">;</span>
  <span class="p">}</span> <span class="nf">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error in getMessage:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>baseDB에서 Docs를 가져와서 데이터를 가져왔습니다.</p>

<p>단점은 Get을 사용하면 모든 데이터를 가져옵니다.</p>

<p>그래서 데이터가 큰 경우에는 성능이 저하 될 수 있습니다.</p>

<p>Firestore은 데이터가 크지 않은 경우에만 사용하는 것이 좋은 것 같습니다.</p>

<p>delete명령을 사용할 때는 인수가 추가 됩니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">deleteDoc</span><span class="p">(</span><span class="nf">doc</span><span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">컬렉션</span> <span class="nx">이름</span><span class="p">,</span> <span class="nx">해당</span> <span class="nx">id</span><span class="p">))</span>
</code></pre></div></div>

<p>가져온 데이터의 아이디를 통해 해당 데이터를 삭제할 수 있습니다.</p>

<h3 id="데이터-생성추가하기">데이터 생성(추가)하기</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">createMessage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="nx">MessageFormInterface</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">addDoc</span><span class="p">(</span><span class="nf">baseDB</span><span class="p">(),</span> <span class="nx">message</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>데이터 생성은 addDoc라는 명령을 통해 이루어집니다.</p>

<hr />

<h2 id="느낀점">느낀점</h2>

<p>생각보다 사용법이 간편해서 수월했습니다.</p>

<p>다만, 언급했던 것처럼 데이터를 한번에 가져와야하니 비효율적으로 느껴졌지만 해당 프로젝트는 많은 데이터 를 요구하는게 아니니 쓸만했습니다.</p>

<p>다음엔 Firebase로 REST API를 만들거나 mongoDB를 배워 직접 API를 만들어 보고 싶습니다:)</p>]]></content><author><name>Sujin Kim</name></author><category term="random-message" /><category term="Firestore" /><category term="DB" /></entry><entry><title type="html">[프로그래머스 / Lv 1] 부족한 금액 계산하기 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 부족한 금액 계산하기 by JS" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EB%B6%80%EC%A1%B1%ED%95%9C%20%EA%B8%88%EC%95%A1%20%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.
놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.
단, 금액이 부족하지 않으면 0을 return 하세요.</p>

<ul>
  <li>놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수</li>
  <li>처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수</li>
  <li>놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">price</span><span class="p">,</span> <span class="nx">money</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="nx">price</span> <span class="o">*</span> <span class="p">((</span><span class="nx">count</span> <span class="o">*</span> <span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">total</span> <span class="o">-</span> <span class="nx">money</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">total</span> <span class="o">-</span> <span class="nx">money</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>📌 정수 1부터 N까지 합: (N(N+1))/2</strong></p>

<ol>
  <li>등차수열 공식을 이용해 요금 합계(<code class="language-plaintext highlighter-rouge">total</code>)를 구한다.</li>
  <li>요금 합계(<code class="language-plaintext highlighter-rouge">total</code>)에서 돈이 모자라면 부족한 금액을 아니라면 0을 반환한다.</li>
</ol>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="등차수열" /><summary type="html"><![CDATA[등차수열 공식을 이용해 정수 1부터 N까지 합 구하기]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] N개의 최소공배수 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-N%EA%B0%9C%EC%9D%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] N개의 최소공배수 by JS" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-N%EA%B0%9C%EC%9D%98%20%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-N%EA%B0%9C%EC%9D%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.</p>

<ul>
  <li>arr은 길이 1이상, 15이하인 배열입니다.</li>
  <li>arr의 원소는 100 이하인 자연수입니다.</li>
</ul>

<h2 id="-나의-풀이">📄 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">gcd</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">b</span> <span class="p">:</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">lcm</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">)</span> <span class="o">/</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">sortedArr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span> <span class="o">=</span> <span class="nf">lcm</span><span class="p">(</span><span class="nx">answer</span><span class="p">,</span> <span class="nx">sortedArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>📌 유클리드 호제법이란?</strong>
유클리드 호제법은 나눗셈을 반복해서 두 수의 최대공약수를 구하는 알고리즘입니다.
두 수 A와 B의 나머지가 r일때, gcd(A, B) = gcd(B, r)입니다.
r이 0이라면 최대공약수는 B가 되고, 아니라면 gcd(B, r)을 계산합니다.</p>
</blockquote>

<ol>
  <li>최대공배수는 <code class="language-plaintext highlighter-rouge">두수를 곱한 값 / 최대 공약수</code>이다.</li>
  <li>주어진 배열을 오름차순으로 정렬한다.(<code class="language-plaintext highlighter-rouge">sortedArr</code>)</li>
  <li>초기값이 1인 <code class="language-plaintext highlighter-rouge">answer</code>와 <code class="language-plaintext highlighter-rouge">sortedArr</code>의 요소의 최대공배수를 구해 answer의 값을 변경해준다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">nlcm</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">)</span> <span class="o">/</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span> <span class="p">?</span> <span class="nf">gcd</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">)</span> <span class="p">:</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>for문 대신 reduce 메소드를 사용해 가독성을 높인 풀이입니다.</p>

<p>이 풀이에서는 누적값 <code class="language-plaintext highlighter-rouge">a</code>가 answer이 되었습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="유클리드 호제법" /><category term="최소공배수" /><summary type="html"><![CDATA[유클리드 호제법을 이용해 최소공배수 구하기]]></summary></entry><entry><title type="html">[알고리즘] DFS/BPS 깊이/너비 우선 탐색 알고리즘</title><link href="http://localhost:4000/algorithm/algorithm-DFS&BFS/" rel="alternate" type="text/html" title="[알고리즘] DFS/BPS 깊이/너비 우선 탐색 알고리즘" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-24T22:06:00+09:00</updated><id>http://localhost:4000/algorithm/algorithm-DFS&amp;BFS</id><content type="html" xml:base="http://localhost:4000/algorithm/algorithm-DFS&amp;BFS/"><![CDATA[<h2 id="-그래프-탐색-알고리즘">📄 그래프 탐색 알고리즘</h2>

<p>여러개체들이 연결되어 있는 자료구조에서 특정 개체를 찾는 알고리즘을 그래프 탐색 알고리즘이라고 합니다.</p>

<p>✔ 대표 문제</p>

<ol>
  <li>경로탐색 유형 (최단거리, 시간)</li>
  <li>네트워크 유형 (연결)</li>
  <li>조합 유형 (모든 조합 만들기)</li>
</ol>

<p>이 알고리즘들의 대표 유형이 DFS(깊이 우선 탐색)/BFS(너비 우선 탐색)입니다.</p>

<h2 id="-dfs--깊이-우선-탐색-알고리즘">📄 DFS | 깊이 우선 탐색 알고리즘</h2>

<p><img src="https://user-images.githubusercontent.com/56298540/233902499-8794557a-888f-4073-8feb-dfc611ecdec0.png" alt="image" /></p>

<p>DFS는 임이의 노드에서 시작해서 그 경로를 완벽히 탐색해야 다음 분기로 넘어가는 특징이 있습니다.</p>

<ul>
  <li>장점: 운이 좋으면 처음부터 최적의 탐색 경로를 알 수 있다</li>
  <li>단점: 처음 경로가 복잡하고 아주 길면 시간이 오래걸릴 수 있다.</li>
</ul>

<p>예시 코드입니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 그래프 정의 (인접 리스트 형태)</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">A</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">B</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">D</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">E</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">C</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">F</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">G</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">D</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">E</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">H</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">F</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">G</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">H</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">E</span><span class="dl">"</span><span class="p">],</span>
<span class="p">};</span>

<span class="c1">// DFS 알고리즘</span>
<span class="kd">function</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span> <span class="c1">// 방문한 노드를 저장하는 Set</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nx">start</span><span class="p">];</span> <span class="c1">// 스택을 사용하여 탐색할 노드를 저장</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 탐색 결과를 저장할 배열</span>

  <span class="nf">while </span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span> <span class="c1">// 스택에서 하나의 노드를 꺼냄</span>

    <span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 해당 노드를 방문하지 않았다면</span>
      <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span> <span class="c1">// 노드를 방문 처리</span>
      <span class="nx">result</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span> <span class="c1">// 결과 배열에 노드를 추가</span>

      <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">node</span><span class="p">];</span> <span class="c1">// 현재 노드의 인접 노드들</span>
      <span class="nf">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// 방문하지 않은 인접 노드들을 스택에 추가</span>
          <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// DFS 실행</span>
<span class="kd">const</span> <span class="nx">startNode</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 시작 노드 설정</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">startNode</span><span class="p">);</span> <span class="c1">// DFS 실행</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// DFS 결과 출력</span>
</code></pre></div></div>

<p>위 코드는 인접 리스트 형태로 그래프를 정의하고, DFS알고리즘을 사용하여 시작 노드에서 출발해 깊이 우선 탐색을 수행합니다.</p>

<p>방문한 노드는 <code class="language-plaintext highlighter-rouge">visited</code> Set에 저장되고, 탐색 결과는 <code class="language-plaintext highlighter-rouge">result</code>배열에 추가됩니다.</p>

<p>작성한 함수를 재귀함수로 만들면 다음과 같습니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 그래프 정의 (인접 리스트 형태)</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">A</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">B</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">D</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">E</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">C</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">F</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">G</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">D</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">E</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">H</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">F</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">G</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">H</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">E</span><span class="dl">"</span><span class="p">],</span>
<span class="p">};</span>

<span class="c1">// DFS 알고리즘 (재귀 함수)</span>
<span class="kd">function</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">visited</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span> <span class="c1">// 현재 노드를 방문 처리</span>
  <span class="nx">result</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span> <span class="c1">// 결과 배열에 노드를 추가</span>

  <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">node</span><span class="p">];</span> <span class="c1">// 현재 노드의 인접 노드들</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 방문하지 않은 인접 노드들에 대해 재귀 호출</span>
      <span class="nf">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">neighbor</span><span class="p">,</span> <span class="nx">visited</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// DFS 실행</span>
<span class="kd">const</span> <span class="nx">startNode</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 시작 노드 설정</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span> <span class="c1">// 방문한 노드를 저장하는 Set</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 탐색 결과를 저장할 배열</span>

<span class="nf">dfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">startNode</span><span class="p">,</span> <span class="nx">visited</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span> <span class="c1">// DFS 실행</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// DFS 결과 출력</span>
</code></pre></div></div>

<p>✔ 재귀함수를 사용했을 때 장점</p>

<ul>
  <li>더 간결하고 직관적이다</li>
  <li>스택의 개념을 명시적으로 사용하지 않아도 된다</li>
</ul>

<p>✔ 재귀함수를 사용했을 때 단점</p>

<ul>
  <li>스택의 크기가 커질 수 있고 스택 오버플로우가 발생할 수 있다</li>
  <li>깊이 가 매우 깊은 트리 구조의 경우 재귀 함수를 사용하면 성능이 저하될 수 있다.</li>
</ul>

<p>따라서 더 간단하고 직관적인 구현이 필요하거나 스택 오버플로우 등의 문제가 발생할 가능성이 낮은 경우에는 재귀 함수를 사용하는 것이 좋습니다.</p>

<p>하지만 성능이 중요하거나 스택의 크기가 커질 수 있는 경우에는 반복문 기반의 구현이 우선적으로 고려되어야 합니다.</p>

<h2 id="-bfs--너비-우선-탐색-알고리즘">📄 BFS | 너비 우선 탐색 알고리즘</h2>

<p><img src="https://user-images.githubusercontent.com/56298540/233904191-5cb143d6-b194-4426-a8ac-4384f1680df5.png" alt="image" /></p>

<p>DFS는 깊게 탐색하기 전에 먼저 넓게 탐색해보는 알고리즘입니다.</p>

<p>✔ BFS 알고리즘의 장점</p>

<ul>
  <li>시작 노드에서 레벨별로 탐색을 진행하기 때문에 <strong>최단 경로 탐색</strong>에 유용하다.</li>
  <li>각 레벨별로 탐색을 진행하기 때문에 같은 노드를 중복 방문하지 않아 <strong>무한 루프 회피</strong>가 가능하다.</li>
  <li>레벨 기반으로 탐색을 진행하기 때문에 그래프의 균형을 잡아주는 특징이 있어 <strong>균형 잡힌 탐색</strong>이 가능해 노드가 균등하게 분포된 경우 유용하다.</li>
</ul>

<p>✔ BFS 알고리즘의 단점</p>

<ul>
  <li>BPS는 큐를 사용해 탐색을 진행하는데, 현재 레벨의 모든 노드를 큐에 저장해야 하므로 그래프의 너비가 큰 경우 <strong>메모리에 부담</strong>이 커질 수 있다.</li>
  <li>무방향 그래프일 경우 같은 노드를 중복 방문할 수 있다.</li>
  <li>그래프가 복잡할 경우 <strong>경로의 복잡성</strong>이 커진다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 그래프의 인접 리스트를 표현한 예시</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
  <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span>
  <span class="mi">4</span><span class="p">:</span> <span class="p">[],</span>
  <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span>
  <span class="mi">6</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">};</span>

<span class="c1">// BFS 알고리즘 함수</span>
<span class="kd">function</span> <span class="nf">bfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 큐</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Set</span><span class="p">();</span> <span class="c1">// 방문한 노드를 저장할 Set</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span> <span class="c1">// 시작 노드를 큐에 넣음</span>
  <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">start</span><span class="p">);</span> <span class="c1">// 시작 노드를 방문 처리</span>

  <span class="nf">while </span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 큐가 빌 때까지 반복</span>
    <span class="kd">const</span> <span class="nx">currentNode</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span> <span class="c1">// 큐에서 노드를 꺼냄</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">currentNode</span><span class="p">);</span> <span class="c1">// 현재 노드를 출력 또는 원하는 작업 수행</span>

    <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">currentNode</span><span class="p">];</span> <span class="c1">// 현재 노드의 인접 노드들</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 방문하지 않은 노드라면</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span> <span class="c1">// 큐에 넣음</span>
        <span class="nx">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span> <span class="c1">// 방문 처리</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// BFS 실행 예시</span>
<span class="nf">bfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 1 2 3 4 5 6 순서로 출력 또는 원하는 작업 수행</span>
</code></pre></div></div>]]></content><author><name>Sujin Kim</name></author><category term="Algorithm" /><category term="DFS" /><category term="BPS" /></entry><entry><title type="html">[메세지가 도착했습니다] 컴포넌트 겹침 현상 해결하기</title><link href="http://localhost:4000/random-message/random-message-CSS-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[메세지가 도착했습니다] 컴포넌트 겹침 현상 해결하기" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-24T22:06:00+09:00</updated><id>http://localhost:4000/random-message/random-message-CSS%20%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83%20%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/random-message/random-message-CSS-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-css-레이아웃-문제-발생">🚨 CSS 레이아웃 문제 발생</h2>

<p>데스크탑 환경에서는 몰랐지만 배포하고 모바일에서 테스트해보니 Footer가 되는 컴포넌트가 다른 컴포넌트와 겹치는 현상이 발생했습니다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/233956639-26067272-4798-4e1b-ba34-077c7a0d73a4.png" alt="image" /></p>

<p>아무래도 Footer컴포넌트가 항상 밑에만 있으면 된다는 생각에 position설정을 absolute로 줘서 그런것 같습니다.</p>

<p>뷰포트 높이의 길이는 한정되어 있는데 모바일 화면은 데스크탑보다 작으니 자리가 고정되어 있는 Footer컴포넌트가 밀리지 않고 겹쳐지게 됩니다.</p>

<h2 id="-문제를-해결해보자">🔨 문제를 해결해보자</h2>

<p>우선 Footer CSS를 변경하겠습니다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.footer</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">max-width</span><span class="p">:</span> <span class="m">650px</span><span class="p">;</span>
  <span class="err">//</span> <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span> <span class="err">🔨</span>
  <span class="err">//</span> <span class="nl">bottom</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span> <span class="err">🔨</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">1rem</span><span class="p">;</span>
  <span class="nl">text-align</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>

  <span class="err">.github__link</span> <span class="err">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="p">;</span>
    <span class="nl">align-items</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
    <span class="nl">text-decoration-line</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">color</span><span class="p">:</span> <span class="err">$</span><span class="n">text-dark1</span><span class="p">;</span>
    <span class="err">&amp;:hover</span> <span class="err">{</span>
      <span class="nl">cursor</span><span class="p">:</span> <span class="nb">pointer</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="err">}</span>
<span class="err">}</span>
</code></pre></div></div>

<p>해당 부분을 주석으로 없앴더니 다른 문제가 발생합니다.</p>

<p>아예 페이지 바깥으로 컨텐츠가 탈출해버렸습니다.</p>

<p><img src="https://user-images.githubusercontent.com/56298540/233959070-e5a521ab-884f-4545-aece-65fcf4294a50.png" alt="image" /></p>

<p>이렇게 컨텐츠가 넘치는 현상을 막기 위해 페이지 컴포넌트에 <code class="language-plaintext highlighter-rouge">overflow: auto</code>를 추가합니다.</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.start__container</span> <span class="p">{</span>
  <span class="k">@include</span> <span class="nd">set-box-size</span><span class="p">();</span>
  <span class="k">@include</span> <span class="nd">set-center-aligned</span><span class="p">;</span>
  <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">column</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="nv">$main-color</span><span class="p">;</span>

  <span class="nl">overflow</span><span class="p">:</span> <span class="nb">auto</span><span class="p">;</span> <span class="c1">// 🎉</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/56298540/233959941-dcbd1bc5-3670-4072-bb87-ffa6391c33cd.png" alt="image" /></p>

<p>이제 더이상 컴포넌트끼리 겹치지도, 컨텐츠가 페이지 밖으로 튀어나오지도 않습니다 :)</p>]]></content><author><name>Sujin Kim</name></author><category term="random-message" /><category term="CSS" /><category term="레이아웃" /></entry><entry><title type="html">[프로그래머스 / Lv 2] 타겟 넘버 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%ED%83%80%EA%B2%9F-%EB%84%98%EB%B2%84/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 타겟 넘버 by JS" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-24T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%ED%83%80%EA%B2%9F%20%EB%84%98%EB%B2%84</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%ED%83%80%EA%B2%9F-%EB%84%98%EB%B2%84/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
</code></pre></div></div>

<p>사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>주어지는 숫자의 개수는 2개 이상 20개 이하입니다.</li>
  <li>각 숫자는 1 이상 50 이하인 자연수입니다.</li>
  <li>타겟 넘버는 1 이상 1000 이하인 자연수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="nf">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">depth</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">depth</span> <span class="o">===</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">if </span><span class="p">(</span><span class="nx">sum</span> <span class="o">===</span> <span class="nx">target</span><span class="p">)</span> <span class="nx">answer</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">dfs</span><span class="p">(</span><span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">depth</span><span class="p">]);</span>
    <span class="nf">dfs</span><span class="p">(</span><span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">-</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">depth</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이번 문제는 dfs알고리즘을 이용해서 재귀함수를 만들어 풀었습니다.</p>

<ol>
  <li>함수 dfs는 주어진 숫자의 개수만큼 깊이가 길어지면 리턴한다. 이때 노드의 충합이 target과 같다면 answer에 1을 더한다.</li>
  <li>1번의 조건과 만족하지 않는다면 <code class="language-plaintext highlighter-rouge">depth</code>에 1을 더하고 number의 요소가 음수인 경우를 포함해 구하기 때문에 재귀함수를 두번 호출한다.</li>
</ol>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="DFS" /><summary type="html"><![CDATA[모든 경로의 수 구하기]]></summary></entry></feed>