<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-03-06T12:15:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">SUJIN DEV NOTE 📝</title><subtitle>주니어 개발자의 꼼질꼼질 성장일지 👻</subtitle><author><name>수진‍ (水珍)</name></author><entry><title type="html">[React] 리액트팀은 왜 가상 돔을 만들었을까?</title><link href="http://localhost:4000/react/react-react-virtual-dom/" rel="alternate" type="text/html" title="[React] 리액트팀은 왜 가상 돔을 만들었을까?" /><published>2023-12-26T00:00:00+09:00</published><updated>2023-09-25T22:06:00+09:00</updated><id>http://localhost:4000/react/react-react%20virtual%20dom</id><content type="html" xml:base="http://localhost:4000/react/react-react-virtual-dom/"><![CDATA[<h2 id="사용자가-브라우저-주소창에-주소를-입력하면-어떤-일이-발생할까">사용자가 브라우저 주소창에 주소를 입력하면 어떤 일이 발생할까?</h2>

<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/cc5d46e7-ab57-462d-8b26-582a91f86f80/9fe21a7c-7ed2-4caa-82d0-cf0dcff5a192/Untitled.png" alt="Untitled" /></p>

<ol>
  <li>브라우저가 사용자가 요청한 주소를 방문해 html을 다운받는다.</li>
  <li>브라우저의 렌더링 엔진이 html 을 파싱해 DOM 트리를 만든다.</li>
  <li>2 과정에서 CSS 파일을 만나면 CSS 파일을 다운받는다.</li>
  <li>브라우저의 렌더링 엔진이 CSS 트리인 CSSOM을 만든다.</li>
  <li>브라우저는 만들어진 DOM트리를 순회한다. 이 과정에서 사용자의 눈에 보여지는 부분만 순회한다. 이를 통해 트리를 분석하는 과정을 빠르게 할 수 있다.</li>
  <li>DOM 트리에서 눈에 보이는 노드에 대한 CSSOM 정보를 찾아 노드에 적용해 렌더트리를 만든다.
    <ol>
      <li>레이아웃(Reflow): 노드가 브라우저 화면에 어느 좌표에 위치해야하는지 계산하는 과정</li>
      <li>페인팅(Repaint): 레이아웃단계를 거친 노드에 색, 이미지 같은 유효한 모습을 그리는 과정</li>
    </ol>
  </li>
</ol>

<h2 id="사용자-인터렉션에-의해-dom이-변경되었을-때는-어떻게-동작할까">사용자 인터렉션에 의해 DOM이 변경되었을 때는 어떻게 동작할까?</h2>

<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/cc5d46e7-ab57-462d-8b26-582a91f86f80/4de94b71-c719-428e-a646-db7dfecd76b8/Untitled.png" alt="Untitled" /></p>

<p>어떠한 인터렉션에 의해 DOM에 변화가 생길 때, 브라우저는 위 과정을 반복하며 렌더 트리를 다시 만든다.</p>

<ol>
  <li>Layout부터 발생하는 경우 (Reflow): 레이아웃의 높이, 너비 등 변화</li>
  <li>Paint부터 발생하는 경우 (Refaint): 이미지, 색상 등 변화</li>
  <li>레이어의 합성만 다시 발생하는 경우 (Composite): transform, opacity 속성 등</li>
</ol>

<p>composite(합성) 단계는 여러 레이어로 나누어진 픽셀값들을 우리가 실제로 보는 화면처럼 합성해주는 단계이다. paint단계에서 만들어진 레이어들을 순서대로 합성해 유저에게 보여준다.</p>

<p>이 과정을 이해하고 있다면 렌더링 최적화 과정을 진행할 수 있다.</p>

<p>예시로 애니메이션을 구현할 때, <code class="language-plaintext highlighter-rouge">position</code>과 <code class="language-plaintext highlighter-rouge">transform</code>을 선택할 수 있는데 <code class="language-plaintext highlighter-rouge">position</code>의 경우는 layout이 변경되어 reflow단계부터 트리가 재구조화된다면, <code class="language-plaintext highlighter-rouge">transform</code>은 coposite단계부터 변화가 적용되어 레이아웃과 페인트 과정을 감소시킬 수 있기 때문이다.</p>

<h2 id="왜-리액트팀은-가상-dom을-만들게-되었을까">왜 리액트팀은 가상 DOM을 만들게 되었을까?</h2>

<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/cc5d46e7-ab57-462d-8b26-582a91f86f80/8c2f8bd5-c3b9-46d7-8d4c-bcb825db568b/Untitled.png" alt="Untitled" /></p>

<p>과거 전통적인 웹사이트는 하나의 문서에 전달되는 정보의 양이 적었다. 그렇기 때문에 DOM이 변경되어도 서버에서 완전히 새로운 페이지를 내려주는 방법이 가능했지만, 현대 웹 사이트는 유저 인터렉션이 빈번하게 발생할 뿐더러 다뤄지는 데이터 양도 많다.</p>

<p>이러한 문제를 해결하기 위해 SPA가 등장했다. SPA는 ‘단일 페이지 어플리케이션’으로 웹 사이트에서 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 변경하는 기술이다. 이러한 SPA 방식은 하나의 페이지에서 모든게 이루어지기 때문에 자바스크립트에 의한 DOM 조작이 빈번하게 발생해 브라우저의 성능을 저하시킨다.</p>

<p>이러한 단점을 극복하기 위해, 리액트 팀은 가상(Virtual) DOM을 만들었다. 가상 DOM의 장점은 변경된 부분만 실제 브라우저 DOM에 적용할 수 있다는 것이다. 또한, 가상 DOM은 실제 브라우저 DOM에 직접 접근하는 것이 아니라 메모리에 저장되는 객체이므로, 가상 DOM에 접근하고 수정하는 과정은 매우 빠르게 이루어진다.</p>

<p>리액트는 두개의 가상 DOM을 가지고 있다.</p>

<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/cc5d46e7-ab57-462d-8b26-582a91f86f80/b6f75ce8-648b-4018-9f62-e572e8335c24/Untitled.png" alt="Untitled" /></p>

<ol>
  <li>렌더링 이전 화면 구조를 나타내는 가상 DOM (Virtual DOM)</li>
  <li>렌더링 이후 화면 구조를 나타내는 가상 DOM (New Virtual DOM)</li>
</ol>

<p><strong>Reconciliation: 재조정</strong></p>

<p>리액트는 상태가 변경되어 리렌더링이 일어날 때 마다 실제 브라우저가 그려지기 전에 두개의 가상 DOM을 생성한다. 이후 diffing알고리즘을 통해 변화가 발생한 노드만 실제 브라우저 DOM에 적용한다.</p>

<p><strong>Batch Update</strong></p>

<p>10개의 노드가 변경 되었다고 가정했을 때, 하나씩 순서대로 적용되는 것이 아니라 변경 사항을 한번에 모아서 실제 DOM에 적용한다.</p>

<h2 id="정리">정리</h2>

<p>리액트 가상 DOM은 자바스크립트 객체이기 때문에 접근하고 수정하는 속도가 빨라 실제 변경된 부분을 빠르게 파악할 수 있다. 이 변경된 부분만 한번에 모아서 실제 DOM에 적용시키기 때문에 브라우저 성능도 개선할 수 있다. 다만 UI 변경이 적고 브라우저에서 보여주는 데이터가 적을 경우에는 SPA 프레임워크없이 기존 웹 사이트 개발 방식을 선택해 개발하는 것도 좋은 방법이다.</p>]]></content><author><name>수진‍ (水珍)</name></author><category term="React" /><category term="브라우저" /><category term="virtual dom" /><category term="가상돔" /><summary type="html"><![CDATA[브라우저 렌더링과 리액트 가상 돔?]]></summary></entry><entry><title type="html">[Next.js] 🚨 이벤트가 함수가 prop로 전달되지 않는 이유</title><link href="http://localhost:4000/nextjs/nextjs-event%ED%95%A8%EC%88%98%EB%8A%94-%EC%99%9C-props%EB%A1%9C-%EC%A0%84%EB%8B%AC%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C/" rel="alternate" type="text/html" title="[Next.js] 🚨 이벤트가 함수가 prop로 전달되지 않는 이유" /><published>2023-11-10T00:00:00+09:00</published><updated>2023-11-13T22:06:00+09:00</updated><id>http://localhost:4000/nextjs/nextjs-event%ED%95%A8%EC%88%98%EB%8A%94%20%EC%99%9C%20props%EB%A1%9C%20%EC%A0%84%EB%8B%AC%EB%90%98%EC%A7%80%20%EC%95%8A%EC%9D%84%EA%B9%8C</id><content type="html" xml:base="http://localhost:4000/nextjs/nextjs-event%ED%95%A8%EC%88%98%EB%8A%94-%EC%99%9C-props%EB%A1%9C-%EC%A0%84%EB%8B%AC%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C/"><![CDATA[<h2 id="-문제-발생">🚨 문제 발생</h2>

<p>Next.js를 사용해 프로젝트를 진행하는데 에러가 발생했다.</p>

<p><img src="https://github.com/SJ0826/coding-swamp-/assets/56298540/c2095e9c-76fb-4671-aa4b-e8a4d69afa99" alt="스크린샷 2023-11-10 오전 11 04 49" /></p>

<p>프로젝트 환경은 다음과 같다.</p>

<ul>
  <li>Next.js (app routing)</li>
  <li>TS</li>
</ul>

<p>이벤트 함수를 컴포넌트 간 props로 전달하는 과정에서 발생했다.</p>

<h2 id="문제-원인">❔문제 원인</h2>

<ol>
  <li>Server Component에서 Client Component로 함수를 전달 할 수 없다.</li>
  <li>각 컴포넌트 간 props로 전달되는 함수는 직렬화 할 수 없기 때문이다.</li>
</ol>

<p>이 때 궁금한점.</p>

<ol>
  <li>난 Client Component로 컴포넌트를 변환한 적이 없는데?</li>
  <li>함수 직렬화가 무엇이지?</li>
</ol>

<h3 id="1-난-client-component로-컴포넌트를-변환한-적이-없는데--client-component로-실행되는-조건">1. 난 Client Component로 컴포넌트를 변환한 적이 없는데? | Client Component로 실행되는 조건</h3>

<p>next.js는 따로 설정하지 않으면 기본적으로 서버 컴포넌트로 실행된다. 하지만 위와 같은 에러가 발생했고 이유를 찾아보았다.</p>

<p>하위 컴포넌트인 <code class="language-plaintext highlighter-rouge">Modal.tsx</code>는 <strong>onClick 이벤트</strong>를 발생시키는 컴포넌트를 포함하고 있다. onClick 이벤트는 자바스크립트 이벤트 핸들러로 웹 브라우저 상에서 사용자에 의해 컨트롤된다.</p>

<p>사용자와 상호작용하는 이벤트 핸들러는 브라우저 환경에서 실행되는 클라이언트 측 코드에서 사용되어야 한다</p>

<p>⭐️ 이벤트 핸들러가 실행되는 함수는 자동으로 클라이언트 컴포넌트로 변환된다!</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyModal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">IModal</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">isOpen</span><span class="p">,</span> <span class="nx">onRequestClose</span><span class="p">,</span> <span class="nx">contentLabel</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span> <span class="c1">// 👀</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">contentLabel</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>...모달내용...<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onRequestClose</span><span class="si">}</span><span class="p">&gt;</span>닫기<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span> // 👀
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>에러가 발생한 포인트는 props전달 과정에 있다. props전달 과정에서 어떤 일이 발생하길래 서버 ↔️ 클라이언트 컴포넌트 간 props를 전달 할 수 없는 것일까?</p>

<h3 id="2-함수-직렬화가-무엇이지--서버-️-클라이언트-컴포넌트-간-props를-전달할-때-발생하는-일">2. 함수 직렬화가 무엇이지? | 서버 ↔️ 클라이언트 컴포넌트 간 props를 전달할 때 발생하는 일</h3>

<blockquote>
  <p>If you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server to Client Components need to be serializable by React. by. NEXT JS 공식문서</p>
</blockquote>

<p>공식문서에서도 서버 컴포넌트가 클라이언트 컴포넌트로 데이터를 props형태로 전달할때 리액트에 의해 직렬화(serializable)되어야 한다고 말한다.</p>

<p>💡 함수 직렬화란?<br />
함수를 <strong>문자열로 변환</strong>하여 데이터를 직렬화하는 과정을 뜻한다. 자바스크립트에서는 데이터를 JSON형태로 변환하는 것을 직렬화한다고 한다.</p>

<p>하지만 NEXT JS에서 서버 컴포넌트에서 클라이언트 컴포넌트로 데이터를 전달할 때 JSON으로 직렬화되지 않고 React.Element로 전달한다. <br />
전달된 React.Elements는 리액트 컴포넌트를 표현하는 객체로, JS 기본 데이터 형식 이외에도 React에 특화된 데이터를 포함하고 있다.</p>

<p>다시 한번 문제를 정리하자면 다음과 같다.</p>

<ol>
  <li>하위 컴포넌트가 이벤트 함수를 props로 전달받아 클라이언트 컴포넌트로 자동 전환되었다.</li>
  <li>컴포넌트간 데이터를 전달할 때는 직렬화 과정이 필요한데, 이때 서버 컴포넌트에서 클라이언트 컴포넌트로 props로 전달된 데이터는 직렬화 과정을 거치지 않는다.</li>
  <li>이 데이터는 JSON으로 직렬화 되지 않고, React.Elements로 전달되기 때문이다.</li>
</ol>

<p>이 문제를 해결하는 데에 여러 방법이 있다.</p>

<h2 id="-문제-해결">🔨 문제 해결</h2>

<h3 id="1-클라이언트-️-클라이언트-구조-만들기">1. 클라이언트 ↔️ 클라이언트 구조 만들기</h3>

<p>서버 컴포넌트 ↔️ 클라이언트 컴포넌트 구조가 문제라면, ㅊ 구조로 바꾸는 것은 어떨까?</p>

<p>이 때 사용되는 명령어는 다음과 같다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">use client</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>상위 컴포넌트 파일 상단에 이 명령어를 추가하면 클라이언트 컴포넌트로 선언된다. 여기서 구분을 명확하게 하기 위해 파일 이름도 바꾸어 주면 좋다.</p>

<p><code class="language-plaintext highlighter-rouge">MyModal.tsx</code> -&gt; <code class="language-plaintext highlighter-rouge">MyModal.client.tsx</code></p>

<p>여기서 또 궁금점이 생겼다.</p>

<p>NEXT JS에서 상위 컴포넌트가 클라이언트 컴포넌트라면 하위 컴포넌트는 모두 클라이언트로 설정된다. 이 프로젝트의 가장 상위 컴포넌트인 <code class="language-plaintext highlighter-rouge">Page.tsx</code>에 <code class="language-plaintext highlighter-rouge">use client</code>를 추가했는데, 이러면 NEXT JS 프레임워크를 사용하는 것이 의미가 있을까?</p>

<p>공식문서에 따르면 이를 해결하기 위해 react-query 같은 third-party 라이브러리 사용을 권장한다. 하지만 프로젝트가 작고 상태관리 라이브러리가 굳이 필요하지 않다면 라이브러리를 추가하지 않고 이벤트 핸들러를 props로 전달하는 경우를 최대한 지양하는 편이 좋다는 생각이 들었다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li>
    <p><a href="https://stackoverflow.com/questions/76948441/passing-props-to-onclick-from-server-to-client-component-in-next13">Passing props to onClick from server to client component in Next13</a></p>
  </li>
  <li>
    <p><a href="https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns">Next.js 공식문서 - composition-patterns</a></p>
  </li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="Nextjs" /><category term="nextjs" /><category term="props" /><category term="error" /><category term="함수의 직렬화" /><category term="서버 컴포넌트" /><category term="클라이언트 컴포넌트" /><summary type="html"><![CDATA[Event handlers cannot be passed to Client Component props]]></summary></entry><entry><title type="html">[JavaScript] 모듈 번들러, 웹팩(Webpack)</title><link href="http://localhost:4000/javascript/javascript-webpack/" rel="alternate" type="text/html" title="[JavaScript] 모듈 번들러, 웹팩(Webpack)" /><published>2023-11-08T00:00:00+09:00</published><updated>2023-11-08T22:06:00+09:00</updated><id>http://localhost:4000/javascript/javascript-webpack</id><content type="html" xml:base="http://localhost:4000/javascript/javascript-webpack/"><![CDATA[<h1 id="webpack---js-모듈-번들링-도구">Webpack - JS 모듈 번들링 도구</h1>

<p>보통 CRA 또는 CNA로만 프로젝트를 빌드해왔기 때문에 “번들링”이라는 개념을 몰라도 프로젝트를 진행하는데 문제가 없었다. 최근 최적화에 관심을 가지게 되면서 평소에 그냥 지나쳤던 웹팩에 대해 관심을 가지게 되었고, 역시 공식문서가 제일 정리가 잘 되어 있다는 것을 알고 전체적으로 읽어 보았다.</p>

<h2 id="-웹팩이란">🟣 웹팩이란?</h2>

<p>웹팩은 <strong>자바스크립트 모듈 번들러</strong>이다.그렇다면 모듈과 번들링의 의미는 무엇일까.</p>

<ul>
  <li>모듈: 프로그래밍 관점에서 특정 기능을 갖는 가장 작은 단위.</li>
  <li>번들링: 웹 애플리케이션을 구성하는 자원을 하나의 파일로 병합, 압축하는 과정</li>
</ul>

<p>즉, 웹팩이 하는 일은 특정 기능을 가지는 작은 코드 뭉치를 하나의 파일로 병합하는 것이다.</p>

<h3 id="웹팩-사용-이유">웹팩 사용 이유</h3>

<ol>
  <li>파일 단위로 변수를 관리할 수 있다. <br />
웹팩은 자바스크립트 파일을 모듈로 관리한다. 모듈로 관리하지 않으면 두개의 파일에서 전역으로 선언된 변수 <code class="language-plaintext highlighter-rouge">example</code>이 중복선언되는 일이 생긴다. 웹팩을 사용하면 같은 이름으로 선언된 전역 변수를 다른 취급으로 관리할 수 있다.</li>
  <li>모듈 번들링을 통해 브라우저에서 서버로 요청하는 파일 숫자를 줄일 수 있다.<br />
브라우저에서 서버로 보낼 수 있는 HTTP요청 수는 정해져있다. 모듈 번들링을 통해 HTTP요청을 줄임으로써 사용자 경험을 높일 수 있다.</li>
  <li>웹팩의 code splitting 기능을 통해 동적으로 모듈을 로딩할 수 있다. <br />
자바스크립트 코드가 모듈로 관리되어 있어 필요한 부분만 동적으로 로딩한다.</li>
</ol>

<h2 id="-웹팩-설치하기">🟣 웹팩 설치하기</h2>

<p>기본 프로젝트에 웹팩을 설치하는 방법이다.</p>

<ol>
  <li>webpack 설치</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm init -y
npm install webpack webpack-cli --save-dev
</code></pre></div></div>

<ol>
  <li>index.html 분리
배포코드(<code class="language-plaintext highlighter-rouge">/dist</code>)와 개발자가 작성하는 소스코드(<code class="language-plaintext highlighter-rouge">/src</code>)를 분리하는 작업이다.</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">webpack</span><span class="o">-</span><span class="nx">demo</span>
  <span class="o">|-</span> <span class="kr">package</span><span class="p">.</span><span class="nx">json</span>
  <span class="o">|-</span> <span class="kr">package</span><span class="o">-</span><span class="nx">lock</span><span class="p">.</span><span class="nx">json</span>
 <span class="o">|-</span> <span class="sr">/dis</span><span class="err">t
</span>   <span class="o">|-</span> <span class="nx">index</span><span class="p">.</span><span class="nx">html</span>
  <span class="o">|-</span> <span class="sr">/sr</span><span class="err">c
</span>    <span class="o">|-</span> <span class="nx">index</span><span class="p">.</span><span class="nx">js</span>
</code></pre></div></div>

<ol>
  <li>webpack.config.js 설정</li>
</ol>

<ul>
  <li>번들링된 코드를 <code class="language-plaintext highlighter-rouge">/dist</code> 경로의 <code class="language-plaintext highlighter-rouge">main.js</code>에서 관리</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">path</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="dl">"</span><span class="s2">./src/index.js</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">output</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">filename</span><span class="p">:</span> <span class="dl">"</span><span class="s2">main.js</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">path</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dist</span><span class="dl">"</span><span class="p">),</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>번들링 실행 명령어</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">webpack</span> <span class="o">--</span><span class="nx">config</span> <span class="nx">webpack</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">js</span>
</code></pre></div></div>

<ol>
  <li>package.json 에서 script 명령어 설정</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">webpack-test</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">version</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1.0.0</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">description</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">main</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">index.js</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">scripts</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">test</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">echo </span><span class="se">\"</span><span class="s2">Error: no test specified</span><span class="se">\"</span><span class="s2"> &amp;&amp; exit 1</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">build</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">webpack</span><span class="dl">"</span> <span class="c1">// 👀</span>
  <span class="p">},</span>
  <span class="dl">"</span><span class="s2">keywords</span><span class="dl">"</span><span class="p">:</span> <span class="p">[],</span>
  <span class="dl">"</span><span class="s2">author</span><span class="dl">"</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">license</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ISC</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">devDependencies</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">webpack</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">^5.89.0</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">webpack-cli</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">^5.1.4</span><span class="dl">"</span>
  <span class="p">},</span>
  <span class="dl">"</span><span class="s2">dependencies</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">lodash</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">^4.17.21</span><span class="dl">"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="-웹팩으로-asset-관련-코드-관리하기">🟣 웹팩으로 Asset 관련 코드 관리하기</h2>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://webpack.kr/">웹팩 공식문서</a></li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="Webpack" /><category term="번들링" /><category term="웹팩" /><summary type="html"><![CDATA[웹팩 공식문서 읽고 정리하기]]></summary></entry><entry><title type="html">tailwind를 사용해보자</title><link href="http://localhost:4000/css/css-tailwind-%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="tailwind를 사용해보자" /><published>2023-11-03T00:00:00+09:00</published><updated>2023-11-03T22:06:00+09:00</updated><id>http://localhost:4000/css/css-tailwind%20%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/css/css-tailwind-%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<h2 id="-tailwind란">📝 Tailwind란?</h2>

<ul>
  <li>CSS 프레임워크</li>
  <li>미리 세팅된 유틸리티 클래스 활용</li>
</ul>

<h2 id="-tailwind-사용하기">📝 tailwind 사용하기</h2>

<h3 id="1-설치-및-환경-세팅">1. 설치 및 환경 세팅</h3>

<ul>
  <li>tailwind를 설치한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">install</span> <span class="o">-</span><span class="nx">D</span> <span class="nx">tailwindcss</span>
<span class="nx">npx</span> <span class="nx">tailwindcss</span> <span class="nx">init</span>
</code></pre></div></div>

<ul>
  <li>tailwind.config.js파일에서 경로를 설정한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @type {import('tailwindcss').Config} */</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">content</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">./src/**/*.{html,js}</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">theme</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="p">{},</span>
  <span class="p">},</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>메인 CSS파일에서 tailwind 지시자를 설정한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">tailwind</span> <span class="nx">base</span><span class="p">;</span>
<span class="p">@</span><span class="nd">tailwind</span> <span class="nx">components</span><span class="p">;</span>
<span class="p">@</span><span class="nd">tailwind</span> <span class="nx">utilities</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>CLI도구를 설치해 메인 CSS 파일을 빌드시켜준다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npx</span> <span class="nx">tailwindcss</span> <span class="o">-</span><span class="nx">i</span> <span class="p">.</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">input</span><span class="p">.</span><span class="nx">css</span> <span class="o">-</span><span class="nx">o</span> <span class="p">.</span><span class="o">/</span><span class="nx">dist</span><span class="o">/</span><span class="nx">output</span><span class="p">.</span><span class="nx">css</span> <span class="o">--</span><span class="nx">watch</span>
</code></pre></div></div>

<ul>
  <li>HTML파일에 빌드된 css파일을 연결한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;!</span><span class="nx">doctype</span> <span class="nx">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">head</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">meta</span> <span class="nx">charset</span><span class="o">=</span><span class="dl">"</span><span class="s2">UTF-8</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">meta</span> <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">viewport</span><span class="dl">"</span> <span class="nx">content</span><span class="o">=</span><span class="dl">"</span><span class="s2">width=device-width, initial-scale=1.0</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">link</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">/dist/output.css</span><span class="dl">"</span> <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="sr">/head</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">h1</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">text-3xl font-bold underline</span><span class="dl">"</span><span class="o">&gt;</span>
    <span class="nx">Hello</span> <span class="nx">world</span><span class="o">!</span>
  <span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/html</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="2-vscode에-맞는-에디터-설치하기">2. vsCode에 맞는 에디터 설치하기</h3>

<ul>
  <li>Tailwind CSS IntelliSense
    <ul>
      <li>클래스 이름, css 함수, 지시자 이름 자동 완성</li>
      <li>린팅기능</li>
      <li>호버시 미리보기 기능</li>
    </ul>
  </li>
  <li>Prettier
    <ul>
      <li>prettier는 공식적으로 tailwind css 코드 sorting기능을 제공</li>
    </ul>
  </li>
</ul>

<h3 id="3-element-classname에-스타일-설정하기">3. element className에 스타일 설정하기</h3>

<ul>
  <li>리액트에서 사용할 경우, class가 아닌 className을 사용한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">text-3xl font-bold underline</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">world</span><span class="o">!&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<p><img src="https://github.com/SJ0826/coding-swamp-/assets/56298540/a65faddb-1761-4e8e-b731-a476de915f71" alt="image" /></p>

<hr />

<p>다음에 또 보기 위해 tailwind 사용법을 간단하게 정리했다. 짧게 써보고 남기는 후기는 다음과 같다.</p>

<ul>
  <li>장) 컴포넌트 이름을 신경쓰지 않아도 괜찮다.</li>
  <li>장) 이미 구현된 유틸리티 클래스 덕에 빠른 구현이 가능하다</li>
  <li>단) 아무래도 클래스 이름이 스타일 코드로 인해 길어져 코드가 혼잡해 보인다.</li>
</ul>

<p>사용하며 더 알게 되는 점이나 기록할 부분이 생기면 추가할 예정이다.</p>

<p>부트스트랩도 사용해본 경험이 없어 css framework는 꽤 생소했다. 잘 쓰면 약, 못쓰면 독일테니 적절하게 잘 사용해 퀄리티를 높이는 연습을 해야겠다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://tailwindcss.com/docs/guides/create-react-app">tailwind 공식문서</a></li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="CSS" /><category term="tailwind" /></entry><entry><title type="html">[React] react hook, 언제 사용해야 할까?</title><link href="http://localhost:4000/react/react-react-hook-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C/" rel="alternate" type="text/html" title="[React] react hook, 언제 사용해야 할까?" /><published>2023-09-25T00:00:00+09:00</published><updated>2023-09-25T22:06:00+09:00</updated><id>http://localhost:4000/react/react-react%20hook%20%EC%96%B8%EC%A0%9C%20%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C</id><content type="html" xml:base="http://localhost:4000/react/react-react-hook-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C/"><![CDATA[<h2 id="-react-hook">📄 react hook?</h2>

<p>리액트 훅 (React hook)은 함수형 컴포넌트에서도 클래스형 컴포넌트의 기능을 사용할 수 있게 해주는 기능이다.</p>

<p>자주 사용되는 리액트 훅의 종류는 다음과 같다.</p>

<ul>
  <li>
    <p>useCallback</p>

    <ul>
      <li>의존성 배열안의 인자가 변경될 때까지 함수를 저장</li>
      <li>하위 컴포넌트의 무의미한 렌더링을 방지할 수 있어 유용</li>
    </ul>
  </li>
  <li>
    <p>useMemo</p>

    <ul>
      <li>의존성 배열안의 인자가 변경될 때까지 계산된 값(value) 저장</li>
      <li>매 렌더링마다 복잡한 계산을 해야하는 상황을 피할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>useEffect</p>
    <ul>
      <li>모든 컴포넌트가 렌더링 (처음 렌더링) 된 후, 실행</li>
      <li>의존성 배열안의 인자가 변경될 때마다, 첫번째 인자로 등록된 함수가 실행</li>
    </ul>
  </li>
</ul>

<p>리액트 훅은 매우 유용하지만 데이터를 메모리에 저장하는 메모이제이션 기능을 담당하기 때문에, 무분별하게 사용한다면 <span style="text-decoration: underline">의미없는 메모리 낭비</span>가 발생하게 된다.</p>

<p>리액트 훅을 어느 상황에서 사용하는 것이 적절한 것인지 정리해보았다.</p>

<h2 id="-usecallback--리렌더링될-때마다-함수-호출하기-싫어요">📄 useCallback | 리렌더링될 때마다 함수 호출하기 싫어요</h2>

<ul>
  <li>목적: 함수 생성 최적화</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">useCallback</code>은 함수를 저장하는 리액트 훅이다.</p>

<p>이때 함수를 저장하다는 것은 함수의 실행 여부를 정한다는 뜻이다.</p>

<p>컴포넌트가 리렌더링된다면 그 안에 종속되어 있는 함수는 매번 호출된다. 간단한 함수라면 문제없지만 api를 통해 데이터를 fetching하는 함수라면 의미없는 api 호출이 계속 발생하게 될 수 있다.</p>

<h3 id="-appjs">💾 App.js</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getItem()</code>: 데이터 fetching 함수. List에 props로 전달한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">List</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./List</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">input</span><span class="p">,</span> <span class="nx">setInput</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">light</span><span class="p">,</span> <span class="nx">setLight</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">getItems</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">input</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">input</span> <span class="o">+</span> <span class="mi">100</span><span class="p">];</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">theme</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">backgroundColor</span><span class="p">:</span> <span class="nx">light</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">White</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">grey</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">color</span><span class="p">:</span> <span class="nx">light</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">grey</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">white</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">theme</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span>
          <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">number</span><span class="dl">"</span>
          <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">input</span><span class="p">}</span>
          <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setInput</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">))}</span>
        <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setLight</span><span class="p">((</span><span class="nx">prevLight</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">prevLight</span><span class="p">)}</span><span class="o">&gt;</span>
          <span class="p">{</span><span class="nx">light</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">dark mode</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">light mode</span><span class="dl">"</span><span class="p">}</span>
        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">List</span> <span class="nx">getItems</span><span class="o">=</span><span class="p">{</span><span class="nx">getItems</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="-listjs">💾 List.js</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useEffect</span><span class="p">,</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">List</span><span class="p">({</span> <span class="nx">getItems</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">items</span><span class="p">,</span> <span class="nx">setItems</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Fetching items</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">setItems</span><span class="p">(</span><span class="nx">getItems</span><span class="p">());</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">getItems</span><span class="p">]);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">item</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">item</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">List</span><span class="p">;</span>
</code></pre></div></div>

<p>🔍 문제 상황: theme을 바꾸는 버튼을 눌렀을 때 컴포넌트 리렌더링 -&gt; 매 렌더링마다 <code class="language-plaintext highlighter-rouge">getItem()</code>호출되어 계속되는 무의미한 api 호출 <br /></p>

<p>🔦 해결 방법: useCallback 함수로 <code class="language-plaintext highlighter-rouge">getItem()</code>을 저장해 의존성 배열안의 값이 바뀔 때만 함수가 실행되도록 하자!</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getItems</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">input</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">input</span> <span class="o">+</span> <span class="mi">100</span><span class="p">];</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">input</span><span class="p">]);</span>
</code></pre></div></div>

<p>useCallback함수로 <code class="language-plaintext highlighter-rouge">getItem()</code>는 input값이 변경될 때만 호출되어 무의미한 data fetching을 없애 주었다.</p>

<h2 id="-usememo--stateful한-값이-변경될-때마다-발생하는-리렌더링을-막고-싶어요">📄 useMemo | stateful한 값이 변경될 때마다 발생하는 리렌더링을 막고 싶어요</h2>

<ul>
  <li>목적: 값 계산 최적화</li>
</ul>

<h3 id="-mycomponentjs">💾 MyComponent.js</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">number</span> <span class="o">=</span> <span class="nx">verySlowFunction</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">number</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="kd">function</span> <span class="nx">verySlowFunction</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span><span class="nx">heavy</span> <span class="nx">work</span> <span class="nx">done</span> <span class="nx">here</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>🔍 문제 상황: MyComponent가 호출될 때마다, <code class="language-plaintext highlighter-rouge">verySlowFunction()</code>가 호출</p>

<p>🔦 해결 방법: useState 값을 저장해 무의미한 컴포넌트 호출을 막을 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kd">const</span> <span class="nx">number</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">verySlowFunction</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="p">},</span> <span class="p">[</span><span class="nx">data</span><span class="p">]);</span>

	<span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">number</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="kd">function</span> <span class="nx">verySlowFunction</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span><span class="nx">heavy</span> <span class="nx">work</span> <span class="nx">done</span> <span class="nx">here</span>
	<span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<hr />

<p>useCallback 과 useMemo는 리액트 컴포넌트 내에서 렌더링과 관련된 함수와 값의 최적화를 달성하기 위해 사용된다.
이로써 불필요한 렌더링을 방지하고 애플리케이션의 성능을 향상 시킬 수 있다.
목적은 의존성 배열을 올바르게 설정하여 효율적인 최적화를 도출하는 것이다.
하지만 무작정 사용하는 것보다 “왜” 사용하는지를 중요시하며, 무의미한 메모리 낭비를 줄이기 위해 신중하게 확인해야 한다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://www.geeksforgeeks.org/when-to-use-usecallback-usememo-and-useeffect/">When to use useCallback, useMemo and useEffect?</a></li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="React" /><category term="useEffect" /><category term="useCallback" /><category term="useMemo" /><summary type="html"><![CDATA[react hook을 사용하는 본격적인 이유]]></summary></entry><entry><title type="html">[Next.js] Next.js 13.5 update!</title><link href="http://localhost:4000/nextjs/nextjs-nextjs-13.5-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/" rel="alternate" type="text/html" title="[Next.js] Next.js 13.5 update!" /><published>2023-09-20T00:00:00+09:00</published><updated>2023-09-21T22:06:00+09:00</updated><id>http://localhost:4000/nextjs/nextjs-nextjs%2013.5%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/nextjs/nextjs-nextjs-13.5-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/"><![CDATA[<h2 id="-nextjs-135-realize">📄 Next.js 13.5 realize!</h2>

<p>Next.js 13.5 버전이 릴리즈 되었다.</p>

<p>어떤 기능이 향상되었는지 확인 겸 정리한다.</p>

<h3 id="1-시작-및-새로고침-시간-단축">1. 시작 및 새로고침 시간 단축</h3>

<ul>
  <li>로컬 서버 시작 시간 22% 단축</li>
  <li>HMR 시간 29% 단축</li>
  <li>메모리 사용량 40% 감소</li>
</ul>

<blockquote>
  <p>💡 HMR(Hot Module Replacement)? 브라우저를 새로고침하지 않아도 Webpack으로 빌드한 결과물이 웹 애플리케이션에 실시간으로 반영</p>
</blockquote>

<h3 id="2-nextimage-기능-향상">2. next/image 기능 향상</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unstable_getImgProps</code> 함수 추가</li>
</ul>

<p>기존에 next/image 를 사용하려면 <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 컴포넌트를 사용해야했다. 이번 업데이트 버전에 따르면 <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 컴포넌트를 사용하지 않아도, 이미지를 렌더링 할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">unstable_getImgProps</span> <span class="k">as</span> <span class="nx">getImgProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">common</span> <span class="o">=</span> <span class="p">{</span> <span class="na">alt</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hero</span><span class="dl">"</span><span class="p">,</span> <span class="na">width</span><span class="p">:</span> <span class="mi">800</span><span class="p">,</span> <span class="na">height</span><span class="p">:</span> <span class="mi">400</span> <span class="p">};</span>
  <span class="kd">const</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="na">srcSet</span><span class="p">:</span> <span class="nx">dark</span> <span class="p">},</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nx">getImgProps</span><span class="p">({</span> <span class="p">...</span><span class="nx">common</span><span class="p">,</span> <span class="na">src</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/dark.png</span><span class="dl">"</span> <span class="p">});</span>
  <span class="kd">const</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="na">srcSet</span><span class="p">:</span> <span class="nx">light</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span> <span class="p">},</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nx">getImgProps</span><span class="p">({</span> <span class="p">...</span><span class="nx">common</span><span class="p">,</span> <span class="na">src</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/light.png</span><span class="dl">"</span> <span class="p">});</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">picture</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">source</span> <span class="nx">media</span><span class="o">=</span><span class="dl">"</span><span class="s2">(prefers-color-scheme: dark)</span><span class="dl">"</span> <span class="nx">srcSet</span><span class="o">=</span><span class="p">{</span><span class="nx">dark</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">source</span> <span class="nx">media</span><span class="o">=</span><span class="dl">"</span><span class="s2">(prefers-color-scheme: light)</span><span class="dl">"</span> <span class="nx">srcSet</span><span class="o">=</span><span class="p">{</span><span class="nx">light</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">img</span> <span class="p">{...</span><span class="nx">rest</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/picture</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p>이 외에도 Import 최적화 등 자잘한 업데이트 사항이 있지만, 이 두가지가 가장 크게 눈에 들어왔다.</p>

<p>더 확실한건 vercel이 page 라우팅 보다 app 라우팅에 중점을 두고 업데이트를 진행했다는 느낌을 받았다.</p>

<p>app 라우팅의 사용량도 점점 늘고 있는만큼 app 라우팅 기능을 잘 활용할 수 있도록 꾸준히 사용해 보아야겠다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://dev-redcat.tistory.com/12">Next.js란?</a></li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="Nextjs" /><category term="nextjs" /><category term="업데이트" /><summary type="html"><![CDATA[Next.js 13.5 버전에서 어떤 부분이 달라졌을까?]]></summary></entry><entry><title type="html">[React] return null vs return false</title><link href="http://localhost:4000/react/react-return-null-%EA%B3%BC-false%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/" rel="alternate" type="text/html" title="[React] return null vs return false" /><published>2023-09-18T00:00:00+09:00</published><updated>2023-09-18T22:06:00+09:00</updated><id>http://localhost:4000/react/react-return%20null%20%EA%B3%BC%20false%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90</id><content type="html" xml:base="http://localhost:4000/react/react-return-null-%EA%B3%BC-false%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/"><![CDATA[<h2 id="-return-null-vs-return-false">📄 return null vs return false</h2>

<p>지금까지 진행했던 프로젝트에서 자바스크립트는 null을 false로 인식해 boolean 체킹을 하기 때문에, boolean타입으로 형변환을 거치지 않고 그대로 null를 반환해서 사용했다.</p>

<p>하지만 리액트의 성능 최적화를 고려한다면, 이 둘을 명확히 구분해서 사용할 필요가 있다.</p>

<h3 id="-null-보다는-false를-사용하자">✅ null 보다는 false를 사용하자!</h3>

<p>null과 false를 반환하는 것에 대한 차이점을 바로 말하자면, <span style="color: #FAAB78; font-weight: bold">리렌더링의 유무</span>이다.</p>

<p>리액트는 null를 유효한 값으로 취급한다.</p>

<p>이말인 즉슨 리액트의 가상 돔이 null을 인식하여 null을 반환하는 하위 컴포넌트를 가진 컴포넌트들이 강제로 리렌더링 된다는 뜻이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Child</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Child rendered</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;-&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="p">{</span><span class="nx">count</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;+&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>하위 컴포넌트인 Children이 null을 반환할 때, 상위 컴포넌트인 Parent가 강제로 리렌더링 된다.</li>
</ul>

<p>이 현상을 방지하기 위한 방법이 false를 반환하는 것이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Child</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Child rendered</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;-&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="p">{</span><span class="nx">count</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;+&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>하위 컴포넌트인 Children이 false를 반환할 때, 상위 컴포넌트인 Parent가 리렌더링 되지 않는다.</li>
</ul>

<p>리액트의 가상돔이 false를 인식하지 않기 떄문에, 상위 컴포넌트에서 리렌더링이 발생하지 않는다는 것을 알 수 있다.</p>

<h2 id="-정리">📄 정리</h2>

<table>
  <thead>
    <tr>
      <th>return</th>
      <th style="text-align: center">null</th>
      <th style="text-align: center">false</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>차이점</td>
      <td style="text-align: center">상위 컴포넌트 리렌더링 O</td>
      <td style="text-align: center">상위 컴포넌트 리렌더링 X</td>
    </tr>
  </tbody>
</table>

<p>비지니스로직이 아닌 뷰로직으로서 <span style="color: #FAAB78; font-weight: bold">아무것도 반환하지 않겠다</span>는 뜻으로 사용할 때는<span style="color: #FAAB78; font-weight: bold"> false</span>를 사용해 리렌더링을 방지할 수 있다.</p>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://medium.com/@davidkelley87/stop-using-return-null-in-react-a2ebf08fc9cd">stop using “return null” in React</a></li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="React" /><category term="null" /><category term="false" /><category term="return" /><summary type="html"><![CDATA[null 과 false를 반환하는 것에 대한 차이점]]></summary></entry><entry><title type="html">[JavaScript] 내쓰내정 카카오톡 api 사용 후기 및 정리</title><link href="http://localhost:4000/javascript/nextjs-%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-api-%EC%82%AC%EC%9A%A9-%ED%9B%84%EA%B8%B0/" rel="alternate" type="text/html" title="[JavaScript] 내쓰내정 카카오톡 api 사용 후기 및 정리" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T22:06:00+09:00</updated><id>http://localhost:4000/javascript/nextjs-%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1%20api%20%EC%82%AC%EC%9A%A9%20%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/javascript/nextjs-%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-api-%EC%82%AC%EC%9A%A9-%ED%9B%84%EA%B8%B0/"><![CDATA[<h2 id="-사용한-카카오톡-api">📄 사용한 카카오톡 api</h2>

<p>프로젝트를 진행하며 카카오톡 api를 사용했다. 주 기능은 <strong>공유하기</strong> 기능과 <strong>카카오 싱크</strong>. 깃허브 로그인은 구현한적이 있는데 기록을 안해서 기억이 하나도 안나더랬다. 그래서 이번엔 또 같은 어려움을 겪기 전에 그리고 또 까먹기 전에 기록한다.</p>

<h2 id="-카카오톡-api를-사용하며-내가-겪었던-삽질들">📄 카카오톡 api를 사용하며 내가 겪었던 삽질들</h2>

<h3 id="1-환경별로-env파일을-따로-관리하자">1. 환경별로 <code class="language-plaintext highlighter-rouge">.env</code>파일을 따로 관리하자</h3>

<p>이번 프로젝트를 진행한 브랜치는 세가지였다.</p>

<ol>
  <li>main</li>
  <li>dev</li>
  <li>test</li>
</ol>

<p>각 브랜치에서 사용한 환경변수는 다음과 같다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">NEXT_PUBLIC_KAKAO_REST_API_KEY</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">비밀이지롱</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">NEXT_PUBLIC_KAKAO_REDIRECT_URL</span> <span class="o">=</span>
  <span class="dl">"</span><span class="s2">http://localhost:3000/카카오 로그인성공하면 이동할 리다이렉트 페이지</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">NEXT_PUBLIC_API_BASE_URL</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">비밀이지롱</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">NEXT_PUBLIC_JS_API_KEY</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">비밀이지롱</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>⭐️ <strong>브랜치별로 사용하는 uri</strong>가 다르기 때문에 리다이렉트 uri를 다르게 관리해야한다.</p>

<ol>
  <li>
    <p>카카오톡에 등록한 uri 주소로 리다이렉트 해야하기 때문에 배포되는 브랜치 작업의 주소를 기준으로 환경변수를 설정한다.</p>
  </li>
  <li>
    <p>카카오톡 로그인 페이지에서 로그인에 성공하면 등록한 리다이렉트 페이지로 이동하는데 이때 쿼리로 <code class="language-plaintext highlighter-rouge">auth code</code>를 받는다.</p>
  </li>
  <li>
    <p>프론트는 이 <code class="language-plaintext highlighter-rouge">auth code</code>를 백엔드에게 보내고 나머지 로직 (home으로 이동 등)을 리다이렉트 페이지에 작성해서 로그인 과정을 진행한다.</p>
  </li>
  <li>
    <p>백엔드는 받은 <code class="language-plaintext highlighter-rouge">auth code</code>로 token을 요청하는데 이때 로그인페이지로 라우팅될 때 사용한 리다이렉트 uri가 같아야 한다.</p>
  </li>
</ol>

<h3 id="2-authorization-code-not-found-for-code-500-error">2. authorization code not found for code (500 Error)</h3>

<p>카카오톡에서 날려주는 500 error.</p>

<p>⭐️ 이 에러가 발생한 이유는 <strong>동일한 인증코드를 여러번 사용</strong>했기 때문이다.</p>

<p>앞서 사용한 <code class="language-plaintext highlighter-rouge">auth code</code>를 두번이상 사용하면 카카오는 500에러를 전송한다.</p>

<p>이때 아마 로그인 요청이 두번 가게되어 에러가 발생했는데 꽤나 고생했던 것 같다.</p>

<h2 id="-마무리">📄 마무리</h2>

<p>처음 사용하면서 봤을 때는 꽤 어려웠는데 정리하다보니 생각보다 별거 아닌 것 같아서 괜히 허무한 것 같다.</p>

<p>카카오 공식문서 짱~</p>]]></content><author><name>수진‍ (水珍)</name></author><category term="JavaScript" /><category term="카카오톡" /><category term="API" /><summary type="html"><![CDATA[카카오톡 api를 사용하며 헷갈렸던 점들]]></summary></entry><entry><title type="html">[React] React Portal</title><link href="http://localhost:4000/react/react-react-portal/" rel="alternate" type="text/html" title="[React] React Portal" /><published>2023-06-14T00:00:00+09:00</published><updated>2023-06-14T22:06:00+09:00</updated><id>http://localhost:4000/react/react-react%20portal</id><content type="html" xml:base="http://localhost:4000/react/react-react-portal/"><![CDATA[<h2 id="️-react-potal-이란">🗒️ React Potal 이란?</h2>

<ul>
  <li>다른 곳에 있는 element를 렌더링할 수 있다.</li>
  <li>컴포넌트가 종속되어 있는 돔 트리를 벗어나 외부의 다른 돔으로 렌더한다. (어플리케이션은 하나지만 부분적으로 다른 돔에 마운트)</li>
</ul>

<h2 id="️-usemodal-hook">🗒️ useModal hook</h2>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useEffect</span><span class="p">,</span> <span class="nx">useRef</span><span class="p">,</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createPortal</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-dom</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">styled</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">styled-components</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">useModal</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">modalOpened</span><span class="p">,</span> <span class="nx">setModalOpened</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">openModal</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setModalOpened</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">closeModal</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setModalOpened</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kr">interface</span> <span class="nx">IProps</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="na">ModalPortal</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">FC</span><span class="o">&lt;</span><span class="nx">IProps</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">Element</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">mounted</span><span class="p">,</span> <span class="nx">setMounted</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

    <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setMounted</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">document</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// dom에 root-modal이 있으면 가져오기</span>
        <span class="kd">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#root-modal</span><span class="dl">"</span><span class="p">);</span>
        <span class="nx">ref</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="p">[]);</span> <span class="c1">// mount</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">ref</span><span class="p">.</span><span class="nx">current</span> <span class="o">&amp;&amp;</span> <span class="nx">mounted</span> <span class="o">&amp;&amp;</span> <span class="nx">modalOpened</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">createPortal</span><span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">Container</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">div</span>
            <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">modal-background</span><span class="dl">"</span>
            <span class="nx">role</span><span class="o">=</span><span class="dl">"</span><span class="s2">presentation</span><span class="dl">"</span>
            <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">closeModal</span><span class="p">}</span>
          <span class="sr">/</span><span class="err">&gt;
</span>          <span class="p">{</span><span class="nx">children</span><span class="p">}</span>
        <span class="o">&lt;</span><span class="sr">/Container&gt;</span><span class="err">,
</span>        <span class="nx">ref</span><span class="p">.</span><span class="nx">current</span>
      <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">openModal</span><span class="p">,</span>
    <span class="nx">closeModal</span><span class="p">,</span>
    <span class="nx">ModalPortal</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">useModal</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Container</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 11;
  .modal-background {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
  }
`</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="️-usemodal-hook-사용하기">🗒️ useModal hook 사용하기</h2>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">styled</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">styled-components</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">AirbnbLogoIcon</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../public/static/svg/logo/logo.svg</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">AirbnbLogoTextIcon</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../public/static/svg/logo/logo_text.svg</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Link</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/link</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">palette</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../styles/palette</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">useModal</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../hooks/useModal</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">SignUpModal</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./auth/SignUpModal</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Header</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">FC</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">openModal</span><span class="p">,</span> <span class="nx">ModalPortal</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useModal</span><span class="p">();</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Container</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Link</span> <span class="nx">href</span><span class="o">=</span><span class="p">{</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">header-logo-wrapper</span><span class="dl">"</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">AirbnbLogoIcon</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">header-logo</span><span class="dl">"</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">AirbnbLogoTextIcon</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Link</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">header-auth-buttons</span><span class="dl">"</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span>
          <span class="kd">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">button</span><span class="dl">"</span>
          <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">header-sign-up-button</span><span class="dl">"</span>
          <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">openModal</span><span class="p">}</span>
        <span class="o">&gt;</span>
          <span class="nx">회원가입</span>
        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="kd">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">button</span><span class="dl">"</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">header-login-button</span><span class="dl">"</span><span class="o">&gt;</span>
          <span class="nx">로그인</span>
        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">ModalPortal</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">SignUpModal</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="sr">/ModalPortal</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Container</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Header</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Container</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  position: sticky;
  top: 0;
  width: 100%;
  height: 80px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 80px;
  background-color: white;
  box-shadow: rgba(0, 0, 0, 0.08) 0px 1px 12px;
  z-index: 10;
  .header-logo-wrapper {
    display: flex;
    align-items: center;
    .header-logo {
      margin-right: 6px;
    }
  }

  .header-auth-buttons {
    .header-sign-up-button {
      height: 42px;
      margin-right: 8px;
      padding: 0 16px;
      border: 0;
      border-radius: 21px;
      background-color: white;
      cursor: pointer;
      outline: none;
      &amp;:hover {
        background-color: </span><span class="p">${</span><span class="nx">palette</span><span class="p">.</span><span class="nx">gray_f7</span><span class="p">}</span><span class="s2">;
      }
    }
    .header-login-button {
      height: 42px;
      padding: 0 16px;
      border: 0;
      box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.18);
      border-radius: 21px;
      background-color: white;
      cursor: pointer;
      outline: none;
      :hover {
        box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.12);
      }
    }
  }
`</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="참고">참고</h2>

<ul>
  <li>클론 코딩으로 시작하는 Next.js</li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="React" /><category term="portal" /><category term="modal" /><summary type="html"><![CDATA[리액트 포탈을 사용한 모달 관리법]]></summary></entry><entry><title type="html">[React] forwardRef로 부모컴포넌트에서 자식컴포넌트 DOM에 접근하기</title><link href="http://localhost:4000/react/react-fowardRef%EB%A1%9C-%EB%B6%80%EB%AA%A8%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-DOM%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[React] forwardRef로 부모컴포넌트에서 자식컴포넌트 DOM에 접근하기" /><published>2023-06-01T00:00:00+09:00</published><updated>2023-06-01T22:06:00+09:00</updated><id>http://localhost:4000/react/react-fowardRef%EB%A1%9C%20%EB%B6%80%EB%AA%A8%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C%20%EC%9E%90%EC%8B%9D%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%20DOM%EC%97%90%20%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/react-fowardRef%EB%A1%9C-%EB%B6%80%EB%AA%A8%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-DOM%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-리액트-폼-관리하기">📄 리액트 폼 관리하기</h2>

<p>하나의 폼을 관리할 때 input이 각각 파일로 나뉘어져 있다면 관리할 수 있는 방법은 여러가지가 있다.</p>

<ol>
  <li>부모-자식 컴포넌트간 통신</li>
  <li>상태 관리 라이브러리 사용</li>
  <li>Context API 사용</li>
  <li>폼 라이브러리 사용</li>
</ol>

<p>원래는 상태 관리 라이브러리로 form을 관리했지만 해당 state를 구독하는 컴포넌트가 타이핑마다 리렌더링되어 비효율적이라는 생각이 들었다.</p>

<p>그래서 다른 방법이 있나 찾아보던 중 <code class="language-plaintext highlighter-rouge">forwardRef</code>라는 react 훅을 알게 되었다.</p>

<h2 id="-forwardref를-써보자">📄 forwardRef를 써보자</h2>

<ul>
  <li>
    <p>역할: 부모컴포넌트가 자녀 컴포넌트에 ref를 전달할 수 있다.</p>
  </li>
  <li>
    <p>사용법: 자식 컴포넌트를 forwardRef로 감싸준다.</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">inputRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">();</span>

<span class="kd">const</span> <span class="nx">focus</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">inputRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">MyInput</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">inputRef</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">focus</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">포커스</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Input</span> <span class="o">=</span> <span class="p">(</span><span class="nx">ref</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">ref</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span><span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">forwardRef</span><span class="p">(</span><span class="nx">MyInput</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="-주의할-점">📄 주의할 점</h3>

<p>자녀 컴포넌트가 가진 DOM노드를 외부로 노출시키는 일이므로 캡슐화를 방해할 수 있다.</p>

<p>필요하다면 사용하지만 굳이 필요없다면 최선책으로 사용할만한 방법은 아니다.</p>

<h2 id="출처">출처</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=LtYzjv2yXHE&amp;list=PLZ5oZ2KmQEYjVH2ie-sZJnbEE6B-uCVIh&amp;index=6">별코딩 Youtube - React의 ForwardRef란?</a></li>
</ul>]]></content><author><name>수진‍ (水珍)</name></author><category term="React" /><category term="forwardRef" /><summary type="html"><![CDATA[각각 파일로 나뉘어져 있는 input을 어떻게 관리하면 좋을까]]></summary></entry></feed>