<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-13T10:18:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sometimes we fall, then we rise ⛵</title><subtitle>프론트엔드 엔지니어가 되기까지</subtitle><author><name>Sujin Kim</name></author><entry><title type="html">[프로그래머스 / Lv 1] 나누어 떨어지는 숫자 배열 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 나누어 떨어지는 숫자 배열 by JS" /><published>2023-04-13T00:00:00+09:00</published><updated>2023-04-13T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4%20%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94%20%EC%88%AB%EC%9E%90%20%EB%B0%B0%EC%97%B4</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.
divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.</p>

<ul>
  <li>arr은 자연수를 담은 배열입니다.</li>
  <li>정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.</li>
  <li>divisor는 자연수입니다.</li>
  <li>array는 길이 1 이상인 배열입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="nx">divisor</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="nx">answer</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span> <span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>filter 메소드로 <code class="language-plaintext highlighter-rouge">divisor</code>로 나누어 떨어지는 수를 배열 <code class="language-plaintext highlighter-rouge">answer</code>에 담는다.</li>
  <li><code class="language-plaintext highlighter-rouge">answer</code>의 길이가 0이면 [-1], 0이 아니면 true를 반환하므로 <code class="language-plaintext highlighter-rouge">answer</code>을 오름차순한 값을 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">_</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="p">(</span><span class="nx">e</span> <span class="o">%</span> <span class="nx">divisor</span><span class="p">));</span>
  <span class="k">return</span> <span class="nx">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">?</span> <span class="nx">_</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">$</span> <span class="o">-</span> <span class="nx">_</span><span class="p">)</span> <span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>filter연산을 좀더 간소화한 풀이입니다. 👍</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="" /><summary type="html"><![CDATA[프로그래머스 Lv 1 나누어 떨어지는 숫자 배열 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 서울에서 김서방 찾기</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 서울에서 김서방 찾기" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C%20%EA%B9%80%EC%84%9C%EB%B0%A9%20%EC%B0%BE%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>String형 배열 seoul의 element중 “Kim”의 위치 x를 찾아, “김서방은 x에 있다”는 String을 반환하는 함수, solution을 완성하세요. seoul에 “Kim”은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.</p>

<ul>
  <li>seoul은 길이 1 이상, 1000 이하인 배열입니다.</li>
  <li>seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다.</li>
  <li>“Kim”은 반드시 seoul 안에 포함되어 있습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">seoul</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`김서방은 </span><span class="p">${</span><span class="nx">seoul</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="dl">"</span><span class="s2">Kim</span><span class="dl">"</span><span class="p">)}</span><span class="s2">에 있다`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>배열 내장 메소드인 <code class="language-plaintext highlighter-rouge">indexOf()</code>를 사용했습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="indexOf" /><summary type="html"><![CDATA[프로그래머스 Lv 1 서울에서 김서방 찾기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 최소직사각형 by JS</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 최소직사각형 by JS" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C%20%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%B5%9C%EC%86%8C-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.</p>

<p>아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.</p>

<p>명함 번호 가로 길이 세로 길이</p>

<ul>
  <li>1 60 50</li>
  <li>2 30 70</li>
  <li>3 60 30</li>
  <li>4 80 40</li>
</ul>

<p>가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.</p>

<p>모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.</p>

<ul>
  <li>sizes의 길이는 1 이상 10,000 이하입니다.
    <ul>
      <li>sizes의 원소는 [w, h] 형식입니다.</li>
      <li>w는 명함의 가로 길이를 나타냅니다.</li>
      <li>h는 명함의 세로 길이를 나타냅니다.</li>
      <li>w와 h는 1 이상 1,000 이하인 자연수입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sortedSizes</span> <span class="o">=</span> <span class="nx">sizes</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">arr</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">));</span> <span class="c1">// 1</span>
  <span class="kd">let</span> <span class="nx">card</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">sizes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">?</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">?</span> <span class="nx">sortedSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">card</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 3</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 배열 <code class="language-plaintext highlighter-rouge">sizes</code>를 순회하여 가로길이에 더 큰 값이 가도록 정렬한다.</li>
  <li>정렬한 배열 <code class="language-plaintext highlighter-rouge">sortedSizes</code>를 반복문을 돌려 가로, 세로 각 최댓값을 구한다.</li>
  <li>구한 최댓값끼리 곱해 답을 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">rotated</span> <span class="o">=</span> <span class="nx">sizes</span><span class="p">.</span><span class="nf">map</span><span class="p">(([</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">w</span> <span class="o">&lt;</span> <span class="nx">h</span> <span class="p">?</span> <span class="p">[</span><span class="nx">h</span><span class="p">,</span> <span class="nx">w</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">]));</span>

  <span class="kd">let</span> <span class="nx">maxSize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
  <span class="nx">rotated</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(([</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">w</span> <span class="o">&gt;</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">maxSize</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>비슷한 방식으로 풀었지만 개인적으로 삼항연산자보다 if문을 사용한게 더 깔끔하다고 느꼈습니다.</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="완전 탐색" /><summary type="html"><![CDATA[프로그래머스 Lv 1 최소직사각형 찾기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 짝지어 제거하기 by JS</title><link href="http://localhost:4000/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 짝지어 제거하기 by JS" /><published>2023-04-11T00:00:00+09:00</published><updated>2023-04-11T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4%20%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EC%A7%9D%EC%A7%80%EC%96%B4-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.</p>

<p>예를 들어, 문자열 S = baabaa 라면</p>

<p>b aa baa → bb aa → aa →</p>

<p>의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.</p>

<ul>
  <li>문자열의 길이 : 1,000,000이하의 자연수</li>
  <li>문자열은 모두 소문자로 이루어져 있습니다.</li>
</ul>

<h2 id="️-나의-풀이-1">🙋‍♀️ 나의 풀이 1</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">s</span><span class="p">];</span> <span class="c1">// 0</span>
  <span class="nf">while </span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1</span>
    <span class="nx">arr</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span>
      <span class="c1">// 2</span>
      <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 3</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 문자열을 배열 <code class="language-plaintext highlighter-rouge">arr</code>로 바꾼다.</li>
  <li>while문 배열의 길이가 0이될 때까지 반복한다.</li>
  <li>배열 요소의 앞 뒤 인덱스가 모두 다른 것만 남도록 조건을 주어 <code class="language-plaintext highlighter-rouge">arr</code>를 바꿔준다.</li>
  <li>만약 바꾼 <code class="language-plaintext highlighter-rouge">arr</code>의 길이와 처음 주어진 문자열 <code class="language-plaintext highlighter-rouge">s</code>의 길이가 같다면 반복문을 나온다.</li>
  <li><code class="language-plaintext highlighter-rouge">arr</code>의 값이 있으면 0 없으면 1을 반환한다.</li>
</ol>

<p>이 코드는 문제가 있습니다.</p>

<p>O(N^2)의 시간복잡도를 가지고 있어 몇개의 테스트코드를 통과하지 못했습니다.</p>

<p>좀 더 나은 시간복잡도를 내기 위해 스택개념을 사용해보기로 했습니다.</p>

<h2 id="️-나의-풀이-2">🙋‍♀️ 나의 풀이 2</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>문자열 s를 순서대로 stack에 넣는다.</li>
  <li>만약 들어온 문자열이 중복으로 또 들어오면 내보낸다. <code class="language-plaintext highlighter-rouge">pop() pop()</code>!!!</li>
</ol>

<p>다른 풀이를 보니 모두 스택 개념을 적용했네요.</p>

<p>스택을 이용해 푸니 시간복잡도가 O(N)이 되어 모든 테스트코드를 통과할 수 있었습니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="스택" /><summary type="html"><![CDATA[프로그래머스 Lv 2 짝지어 제거하기 찾기 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 위장</title><link href="http://localhost:4000/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 위장" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-04-10T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EC%9C%84%EC%9E%A5/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.</p>

<p>예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.</p>

<p>스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.</li>
  <li>스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.</li>
  <li>같은 이름을 가진 의상은 존재하지 않습니다.</li>
  <li>clothes의 모든 원소는 문자열로 이루어져 있습니다.</li>
  <li>모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.</li>
  <li>스파이는 하루에 최소 한 개의 의상은 입습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">clothes</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">clothesMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">();</span> <span class="c1">// 1</span>
  <span class="nx">clothes</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">clothesMap</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nx">clothesMap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="p">});</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">cloth</span><span class="p">,</span> <span class="nx">num</span><span class="p">]</span> <span class="k">of</span> <span class="nx">clothesMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span> <span class="o">*=</span> <span class="nx">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 3</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이번 문제는 해시 개념을 이용한 문제입니다.</p>

<ul>
  <li>각 (옷의 종류가 가진 옷의 개수 +1)를 곱해서 답을 구한다. +1은 해당 옷을 입지 않았을 때의 경우이다.</li>
  <li>스파이는 하루 최소 한개의 의상을 입으므로 모든 옷을 입지 않았을 경우(-1)를 빼준다.</li>
</ul>

<p>예전에 풀었던 [완주하지 못한 선수]를 풀 때 봤던 <code class="language-plaintext highlighter-rouge">map()</code>메소드를 사용해보았습니다.</p>

<ol>
  <li>주어진 의상을 의상별로 정리할 데이터를 담을 Map 객체(<code class="language-plaintext highlighter-rouge">clothesMap</code>)를 생성한다.</li>
  <li><code class="language-plaintext highlighter-rouge">clothes</code>를 순회하며 같은 의상의 이름에 값을 누적하며 더해준다.(+1)</li>
  <li>완성된 <code class="language-plaintext highlighter-rouge">clothesMap</code>에 있는 의상의 개수끼리 곱한다.</li>
  <li>옷을 아예 입지 않은 경우를 제외시키 위해 answer에 <code class="language-plaintext highlighter-rouge">-1</code>을 하고 답을 반환한다.</li>
</ol>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="해시" /><summary type="html"><![CDATA[프로그래머스 Lv 2 위장 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 콜라츠 추측</title><link href="http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 콜라츠 추측" /><published>2023-04-10T00:00:00+09:00</published><updated>2023-04-10T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0%20%EC%B6%94%EC%B8%A1</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/"><![CDATA[<h2 id="-문제-출처">📄 문제 출처</h2>

<p>1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.</p>

<p>예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.</p>

<ul>
  <li>입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">while </span><span class="p">(</span><span class="nx">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">num</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="nf">if </span><span class="p">(</span><span class="nx">answer</span> <span class="o">===</span> <span class="mi">500</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>재귀함수를 사용해 볼까 하다가 성능상 반복문이 더 좋을 것 같아 <code class="language-plaintext highlighter-rouge">while</code>문에 조건을 걸어 <code class="language-plaintext highlighter-rouge">num</code>가 1이 될때 까지 반복했습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">collatz</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">?</span> <span class="nx">count</span> <span class="o">&gt;=</span> <span class="mi">500</span>
      <span class="p">?</span> <span class="o">-</span><span class="mi">1</span>
      <span class="p">:</span> <span class="nx">count</span>
    <span class="p">:</span> <span class="nf">collatz</span><span class="p">(</span><span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="nx">count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그래도 재귀함수를 사용한 풀이는 멋있네요.</p>

<p>삼항 연산자를 중첩으로 사용할 수 있다는 것도 처음 알아갑니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="콜라츠 추측" /><summary type="html"><![CDATA[프로그래머스 Lv 1 콜라츠 추측 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 2] 가장 큰 수</title><link href="http://localhost:4000/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 2] 가장 큰 수" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5%20%ED%81%B0%20%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv2/programmers-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.</p>

<p>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.</p>

<p>0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>numbers의 길이는 1 이상 100,000 이하입니다.</li>
  <li>numbers의 원소는 0 이상 1,000 이하입니다.</li>
  <li>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">numbers</span>
    <span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="dl">""</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span> <span class="p">:</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 배열 <code class="language-plaintext highlighter-rouge">numbers</code>를 순회해 sort()메소드를 적용한다.’</li>
  <li>인접한 두 수를 순서를 바꿔 비교하고 내림차순한다.</li>
  <li>완성된 배열을 join(““)으로 문자열로 바꾼다.</li>
  <li>만약 [0, 0, 0]인경우 답이 “000”이 되므로 삼항연산자를 이용해 첫번째 자릿수가 0인경우 0을 바로 반환한다.</li>
</ol>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv2" /><category term="가장 큰 수" /><category term="정렬" /><category term="sort" /><summary type="html"><![CDATA[프로그래머스 Lv 2 가장 큰 수]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 두 정수 사이의 합</title><link href="http://localhost:4000/programmers-lv1/programmers-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4-%ED%95%A9/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 두 정수 사이의 합" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%EB%91%90%20%EC%A0%95%EC%88%98%20%EC%82%AC%EC%9D%B4%20%ED%95%A9</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4-%ED%95%A9/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.
예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.</p>

<ul>
  <li>a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.</li>
  <li>a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.</li>
  <li>a와 b의 대소관계는 정해져있지 않습니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="p">[</span><span class="nx">newA</span><span class="p">,</span> <span class="nx">newB</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">].</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">newA</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">newB</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 정수를 배열에 담아 정렬후 구조분해 할당을 사용해 새로운 값을 만들었다.</li>
  <li>반복문으로 <code class="language-plaintext highlighter-rouge">newA</code>부터 <code class="language-plaintext highlighter-rouge">newB</code>까지의 합을 구해 답을 반환한다.</li>
</ol>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">adder</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">s</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Math 메소드를 적절히 활용한 풀이입니다. 👍</p>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="sort" /><summary type="html"><![CDATA[프로그래머스 Lv 1 두 정수 사이의 합 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] 하샤드 수</title><link href="http://localhost:4000/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] 하샤드 수" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C%20%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.</p>

<ul>
  <li>x는 1 이상, 10000 이하인 정수입니다.</li>
</ul>

<h2 id="️-나의-풀이">🙋‍♀️ 나의 풀이</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">x</span><span class="p">.</span><span class="nf">toString</span><span class="p">()].</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">return </span><span class="p">(</span><span class="nx">acc</span> <span class="o">+=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">cur</span><span class="p">));</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">%</span> <span class="nx">sum</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>주어진 숫자(x)를 문자열로 변환 후, 각 자릿값을 배열의 요소로 만든다.</li>
  <li>배열의 요소를 reduce메소드를 사용해 더한 누적값을 변수 <code class="language-plaintext highlighter-rouge">sum</code>에 할당한다.</li>
  <li>요구사항대로 주어진 숫자를 누적값으로 나누었을 때 0이 되는지에 대한 boolean값을 반환한다.</li>
</ol>

<p>처음으로 프로그래머스에서 reduce함수를 사용했습니다. <br />
점점 응용하는 메소드가 생길수록 뿌듯합니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Harshad</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="dl">""</span><span class="p">).</span><span class="nf">split</span><span class="p">(</span><span class="dl">""</span><span class="p">).</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">b</span> <span class="o">+</span> <span class="o">+</span><span class="nx">a</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>반환값을 true/false가 아닌 0과 1을 통해 표현할 수도 있다는 것을 적용한 식입니다. 👍</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="하샤드 수" /><category term="reduce" /><summary type="html"><![CDATA[프로그래머스 Lv 1 하샤드 수 문제 풀이]]></summary></entry><entry><title type="html">[프로그래머스 / Lv 1] k번째수</title><link href="http://localhost:4000/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98/" rel="alternate" type="text/html" title="[프로그래머스 / Lv 1] k번째수" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T22:06:00+09:00</updated><id>http://localhost:4000/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98</id><content type="html" xml:base="http://localhost:4000/programmers-lv1/programmers-k%EB%B2%88%EC%A7%B8%EC%88%98/"><![CDATA[<h2 id="-문제">📄 문제</h2>

<p>배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.</p>

<p>예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면</p>

<p>array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.
1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.
2에서 나온 배열의 3번째 숫자는 5입니다.
배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>

<ul>
  <li>array의 길이는 1 이상 100 이하입니다.</li>
  <li>array의 각 원소는 1 이상 100 이하입니다.</li>
  <li>commands의 길이는 1 이상 50 이하입니다.</li>
  <li>commands의 각 원소는 길이가 3입니다.</li>
</ul>

<h2 id="️-나의-풀이-1">🙋‍♀️ 나의 풀이 #1</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">commands</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">commands</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span>
      <span class="nx">array</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]).</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)[</span>
        <span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">]</span>
    <span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/56298540/230713712-3a7bcde9-3dd8-4bda-9072-05edb083103c.png" alt="image" /></p>

<p>주어진 배열 array를 요구사항대로 자르고 sort() 메소드로 정렬했습니다.</p>

<p>그래도 정렬 알고리즘을 배웠으니 한번 메소드를 사용하지 않고 풀어보겠습니다.</p>

<h3 id="️-나의-풀이-2">🙋‍♀️ 나의 풀이 #2</h3>

<p>삽입 정렬을 사용한 풀이입니다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">commands</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">answer</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">commands</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">slicedArray</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="c1">// 삽입 정렬 시작</span>
    <span class="nf">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">slicedArray</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="nf">while </span><span class="p">(</span><span class="nx">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span><span class="p">];</span>
        <span class="nx">left</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">slicedArray</span><span class="p">[</span><span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">answer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">slicedArray</span><span class="p">[</span><span class="nx">commands</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/56298540/230713681-e96b3412-0e75-49d2-8f7a-2955653ddc57.png" alt="image" /></p>

<p>속도면에서는 크게 다른 점이 없습니다.</p>

<h2 id="-best-practice">👍 Best Practice</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">solution</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">commands</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">commands</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">command</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">sPosition</span><span class="p">,</span> <span class="nx">ePosition</span><span class="p">,</span> <span class="nx">position</span><span class="p">]</span> <span class="o">=</span> <span class="nx">command</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">array</span>
      <span class="p">.</span><span class="nf">filter</span><span class="p">(</span>
        <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">fIndex</span> <span class="o">&gt;=</span> <span class="nx">sPosition</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">fIndex</span> <span class="o">&lt;=</span> <span class="nx">ePosition</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">)</span>
      <span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">newArray</span><span class="p">[</span><span class="nx">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>주어진 조건 <code class="language-plaintext highlighter-rouge">commands</code>를 구조 분해 할당을 사용해 가독성을 높인 풀이입니다.</p>

<p>slice 메소드가 아니라 filter 메소드를 사용해 배열을 자를 수도 있다는걸 하나 알아갑니다.</p>

<h2 id="문제-출처">문제 출처</h2>

<ul>
  <li>프로그래머스</li>
</ul>]]></content><author><name>Sujin Kim</name></author><category term="programmers-lv1" /><category term="정렬" /><category term="k번째 수" /><summary type="html"><![CDATA[프로그래머스 Lv 1 k번째수 sort 메소드 대신 정렬 알고리즘으로 풀어보기]]></summary></entry></feed>